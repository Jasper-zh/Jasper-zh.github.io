<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RabbitMQ详解 | 木瓜煲鸡脚's blog</title><meta name="author" content="木瓜煲鸡脚,1839646816@qq.com"><meta name="copyright" content="木瓜煲鸡脚"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="超长警告！！！善用目录！！！   1. 什么是RabbitMQ1.1 MQ（Message Queue）消息队列 消息队列中间件，是分布式系统中的重要组件 主要解决，异步处理，应用解耦，流量削峰等问题 从而实现高性能，高可用，可伸缩和最终一致性的架构 使用较多的消息队列产品：RabbitMQ，Roc"><link rel="shortcut icon" href="/assets/img/favicon64.ico"><link rel="canonical" href="http://yournotes.cn/2021/06/22/RabbitMQ%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?43ef74dd386a5adcc7d5e42daaa55700";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 木瓜煲鸡脚","link":"链接: ","source":"来源: 木瓜煲鸡脚's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-17 16:34:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/hao.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">165</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-folder-open"></i><span> 说说</span></a></li><li><a class="site-page child" href="/tools/"><i class="fa-fw fa fa-wrench"></i><span> 工具</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/assets/img/article/article.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">木瓜煲鸡脚's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 空间</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-folder-open"></i><span> 说说</span></a></li><li><a class="site-page child" href="/tools/"><i class="fa-fw fa fa-wrench"></i><span> 工具</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-06-22T07:25:09.000Z" title="发表于 2021-06-22 15:25:09">2021-06-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/">记录文档</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RabbitMQ详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/06/22/RabbitMQ%E8%AF%A6%E8%A7%A3/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note warning simple"><p>超长警告！！！善用目录！！！</p>
</div>

<h2 id="1-什么是RabbitMQ"><a href="#1-什么是RabbitMQ" class="headerlink" title="1. 什么是RabbitMQ"></a>1. 什么是RabbitMQ</h2><h3 id="1-1-MQ（Message-Queue）消息队列"><a href="#1-1-MQ（Message-Queue）消息队列" class="headerlink" title="1.1 MQ（Message Queue）消息队列"></a>1.1 MQ（Message Queue）消息队列</h3><ul>
<li>消息队列中间件，是分布式系统中的重要组件</li>
<li>主要解决，异步处理，应用解耦，流量削峰等问题</li>
<li>从而实现高性能，高可用，可伸缩和最终一致性的架构</li>
<li>使用较多的消息队列产品：RabbitMQ，RocketMQ，ActiveMQ，ZeroMQ，Kafka等</li>
</ul>
<h4 id="1-1-1-异步处理"><a href="#1-1-1-异步处理" class="headerlink" title="1.1.1 异步处理"></a>1.1.1 异步处理</h4><ul>
<li><p>用户注册后，需要发送验证邮箱和手机验证码；</p>
</li>
<li><p>将注册信息写入数据库，发送验证邮件，发送手机，三个步骤全部完成后，返回给客户端</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624154939.png"></p>
</li>
</ul>
<h4 id="1-1-2-应用解耦"><a href="#1-1-2-应用解耦" class="headerlink" title="1.1.2 应用解耦"></a>1.1.2 应用解耦</h4><ul>
<li><p>场景：订单系统需要通知库存系统</p>
</li>
<li><p>如果库存系统异常，则订单调用库存失败，导致下单失败</p>
<ul>
<li>原因：订单系统和库存系统<strong>耦合度太高</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624155029.png"></p>
</li>
<li><p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户，下单成功；</p>
</li>
<li><p>库存系统：订阅下单的消息，获取下单信息，库存系统根据下单信息，再进行库存操作；</p>
</li>
<li><p>假如：下单的时候，库存系统不能正常运行，也不会影响下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了，实现了订单系统和库存系统的应用解耦；</p>
</li>
<li><p>所以说，消息队列是典型的：<strong>生产者消费者模型</strong></p>
</li>
<li><p>生产者不断的向消息队列中生产消息，消费者不断的从队列中获取消息</p>
</li>
<li><p>因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的入侵，这样就实现了生产者和消费者的解耦</p>
</li>
</ul>
<h4 id="1-1-3-流量削峰"><a href="#1-1-3-流量削峰" class="headerlink" title="1.1.3 流量削峰"></a>1.1.3 流量削峰</h4><ul>
<li><p>抢购，秒杀等业务，针对高并发的场景</p>
</li>
<li><p>因为流量过大，暴增会导致应用挂掉，为解决这个问题，在前端加入消息队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624155207.png"></p>
</li>
<li><p>用户的请求，服务器接收后，首先写入消息队列，如果超过队列的长度，就抛弃，甩一个秒杀结束的页面！</p>
</li>
<li><p>说白了，秒杀成功的就是进入队列的用户；</p>
</li>
</ul>
<h3 id="1-2-背景知识介绍"><a href="#1-2-背景知识介绍" class="headerlink" title="1.2 背景知识介绍"></a>1.2 背景知识介绍</h3><h4 id="1-2-1-AMQP高级消息队列协议"><a href="#1-2-1-AMQP高级消息队列协议" class="headerlink" title="1.2.1 AMQP高级消息队列协议"></a>1.2.1 AMQP高级消息队列协议</h4><ul>
<li>即<strong>A</strong>dvanced <strong>M</strong>essage <strong>Q</strong>ueuing <strong>P</strong>rotocol，一个提供统一消息服务的应用层标准高级消息队列协议</li>
<li>协议：数据在传输的过程中必须要遵守的规则</li>
<li>基于此协议的客户端可以与消息中间件传递消息</li>
</ul>
<h4 id="1-2-2-JMS"><a href="#1-2-2-JMS" class="headerlink" title="1.2.2 JMS"></a>1.2.2 JMS</h4><ul>
<li><strong>J</strong>ava <strong>M</strong>essage <strong>S</strong>erver，Java消息服务应用程序接口， 一种规范，和JDBC担任的角色类似</li>
<li>是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信</li>
</ul>
<h4 id="1-2-3-二者的联系"><a href="#1-2-3-二者的联系" class="headerlink" title="1.2.3 二者的联系"></a>1.2.3 二者的联系</h4><ul>
<li>JMS是定义了统一接口，<strong>统一消息操作</strong>；AMQP通过协议<strong>统一数据交互格式</strong></li>
<li>JMS必须是java语言；AMQP只是协议，与语言无关</li>
</ul>
<h4 id="1-2-4-Erlang语言"><a href="#1-2-4-Erlang语言" class="headerlink" title="1.2.4 Erlang语言"></a>1.2.4 Erlang语言</h4><ul>
<li>Erlang（[‘ə:læŋ]）是一种通用的面向<strong>并发</strong>的编程语言，它由瑞典电信设备制造商爱立信所辖的CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言和运行环境</li>
<li>最初是由爱立信专门为<strong>通信应用设计</strong>的，比如控制交换机或者变换协议等，因此非常适合构建分布式，实时软并行计算系统</li>
<li>Erlang运行时环境是一个<strong>虚拟机</strong>，有点像Java的虚拟机，这样代码一经编译，同样可以随处运行</li>
</ul>
<h3 id="1-3-为什么选择RabbitMQ"><a href="#1-3-为什么选择RabbitMQ" class="headerlink" title="1.3 为什么选择RabbitMQ"></a>1.3 为什么选择RabbitMQ</h3><ul>
<li>我们开篇说消息队列产品那么多，为什么偏偏选择RabbitMQ呢？</li>
<li>先看命名：兔子行动非常迅速而且繁殖起来也非常疯狂，所以就把Rabbit用作这个分布式软件的命名（就是这么简单）</li>
<li>Erlang开发，AMQP的最佳搭档，安装部署简单，上手门槛低</li>
<li>企业级消息队列，经过大量实践考验的高可靠，大量成功的应用案例，例如阿里、网易等一线大厂都有使用</li>
<li>有强大的WEB管理页面</li>
<li>强大的社区支持，为技术进步提供动力</li>
<li>支持消息持久化、支持消息确认机制、灵活的任务分发机制等，支持功能非常丰富</li>
<li>集群扩展很容易，并且可以通过增加节点实现成倍的性能提升</li>
<li><strong>总结：如果你希望使用一个可靠性高、功能强大、易于管理的消息队列系统那么就选择RabbitMQ，如果你想用一个性能高，但偶尔丢点数据不是很在乎可以使用kafka或者zeroMQ</strong></li>
<li>kafka和zeroMQ的性能爆表，绝对可以压RabbitMQ一头！</li>
</ul>
<h3 id="1-4-RabbitMQ各组件功能"><a href="#1-4-RabbitMQ各组件功能" class="headerlink" title="1.4 RabbitMQ各组件功能"></a>1.4 RabbitMQ各组件功能</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624155732.png"></p>
<ul>
<li><p><strong>Broker</strong>：消息队列服务器实体</p>
</li>
<li><p><strong>Virtual Host</strong>：虚拟主机</p>
<ul>
<li>标识一批交换机、消息队列和相关对象，形成的整体</li>
<li>虚拟主机是共享相同的身份认证和加密环境的独立服务器域</li>
<li>每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制</li>
<li>vhost是AMQP概念的基础，RabbitMQ默认的vhost是 &#x2F;，必须在链接时指定</li>
</ul>
</li>
<li><p><strong>Exchange</strong>：交换器（路由）</p>
<ul>
<li>用来接收生产者发送的消息并将这些消息路由给服务器中的队列</li>
</ul>
</li>
<li><p><strong>Queue</strong>：消息队列</p>
<ul>
<li>用来保存消息直到发送给消费者。</li>
<li>它是消息的容器，也是消息的终点。</li>
<li>一个消息可投入一个或多个队列。</li>
<li>消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>
</ul>
</li>
<li><p><strong>Banding</strong>：绑定，用于消息队列和交换机之间的关联。</p>
</li>
<li><p><strong>Channel</strong>：通道（信道）</p>
<ul>
<li><p>多路复用连接中的一条独立的双向数据流通道。</p>
</li>
<li><p>信道是建立在真实的TCP连接内的 <strong>虚拟链接</strong></p>
</li>
<li><p>AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信</p>
<p>道完成的</p>
</li>
<li><p>因为对于操作系统来说，建立和销毁TCP连接都是非常昂贵的开销，所以引入了信道的概</p>
<p>念，用来复用TCP连接。</p>
</li>
<li><p><strong>Connection</strong>：网络连接，比如一个TCP连接。</p>
</li>
<li><p><strong>Publisher</strong>：消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
</li>
<li><p><strong>Consumer</strong>：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p>
</li>
<li><p><strong>Message</strong>：消息</p>
<ul>
<li>消息是不具名的，它是由消息头和消息体组成。</li>
<li>消息体是不透明的，而消息头则是由一系列的可选属性组成，这些属性包括routing-key(路由键)、priority(优先级)、delivery-mode(消息可能需要持久性存储[消息的路由模式])等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-怎么用RabbitMQ"><a href="#2-怎么用RabbitMQ" class="headerlink" title="2. 怎么用RabbitMQ"></a>2. 怎么用RabbitMQ</h2><ul>
<li><p>想要安装RabbitMQ，必须先安装erlang语言环境，类似安装tomcat，必须先安装JDK</p>
</li>
<li><p>查看匹配的版本：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624160204.png"></p>
</li>
</ul>
<h3 id="2-1-RabbitMQ安装启动"><a href="#2-1-RabbitMQ安装启动" class="headerlink" title="2.1 RabbitMQ安装启动"></a>2.1 RabbitMQ安装启动</h3><p>erlang下载：<a target="_blank" rel="noopener" href="https://dl.bintray.com/rabbitmq-erlang/rpm/erlang">https://dl.bintray.com/rabbitmq-erlang/rpm/erlang</a></p>
<p>socat下载：<a target="_blank" rel="noopener" href="http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm">http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</a></p>
<p>RabbitMQ下载：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-rpm.html#downloads">https://www.rabbitmq.com/install-rpm.html#downloads</a></p>
<h3 id="2-1-1-安装"><a href="#2-1-1-安装" class="headerlink" title="2.1.1 安装"></a>2.1.1 安装</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rpm</span> -ivh erlang-<span class="number">21.3.8.16</span>-<span class="number">1</span>.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh socat-<span class="number">1.7</span>.<span class="number">3.2</span>-<span class="number">5</span><span class="selector-class">.el7</span><span class="selector-class">.lux</span><span class="selector-class">.x86_64</span>.rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rpm</span> -ivh rabbitmq-server-<span class="number">3</span>.<span class="number">8</span>.<span class="number">6</span>-<span class="number">1</span>.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-启动后台管理插件"><a href="#2-1-2-启动后台管理插件" class="headerlink" title="2.1.2 启动后台管理插件"></a>2.1.2 启动后台管理插件</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># rabbitmq-plugins enable rabbitmq_management</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-启动RabbitMQ"><a href="#2-1-3-启动RabbitMQ" class="headerlink" title="2.1.3 启动RabbitMQ"></a>2.1.3 启动RabbitMQ</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># systemctl start rabbitmq-server.service </span></span><br><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># systemctl status rabbitmq-server.service </span></span><br><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># systemctl restart rabbitmq-server.service </span></span><br><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># systemctl stop rabbitmq-server.service</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-查看进程"><a href="#2-1-4-查看进程" class="headerlink" title="2.1.4 查看进程"></a>2.1.4 查看进程</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="keyword">opt</span>]# <span class="keyword">ps</span> -ef | <span class="keyword">grep</span> rabbitmq</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-测试"><a href="#2-1-5-测试" class="headerlink" title="2.1.5 测试"></a>2.1.5 测试</h3><ol>
<li><p>关闭防火墙： systemctl stop firewalld </p>
</li>
<li><p>浏览器输入：<a target="_blank" rel="noopener" href="http://ip:15672/">http://ip:15672</a></p>
</li>
<li><p>默认帐号密码：guest，guest用户默认不允许远程连接</p>
<ul>
<li><p>创建账号</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># rabbitmqctl add_user laosun 123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置用户角色</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># rabbitmqctl set_user_tags laosun administrator</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置用户权限</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> laosun <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前用户和角色</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># rabbitmqctl list_users</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前用户和角色</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># rabbitmqctl change_password laosun 123123</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624161108.png"></p>
<p><strong>管理界面介绍</strong></p>
<ul>
<li>overview：概览</li>
<li>connections：查看链接情况</li>
<li>channels：信道（通道）情况</li>
<li>Exchanges：交换机（路由）情况，默认4类7个</li>
<li>Queues：消息队列情况</li>
<li>Admin：管理员列表</li>
<li>端口：<ul>
<li><strong>5672</strong>：RabbitMQ提供给编程语言客户端链接的端口</li>
<li><strong>15672</strong>：RabbitMQ管理界面的端口</li>
<li><strong>25672</strong>：RabbitMQ集群的端口</li>
</ul>
</li>
</ul>
<h3 id="2-2-RabbitMQ快速入门"><a href="#2-2-RabbitMQ快速入门" class="headerlink" title="2.2 RabbitMQ快速入门"></a>2.2 RabbitMQ快速入门</h3><h4 id="2-2-1-依赖"><a href="#2-2-1-依赖" class="headerlink" title="2.2.1 依赖"></a>2.2.1 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-日志依赖log4j（可选项）"><a href="#2-2-2-日志依赖log4j（可选项）" class="headerlink" title="2.2.2 日志依赖log4j（可选项）"></a>2.2.2 日志依赖log4j（可选项）</h4><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.stdout.Target=System.out </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;<span class="attribute">yyyy-MM-dd HH</span>:mm:ss&#125; %m%n </span><br><span class="line">log4j<span class="variable">.appender</span><span class="variable">.file</span>=org<span class="variable">.apache</span><span class="variable">.log</span>4j<span class="variable">.FileAppender</span> </span><br><span class="line">log4j<span class="variable">.appender</span><span class="variable">.file</span><span class="variable">.File</span>=rebbitmq<span class="variable">.log</span> </span><br><span class="line">log4j<span class="variable">.appender</span><span class="variable">.file</span><span class="variable">.layout</span>=org<span class="variable">.apache</span><span class="variable">.log</span>4j<span class="variable">.PatternLayout</span> </span><br><span class="line">log4j<span class="variable">.appender</span><span class="variable">.file</span><span class="variable">.layout</span><span class="variable">.ConversionPattern</span>=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n </span><br><span class="line">log4j<span class="variable">.rootLogger</span>=debug, stdout,file</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-创建连接"><a href="#2-2-3-创建连接" class="headerlink" title="2.2.3 创建连接"></a>2.2.3 创建连接</h4><p>先创建好<strong>虚拟主机</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624161520.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: lagou-rabbitmq </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: GuoAn.Sun </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 专门与RabbitMQ获得连接 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionUtil</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">//1.创建连接工厂 </span></span><br><span class="line">		<span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">		<span class="comment">//2.在工厂对象中设置MQ的连接信息（ip,port,vhost,username,password） </span></span><br><span class="line">		factory.setHost(<span class="string">&quot;192.168.204.141&quot;</span>);</span><br><span class="line">		factory.setPort(<span class="number">5672</span>);</span><br><span class="line">		factory.setVirtualHost(<span class="string">&quot;/lagou&quot;</span>);</span><br><span class="line">		factory.setUsername(<span class="string">&quot;laosun&quot;</span>);</span><br><span class="line">		factory.setPassword(<span class="string">&quot;123123&quot;</span>);</span><br><span class="line">		<span class="comment">//3.通过工厂获得与MQ的连接 </span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">		<span class="keyword">return</span> connection;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection();</span><br><span class="line">		System.out.println(<span class="string">&quot;connection = &quot;</span> + connection);</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-RabbitMQ模式"><a href="#2-3-RabbitMQ模式" class="headerlink" title="2.3 RabbitMQ模式"></a>2.3 RabbitMQ模式</h3><ul>
<li><p>RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此我们只学习前5种</p>
</li>
<li><p>在线手册：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624161801.png"></p>
</li>
<li><p>5种消息模型，大体分为两类：</p>
<ul>
<li>1和2属于点对点</li>
<li>3、4、5属于发布订阅模式（一对多）</li>
</ul>
</li>
<li><p><strong>点对点模式</strong>：P2P（point to point）模式包含三个角色：</p>
<ul>
<li>消息队列（queue），发送者（sender），接收者（receiver）</li>
<li>每个消息发送到一个特定的队列中，接收者从中获得消息</li>
<li>队列中保留这些消息，直到他们被消费或超时</li>
<li>特点：<ol>
<li>每个消息只有一个消费者，一旦消费，消息就不在队列中了</li>
<li>发送者和接收者之间没有依赖性，发送者发送完成，不管接收者是否运行，都不会影响消息发送到队列中（我给你发微信，不管你看不看手机，反正我发完了）</li>
<li>接收者成功接收消息之后需向对象应答成功（确认）</li>
</ol>
</li>
<li>如果希望发送的每个消息都会被成功处理，那需要P2P</li>
</ul>
</li>
<li><p><strong>发布订阅模式</strong>：publish（Pub）&#x2F;subscribe（Sub）</p>
<ul>
<li>pub&#x2F;sub模式包含三个角色：交换机（exchange），发布者（publisher），订阅者（subcriber）</li>
<li>多个发布者将消息发送交换机，系统将这些消息传递给多个订阅者</li>
<li>特点：<ol>
<li>每个消息可以有多个订阅者</li>
<li>发布者和订阅者之间在时间上有依赖，对于某个交换机的订阅者，必须创建一个订阅后，才能消费发布者的消息</li>
<li>为了消费消息，订阅者必须保持运行状态；类似于，看电视直播。</li>
</ol>
</li>
<li>如果希望发送的消息被多个消费者处理，可采用本模式</li>
</ul>
</li>
</ul>
<h4 id="2-3-1-简单模式"><a href="#2-3-1-简单模式" class="headerlink" title="2.3.1 简单模式"></a>2.3.1 简单模式</h4><p>下面引用官网的一段介绍：</p>
<blockquote>
<p><strong>Introduction</strong></p>
<p>RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be surethat Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy,RabbitMQ is a post box, a post office and a postman.</p>
<p>译文：RabbitMQ是一个消息代理:它接收和转发消息。你可以把它想象成一个邮局:当你把你想要寄的邮件放到一个邮箱里，你可以确定邮递员先生或女士最终会把邮件送到你的收件人那里。在这个类比中，RabbitMQ是一个邮箱、一个邮局和一个邮递员。</p>
</blockquote>
<p>RabbitMQ本身只是接收，存储和转发消息，并不会对信息进行处理！</p>
<p>类似邮局，处理信件的应该是收件人而不是邮局！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624162301.png"></p>
<ul>
<li><p>生产者P</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplest;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> util.ConnectionUtil;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: lagou-rabbitmq </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: GuoAn.Sun </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息生产者 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;老孙：Hello,RabbitMQ!&quot;</span>;</span><br><span class="line">		<span class="comment">// 1.获得连接 </span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="comment">// 2.在连接中创建通道（信道） </span></span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 3.创建消息队列(1,2,3,4,5)</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		参数1:队列的名称 </span></span><br><span class="line"><span class="comment">		参数2:队列中的数据是否持久化 </span></span><br><span class="line"><span class="comment">		参数3:是否排外（是否支持扩展，当前队列只能自己用，不能给别人用） </span></span><br><span class="line"><span class="comment">		参数4:是否自动删除（当队列的连接数为0时，队列会销毁，不管队列是否还存保存数据） </span></span><br><span class="line"><span class="comment">		参数5:队列参数（没有参数为null） </span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;queue1&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 4.向指定的队列发送消息(1,2,3,4) </span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		参数1:交换机名称，当前是简单模式，也就是P2P模式，没有交换机，所以名称为&quot;&quot; </span></span><br><span class="line"><span class="comment">		参数2:目标队列的名称 </span></span><br><span class="line"><span class="comment">		参数3:设置消息的属性（没有属性则为null） </span></span><br><span class="line"><span class="comment">		参数4:消息的内容(只接收字节数组) </span></span><br><span class="line"><span class="comment">		*/</span> </span><br><span class="line">		channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;queue1&quot;</span>,<span class="literal">null</span>,msg.getBytes());</span><br><span class="line">		System.out.println(<span class="string">&quot;发送：&quot;</span> + msg);</span><br><span class="line">		<span class="comment">// 5.释放资源 </span></span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动生产者，即可前往管理端查看队列中的信息，会有一条信息没有处理和确认</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624162645.png"></p>
</li>
<li><p>消费者C</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplest;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: lagou-rabbitmq </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: GuoAn.Sun </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息接收者 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 1.获得连接 </span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="comment">// 2.获得通道（信道） </span></span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 3.从信道中获得消息 </span></span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="comment">//交付处理（收件人信息，包裹上的快递标签，协议的配置，消息） </span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="comment">// body就是从队列中获取的消息 </span></span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;接收 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 4.监听队列 true:自动消息确认 </span></span><br><span class="line">		channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动消费者，前往管理端查看队列中的信息，所有信息都已经处理和确认，显示0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624163005.png"></p>
<ul>
<li><p>消息确认机制ACK</p>
<p>通过刚才的案例可以看出，消息一旦被消费，消息就会立刻从队列中移除</p>
<p>RabbitMQ如何得知消息被消费者接收？</p>
<ol>
<li>如果消费者接收消息后，还没执行操作就抛异常宕机导致消费失败，但是RabbitMQ无从得知，这样消息就丢失了</li>
<li>因此，RabbitMQ有一个<strong>ACK机制</strong>，当消费者获取消息后，会向RabbitMQ发送<strong>回执ACK</strong>，告知消息已经被接收</li>
<li>ACK：(Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误我们在使用http请求时，http的状态码200就是告诉我们服务器执行成功</li>
<li>整个过程就想快递员将包裹送到你手里，并且需要你的签字，并拍照回执</li>
<li>不过这种回执ACK分为两种情况：<ul>
<li><strong>自动ACK</strong>：消息接收后，消费者立刻自动发送ACK（快递放在快递柜）</li>
<li><strong>手动ACK</strong>：消息接收后，不会发送ACK，需要手动调用（快递必须本人签收）</li>
</ul>
</li>
<li>两种情况如何选择，需要看消息的重要性：<ul>
<li>如果消息不太重要，丢失也没有影响，自动ACK会比较方便</li>
<li>如果消息非常重要，最好消费完成手动ACK，如果自动ACK消费后，RabbitMQ就会把消息从队列中删除，如果此时消费者抛异常宕机，那么消息就永久丢失了</li>
</ul>
</li>
</ol>
</li>
<li><p>修改手动消息确认</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false：手动消息确认 </span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="literal">false</span>, consumer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624163356.png"></p>
</li>
<li><p>解决问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecerByACK</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 1.获得连接 </span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="comment">// 2.获得通道（信道）</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 3.从信道中获得消息 </span></span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> <span class="comment">//交付处理（收件人信息，包裹上的快递标签，协议的配置，消息） </span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="comment">// body就是从队列中获取的消息 </span></span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;接收 = &quot;</span> + s);</span><br><span class="line">				<span class="comment">// 手动确认（收件人信息，是否同时确认多个消息） </span></span><br><span class="line">				channel.basicAck(envelope.getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		;</span><br><span class="line">		<span class="comment">// 4.监听队列，false:手动消息确认 </span></span><br><span class="line">		channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="literal">false</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-2-工作队列模式"><a href="#2-3-2-工作队列模式" class="headerlink" title="2.3.2 工作队列模式"></a>2.3.2 工作队列模式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624163625.png"></p>
<ul>
<li>之前我们学习的简单模式，一个消费者来处理消息，如果生产者生产消息过快过多，而消费者的能力有限，就会产生消息在队列中堆积（生活中的滞销）</li>
<li>一个烧烤师傅，一次烤50支羊肉串，就一个人吃的话，烤好的肉串会越来越多，怎么处理？</li>
<li>多招揽客人进行消费即可。当我们运行许多消费者程序时，消息队列中的任务会被众多消费者共享，但其中某一个消息只会被一个消费者获取（100支肉串20个人吃，但是其中的某支肉串只能被一个人吃）</li>
</ul>
<h5 id="2-3-2-1-生产者P"><a href="#2-3-2-1-生产者P" class="headerlink" title="2.3.2.1 生产者P"></a>2.3.2.1 生产者P</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列（此处为生产者，创建队列）注明出餐口位置，通知大家来排队 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_work_queue&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;羊肉串 --&gt; &quot;</span>+i;</span><br><span class="line">			channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test_work_queue&quot;</span>, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">			System.out.println(<span class="string">&quot;师傅烤好：&quot;</span> + msg);</span><br><span class="line">		&#125;</span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-2-消费者1"><a href="#2-3-2-2-消费者1" class="headerlink" title="2.3.2.2 消费者1"></a>2.3.2.2 消费者1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageReceiver1</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 记录执行次数 </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列（此处为消费者，不是声明创建队列，而且获取，二者代码相同）出餐口排队 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_work_queue&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【顾客1】吃掉 &quot;</span> + msg+<span class="string">&quot; ! 共吃【&quot;</span>+i++ +<span class="string">&quot;】串&quot;</span>);</span><br><span class="line">				<span class="comment">// 撸一会，有延迟 </span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">200</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">				&#125;</span><br><span class="line">				channel.basicAck(envelope.getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_work_queue&quot;</span>, <span class="literal">false</span>, consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-3-消费者2"><a href="#2-3-2-3-消费者2" class="headerlink" title="2.3.2.3 消费者2"></a>2.3.2.3 消费者2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageReceiver2</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 记录执行次数 </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列（此处为消费者，不是声明创建队列，而且获取，二者代码相同）出餐口排队 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_work_queue&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【顾客2】吃掉 &quot;</span> + msg+<span class="string">&quot; ! 共吃【&quot;</span>+i++ +<span class="string">&quot;】串&quot;</span>);</span><br><span class="line">				<span class="comment">// 撸一会，有延迟</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">200</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">				&#125;</span><br><span class="line">				channel.basicAck(envelope.getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		;</span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_work_queue&quot;</span>, <span class="literal">false</span>, consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先运行2个消费者，排队等候消费（取餐），再运行生产者开始生产消息（烤肉串）</p>
</li>
<li><p>虽然两个消费者的消费速度不一致（线程休眠时间），但是消费的数量却是一致的，各消费50个消息</p>
<ul>
<li><p>例如：工作中，A同学编码速率高，B同学编码速率低，两个人同时开发一个项目，A10天完成，B30天完成，A完成自己的编码部分，就无所事事了，等着B完成就可以了，这样是不可以的，应该遵循“能者多劳”</p>
</li>
<li><p>效率高的多干点，效率低的少干点</p>
</li>
<li><p>看下面官网是如何给出解决思路的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624164605.png"></p>
<blockquote>
<p>公平的分配</p>
<p>您可能已经注意到分派仍然不能完全按照我们的要求工作。例如，如果有两个员工，当所有奇怪的消息都很重，甚至消息都很轻时，一个员工会一直很忙，而另一个人几乎什么工作都不做。好吧，RabbitMQ对此一无所知，它仍然会均匀地分派消息。</p>
<p>这是因为RabbitMQ只在消息进入队列时发送消息。它不查看用户未确认消息的数量。它只是盲目地将每条第n个消息分派给第n个消费者。为了克服这个问题，我们可以使用设置为prefetchCount &#x3D; 1的basicQos方法。这告诉</p>
<p>RabbitMQ一次不要给一个worker发送一条以上的消息。或者，换句话说，在worker处理并确认前一个消息之前，不要向它发送新消息。相反，它将把它分派到下一个不繁忙的worker。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明队列（此处为消费者，不是声明创建队列，而且获取，二者代码相同）出餐口排队 </span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;test_work_queue&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>); </span><br><span class="line"><span class="comment">// 可以理解为：快递一个一个送，送完一个再送下一个，速度快的送件就多 </span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>能者多劳必须要配合手动的ACK机制才生效</p>
</li>
</ul>
<h5 id="2-3-2-4-面试题：避免消息堆积？"><a href="#2-3-2-4-面试题：避免消息堆积？" class="headerlink" title="2.3.2.4 面试题：避免消息堆积？"></a>2.3.2.4 面试题：避免消息堆积？</h5><ol>
<li>workqueue，多个消费者监听同一个队列</li>
<li>接收到消息后，通过线程池，异步消费</li>
</ol>
<h4 id="2-3-3-发布订阅模式"><a href="#2-3-3-发布订阅模式" class="headerlink" title="2.3.3 发布订阅模式"></a>2.3.3 发布订阅模式</h4><p>看官网：</p>
<blockquote>
<p><strong>Publish&#x2F;Subscribe</strong></p>
<p>In the previous tutorial we created a work queue. The assumption behind a work queueis that each task is delivered to exactly one worker. In this part we’ll do something completely different – we’ll deliver a message to multiple consumers. This pattern is known as “publish&#x2F;subscribe”.</p>
<p>To illustrate the pattern, we’re going to build a simple logging system. It will consist of two programs – the first will emit log messages and the second will receive and print them.</p>
<p>In our logging system every running copy of the receiver program will get the messages.That way we’ll be able to run one receiver and direct the logs to disk; and at the same time we’ll be able to run another receiver and see the logs on the screen.</p>
<p>Essentially, published log messages are going to be broadcast to all the receivers.</p>
<p>发布-订阅</p>
<p>在上一篇教程中，我们创建了一个工作队列。工作队列背后的假设是，每个任务都被准确地交付给一个工作者。在这一部分中，我们将做一些完全不同的事情——将消息传递给多个消费者。此模式称为“发布&#x2F;订阅”。</p>
<p>为了演示这个模式，我们将构建一个简单的日志记录系统。它将由两个程序组成——第一个将发送日志消息，第二个将接收和打印它们。</p>
<p>在我们的日志系统中，接收程序的每一个正在运行的副本都将获得消息。这样我们就可以运行</p>
<p>一个接收器并将日志指向磁盘;与此同时，我们可以运行另一个接收器并在屏幕上看到日志。</p>
<p>基本上，发布的日志消息将广播到所有接收方。</p>
</blockquote>
<p><strong>生活中的案例：就是玩抖音快手，众多粉丝关注一个视频主，视频主发布视频，所有粉丝都可以得到视频通知</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624165340.png"></p>
<ul>
<li><p>上图中，X就是视频主，红色的队列就是粉丝。binding是绑定的意思（关注）</p>
</li>
<li><p>P生产者发送信息给X路由，X将信息转发给绑定X的队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624180939.png"></p>
</li>
<li><p>X队列将信息通过信道发送给消费者，从而进行消费</p>
</li>
<li><p>整个过程，必须先创建路由</p>
<ul>
<li>路由在生产者程序中创建</li>
<li>因为路由没有存储消息的能力，当生产者将信息发送给路由后，消费者还没有运行，所以没有队列，路由并不知道将信息发送给谁</li>
<li>运行程序的顺序：<ol>
<li>MessageSender</li>
<li>MessageReceiver1和MessageReceiver2</li>
<li>MessageSender</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="2-3-3-1-生产者"><a href="#2-3-3-1-生产者" class="headerlink" title="2.3.3.1 生产者"></a>2.3.3.1 生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明路由(路由名，路由类型) </span></span><br><span class="line">		<span class="comment">// fanout：不处理路由键（只需要将队列绑定到路由上，发送到路由的消息都会被转发到与该 路由绑定的所有队列上） </span></span><br><span class="line">		channel.exchangeDeclare(<span class="string">&quot;test_exchange_fanout&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello，大家好！&quot;</span>;</span><br><span class="line">		channel.basicPublish(<span class="string">&quot;test_exchange_fanout&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">		System.out.println(<span class="string">&quot;生产者：&quot;</span> + msg);</span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3-3-2-消费者1"><a href="#2-3-3-2-消费者1" class="headerlink" title="2.3.3.2 消费者1"></a>2.3.3.2 消费者1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_exchange_fanout_queue_1&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 绑定路由（关注） /*参数1：队列名 参数2：交换器名称 参数3：路由key（暂时无用，&quot;&quot;即可） */</span></span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_fanout_queue_1&quot;</span>, <span class="string">&quot;test_exchange_fanout&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【消费者1】 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 4.监听队列 true:自动消息确认</span></span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_exchange_fanout_queue_1&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3-3-3-消费者2"><a href="#2-3-3-3-消费者2" class="headerlink" title="2.3.3.3 消费者2"></a>2.3.3.3 消费者2</h5><ul>
<li>将消费者1代码中的1修改为2即可，具体代码略</li>
</ul>
<h4 id="2-3-4-路由模式"><a href="#2-3-4-路由模式" class="headerlink" title="2.3.4 路由模式"></a>2.3.4 路由模式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624180913.png"></p>
<ul>
<li>路由会根据类型进行<strong>定向分发</strong>消息给不同的队列，如图所示</li>
<li>可以理解为是快递公司的分拣中心，整个小区，东面的楼小张送货，西面的楼小王送货</li>
</ul>
<h5 id="2-3-4-1-生产者"><a href="#2-3-4-1-生产者" class="headerlink" title="2.3.4.1 生产者"></a>2.3.4.1 生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明路由(路由名，路由类型) </span></span><br><span class="line">		<span class="comment">// direct：根据路由键进行定向分发消息 </span></span><br><span class="line">		channel.exchangeDeclare(<span class="string">&quot;test_exchange_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;用户注册，【userid=S101】&quot;</span>;</span><br><span class="line">		channel.basicPublish(<span class="string">&quot;test_exchange_direct&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">		System.out.println(<span class="string">&quot;[用户系统]：&quot;</span> + msg);</span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3-4-2-消费者1"><a href="#2-3-4-2-消费者1" class="headerlink" title="2.3.4.2 消费者1"></a>2.3.4.2 消费者1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_exchange_direct_queue_1&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 绑定路由（如果路由键的类型是 添加，删除，修改 的话，绑定到这个队列1上）</span></span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_direct_queue_1&quot;</span>, <span class="string">&quot;test_exchange_direct&quot;</span>, <span class="string">&quot;insert&quot;</span>);</span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_direct_queue_1&quot;</span>, <span class="string">&quot;test_exchange_direct&quot;</span>, <span class="string">&quot;update&quot;</span>);</span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_direct_queue_1&quot;</span>, <span class="string">&quot;test_exchange_direct&quot;</span>, <span class="string">&quot;delete&quot;</span>);</span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【消费者1】 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 4.监听队列 true:自动消息确认 </span></span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_exchange_direct_queue_1&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3-4-3-消费者2"><a href="#2-3-4-3-消费者2" class="headerlink" title="2.3.4.3 消费者2"></a>2.3.4.3 消费者2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 绑定路由（如果路由键的类型是 查询 的话，绑定到这个队列2上） </span></span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>, <span class="string">&quot;test_exchange_direct&quot;</span>, <span class="string">&quot;select&quot;</span>);</span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【消费者2】 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 4.监听队列 true:自动消息确认 </span></span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>记住运行程序的顺序，先运行一次sender（创建路由器），</li>
<li>有了路由器之后，在创建两个Recer1和Recer2，进行队列绑定</li>
<li>再次运行sender，发出消息</li>
</ol>
<h4 id="2-3-5-通配符模式"><a href="#2-3-5-通配符模式" class="headerlink" title="2.3.5 通配符模式"></a>2.3.5 通配符模式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624170909.png"></p>
<ul>
<li><p>和路由模式90%是一样的。</p>
</li>
<li><p>唯独的区别就是路由键支持模糊匹配</p>
</li>
<li><p>匹配符号</p>
<ul>
<li>*：只能匹配一个词（正好一个词，多一个不行，少一个也不行）</li>
<li>#：匹配0个或更多个词</li>
</ul>
</li>
<li><p>看一下官网案例：</p>
<ul>
<li><p>Q1绑定了路由键 <em>.orange.</em> Q2绑定了路由键 <em>.</em>.rabbit 和 lazy.#</p>
</li>
<li><p>下面生产者的消息会被发送给哪个队列？</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">quick.<span class="keyword">orange.rabbit </span>   <span class="comment"># Q1 Q2 </span></span><br><span class="line">lazy.<span class="keyword">orange.elephant </span>  <span class="comment"># Q1 Q2 </span></span><br><span class="line">quick.<span class="keyword">orange.fox </span>      <span class="comment"># Q1 </span></span><br><span class="line">lazy.<span class="keyword">brown.fox </span>        <span class="comment"># Q2 </span></span><br><span class="line">lazy.pink.rabbit       <span class="comment"># Q2 </span></span><br><span class="line">quick.<span class="keyword">brown.fox </span>       <span class="comment"># 无 </span></span><br><span class="line"><span class="keyword">orange </span>                <span class="comment"># 无 </span></span><br><span class="line">quick.<span class="keyword">orange.male.rabbit </span><span class="comment"># 无</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="2-3-5-1-生产者"><a href="#2-3-5-1-生产者" class="headerlink" title="2.3.5.1 生产者"></a>2.3.5.1 生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明路由(路由名，路由类型) </span></span><br><span class="line">		<span class="comment">// topic：模糊匹配的定向分发 </span></span><br><span class="line">		channel.exchangeDeclare(<span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;商品降价&quot;</span>;</span><br><span class="line">		channel.basicPublish(<span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;product.price&quot;</span>, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">		System.out.println(<span class="string">&quot;[用户系统]：&quot;</span> + msg);</span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-5-2-消费者1"><a href="#2-3-5-2-消费者1" class="headerlink" title="2.3.5.2 消费者1"></a>2.3.5.2 消费者1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_exchange_topic_queue_1&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 绑定路由（绑定 用户相关 的消息） </span></span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_topic_queue_1&quot;</span>, <span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;user.#&quot;</span>);</span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【消费者1】 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 4.监听队列 true:自动消息确认 </span></span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_exchange_topic_queue_1&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-5-3-消费者2"><a href="#2-3-5-3-消费者2" class="headerlink" title="2.3.5.3 消费者2"></a>2.3.5.3 消费者2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列 </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_exchange_topic_queue_2&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 绑定路由（绑定 商品和订单相关 的消息） </span></span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_topic_queue_2&quot;</span>, <span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;product.#&quot;</span>);</span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_topic_queue_2&quot;</span>, <span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;order.#&quot;</span>);</span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【消费者2】 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		;</span><br><span class="line">		<span class="comment">// 4.监听队列 true:自动消息确认 </span></span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_exchange_topic_queue_2&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-持久化"><a href="#2-4-持久化" class="headerlink" title="2.4 持久化"></a>2.4 持久化</h3><ul>
<li>消息的可靠性是RabbitMQ的一大特色，那么RabbitMQ是如何避免消息丢失？<ul>
<li>消费者的ACK确认机制，可以防止消费者丢失消息</li>
<li>万一在消费者消费之前，RabbitMQ服务器宕机了，那消息也会丢失</li>
</ul>
</li>
<li>想要将消息持久化，那么 路由和队列都要持久化 才可以</li>
</ul>
<h4 id="2-4-1-生产者"><a href="#2-4-1-生产者" class="headerlink" title="2.4.1 生产者"></a>2.4.1 生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明路由(路由名，路由类型，持久化) </span></span><br><span class="line">		channel.exchangeDeclare(<span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;商品降价&quot;</span>;</span><br><span class="line">		<span class="comment">// 发送消息(第三个参数作用是让消息持久化) </span></span><br><span class="line">		channel.basicPublish(<span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;product.price&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">		System.out.println(<span class="string">&quot;[用户系统]：&quot;</span> + msg);</span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-4-2-消费者"><a href="#2-4-2-消费者" class="headerlink" title="2.4.2 消费者"></a>2.4.2 消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		<span class="comment">// 声明队列( 第二个参数为true：支持持久化) </span></span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_exchange_topic_queue_1&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_exchange_topic_queue_1&quot;</span>, <span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;user.#&quot;</span>);</span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【消费者1】 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_exchange_topic_queue_1&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-Spring整合RabbitMQ"><a href="#2-5-Spring整合RabbitMQ" class="headerlink" title="2.5 Spring整合RabbitMQ"></a>2.5 Spring整合RabbitMQ</h3><ul>
<li>五种消息模型，在企业中应用最广泛的就是最后一种：定向匹配topic</li>
<li>Spring AMQP 是基于 Spring 框架的AMQP消息解决方案，提供模板化的发送和接收消息的抽象层，提供基于消息驱动的 POJO的消息监听等，简化了我们对于RabbitMQ相关程序的开发。</li>
</ul>
<h4 id="2-5-1-生产端工程"><a href="#2-5-1-生产端工程" class="headerlink" title="2.5.1 生产端工程"></a>2.5.1 生产端工程</h4><ul>
<li><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-rabbitmq-producer.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot; http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd   </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/rabbit </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.配置连接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">host</span>=<span class="string">&quot;192.168.204.141&quot;</span> <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span> <span class="attr">username</span>=<span class="string">&quot;laosun&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span> <span class="attr">virtual-host</span>=<span class="string">&quot;/lagou&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.配置队列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置rabbitAdmin：主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删 除队列与交换机，发送消息等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.配置topic类型exchange；队列绑定到交换机 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">&quot;spring_topic_exchange&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;test_spring_queue_1&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;msg.#&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:topic-exchange</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5. 配置消息对象json转换类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 6. 配置RabbitTemplate（消息生产者） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">exchange</span>=<span class="string">&quot;spring_topic_exchange&quot;</span> <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 1.创建spring容器 </span></span><br><span class="line">		<span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring/spring-rabbitmq-producer.xml&quot;</span>);</span><br><span class="line">		<span class="comment">// 2.从容器中获取对象 </span></span><br><span class="line">		<span class="type">RabbitTemplate</span> <span class="variable">template</span> <span class="operator">=</span> context.getBean(RabbitTemplate.class);</span><br><span class="line">		<span class="comment">// 3.发送消息</span></span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;大佬孙&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;19998539@qq.com&quot;</span>);</span><br><span class="line">		template.convertAndSend(<span class="string">&quot;msg.user&quot;</span>, map);</span><br><span class="line">		context.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-2-消费端工程"><a href="#2-5-2-消费端工程" class="headerlink" title="2.5.2 消费端工程"></a>2.5.2 消费端工程</h4><ul>
<li><p>依赖与生产者一致</p>
</li>
<li><p>spring-rabbitmq-consumer.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot; http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/rabbit </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/rabbit/spring-rabbit.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 配置连接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">host</span>=<span class="string">&quot;192.168.204.141&quot;</span><span class="attr">port</span>=<span class="string">&quot;5672&quot;</span> <span class="attr">username</span>=<span class="string">&quot;laosun&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span> <span class="attr">virtual-host</span>=<span class="string">&quot;/lagou&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 配置队列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置rabbitAdmin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.springIOC注解扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;listener&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.配置监听 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;consumerListener&quot;</span> <span class="attr">queue-</span> <span class="attr">names</span>=<span class="string">&quot;test_spring_queue_1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者</p>
<ul>
<li>MessageListener接口用于spring容器接收到消息后处理消息</li>
<li>如果需要使用自己定义的类型 来实现 处理消息时，必须实现该接口，并重写onMessage()方法</li>
<li>当spring容器接收消息后，会自动交由onMessage进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">	<span class="comment">// jackson提供序列化和反序列中使用最多的类，用来转换json的 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 将message对象转换成json </span></span><br><span class="line">			<span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> MAPPER.readTree(message.getBody());</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;name&quot;</span>).asText();</span><br><span class="line">			<span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;email&quot;</span>).asText();</span><br><span class="line">			System.out.println(<span class="string">&quot;从队列中获取：【&quot;</span>+name+<span class="string">&quot;的邮箱是:&quot;</span>+email+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动项目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunner</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 获得容器 </span></span><br><span class="line">		<span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring/spring-rabbitmq-consumer.xml&quot;</span>);</span><br><span class="line">		<span class="comment">// 让程序一直运行，别终止 </span></span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-消息成功确认机制"><a href="#2-6-消息成功确认机制" class="headerlink" title="2.6 消息成功确认机制"></a>2.6 消息成功确认机制</h3><p>在实际场景下，有的生产者发送的消息是必须保证成功发送到消息队列中，那么如何保证成功投递呢？</p>
<ul>
<li>事务机制</li>
<li>发布确认机制</li>
</ul>
<h4 id="2-6-1-事务机制"><a href="#2-6-1-事务机制" class="headerlink" title="2.6.1 事务机制"></a>2.6.1 事务机制</h4><ul>
<li>AMQP协议提供的一种保证消息成功投递的方式，通过信道开启 transactional 模式</li>
<li>并利用信道 的三个方法来实现以事务方式 发送消息，若发送失败，通过异常处理回滚事务，确保消息成功投递<ul>
<li>channel.txSelect()： 开启事务</li>
<li>channel.txCommit() ：提交事务</li>
<li>channel.txRollback() ：回滚事务</li>
</ul>
</li>
<li>Spring已经对上面三个方法进行了封装，所以我们只能使用原始的代码演示</li>
</ul>
<h5 id="2-6-1-1-生产者"><a href="#2-6-1-1-生产者" class="headerlink" title="2.6.1.1 生产者"></a>2.6.1.1 生产者</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Sender &#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">		<span class="keyword">Connection</span> <span class="keyword">connection</span> = ConnectionUtil.getConnection();</span><br><span class="line">		Channel channel = <span class="keyword">connection</span>.createChannel();</span><br><span class="line">		channel.exchangeDeclare(&quot;test_transaction&quot;, &quot;topic&quot;);</span><br><span class="line">		channel.txSelect();</span><br><span class="line">		// 开启事务 </span><br><span class="line">		try &#123;</span><br><span class="line">			channel.basicPublish(&quot;test_transaction&quot;, &quot;product.price&quot;, <span class="keyword">null</span>, &quot;商品 降价1&quot;.getBytes());</span><br><span class="line">			// <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="number">1</span>/<span class="number">0</span>); // 模拟异常！ </span><br><span class="line">			channel.basicPublish(&quot;test_transaction&quot;, &quot;product.price&quot;, <span class="keyword">null</span>, &quot;商品 降价2&quot;.getBytes());</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;消息全部发出！&quot;);</span><br><span class="line">			channel.txCommit();</span><br><span class="line">			// 事务提交</span><br><span class="line">		&#125;</span><br><span class="line">		catch (<span class="keyword">Exception</span> e)&#123;</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;由于系统异常，消息全部撤回！&quot;);</span><br><span class="line">			channel.txRollback();</span><br><span class="line">			// 事务回滚 </span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			channel.<span class="keyword">close</span>();</span><br><span class="line">			<span class="keyword">connection</span>.<span class="keyword">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-6-1-2-消费者"><a href="#2-6-1-2-消费者" class="headerlink" title="2.6.1.2 消费者"></a>2.6.1.2 消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">		channel.queueDeclare(<span class="string">&quot;test_transaction_queue&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">		channel.queueBind(<span class="string">&quot;test_transaction_queue&quot;</span>, <span class="string">&quot;test_transaction&quot;</span>, <span class="string">&quot;product.#&quot;</span>);</span><br><span class="line">		<span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">				System.out.println(<span class="string">&quot;【消费者】 = &quot;</span> + s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(<span class="string">&quot;test_transaction_queue&quot;</span>, <span class="literal">true</span>,consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-6-2-Confirm发布确认机制"><a href="#2-6-2-Confirm发布确认机制" class="headerlink" title="2.6.2 Confirm发布确认机制"></a>2.6.2 Confirm发布确认机制</h4><ul>
<li><p>RabbitMQ为了保证消息的成功投递，采用通过AMQP协议层面为我们提供事务机制的方案，但是采用事务会大大降低消息的吞吐量</p>
</li>
<li><p>老孙我本机SSD硬盘测试结果10w条消息未开启事务，大约8s发送完毕；而开启了事务后，需要将近310s，差了30多倍。</p>
</li>
<li><p>接着翻阅官网，发现官网中已标注</p>
<blockquote>
<p>Using standard AMQP 0-9-1, the only way to guarantee that a message isn’t lost is by using transactions – make the channel transactional then for each message or set of messages publish, commit. In this case, transactions are unnecessarily heavy weightand decrease throughput by a factor of 250. To remedy this, a confirmation mechanism was introduced. It mimics the consumer acknowled gements mechanismalready present in the protocol.</p>
<p>关键性译文：开启事务性能最大损失超过250倍</p>
</blockquote>
</li>
<li><p>那么有没有更加高效的解决方式呢？答案就是采用Confirm模式。</p>
</li>
<li><p>事务效率为什么会这么低呢？试想一下：10条消息，前9条成功，如果第10条失败，那么9条消息要全部撤销回滚。太太太浪费</p>
</li>
<li><p>而confirm模式则采用<strong>补发</strong>第10条的措施来完成10条消息的送达</p>
</li>
</ul>
<h5 id="2-6-2-1-在spring中应用"><a href="#2-6-2-1-在spring中应用" class="headerlink" title="2.6.2.1 在spring中应用"></a>2.6.2.1 在spring中应用</h5><ul>
<li><p>spring-rabbitmq-producer.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置连接，启动生产者确认机制: publisher-confirms=&quot;true&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> 	 		 		       <span class="attr">host</span>=<span class="string">&quot;192.168.204.141&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">&quot;laosun&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">virtual-host</span>=<span class="string">&quot;/lagou&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">publisher-confirms</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--6.配置rabbitmq的模版,添加确认回调处理类:confirm- callback=&quot;msgSendConfirmCallback&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">exchange</span>=<span class="string">&quot;spring_topic_exchange&quot;</span> <span class="attr">message-</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> <span class="attr">confirm-</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">callback</span>=<span class="string">&quot;msgSendConfirmCallback&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--7.确认机制处理类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;msgSendConfirmCallback&quot;</span> <span class="attr">class</span>=<span class="string">&quot;confirm.MsgSendConfirmCallback&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息确认处理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> confirm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.support.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: spring-rabbitmq-producer </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: GuoAn.Sun </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 确认机制 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgSendConfirmCallback</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, Boolean b, String s)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (b)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;消息确认成功！！&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;消息确认失败...&quot;</span>);</span><br><span class="line">			<span class="comment">// 如果本条消息一定要发送到队列中，例如下订单消息，我们可以采用消息补发 </span></span><br><span class="line">			<span class="comment">// 采用递归（固定次数，不可无限）或 redis+定时任务</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>log4j.properties</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.stdout.Target=System.out </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;<span class="attribute">yyyy-MM-dd HH</span>:mm:ss&#125; %m%n log4j<span class="variable">.appender</span><span class="variable">.file</span>=org<span class="variable">.apache</span><span class="variable">.log</span>4j<span class="variable">.FileAppender</span> </span><br><span class="line">log4j<span class="variable">.appender</span><span class="variable">.file</span><span class="variable">.File</span>=rabbitmq<span class="variable">.log</span> </span><br><span class="line">log4j<span class="variable">.appender</span><span class="variable">.file</span><span class="variable">.layout</span>=org<span class="variable">.apache</span><span class="variable">.log</span>4j<span class="variable">.PatternLayout</span> </span><br><span class="line">log4j<span class="variable">.appender</span><span class="variable">.file</span><span class="variable">.layout</span><span class="variable">.ConversionPattern</span>=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n log4j<span class="variable">.rootLogger</span>=debug, stdout,file</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring/spring-rabbitmq-producer.xml&quot;</span>);</span><br><span class="line">		<span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> context.getBean(RabbitTemplate.class);</span><br><span class="line">		Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;吕布&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;666@qq.com&quot;</span>);</span><br><span class="line">		<span class="comment">// 第一个参数是路由名称，</span></span><br><span class="line">		<span class="comment">// 不写，则使用spring容器中创建的路由 </span></span><br><span class="line">		<span class="comment">// 乱写一个，因为路由名错误导致报错，则进入消息确认失败流程 </span></span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;msg.user&quot;</span>,map);</span><br><span class="line">		System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">		context.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-消费端限流"><a href="#2-7-消费端限流" class="headerlink" title="2.7 消费端限流"></a>2.7 消费端限流</h3><ul>
<li><p>在沙漠中行走，3天不喝水，突然喝水，如果使劲喝，容易猝死，要一口一口慢慢喝</p>
</li>
<li><p>我们 Rabbitmq 服务器积压了成千上万条未处理的消息，然后随便打开一个消费者客户端，就会出现这样的情况: 巨量的消息瞬间全部喷涌推送过来，但是单个客户端无法同时处理这么多数据，就会被压垮崩溃</p>
</li>
<li><p>所以，当数据量特别大的时候，我们对<strong>生产端限流</strong>肯定是不科学的，因为有时候并发量就是特别大，有时候并发量又特别少，这是用户的行为，我们是无法约束的</p>
</li>
<li><p>所以我们应该对<strong>消费端限流</strong>，用于保持消费端的稳定</p>
</li>
<li><p>例如：汽车企业不停的生产汽车，4S店有好多库存车卖不出去，但是也不会降价处理，就是要保证市值的稳定，如果生产多少台，就卖多少台，不管价格的话，市场就乱了，所以我们要用不变的价格来稳住消费者购车，才能平稳发展</p>
</li>
<li><p>RabbitMQ 提供了一种 Qos （Quality of Service，服务质量）服务质量保证功能</p>
<ul>
<li>即在非自动确认消息的前提下，如果一定数目的消息未被确认前，不再进行消费新的消息</li>
</ul>
</li>
<li><p>生产者使用循环发出多条消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;msg.user&quot;</span>, map);</span><br><span class="line">	System.out.println(<span class="string">&quot;消息已发出...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产10条堆积未处理的消息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624180827.png"></p>
</li>
<li><p>消费者进行限流处理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--5.配置监听--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- prefetch=&quot;3&quot; 一次性消费的消息数量。会告诉 RabbitMQ 不要同时给一个消费者推送多于 N 个消息，一旦有 N 个消息还没有ack，则该 consumer 将阻塞，直到消息被ack--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- acknowledge-mode: manual 手动确认--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">prefetch</span>=<span class="string">&quot;3&quot;</span> <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;consumerListener&quot;</span> <span class="attr">queue-names</span>=<span class="string">&quot;test_spring_queue_1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAdaptableMessageListener用于在spring容器接收到消息后用于处理消息的抽象 基类</span></span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerListener</span> <span class="keyword">extends</span> <span class="title class_">AbstractAdaptableMessageListener</span> &#123;</span><br><span class="line">	<span class="comment">// jackson提供序列化和反序列中使用最多的类，用来转换json的 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// String str = new String(message.getBody()); </span></span><br><span class="line">			<span class="comment">// 将message对象转换成json </span></span><br><span class="line">			<span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> MAPPER.readTree(message.getBody());</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;name&quot;</span>).asText();</span><br><span class="line">			<span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;email&quot;</span>).asText();</span><br><span class="line">			System.out.println(<span class="string">&quot;从队列中获取：【&quot;</span>+name+<span class="string">&quot;的邮箱是:&quot;</span>+email+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">			<span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">			<span class="comment">//确认收到(参数1,参数2) </span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			参数1：RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID，是一个单调递 增的正整数，delivery_tag 的范围仅限于 Channel </span></span><br><span class="line"><span class="comment">			参数2：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以 一次性确认 delivery_tag 小于等于传入值的所有消息 </span></span><br><span class="line"><span class="comment">			*/</span> </span><br><span class="line">			channel.basicAck(deliveryTag , <span class="literal">true</span>);</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;休息三秒然后再接收消息&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次确认接收3条消息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624174934.png"></p>
</li>
</ul>
<h3 id="2-8-过期时间TTL"><a href="#2-8-过期时间TTL" class="headerlink" title="2.8 过期时间TTL"></a>2.8 过期时间TTL</h3><ul>
<li>Time To Live：生存时间、还能活多久，单位毫秒</li>
<li>在这个周期内，消息可以被消费者正常消费，超过这个时间，则自动删除（其实是被称为deadmessage并投入到死信队列，无法消费该消息）</li>
<li>RabbitMQ可以对<strong>消息</strong>和<strong>队列</strong>设置TTL<ul>
<li>通过队列设置，队列中所有消息都有相同的过期时间</li>
<li>对消息单独设置，每条消息的TTL可以不同（更颗粒化）</li>
</ul>
</li>
</ul>
<h4 id="2-8-1-设置队列TTL"><a href="#2-8-1-设置队列TTL" class="headerlink" title="2.8.1 设置队列TTL"></a>2.8.1 设置队列TTL</h4><ul>
<li><p>spring-rabbitmq-producer.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.重新配置一个队列，同时，对队列中的消息设置过期时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_ttl&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624175144.png"></p>
</li>
<li><p>5秒之后，消息自动删除</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624175207.png"></p>
</li>
</ul>
<h4 id="2-8-2-设置消息TTL"><a href="#2-8-2-设置消息TTL" class="headerlink" title="2.8.2 设置消息TTL"></a>2.8.2 设置消息TTL</h4><ul>
<li><p>设置某条消息的ttl，只需要在创建发送消息时指定即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.配置队列--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_ttl_2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: spring-rabbitmq-producer </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: GuoAn.Sun </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring/spring-rabbitmq-producer.xml&quot;</span>);</span><br><span class="line">		<span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> context.getBean(RabbitTemplate.class);</span><br><span class="line">		<span class="comment">// 创建消息配置对象 </span></span><br><span class="line">		<span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">		<span class="comment">// 设置消息过期时间 </span></span><br><span class="line">		messageProperties.setExpiration(<span class="string">&quot;6000&quot;</span>);</span><br><span class="line">		<span class="comment">// 创建消息 </span></span><br><span class="line">		<span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;6秒后自动删除&quot;</span>.getBytes(), messageProperties);</span><br><span class="line">		<span class="comment">// 发送消息 </span></span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;msg.user&quot;</span>, message);</span><br><span class="line">		System.out.println(<span class="string">&quot;消息已发出...&quot;</span>);</span><br><span class="line">		context.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果同时设置了queue和message的TTL值，则二者中较小的才会起作用</p>
</li>
</ul>
<h3 id="2-9-死信队列"><a href="#2-9-死信队列" class="headerlink" title="2.9 死信队列"></a>2.9 死信队列</h3><ul>
<li><p>DLX（Dead Letter Exchanges）死信交换机&#x2F;死信邮箱，当消息在队列中由于某些原因没有被及时消费而变成死信（dead message）后，这些消息就会被分发到DLX交换机中，而绑定DLX交换机的队列，称之为：“死信队列”</p>
</li>
<li><p>消息没有被及时消费的原因：</p>
<ul>
<li>消息被拒绝（basic.reject&#x2F; basic.nack）并且不再重新投递 requeue&#x3D;false</li>
<li>消息超时未消费</li>
<li>达到最大队列长度</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624175500.png"></p>
</li>
<li><p>spring-rabbitmq-producer-dlx.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置连接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">host</span>=<span class="string">&quot;192.168.204.141&quot;</span> <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span> <span class="attr">username</span>=<span class="string">&quot;laosun&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span> <span class="attr">virtual-host</span>=<span class="string">&quot;/lagou&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.配置rabbitAdmin:主要用于在java代码中对队列的管理，用来创建，绑定，删除队列与交 换机，发送消息等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--6.配置rabbitmq的模版--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span><span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">exchange</span>=<span class="string">&quot;my_exchange&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ##################################################################--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--死信队列--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;dlx_queue&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定向死信交换机--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">&quot;dlx_exchange&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_ttl&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;dlx_queue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_max&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;dlx_queue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试超时的队列--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_ttl_queue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--队列ttl为6秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--超时 消息 投递给 死信交换机--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dlx_exchange&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试超长度的队列--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_max_queue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--队列ttl为6秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-max-length&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--超时 消息 投递给 死信交换机--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dlx_exchange&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定向测试交换机--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">&quot;my_exchange&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_ttl&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;test_ttl_queue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">&quot;dlx_max&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;test_max_queue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发消息进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SenderDLX</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring/spring-rabbitmq-producer-dlx.xml&quot;</span>);</span><br><span class="line">		<span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> context.getBean(RabbitTemplate.class);</span><br><span class="line">		<span class="comment">// rabbitTemplate.convertAndSend(&quot;dlx_ttl&quot;, &quot;测试超时&quot;.getBytes());</span></span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;dlx_max&quot;</span>, <span class="string">&quot;测试长度1&quot;</span>.getBytes());</span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;dlx_max&quot;</span>, <span class="string">&quot;测试长度2&quot;</span>.getBytes());</span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;dlx_max&quot;</span>, <span class="string">&quot;测试长度3&quot;</span>.getBytes());</span><br><span class="line">		System.out.println(<span class="string">&quot;消息已发出...&quot;</span>);</span><br><span class="line">		context.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-10-延迟队列"><a href="#2-10-延迟队列" class="headerlink" title="2.10 延迟队列"></a>2.10 延迟队列</h3><ul>
<li>延迟队列：TTL + 死信队列的合体</li>
<li>死信队列只是一种特殊的队列，里面的消息仍然可以消费</li>
<li>在电商开发部分中，都会涉及到延时关闭订单，此时延迟队列正好可以解决这个问题</li>
</ul>
<h4 id="2-10-1-生产者"><a href="#2-10-1-生产者" class="headerlink" title="2.10.1 生产者"></a>2.10.1 生产者</h4><p>沿用上面死信队列案例的超时测试，超时时间改为订单关闭时间即可</p>
<h4 id="2-10-2-消费者"><a href="#2-10-2-消费者" class="headerlink" title="2.10.2 消费者"></a>2.10.2 消费者</h4><ul>
<li><p>spring-rabbitmq-consumer.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 监听死信队列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">prefetch</span>=<span class="string">&quot;3&quot;</span> <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;consumerListener&quot;</span> <span class="attr">queue-names</span>=<span class="string">&quot;dlx_queue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-RabbitMQ集群"><a href="#3-RabbitMQ集群" class="headerlink" title="3. RabbitMQ集群"></a>3. RabbitMQ集群</h2><p>rabbitmq有3种模式，但集群模式是2种。详细如下：</p>
<ul>
<li>单一模式：即单机情况不做集群，就单独运行一个rabbitmq而已。之前我们一直在用</li>
<li>普通模式：默认模式，以两个节点（A、B）为例来进行说明<ul>
<li>当消息进入A节点的Queue后，consumer从B节点消费时，RabbitMQ会在A和B之间创建临时通道进行消息传输，把A中的消息实体取出并经过通过交给B发送给consumer</li>
<li>当A故障后，B就无法取到A节点中未消费的消息实体<ul>
<li>如果做了消息持久化，那么得等A节点恢复，然后才可被消费</li>
<li>如果没有持久化的话，就会产生消息丢失的现象</li>
</ul>
</li>
</ul>
</li>
<li>镜像模式：非常经典的 mirror 镜像模式，保证 100% 数据不丢失。<ul>
<li>高可靠性解决方案，主要就是实现数据的同步，一般来讲是 2 - 3 个节点实现数据同步</li>
<li>对于 100% 数据可靠性解决方案，一般是采用 3 个节点。</li>
<li>在实际工作中也是用得最多的，并且实现非常的简单，一般互联网大厂都会构建这种镜像集群模式</li>
</ul>
</li>
<li>还有主备模式，远程模式，多活模式等，本次课程不作为重点，可自行查阅资料了解</li>
</ul>
<h3 id="3-1-集群搭建"><a href="#3-1-集群搭建" class="headerlink" title="3.1 集群搭建"></a>3.1 集群搭建</h3><p>前置条件：准备两台linux，并安装好rabbitmq</p>
<p><strong>集群步骤如下：</strong></p>
<ol>
<li><p>修改 &#x2F;etc&#x2F;hosts 映射文件</p>
<p><strong>A服务器：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span> A localhost localhost.localdomain localhost4</span><br><span class="line">localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span> A localhost localhost.localdomain localhost6</span><br><span class="line">localhost6.localdomain6</span><br><span class="line"></span><br><span class="line"><span class="number">192.168.204.141</span> A</span><br><span class="line"><span class="number">192.168.204.142</span> B</span><br></pre></td></tr></table></figure>

<p><strong>B服务器：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span> B localhost localhost.localdomain localhost4</span><br><span class="line">localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span> B localhost localhost.localdomain localhost6</span><br><span class="line">localhost6.localdomain6</span><br><span class="line"></span><br><span class="line"><span class="number">192.168.204.141</span> A</span><br><span class="line"><span class="number">192.168.204.142</span> B</span><br></pre></td></tr></table></figure>
</li>
<li><p>相互通信，cookie必须保持一致，同步 rabbitmq的cookie 文件：跨服务器拷贝 .erlang.cookie（隐藏文件，使用 ls -all 显示）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@A</span> opt]# scp <span class="regexp">/var/</span>lib<span class="regexp">/rabbitmq/</span>.erlang.cookie <span class="number">192.168</span>.<span class="number">204.142</span>:<span class="regexp">/var/</span>lib<span class="operator">/</span>rabbitmq</span><br></pre></td></tr></table></figure>
<p><strong>修改cookie文件，要重启服务器，reboot</strong></p>
</li>
<li><p>停止防火墙，启动rabbitmq服务</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@A ~]<span class="comment"># systemctl stop firewalld </span></span><br><span class="line">[root@A ~]<span class="comment"># systemctl start rabbitmq-server</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加入集群节点</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@B</span> ~]<span class="comment"># rabbitmqctl stop_app </span></span><br><span class="line">[root<span class="variable">@B</span> ~]<span class="comment"># rabbitmqctl join_cluster rabbit<span class="doctag">@A</span> </span></span><br><span class="line">[root<span class="variable">@B</span> ~]<span class="comment"># rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看节点状态</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@B</span> ~]<span class="meta"># rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看管理端</p>
<ul>
<li><p>搭建集群结构之后，之前创建的交换机、队列、用户都属于单一结构，在新的集群环境中是不能用的</p>
</li>
<li><p>所以在新的集群中<strong>重新手动添加用户</strong>即可（任意节点添加，所有节点共享）</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@A</span> ~]<span class="meta"># rabbitmqctl add_user laosun 123123 </span></span><br><span class="line">[root<span class="symbol">@A</span> ~]<span class="meta"># rabbitmqctl set_user_tags laosun administrator </span></span><br><span class="line">[root<span class="symbol">@A</span> ~]<span class="meta"># rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> laosun <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：当节点脱离集群还原成单一结构后，交换机，队列和用户等数据 都会重新回来</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210624180619.png"></p>
</li>
</ol>
<p>此时，集群搭建完毕，但是默认采用的模式**“普通模式”**，<strong>可靠性</strong>不高</p>
<h3 id="3-2-镜像模式"><a href="#3-2-镜像模式" class="headerlink" title="3.2 镜像模式"></a>3.2 镜像模式</h3><ul>
<li><p>将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态一致</p>
<ul>
<li><p>语法：set_policy {name} {pattern} {definition}</p>
</li>
<li><p>name：策略名，可自定义</p>
</li>
<li><p>pattern：队列的匹配模式（正则表达式）</p>
<ul>
<li>“^” 可以使用正则表达式，比如”^queue_” 表示对队列名称以“queue_”开头的所有队列进行镜像，而”^”表示匹配所有的队列</li>
</ul>
</li>
<li><p>definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</p>
<ul>
<li><p>ha-mode：（<strong>H</strong>igh <strong>A</strong>vailable，高可用）模式，指明镜像队列的模式，有效值为all&#x2F;exactly&#x2F;nodes，当前策略模式为 all，即复制到所有节点，包含新增节点</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">all</span>：表示在集群中所有的节点上进行镜像 </span><br><span class="line">exactly：表示在指定个数的节点上进行镜像，节点的个数由<span class="keyword">ha</span>-params指定 </span><br><span class="line">nodes：表示在指定的节点上进行镜像，节点名称通过<span class="keyword">ha</span>-params指定</span><br></pre></td></tr></table></figure>
</li>
<li><p>ha-params：ha-mode模式需要用到的参数</p>
</li>
<li><p>ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@A</span> ~]<span class="meta"># rabbitmqctl set_policy xall <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过管理端设置镜像策略</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628163613.png"></p>
</li>
</ul>
<h3 id="3-3-HAProxy实现镜像队列的负载均衡"><a href="#3-3-HAProxy实现镜像队列的负载均衡" class="headerlink" title="3.3 HAProxy实现镜像队列的负载均衡"></a>3.3 HAProxy实现镜像队列的负载均衡</h3><ul>
<li>虽然我们在程序中访问A服务器，可以实现消息的同步，虽然在同步，但都是A服务器在接收消息，A太累</li>
<li>是否可以想Nginx一样，做负载均衡，A和B轮流接收消息，再镜像同步</li>
</ul>
<h4 id="3-3-1-HAProxy简介"><a href="#3-3-1-HAProxy简介" class="headerlink" title="3.3.1 HAProxy简介"></a>3.3.1 HAProxy简介</h4><ul>
<li>HA（High Available，高可用），Proxy（代理）</li>
<li>HAProxy是一款提供高可用性，负载均衡，并且基于TCP和HTTP应用的代理软件</li>
<li>HAProxy完全免费</li>
<li>HAProxy可以支持数以万计的并发连接</li>
<li>HAProxy可以简单又安全的整合进架构中，同时还保护web服务器不被暴露到网络上</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628163909.png"></p>
<h4 id="3-3-2-HAProxy与Nginx"><a href="#3-3-2-HAProxy与Nginx" class="headerlink" title="3.3.2 HAProxy与Nginx"></a>3.3.2 HAProxy与Nginx</h4><p>OSI：（<strong>Open System Interconnection</strong>：开放式系统互联 是把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层）</p>
<ul>
<li>Nginx的优点：<ul>
<li>工作在OSI第7层，可以针对http应用做一些分流的策略</li>
<li>Nginx对网络的依赖非常小，理论上能ping通就就能进行负载功能，屹立至今的绝对优势</li>
<li>Nginx安装和配置比较简单，测试起来比较方便；</li>
<li>Nginx不仅仅是一款优秀的负载均衡器&#x2F;反向代理软件，它同时也是功能强大的Web应用服务器</li>
</ul>
</li>
<li>HAProxy的优点：<ul>
<li>工作在网络4层和7层，支持TCP与Http协议，</li>
<li>它仅仅就只是一款负载均衡软件；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的</li>
<li>支持8种负载均衡策略 ，支持心跳检测</li>
</ul>
</li>
<li>性能上HA胜，功能性和便利性上Nginx胜</li>
<li>对于Http协议，Haproxy处理效率比Nginx高。所以，没有特殊要求的时候或者一般场景，建议使用Haproxy来做Http协议负载</li>
<li>但如果是Web应用，那么建议使用Nginx！</li>
<li>总之，大家可以结合各自使用场景的特点来进行合理地选择</li>
</ul>
<h4 id="3-3-3-安装和配置"><a href="#3-3-3-安装和配置" class="headerlink" title="3.3.3 安装和配置"></a>3.3.3 安装和配置</h4><p>HAProxy下载：<a target="_blank" rel="noopener" href="http://www.haproxy.org/download/1.8/src/haproxy-1.8.12.tar.gz">http://www.haproxy.org/download/1.8/src/haproxy-1.8.12.tar.gz</a></p>
<ul>
<li><p>解压</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># tar -zxvf haproxy-1.8.12.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>make时需要使用 TARGET 指定内核及版本</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># uname -r </span></span><br><span class="line"><span class="number">3.10</span><span class="number">.0</span><span class="number">-514.6</span><span class="number">.2</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据内核版本选择编译参数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628165246.png"></p>
</li>
<li><p>进入目录，编译和安装</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> opt]<span class="meta"># cd haproxy-1.8.12 </span></span><br><span class="line">[root<span class="symbol">@localhost</span> haproxy<span class="number">-1.8</span><span class="number">.12</span>]<span class="meta"># make TARGET=linux2628 PREFIX=/usr/local/haproxy </span></span><br><span class="line">[root<span class="symbol">@localhost</span> haproxy<span class="number">-1.8</span><span class="number">.12</span>]<span class="meta"># make install PREFIX=/usr/local/haproxy</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装成功后，查看版本</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> haproxy<span class="operator">-</span><span class="number">1.8</span>.<span class="number">12</span>]# <span class="regexp">/usr/</span>local<span class="regexp">/haproxy/</span>sbin<span class="operator">/</span>haproxy <span class="operator">-</span>v</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置启动文件，复制haproxy文件到&#x2F;usr&#x2F;sbin下 ，复制haproxy脚本，到&#x2F;etc&#x2F;init.d下 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> haproxy<span class="operator">-</span><span class="number">1.8</span>.<span class="number">12</span>]# cp <span class="regexp">/usr/</span>local<span class="regexp">/haproxy/</span>sbin<span class="regexp">/haproxy /</span>usr<span class="regexp">/sbin/</span></span><br><span class="line">[root<span class="meta">@localhost</span> haproxy<span class="operator">-</span><span class="number">1.8</span>.<span class="number">12</span>]# cp <span class="operator">./</span>examples<span class="regexp">/haproxy.init /</span>etc<span class="regexp">/init.d/</span>haproxy</span><br><span class="line">[root<span class="meta">@localhost</span> haproxy<span class="operator">-</span><span class="number">1.8</span>.<span class="number">12</span>]# chmod <span class="number">755</span> <span class="regexp">/etc/</span><span class="keyword">init</span>.d<span class="operator">/</span>haproxy</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建系统账号</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> haproxy<span class="number">-1.8</span><span class="number">.12</span>]<span class="meta"># useradd -r haproxy</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>haproxy.cfg 配置文件需要自行创建</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> haproxy<span class="number">-1.8</span><span class="number">.12</span>]<span class="meta"># mkdir /etc/haproxy </span></span><br><span class="line">[root<span class="symbol">@localhost</span> haproxy<span class="number">-1.8</span><span class="number">.12</span>]<span class="meta"># vim /etc/haproxy/haproxy.cfg</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置信息到haproxy.cfg</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局配置 </span></span><br><span class="line"><span class="attribute">global</span></span><br><span class="line">    <span class="comment">#设置日志 </span></span><br><span class="line">    <span class="attribute">log</span> <span class="number">127.0.0.1</span> local0 info </span><br><span class="line">    <span class="comment">#当前工作目录 </span></span><br><span class="line">    <span class="attribute">chroot</span> /usr/local/haproxy </span><br><span class="line">    <span class="comment">#用户与用户组 </span></span><br><span class="line">    <span class="attribute">user</span> haproxy group haproxy </span><br><span class="line">    <span class="comment">#运行进程ID </span></span><br><span class="line">    <span class="attribute">uid</span> <span class="number">99</span> </span><br><span class="line">    <span class="attribute">gid</span> <span class="number">99</span> </span><br><span class="line">    <span class="comment">#守护进程启动 </span></span><br><span class="line">    <span class="attribute">daemon</span> </span><br><span class="line">    <span class="comment">#最大连接数 </span></span><br><span class="line">    <span class="attribute">maxconn</span> <span class="number">4096</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment">#默认配置 </span></span><br><span class="line"><span class="attribute">defaults</span> </span><br><span class="line">    <span class="comment">#应用全局的日志配置 </span></span><br><span class="line">    <span class="attribute">log</span> global </span><br><span class="line">    <span class="comment">#默认的模式mode &#123;tcp|http|health&#125;，TCP是4层，HTTP是7层，health只返回OK </span></span><br><span class="line">    <span class="attribute">mode</span> tcp </span><br><span class="line">    <span class="comment">#日志类别tcplog </span></span><br><span class="line">    <span class="attribute">option</span> tcplog </span><br><span class="line">    <span class="comment">#不记录健康检查日志信息</span></span><br><span class="line">    <span class="attribute">option</span> dontlognull </span><br><span class="line">    <span class="comment">#3次失败则认为服务不可用 </span></span><br><span class="line">    <span class="attribute">retries</span> <span class="number">3</span> </span><br><span class="line">    <span class="comment">#每个进程可用的最大连接数 </span></span><br><span class="line">    <span class="attribute">maxconn</span> <span class="number">2000</span> </span><br><span class="line">    <span class="comment">#连接超时 </span></span><br><span class="line">    <span class="attribute">timeout</span> connect <span class="number">5</span>s </span><br><span class="line">    <span class="comment">#客户端超时30秒，ha就会发起重新连接 </span></span><br><span class="line">    <span class="attribute">timeout</span> client <span class="number">30</span>s </span><br><span class="line">    <span class="comment">#服务端超时15秒，ha就会发起重新连接 </span></span><br><span class="line">    <span class="attribute">timeout</span> server <span class="number">15</span>s</span><br><span class="line">    </span><br><span class="line"><span class="comment">#绑定配置 </span></span><br><span class="line"><span class="attribute">listen</span> rabbitmq_cluster </span><br><span class="line">    <span class="attribute">bind</span> <span class="number">192.168.204.143:5672</span> </span><br><span class="line">    <span class="comment">#配置TCP模式 </span></span><br><span class="line">    <span class="attribute">mode</span> tcp </span><br><span class="line">    <span class="comment">#简单的轮询 </span></span><br><span class="line">    <span class="attribute">balance</span> roundrobin </span><br><span class="line">    <span class="comment">#RabbitMQ集群节点配置，每隔5秒对mq集群做检查，2次正确证明服务可用，3次失败证 明服务不可用</span></span><br><span class="line">    <span class="attribute">server</span> A <span class="number">192.168.204.141:5672</span> check inter <span class="number">5000</span> rise <span class="number">2</span> fall <span class="number">3</span> </span><br><span class="line">    <span class="attribute">server</span> B <span class="number">192.168.204.142:5672</span> check inter <span class="number">5000</span> rise <span class="number">2</span> fall <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#haproxy监控页面地址 </span></span><br><span class="line"><span class="attribute">listen</span> monitor </span><br><span class="line">    <span class="attribute">bind</span> <span class="number">192.168.204.143:8100</span> </span><br><span class="line">    <span class="attribute">mode</span> http</span><br><span class="line">    <span class="attribute">option</span> httplog </span><br><span class="line">    <span class="attribute">stats</span> enable </span><br><span class="line">    <span class="comment"># 监控页面地址 http://192.168.204.143:8100/monitor </span></span><br><span class="line">    <span class="attribute">stats</span> uri /monitor stats refresh <span class="number">5</span>s</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动HAProxy</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> haproxy]<span class="meta"># service haproxy start</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问监控中心：<a target="_blank" rel="noopener" href="http://192.168.204.143:8100/monitor">http://192.168.204.143:8100/monitor</a></p>
<p>记得关闭防火墙： systemctl stop firewalld</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628170340.png"></p>
</li>
<li><p>项目发消息，只需要将服务器地址修改为143即可，其余不变</p>
</li>
<li><p>所有的请求都会交给HAProxy，其负载均衡给每个rabbitmq服务器</p>
</li>
</ul>
<h3 id="3-4-KeepAlived搭建高可用的HAProxy集群"><a href="#3-4-KeepAlived搭建高可用的HAProxy集群" class="headerlink" title="3.4 KeepAlived搭建高可用的HAProxy集群"></a>3.4 KeepAlived搭建高可用的HAProxy集群</h3><p>现在的最后一个问题暴露出来了，如果HAProxy服务器宕机，rabbitmq服务器就不可用了。所以我们需要对HAProxy也要做高可用的集群</p>
<h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h4><ul>
<li>Keepalived是Linux下一个轻量级别的高可用热备解决方案</li>
<li>Keepalived的作用是检测服务器的状态，它根据TCP&#x2F;IP参考模型的第三、第四层、第五层交换机制检测每个服务节点的状态，如果有一台web服务器宕机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，同时使用其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。</li>
<li>keepalived基于vrrp（<strong>V</strong>irtual <strong>R</strong>outer <strong>R</strong>edundancy <strong>P</strong>rotocol，虚拟路由冗余协议）协议，vrrp它是一种<strong>主备</strong>（主机和备用机）模式的协议，通过VRRP可以在网络发生故障时<strong>透明的进行设备切换</strong>而不影响主机之间的数据通信</li>
<li>两台主机之间生成一个虚拟的ip，我们称漂移ip，漂移ip由主服务器承担，一但主服务器宕机，备份服务器就会抢夺漂移ip，继续工作，有效的解决了群集中的单点故障</li>
<li>说白了，将多台路由器设备<strong>虚拟</strong>成一个设备，对外提供统一ip（VIP）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628170534.png"></p>
<h4 id="3-4-2-安装KeepAlived"><a href="#3-4-2-安装KeepAlived" class="headerlink" title="3.4.2 安装KeepAlived"></a>3.4.2 安装KeepAlived</h4><ul>
<li><p>修改hosts文件的地址映射</p>
<table>
    <tr>
        <th>IP</th>
        <th>用途</th>
        <th>主机名</th>
    </tr>
    <tr>
        <td>192.168.204.143</td>
        <td>KeepAlived HAProxy</td>
        <td>C</td>
    </tr>
    <tr>
        <td>192.168.204.144</td>
        <td>KeepAlived HAProxy</td>
        <td>D</td>
    </tr>
</table>
</li>
<li><p>安装 keepalived</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@C</span> ~]<span class="meta"># yum install -y keepalived</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件（内容大改，不如删掉，重新创建）</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@C</span> ~]<span class="meta"># rm -rf /etc/keepalived/keepalived.conf </span></span><br><span class="line">[root<span class="symbol">@C</span> ~]<span class="meta"># vim /etc/keepalived/keepalived.conf</span></span><br></pre></td></tr></table></figure>

<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id C ## 非常重要，标识本机的hostname</span><br><span class="line">&#125; </span><br><span class="line">vrrp_script chk_haproxy&#123;</span><br><span class="line">    script <span class="string">&quot;/etc/keepalived/haproxy_check.sh&quot;</span> ## 执行的脚本位置</span><br><span class="line">    interval <span class="number">2</span> ## 检测时间间隔</span><br><span class="line">    weight <span class="number">-20</span> ## 如果条件成立则权重减<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER ## 非常重要，标识主机，备用机<span class="number">143</span>改为 BACKUP</span><br><span class="line">    interface ens33 ## 非常重要，网卡名（ifconfig查看）</span><br><span class="line">    virtual_router_id <span class="number">66</span> ## 非常重要，自定义，虚拟路由ID号（主备节点要相同）</span><br><span class="line">    priority <span class="number">100</span> ## 优先级（<span class="number">0</span><span class="number">-254</span>），一般主机的大于备机</span><br><span class="line">    advert_int <span class="number">1</span> ## 主备信息发送间隔，两个节点必须一致，默认<span class="number">1</span>秒</span><br><span class="line">    authentication &#123; ## 认证匹配，设置认证类型和密码，MASTER和BACKUP必须使 用相同的密码才能正常通信</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_haproxy ## 检查haproxy健康状况的脚本</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; ## 简称“VIP”</span><br><span class="line">        <span class="number">192.168</span><span class="number">.204</span><span class="number">.66</span>/<span class="number">24</span> ## 非常重要，虚拟ip，可以指定多个，以后连接mq就用这个虚拟ip</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server <span class="number">192.168</span><span class="number">.204</span><span class="number">.66</span> <span class="number">5672</span> &#123; ## 虚拟ip的详细配置</span><br><span class="line">    delay_loop <span class="number">6</span> # 健康检查间隔，单位为秒</span><br><span class="line">    lb_algo rr # lvs调度算法rr|wrr|lc|wlc|lblc|sh|dh</span><br><span class="line">    lb_kind NAT # 负载均衡转发规则。一般包括DR,NAT,TUN <span class="number">3</span>种</span><br><span class="line">    protocol TCP # 转发协议，有TCP和UDP两种，一般用TCP</span><br><span class="line">    real_server <span class="number">192.168</span><span class="number">.204</span><span class="number">.143</span> <span class="number">5672</span> &#123; ## 本机的真实ip</span><br><span class="line">        weight <span class="number">1</span> # 默认为<span class="number">1</span>,<span class="number">0</span>为失效</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建执行脚本 &#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">COUNT=`ps -C haproxy --no-header |<span class="built_in">wc</span> -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$COUNT</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class="line">    <span class="built_in">sleep</span> 2</span><br><span class="line">    <span class="keyword">if</span> [ `ps -C haproxy --no-header |<span class="built_in">wc</span> -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        killall keepalived</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>Keepalived 组之间的心跳检查并不能察觉到 HAproxy 负载是否正常，所以需要使用此脚本。在 Keepalived 主机上，开启此脚本检测 HAproxy 是否正常工作，如正常工作，记录日志。如进程不存在，则尝试重启 HAproxy ，2秒后检测，如果还没有，则关掉主 Keepalived ，此时备Keepalived 检测到主 Keepalived 挂掉，接管VIP，继续服务</p>
</li>
<li><p>授权，否则不能执行</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@C</span> etc]<span class="meta"># chmod +x /etc/keepalived/haproxy_check.sh</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动keepalived（两台都启动）</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C etc]<span class="comment"># systemctl stop firewalld </span></span><br><span class="line">[root@C etc]<span class="comment"># service keepalived start | stop | status | restart</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@C</span> etc]<span class="meta"># ps -ef | grep haproxy</span></span><br><span class="line">[root<span class="symbol">@C</span> etc]<span class="meta"># ps -ef | grep keepalived</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看ip情况 ip addr 或 ip a </p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@C</span> etc]<span class="meta"># ip a</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628172305.png"></p>
</li>
<li><p>此时，安装完毕，按照上面的步骤就可以安装第二台了（服务器hostname和ip注意要修改）</p>
</li>
<li><p>常见的网络错误：子网掩码、网关等信息要一致</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628172420.png"></p>
</li>
</ul>
<h4 id="3-4-3-测试ip漂移的规则"><a href="#3-4-3-测试ip漂移的规则" class="headerlink" title="3.4.3 测试ip漂移的规则"></a>3.4.3 测试ip漂移的规则</h4><ul>
<li><p>查看虚<code>拟ip ip addr</code> 或 <code>ip a</code></p>
</li>
<li><p>目前，C节点是主机，所以虚拟ip在C节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628172507.png"></p>
</li>
<li><p>停止C的keepalived，虚拟ip漂移到D节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628172528.png"></p>
</li>
<li><p>重新启动C节点keepalived，虚拟ip依旧在D节点，并不会由于C的回归而回归</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628172621.png"></p>
</li>
<li><p>停止D的keepalived，虚拟ip再漂移回C节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/20210628172610.png"></p>
</li>
<li><p>测试vip+端口是否提供服务（在141，A服务器上测试）</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@A</span> ~]<span class="meta"># curl 192.168.204.66:5672</span></span><br><span class="line">AMQP <span class="meta">## 正常提供AMQP服务，表示通过vip访问mq服务正常</span></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/assets/img/article/article.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/29/SpringBoot/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/article/article.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot详解</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/15/FastDFS%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/img/article/article.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">FastDFS详解</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFRabbitMQ"><span class="toc-text">1. 什么是RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-MQ%EF%BC%88Message-Queue%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">1.1 MQ（Message Queue）消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-text">1.1.1 异步处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="toc-text">1.1.2 应用解耦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="toc-text">1.1.3 流量削峰</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.2 背景知识介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-AMQP%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8D%8F%E8%AE%AE"><span class="toc-text">1.2.1 AMQP高级消息队列协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-JMS"><span class="toc-text">1.2.2 JMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E4%BA%8C%E8%80%85%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-text">1.2.3 二者的联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-Erlang%E8%AF%AD%E8%A8%80"><span class="toc-text">1.2.4 Erlang语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9RabbitMQ"><span class="toc-text">1.3 为什么选择RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-RabbitMQ%E5%90%84%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="toc-text">1.4 RabbitMQ各组件功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E7%94%A8RabbitMQ"><span class="toc-text">2. 怎么用RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-RabbitMQ%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8"><span class="toc-text">2.1 RabbitMQ安装启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%AE%89%E8%A3%85"><span class="toc-text">2.1.1 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%90%AF%E5%8A%A8%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6"><span class="toc-text">2.1.2 启动后台管理插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E5%90%AF%E5%8A%A8RabbitMQ"><span class="toc-text">2.1.3 启动RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">2.1.4 查看进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E6%B5%8B%E8%AF%95"><span class="toc-text">2.1.5 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-RabbitMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">2.2 RabbitMQ快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E4%BE%9D%E8%B5%96"><span class="toc-text">2.2.1 依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%97%A5%E5%BF%97%E4%BE%9D%E8%B5%96log4j%EF%BC%88%E5%8F%AF%E9%80%89%E9%A1%B9%EF%BC%89"><span class="toc-text">2.2.2 日志依赖log4j（可选项）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="toc-text">2.2.3 创建连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-RabbitMQ%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3 RabbitMQ模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3.1 简单模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3.2 工作队列模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1-%E7%94%9F%E4%BA%A7%E8%80%85P"><span class="toc-text">2.3.2.1 生产者P</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="toc-text">2.3.2.2 消费者1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="toc-text">2.3.2.3 消费者2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-4-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%EF%BC%9F"><span class="toc-text">2.3.2.4 面试题：避免消息堆积？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3.3 发布订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">2.3.3.1 生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="toc-text">2.3.3.2 消费者1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="toc-text">2.3.3.3 消费者2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3.4 路由模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">2.3.4.1 生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="toc-text">2.3.4.2 消费者1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="toc-text">2.3.4.3 消费者2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3.5 通配符模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">2.3.5.1 生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="toc-text">2.3.5.2 消费者1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="toc-text">2.3.5.3 消费者2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.4 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">2.4.1 生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.4.2 消费者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Spring%E6%95%B4%E5%90%88RabbitMQ"><span class="toc-text">2.5 Spring整合RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E7%94%9F%E4%BA%A7%E7%AB%AF%E5%B7%A5%E7%A8%8B"><span class="toc-text">2.5.1 生产端工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%B6%88%E8%B4%B9%E7%AB%AF%E5%B7%A5%E7%A8%8B"><span class="toc-text">2.5.2 消费端工程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%B6%88%E6%81%AF%E6%88%90%E5%8A%9F%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">2.6 消息成功确认机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">2.6.1 事务机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">2.6.1.1 生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-2-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.6.1.2 消费者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-Confirm%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">2.6.2 Confirm发布确认机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-1-%E5%9C%A8spring%E4%B8%AD%E5%BA%94%E7%94%A8"><span class="toc-text">2.6.2.1 在spring中应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81"><span class="toc-text">2.7 消费端限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4TTL"><span class="toc-text">2.8 过期时间TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1-%E8%AE%BE%E7%BD%AE%E9%98%9F%E5%88%97TTL"><span class="toc-text">2.8.1 设置队列TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2-%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AFTTL"><span class="toc-text">2.8.2 设置消息TTL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">2.9 死信队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">2.10 延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">2.10.1 生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-2-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.10.2 消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-RabbitMQ%E9%9B%86%E7%BE%A4"><span class="toc-text">3. RabbitMQ集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-text">3.1 集群搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.2 镜像模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-HAProxy%E5%AE%9E%E7%8E%B0%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">3.3 HAProxy实现镜像队列的负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-HAProxy%E7%AE%80%E4%BB%8B"><span class="toc-text">3.3.1 HAProxy简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-HAProxy%E4%B8%8ENginx"><span class="toc-text">3.3.2 HAProxy与Nginx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-text">3.3.3 安装和配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-KeepAlived%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84HAProxy%E9%9B%86%E7%BE%A4"><span class="toc-text">3.4 KeepAlived搭建高可用的HAProxy集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">3.4.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%AE%89%E8%A3%85KeepAlived"><span class="toc-text">3.4.2 安装KeepAlived</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E6%B5%8B%E8%AF%95ip%E6%BC%82%E7%A7%BB%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">3.4.3 测试ip漂移的规则</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 木瓜煲鸡脚</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><span>鄂ICP备19025079号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-min.vercel.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, {"avatarCDN":""}))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-min.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>