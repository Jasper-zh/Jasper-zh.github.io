{"meta":{"title":"木瓜煲鸡脚's blog","subtitle":"公众号：IT那个小笔记","description":null,"author":"木瓜煲鸡脚","url":"http://yournotes.cn","root":"/"},"pages":[{"title":"","date":"2025-04-17T08:34:52.043Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"baidu_verify_code-6ih5lLBPBc.html","permalink":"http://yournotes.cn/baidu_verify_code-6ih5lLBPBc.html","excerpt":"","text":"874a2cdb47e0257a8e788a1cb273ce4f"},{"title":"说说","date":"2021-04-08T13:48:25.000Z","updated":"2025-04-17T08:34:52.025Z","comments":false,"path":"artitalk/index.html","permalink":"http://yournotes.cn/artitalk/index.html","excerpt":"","text":"new Artitalk({ appId: 'QQMg3jxS8pGF0Rtc5A3g9WDu-MdYXbMMI', appKey: 'Td165vac7Xep12Tgxxi6Daev', shuoPla: '说点啥....' })"},{"title":"分类","date":"2021-04-07T11:11:33.000Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"categories/index.html","permalink":"http://yournotes.cn/categories/index.html","excerpt":"","text":""},{"title":"我的相册","date":"2021-04-07T13:27:44.000Z","updated":"2025-04-17T08:34:51.956Z","comments":true,"path":"Gallery/index.html","permalink":"http://yournotes.cn/Gallery/index.html","excerpt":"","text":"壁紙 收藏的一些壁紙 摄影 莫名其妙的随拍 画画 在画些啥 食物 在吃些啥"},{"title":"我的歌单","date":"2021-04-07T11:45:10.000Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"music/index.html","permalink":"http://yournotes.cn/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-07T11:19:14.000Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"link/index.html","permalink":"http://yournotes.cn/link/index.html","excerpt":"","text":""},{"title":"","date":"2025-04-17T08:34:52.043Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"photos/data.json","permalink":"http://yournotes.cn/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2020-9\",\"arr\":{\"text\":[\"get鸡蛋酱油焖面\"],\"type\":[\"image\"],\"month\":9,\"link\":[\"2020-9_get鸡蛋酱油焖面.jpg\"],\"year\":2020}},{\"date\":\"2020-8\",\"arr\":{\"text\":[\"鲜虾馄饨\"],\"type\":[\"image\"],\"month\":8,\"link\":[\"2020-8_鲜虾馄饨.jpg\"],\"year\":2020}},{\"date\":\"2020-6\",\"arr\":{\"text\":[\"\",\"可\",\" \"],\"type\":[\"image\",\"image\",\"image\"],\"month\":6,\"link\":[\"2020-6_.jpg\",\"2020-6_可.jpg\",\"2020-6_ .jpg\"],\"year\":2020}},{\"date\":\"2019-12\",\"arr\":{\"text\":[\"\"],\"type\":[\"image\"],\"month\":12,\"link\":[\"2019-12_.jpg\"],\"year\":2019}}]}"},{"title":"","date":"2025-04-17T08:34:52.043Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"photos/ins.css","permalink":"http://yournotes.cn/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2025-04-17T08:34:52.043Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"photos/ins.js","permalink":"http://yournotes.cn/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://gitee.com/Jasper-zh/photos/raw/master/min_photos/' + data.link[i]; var src = 'https://gitee.com/Jasper-zh/photos/raw/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2025-04-17T08:34:52.043Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://yournotes.cn/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"相册","slug":"photos","date":"2025-04-17T08:34:52.043Z","updated":"2025-04-17T08:34:52.043Z","comments":false,"path":"photos/index.html","permalink":"http://yournotes.cn/photos/index.html","excerpt":"","text":"Photos Video 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"标签","date":"2021-04-07T11:16:33.000Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"tags/index.html","permalink":"http://yournotes.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-04-17T08:34:51.956Z","updated":"2025-04-17T08:34:51.956Z","comments":true,"path":"Gallery/eating/index.html","permalink":"http://yournotes.cn/Gallery/eating/index.html","excerpt":"","text":""},{"title":"tools","date":"2022-09-01T14:04:23.000Z","updated":"2025-04-17T08:34:52.043Z","comments":true,"path":"tools/index.html","permalink":"http://yournotes.cn/tools/index.html","excerpt":"","text":"&lt;div style=&quot;margin: 0px 0 0 50px;&quot; class=&quot;start-screen-recording-mid&quot;&gt; &lt;div&gt; &lt;div class=&quot;rec-dot&quot;&gt;&lt;/div&gt;&lt;span&gt;在线录屏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://yournotes.oss-cn-beijing.aliyuncs.com/tools/xx.js&quot;&gt;&lt;/script&gt;"},{"title":"daily","date":"2022-03-21T01:38:58.000Z","updated":"2025-04-17T08:34:51.956Z","comments":true,"path":"Gallery/daily/index.html","permalink":"http://yournotes.cn/Gallery/daily/index.html","excerpt":"","text":"#article-container .timeline .timeline-item .timeline-item-content { background: #e4f3fd00 !important; } 2022 11-20 07-17 07-10 07-06 07-04 04-09 04-05 03-20"},{"title":"wallpaper","date":"2021-04-07T13:38:58.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"Gallery/wallpaper/index.html","permalink":"http://yournotes.cn/Gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"","date":"2025-04-17T08:34:51.956Z","updated":"2025-04-17T08:34:51.956Z","comments":true,"path":"Gallery/Painting/index.html","permalink":"http://yournotes.cn/Gallery/Painting/index.html","excerpt":"","text":""},{"title":"","date":"2025-09-21T07:30:05.032Z","updated":"2025-09-21T07:06:00.184Z","comments":true,"path":"assets/other/index.html","permalink":"http://yournotes.cn/assets/other/index.html","excerpt":"","text":"user Agreement document.documentElement.style.fontSize = 8 + 'px'; PennyNote用户服务协议 更新日期：2024年12月19日 重要说明：请您仔细阅读本协议的全部内容，特别是字体加粗部分。如您对本协议内容有疑问，请勿进行下一步操作。如您使用PennyNote服务即视为您已阅读并同意本协议的约束。 1. 关于我们 感谢您选择使用PennyNote智能记账应用。 PennyNote是由我们团队开发的一款智能记账理财应用（以下简称\"我们\"或\"PennyNote\"），致力于为用户提供便捷、安全的个人财务管理服务。 本用户服务协议是我们与用户（以下简称\"您\"）关于使用PennyNote服务所订立的有效协议。 2. 协议范围、目的及确认方式 本用户服务协议及附属协议，以及页面展示的单项协议或规则、操作提示（以下合称为\"本协议\"）是我们为您提供PennyNote服务所依据的条款，不可分割，您需同时遵守。 请您仔细阅读本协议的全部内容，特别是字体加粗部分。 如您对本协议内容及页面提示信息有疑问，请勿进行下一步操作。如您使用PennyNote服务即视为您已阅读并同意本协议的约束。 如果您不同意本协议的任意内容，或无法准确理解条款内容，请停止使用，不要进行后续操作。 3. 使用本服务的要求 3.1 您具备完全民事行为能力，方可使用PennyNote服务，若您为无民事行为能力或为限制民事行为能力，请告知您的监护人，在您监护人的指导下阅读本协议，并在取得您监护人同意的前提下使用PennyNote服务； 3.2 您明确声明和保证：您具备足够的法律权利或授权来签署和履行本协议；您对于本协议的签署和履行不会对您须履行的任何其他协议、安排造成冲突或导致违约； 3.3 如您所属的国家或地区排除本协议的全部或部分内容，则您应立即停止使用PennyNote服务，否则，您继续使用PennyNote服务视为您同意承担相关的法律风险或法律责任。 4. 服务内容 PennyNote是我们通过互联网（含移动互联网）为您提供的智能记账理财服务平台，您可通过该平台享受以下服务： 4.1 账单管理服务：记录、编辑、删除个人收支账单，支持多种分类和标签管理； 4.2 账户管理服务：管理个人财务账户，包括现金、银行卡、信用卡等多种账户类型； 4.3 统计分析服务：提供收支统计、趋势分析、图表展示等财务分析功能； 4.4 数据同步服务：支持本地数据存储和云端数据同步，确保数据安全备份； 4.5 其他增值服务：包括数据导出、报表生成等辅助功能。 5. 用户使用规则 5.1 您在使用PennyNote时，请确保输入的账单信息真实、准确； 5.2 您应妥善保管您的设备，避免他人未经授权使用您的记账数据； 5.3 您理解并同意，PennyNote仅作为记账工具，不提供投资建议； 5.4 请勿恶意刷取或滥用服务功能，影响其他用户正常使用。 6. 免责声明 我们基于互联网提供服务，由于网络故障、系统维护等原因，可能导致PennyNote服务暂时中断，我们将尽力恢复正常服务。 我们对以下情形不承担责任： （1） 网络故障或系统维护导致的服务中断； （2） 您的设备或网络环境问题； （3） 您操作不当导致的数据问题； （4） 其他我们无法控制的情形。 7. 用户禁止性规定 您在使用PennyNote时，请遵守以下规定： （1） 不得恶意刷取或滥用服务功能； （2） 不得利用本软件进行任何违法活动； 如因您违反上述规定，我们有权暂停或终止为您提供服务。 8. 对本协议的修订 我们有权在必要时修改本协议条款，您可以在PennyNote的最新版本中查阅相关协议条款。 更新后的协议条款一旦公布即代替原来的协议条款，我们会在服务页面上及时发布对本协议的变更。若对本协议的修订会严重影响您或严重限制您对本服务的访问或使用，我们会在变更之前的合理时间内通知您。对于为了满足安全、法律或监管要求而对本服务作出的修订，我们可能无法满足前述的预告时间要求，但我们会尽快通知您。 本协议条款变更后，如果您不接受修改后的协议，请立即停止使用本服务；如果您继续访问或使用本服务，即被视为您已接受修改后的协议。 9. 适用法律及管辖 本协议的订立、执行、解释及争议的解决均适用中华人民共和国法律。 您同意，本协议签订地为中国北京市。 在合同履行过程中双方如发生纠纷，应协商解决；协商不成的，双方应向协议签订地有管辖权的人民法院以诉讼的方式解决。 10. 数据安全与隐私保护 10.1 数据收集：我们仅收集您主动提供的记账数据，用于为您提供记账服务。 10.2 数据存储：您的数据将安全存储在本地设备和云端服务器中。 10.3 数据使用：我们不会将您的个人财务数据用于其他商业目的或向第三方出售。 10.4 数据同步：您可以选择是否启用云端同步功能，确保数据在多设备间同步。 10.5 数据删除：您可以随时删除您的账户和数据，删除后将无法恢复。 11. 服务终止 11.1 用户终止：您可以随时停止使用PennyNote服务。 11.2 服务终止：如您违反本协议条款，我们有权暂停或终止为您提供服务。 12. 联系我们 如您对本协议有任何疑问，请通过以下方式联系我们： 邮箱：zhanghao9031@outlook.com 在线客服：通过PennyNote应用内的\"联系我们\"功能 反馈渠道：通过应用内的\"意见反馈\"功能 我们将在收到您的咨询后尽快回复。 * { margin: 0; font-size: 16px; color: rgba(0, 0, 0, 0.9); } body { max-width: 860px; margin: auto; padding: 2rem 2rem 5rem 2rem; } ul { padding: 0; list-style: none; } a { color: #0a59f7; cursor: pointer; text-decoration: none; } #icon { font-size: 0; text-align: center; } #icon svg { width: 4rem; height: 4rem; } #privacyName { margin: 2rem 0 0.5rem; text-align: center; font-size: 18px; } #update-time { text-align: center; span { font-size: 14px; } } .font-secondary { color: rgba(0, 0, 0, 0.6); } .icon-emphasize { color: rgba(10, 89, 247, 1); } h5 { word-break: break-all; margin-top: 3rem; margin-bottom: 1rem; } p { word-break: break-all; line-height: 1.4; } @media (prefers-color-scheme: dark) { body { background-color: #000000; } .font-secondary { color: rgba(255, 255, 255, 0.6); } .icon-emphasize { color: rgba(82, 145, 255, 1); } }"}],"posts":[{"title":"Langchain接入LlamaIndex Retriever","slug":"Langchain接入LlamaIndex Retriever","date":"2025-03-26T09:56:47.000Z","updated":"2025-04-17T09:22:39.297Z","comments":true,"path":"2025/03/26/Langchain接入LlamaIndex Retriever/","link":"","permalink":"http://yournotes.cn/2025/03/26/Langchain%E6%8E%A5%E5%85%A5LlamaIndex%20Retriever/","excerpt":"","text":"前言Langchain和LlamaIndex都是在 构建LLM应用当中最常用的两个库，但是他们的侧重点不一样： Langchain侧重于构建更复杂的LLM应用流程，因为足够自定义，帮你解决了围绕大模型应用开发的基础的脏活。 LlamaIndex是可以更快速的基于文档进行问答，封装度更高，侧重点在于快速集成数据和大模型，可以快速构建一个RAG系统。 为什么要采用Langchain和LlamaIndex相结合的方式，因为Langchain更偏基础层可以很方便扩展或者对接其他服务，因此整个大模型的编排交互依然由Langchain进行，但是LlamaIndex擅长什么？没错，就是文档的加载和检索，除了官方提供的一些基础加载库或者检索器，背后还有一个LlamaHub的社区库。提供了更多的解析器或者检索器，可以方便接入LlamaIndex使用。 那么现在思路很明确，整个大模型应用的链路流程由Langchain构建，包括提示词、包括对大模型进行交互、包括后续各种各样的功能，而链路中如果有需要查找知识库（或者构建知识库），由LlamaIndex进行处理。因此可能需要把LlamaIndex的检索器包括检索过程，对接到Langchain的检索器类型当中。 实现首先我们依然是通过LlamaIndex构建索引，然后生成检索器。 第二我们需要实现一个自定义类来继承Langchain的检索器基类，通过我们的LlamaIndex来实现它的方法，并且以Langchain的文档类型返回 自定义Langchain检索器123456789101112131415161718192021222324252627282930313233343536373839from typing import Any, Listfrom pydantic import Fieldfrom langchain_core.retrievers import BaseRetrieverfrom langchain_core.documents import Document as LangchainDocumentfrom config.config import SIMILARITY_TOP_Kfrom logger import get_loggerlogger = get_logger(__name__)class LlamaIndexRetriever(BaseRetriever): index_retriever: Any = Field(default=None, description=&quot;LlamaIndex retriever instance&quot;) def __init__(self, index_retriever: Any, **kwargs): super().__init__(**kwargs) self.index_retriever = index_retriever def _get_relevant_documents(self, query: str) -&gt; List[LangchainDocument]: # 打印查询时的维度 logger.info(f&quot;查询时的维度: &#123;self.index_retriever._vector_store._faiss_index.d&#125;&quot;) logger.info(f&quot;查询向量: &#123;self.index_retriever._vector_store._faiss_index.ntotal&#125;&quot;) nodes = self.index_retriever.retrieve(query) logger.info(f&quot;检索到的节点数量: &#123;len(nodes)&#125;&quot;) return [ LangchainDocument( page_content=node.text, metadata=node.metadata ) for node in nodes ] async def _aget_relevant_documents(self, query: str) -&gt; List[LangchainDocument]: return self._get_relevant_documents(query)def get_retriever(index): &quot;&quot;&quot;创建检索器&quot;&quot;&quot; index_retriever = index.as_retriever(similarity_top_k=SIMILARITY_TOP_K) return LlamaIndexRetriever(index_retriever=index_retriever) 构建检索&amp;问答链简单构建通过前面获取到了我们自定义的检索器，可以通过from_chain_type()的方式构建chain 1234567你是一个智能中文助手参考资料：&#123;context&#125;请根据参考资料，准确自然的回答用户当前的问题：&#123;query&#125; 12345678# 单query交互qa_chain = RetrievalQA.from_chain_type( llm=llm, retriever=retriever, chain_type=&quot;stuff&quot;, chain_type_kwargs=&#123;&quot;prompt&quot;: prompt_template&#125;, return_source_documents=True) 1qa_chain.invoke(&#123;&quot;query&quot;:&quot;你好&quot;&#125;) 这样的方式就已经可以使用了效果还挺好，同时通过 return_source_documents&#x3D;True ， 能够返回检索过程的文档列表。 这样的方式局限在于只能单次query交互，在这样的方式情况下你的提示词模板只能有两个参数，一个是context 一个随便叫啥（question） context是内定的，他会把检索器的资料放到context中，不需要你传。另外一个参数就是你传入的叫啥名都可以。他会拿去进行检索，然后再进行LLM问答 当使用这种方式时我们无法进行多轮对话的输入，因为只能输入一个query. 它既进行检索也进行问答. 浓缩上下文构建123456789101112131415161718192021222324# 多query但是浓缩上下文# 构建聊天 Promptchat_prompt = ChatPromptTemplate.from_messages([ SystemMessage(content=&#x27;&#x27;&#x27; ## 你的角色 你是一智能中文助手 ## 你的任务 以亲切专业的语气完成以下职责：xxx ## 知识库 以下是查询所得到的知识库内容：\\n &#123;conntent&#125; &#x27;&#x27;&#x27;), HumanMessage(content=&quot;&#123;question&#125;&quot;)])# 构建链qa_chain = ConversationalRetrievalChain.from_llm( llm=llm, retriever=retriever, condense_question_prompt=chat_prompt, return_source_documents=True) 通过ConversationalRetrievalChain的方式，虽然可以累计消息列表，也就更新chat_prompt消息列表的方式，可以累计多条消息。但是这种方式是一种浓缩的方式，所以虽然支持消息历史而不是只能单条，但是效果很差。 自定义构建上面都是曲线救国，正常来说应该不会用，通过自定义的方式才是最简单的，也是满足大多需要的 1234567891011121314# 从检索器中拿上下文docs = retriever.get_relevant_documents(query)context = &quot;\\n\\n&quot;.join([doc.page_content for doc in docs])qa_llm_chain = LLMChain( llm=llm, prompt=prompt_template)result = qa_llm_chain.invoke(&#123; &quot;query&quot;: query, &quot;chat_history&quot;: chat_history, &quot;context&quot;: context&#125;) 通过这样的方式，不用走它的检索器chain，就一个正常chain，完全自定义构建提示词，自己调用检索得到文档、自己组装消息列表 。自定义拼接到提示词模板即可。 总结正常都是使用最后的方式，也不需要自定义检索器类。他这种配合检索器的构建链可能是快速构建rag的方式吧，但是基本上想要自定义程度或者掌控程度越高就越偏原生一点去写。","categories":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/tags/LLM/"}]},{"title":"Langchain流式问题","slug":"Langchain流式问题","date":"2025-03-25T09:56:47.000Z","updated":"2025-04-17T09:11:59.125Z","comments":true,"path":"2025/03/25/Langchain流式问题/","link":"","permalink":"http://yournotes.cn/2025/03/25/Langchain%E6%B5%81%E5%BC%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言构建好chain，正常run或者invoke没问题但是流式一直是连接后等半天单次就输出完毕了 123456789async for chunk in qa_llm_chain.astream(&#123; &quot;query&quot;: query, &quot;chat_history&quot;: chat_history, &quot;context&quot;: context, &quot;tone&quot;: tone&#125;): # 打印 chunk 的内容和类型 logger.info(f&quot;chunk type: &#123;type(chunk)&#125;&quot;) logger.info(f&quot;chunk content: &#123;chunk&#125;&quot;) 解决挺奇怪的，按理来说应该是可以的。一直好像解决不了，最终是选择直接通过llm调用，而不是chain的方式 12345678910111213# 手动构造 prompt 文本prompt_str = prompt_template.format( query=query, chat_history=chat_history, context=context, tone=tone) async for chunk in llm.astream(prompt_str): # 打印 chunk 的内容和类型 logger.info(f&quot;chunk type: &#123;type(chunk)&#125;&quot;) logger.info(f&quot;chunk content: &#123;chunk&#125;&quot;) 总结等有时间了这块地方再回来看看，看看是不是chain的astream是假流式，还是说使用方式上有什么问题。目前解决是直接通过llm调用就ok了。","categories":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/tags/LLM/"}]},{"title":"RAG高级技术与最佳实践","slug":"RAG高级技术与最佳实践","date":"2025-03-23T09:56:47.000Z","updated":"2025-04-17T08:34:52.001Z","comments":true,"path":"2025/03/23/RAG高级技术与最佳实践/","link":"","permalink":"http://yournotes.cn/2025/03/23/RAG%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"RAG技术树![[Pasted image 20250323163322.png]] RAG研究的技术树主要涉及预训练（Pre-training）- 微调（Fine-tuning）- 推理（Inference）等阶段 随着LLM的出现，RAG的研究最初侧重于利用LLMs强大的上下文学习能力，主要集中在推理阶段。 随后进一步深入，逐渐与LLMs的模型微调阶段更加融合。研究人员也在探索通过检索增强技术来提升预训练阶段语言模型的性能 回顾NativeRAG过程：indexing：如何更好的把知识存起来 （分割、embedding、存入）retrieval：如何在大量的知识中，找到一部分有用的，给模型参考generation：如何结合用户的提问和检索的知识，让模型生成有用的答案 Qwen-Agent之前使用了coze或者完全自己编码去使用了RAG，除此之外还可以使用Qwen-Agent这样的工具库来更好的应用上RAG![[Pasted image 20250319183148.png]] Qwen-Agent构建的智能体包含三个复杂的级别，每一层都建立在前一层的基础上： 级别一：检索处理大上下文时采用RAG进行分割，挑战在于如何定位最相关的快步骤1：指导聊天模型将用户查询中的指令与非指令信息分开步骤2：要求聊天模型从查询的部分信息推到出更多的语言关键字步骤3：运用BM25这一传统的基于关键字检索的方法找到与提取关键字最相关的块 级别二：分块阅读直接RAG很快，但是在相关块与用户查询的关键词重叠度不足时失效&#x3D;&gt;导致这些相关的块未被检索到尽管我们会使用到向量检索来缓解这一个问题，但是实际效果有限。为了解决这个局限，我们采用一种暴力策略： 步骤1：对于每个chunk让聊天模型评估与用户查询的相关性，不相干则输出无，否则输出 步骤2：取出那些非“无”的句子，用他们作为搜索的查询词，通过BM25匹配出最相关的块（总结果控制在上下文限制数量内） 步骤3：基于检索到的上下文生成最终答案，和通常的RAG相同 级别三：逐步推理在基于文档的问题回答中，一个典型的挑战是多跳推理。例如：“与第五交响曲”创作与同一世纪的交通工具是什么？实际上他需要先找到第五交响曲是哪个世纪？这个问题解决后知道是十九世纪，再寻找19世纪产生了什么交通工具。实际上这是一个循环的Agent的过程，直到最终得到结果 评测结果![[Pasted image 20250319190718.png]] ![[Pasted image 20250319190744.png]] 代码示例https://github.com/Jasper-zh/agi_study/tree/main/embeding/rag/qwen_agent RAFT方法全称：Retrieval Augmented Fine Tuning 在RAFT之前我们一般有两种方式来让大模型符合预期： 基础的RAG Fine-Tune微调 对于前者，就是不用学习直接给大模型进行一个开卷考试，可以参考知识；对于后者就是先去学习然后闭卷考试。 那么都存在一些优缺点可能是效果上的可能是成本上的，那么RAFT就是结合了这两种。带着开卷的情况下进行训练，让大模型对知识库里面知识相关的概念更熟悉，相当于仍然是RAG的开卷考试，但是对于旁边的课本更熟悉，对于查找的知识判断是否符合更准。 ![[Pasted image 20250319164825.png]] ![[Pasted image 20250319165406.png]] 大概对于RAFT训练的话，样本数量可以一千个差不多了，尽量列举所有场景类型的例子平均一点 RAG高效召回改进检索算法利用知识图谱中的语义信息和实体关系，增强对查询和文档的理解，提升召回的相关性 引入重排序（Reranking）重排序模型：对召回结果进行重新排序，提高问题和文档的相关性。常见的重排序模型有BGE-Rerank和Cohere Rerank 混合检索：结合向量检索和关键字检索进行归一化处理 优化查询扩展相似语义改写：使用大模型将用户问题改写成多个语义相近的查询，提高召回多样性。例如Langchain的MultiQueryRetriever 双向改写将查询改成文档，或者将文档改成查询，缓解短文本向量化效果差的问题![[Pasted image 20250319174149.png]] 索引扩展 离散索引扩展：使用关键字抽取、实体识别等技术生成离散索引，与向量检索互补，提高召回准确性。 ![[Pasted image 20250319175056.png]] 连续索引扩展：结合多种向量模型（如OpenAI的Ada、智源的BGE）进行多路召回，取长补短 混合索引召回：将BM25等离散索引与向量索引结合，通过Ensemble Retriever实现混合召回，提升召回多样性 Small-to-Big：以文档的摘要作为索引，先检索出摘要再补充信息（因为目前大模型对于上下文的尺寸还是挺大的，所以一篇几万字给大模型进行总结分析比RAG的分割更加有效率，因此存在这样的策略直接检索小规模的内容，匹配上后可以贴出大规模的内容）也是比较不错的策略。 GraphRAG使用知识图谱来推理复杂信息时显著提升问答性能，但是由于前期需要依赖大模型来进行构建图谱因此需要对于大模型本身的能力有一定的要求且消耗量大，虽然新版本已经好了很多但是仍然还是消耗很大，所以需要选择性价比高一些的模型。 仍然是分三个步骤：索引、查询、回答（提示词）索引： 除了分割之外，额外从分割内容去分析建实体来通过Leiden算法构建知识图谱，构建每个分类社区以及实体的摘要总结查询： 全局搜索global通过检索分类去匹配返回下面的所有实体、local局部搜索直接搜索实体、DRIFT获取的实体的上下文信息 ；追求完整的信息则选用全局搜索 本来简单试一下结果把我token余额干完了，也就六篇文档。构建过程会生成一些知识图谱的表比如实体信息、社区报告啥的 社区列表 社区报告 文档列表 实体列表 节点表 关系实体表 切分区块表 于是乎我又通过本地部署的方式来对接，好像我的电脑显卡有点垃了，七个文本大概是有三万字，体会到了构建知识图谱数据的过程这么慢。估计得个把小时完成![[Pasted image 20250326123210.png]] 生成完后就可以基于知识图谱进行RAG问答了 1graphrag query --root ./input --method local --query &quot;有哪些产品啊介绍一下&quot; 总体来说这种方式算是通过策略提高了召回的准确性但需要的算力很大 总结目前来说没有哪一种方式就是最好，一般采用”MVP验证→渐进增强”路径：先用Qwen-Agent搭建基础流程，针对bad case逐步引入RAFT微调或GraphRAG组件，同时通过检索算法优化（如重排序+混合检索）降低后期迭代成本。检索环节的优化仍是核心突破口，混合检索、查询双向改写、Small-to-Big等策略已证明局部最优解的存在，但尚未形成通用范式，可以持续关注。","categories":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/tags/LLM/"}]},{"title":"LlamaIndex对于向量库的持久化与加载","slug":"LlamaIndex对于向量库的持久化与加载","date":"2025-03-19T09:56:47.000Z","updated":"2025-04-17T09:11:45.491Z","comments":true,"path":"2025/03/19/LlamaIndex对于向量库的持久化与加载/","link":"","permalink":"http://yournotes.cn/2025/03/19/LlamaIndex%E5%AF%B9%E4%BA%8E%E5%90%91%E9%87%8F%E5%BA%93%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"前言之前使用LlamaIndex做RAG环节的文档加载和检索，使用Faiss作为向量库。知识库构建进行持久化存储，再次加载进行检索时出现维度不匹配的情况。 12345678query_result = self._vector_store.query(query, **self._kwargs) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^File &quot;D:\\MySpace\\dev\\python\\3.11\\Lib\\site-packages\\llama_index\\vector_stores\\faiss\\base.py&quot;, line 195, in query dists, indices = self._faiss_index.search( ^^^^^^^^^^^^^^^^^^^^^^^^^File &quot;D:\\MySpace\\dev\\python\\3.11\\Lib\\site-packages\\faiss\\class_wrappers.py&quot;, line 329, in replacement_search assert d == self.d ^^^^^^^^^^^ 这个是由于LlamaIndex进行VectorStoreIndex持久化时，里面的词嵌入模型是不会保存的， 当从持久化文件进行加载时，仍然需要显示的传入词嵌入模型，否则会采用默认的编码方式，会和之前存入的向量维度不一样 构建索引&amp;持久化123456789101112131415161718192021# 初始化 FAISS 向量存储# 由于我这里使用BGE-M3作为词嵌入模型，所以维度设置为VECTOR_DIMENSION = 1024faiss_index = IndexFlatL2(VECTOR_DIMENSION) faiss_vector_store = FaissVectorStore(faiss_index=faiss_index)# 创建存储上下文 (构建索引时不要配置目录)storage_context = StorageContext.from_defaults(vector_store=faiss_vector_store)# 创建索引index = VectorStoreIndex.from_documents( docs, storage_context=storage_context, embed_model=embed_model, show_progress=True)# 持久化索引(通过语法也可以看到，并不包含embed_model，只有storage_context)index.storage_context.persist(persist_dir=str(VECTOR_STORE_PATH01)) 本地存储加载索引12345678# 从本地存储加载索引... （如果是特定的向量库，可能需要先用对应的库去加载向量存储）faiss_vector_store = FaissVectorStore.from_persist_dir(str(VECTOR_STORE_PATH01))storage_context = StorageContext.from_defaults(vector_store=faiss_vector_store, persist_dir=str(VECTOR_STORE_PATH01))# 加载index 除了本地的storage_context 还要传入 embed_model (否则检索时不知道用什么对query编码)index = load_index_from_storage(storage_context=storage_context,embed_model=embed_model)","categories":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/tags/LLM/"}]},{"title":"RAG技术与应用","slug":"RAG技术与应用","date":"2025-03-14T09:56:47.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2025/03/14/RAG技术与应用/","link":"","permalink":"http://yournotes.cn/2025/03/14/RAG%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"","text":"1、大模型应用开发的三种模式首先要提到进行大模型应用设计时可能会用到三种方式。 分别是 【提示工程 、RAG 、微调】 那么这三种分别应该在什么时候使用呢？ 一般来说是需要有一个循序渐进的过程，比如当回答出现问题，先思考提示词是否不够准确，然后才考虑是否知识信息不具备（比如一些内部私有信息），在此基础上提示词已经非常准确，需要的知识也通过RAG进行了提供但还是有问题，此时说明大模型能力还不够这个时候就需要微调了或者换大模型 微调成本很高所以基本上应该优先在原有的基础上优化，微调的成本体现在：首先数据集的建立就很耗人力，而且特定数据多了还会导致破坏大模型原有的能力有这种风险。以及需要的硬件成本。 2、什么是RAG 回到正题那么什么是RAG呢？ RAG全称Retrieval-Augmented Generation 翻译过来就是 检索增强生成，是一种结合信息检索（Retrieval）和文本生成(Gen)的技术 优势是什么？ 解决知识的时效性 减少模型幻觉 提升专业领域的回答质量 2.1 RAG构建的步骤step1 数据预处理知识库构建：收集并整理文档、网页、数据等多元数据，构建外部知识库 文档分块：将文档分为合适的大小（挺重要） 向量化处理：使用合适的嵌入模型 （一般现在用BAAI的BGE-M3） step2 检索阶段查询处理：将用问题转化为向量，在向量数据库进行相似度检索 top-k 重排序：对检索结果进行相关性排序，选择最相关的 step3 生成阶段上下文组装：通过设计提示词将检索信息和用户问题结合，形成增强的上下文输入 生成回答：大语言模型基于增加看i的上下文生成最终回答。 RAG的本质上重构了新的提示词： LLM &#x3D;&gt; 推理引擎 大脑 知识库 &#x3D;&gt; 外挂 硬盘 记事本 3、NativeRAG刚刚整个步骤的实现就是NativeRAG，也是最基础的RAG。之后还有一些变体比如图谱的 比较好用的线上的产品有NotebookLM 可以创建多个RAG应用，每个应用它可以一共传入五十个文档，每个可以两百兆，然后他就只根据这些知识来进行回答。 这样你可以创建一个应用，传入你自己手上某个方向的质量好资料或者一些相关的书籍没时间自己消化（Youtube视频链接也可以），然后它就变成这个领域的专业助手了，从别的地方问可能有很多错误，但这个就是从你自己的资料库当中回答问题，非常好用推荐推荐。 国内的这种产品结构的有腾讯的 imacopilot，比较NotebookLM质量实际体验弱一点![[Pasted image 20250317123706.png]] 即使通过相同的大模型，加上NotebookLM的RAG进行提示组装之后会等到更准确的推理结果，并且可以指出参考哪一篇的REK，方便医生快速进行验证它的正确性 在使用上你除了用来构建知识库助手（往一个应用在长期的使用中慢慢的补充资料，毕竟50个还是挺多的，一本书的pdf就算一个），该应用在这个知识方向越来越好用。 除此之外有些你懒得看的东西比如就只有一篇pdf的保险介绍也可以创建一个临时应用，问一问。![[Pasted image 20250317125907.png]] ![[Pasted image 20250317130042.png]] 4、Embedding模型的选择关于模型选择可以到如下的地址去查看对比，目前来说的话语言能力最好的是BGE-M3 huggingface.co&#x2F;spaces&#x2F;mteb&#x2F;leaderboard ![[Pasted image 20250317130519.png]] ![[Pasted image 20250317130726.png]] 试了一下BGE-M3和gte-Qwen2，案例代码如下地址：https://github.com/Jasper-zh/agi_study/tree/main/embeding/embedding_model 5、OpenAI + Faiss 构建 RAG PDF文本读取: 使用的PyPDF2 向量数据库的构建：使用OpenAI的Embedding模块转向量、使用Faiss进行存储知识库 语义搜索与问答：使用Faiss提供的函数进行相近搜索、OpenAI进行语言回答 成本跟踪与结果展示：使用langchain的get_openai_callback来解析本次调用成本，前面记录每个chunk的页码，最终展示时可以通过chunk去找到参考页码 代码如下地址：https://github.com/Jasper-zh/agi_study/blob/main/embeding/rag/chatpdf-faiss.py ![[Pasted image 20250317164020.png]] 6、常见问题6.1 如果LLM可以处理无限上下文了，RAG还有意义么？效率成本：RAG通过检索，减少了输入token知识更新：LLM知识是截止于训练数据可解释性：RAG的数据是透明的，可查看来源定制化：可针对特定领域定制数据隐私：可以在本地私有数据进行检索，避免上传云端 &#x3D;&gt; 结合RAG的能力，可以提升整体性能，提供更全面、准确的回答。 6.2 如何提升RAG质量？数据准备阶段面对的问题 -&gt; 数据质量差：特别是一些非结构数据缺乏良好的管理，包含很多过时、矛盾或者不正确的信息 多模态信息：提取、定义和理解文档中的不同元素内容，如标题、配色方案、图像和标签等存在挑战 复杂的PDF提取：PDF是为人类阅读设计的，机器解析起来非常复杂 如何提升数据准备阶段的质量？ 目前两种方式： 构建完整的数据准备流程 智能文档技术 第一种方式就是做好以下几点： 数据评估与分类 数据审计：全面审查现有数据，识别敏感、过时、矛盾或者不准确的信息 数据分类：按类型、来源、敏感性和重要新对数据做好分类 数据清洗 去重：去除重复数据 纠错：发现错误进行修正比如格式错误或者拼写错误 更新：替换过时的信息，确保数据时效 一致性：解决数据矛盾，确保逻辑一致 敏感信息处理 进行脱敏，确保合规 数据标记与标注 元数据标记：添加元信息，如来源、创建时间等 内容标注：对非结构化数据进行标注，便于后续检索和分析 数据治理框架 制定政策：明确数据管理、访问控制和更新流程 责任分配：指定数据治理负责人，确保政策执行 监控与审计：定期监控数据质量，进行审计 数据治理是很漫长很花精力的一个工作，不是一次性就能完成的，需要多人花时间按照指制定的标准一直去维护 第二种方式就是智能文档技术 这种技术相当于是把不同的文件类型，都能按照统一的特征空间去表示，相当于是一个多模态大模型。在这样的理论上，就可以解决文档的内容读取和分割的问题，特别是PDF的文字读取。直接通过文件就能知道含义而不是取出文字再给语言模型分析语义。 ![[Pasted image 20250317165331.png]] 这是一个还处于比较新的方向，目前已知的产品有 LayoutLM 知识检索阶段上面说完了数据准备阶段的点，现在说讲知识检索阶段，那么知识检索阶段可能会出现如下问题： 内容缺失：检索过程中确实关键内容，系统提供不完整碎片化的答案 &#x3D;&gt; 降低RAG的质量 错过排名靠前的文档：用户查询相关文档时被检索到，但相关度很低，导致不满足需求，因为只经过一次top-k，这个k设置多少也需要长时间使用以及调试经验 不在上下文：从数据库返回了包含答案的文档，但未能出现在提示词当中，可能数量太大需要进行整合 如何提升知识检索阶段的质量？ 转换澄清用户意图 采用混合检索和重排策略 两个点第一个就是详细化用户意图，当用户比较含糊时，可以细化用户意图可以给用户确定也可以直接细化后直接检索 第二个点就是混合检索和重排，意思就是既进行语义检索也进行关键字匹配检索，或者进行第二次排序 答案生成阶段在这个阶段的问题可能如下： 未提取：答案与所提供的上下文不相符，可能上下文太多存在噪音，或者有冲突信息 不完整：尽管能根据上下文生成答案，但信息缺失会导致回答不完整 格式错误：当提示词中的附加指令格式不正确时，LLM可能误解从而导致错误答案 幻觉：大模型可能产生误导性或者虚假信息 如何提升答案阶段的质量 改进提示词模板：比如利用推理模型 DeepSeek-r1 、qwq 实施动态防护栏 抛开前面的问题，仅仅答案阶段的效果就只能是提示词了，动态防护栏也是提示词的一种方式例子如下，可以通过另外的模型去分析需要回答的要素，拼接到提示词当中 ![[Pasted image 20250317171933.png]] ![[Pasted image 20250317172054.png]] ![[Pasted image 20250317172226.png]] 7、总结RAG是目前应用实践效果最好的一种大模型的应用架构，主要分为三个部分 数据、向量化、检索回答。其中最主要的部分还是数据的处理，想要做一些练习的话可以做类似谷歌的NoteBookLM可以上传不同类型文件，同时回答会显示参考来源文件","categories":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/tags/LLM/"}]},{"title":"Embedding：推荐系统中从词袋到向量空间的技术跃迁","slug":"Embedding：推荐系统中从词袋到向量空间的技术跃迁","date":"2025-03-12T09:56:47.000Z","updated":"2025-04-17T08:34:51.958Z","comments":true,"path":"2025/03/12/Embedding：推荐系统中从词袋到向量空间的技术跃迁/","link":"","permalink":"http://yournotes.cn/2025/03/12/Embedding%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BB%8E%E8%AF%8D%E8%A2%8B%E5%88%B0%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E7%9A%84%E6%8A%80%E6%9C%AF%E8%B7%83%E8%BF%81/","excerpt":"","text":"1、 基于内容推荐 依赖性低，不需要动态的用户行为，只要有内容就可以进行推荐 系统不同阶段都可以用： 系统冷启动：内容是任何系统天生的属性，可以从中挖掘特征，实现推荐系统的冷启动。一个复杂的推荐系统都是基于内容推荐成长起来 商品冷启动：不论什么阶段都会有新商品加入，只要商品有内容信息，就可以帮他进行推荐 数据中台越来越显示其价值结构化数据 &#x3D;&gt; 分析、预测、洞察非结构化数据 &#x3D;&gt; 检索、推荐、撰写 业务驱动数据数据流：企业中的数据中台 &#x3D;&gt; 上层业务分析实现路径：业务驱动，由各个部门、小组发起指定数据（结构化、非结构化）以部门业务为导向，规划结构化数据和非结构化数据 [!note] 应用形式以智能体展示为主，需要结合员工权限管理和数据安全考虑在用户停留的地方进行集成办公IM：企业微信、钉钉、飞书企业OA、SAP、CRM [!note] PMO角色AI助手需求收集、推广、运营反馈、开发迭代安排 1.1、特征提取和余弦相似要想实现近似内容推荐首先我们就要理解特征和这个余弦相似度两个概念首先余弦相似度就是判断两个向量的余弦值：完全相同时为1，垂直时为0，相反时为 -1 总之相似度是在[-1,1]范围 ![[Pasted image 20250313194407.png]] ![[Pasted image 20250313134831.png]] 上述是一个简单的原理示例就是对于词频TF的一个统计，对于两个句子提取了八个维度的特征（8个词）对于对于八个维度填入每个维度的值（每个词的频率）就形成了一个序列来表达这个句子，这样就可以计算相似度。 但是这样简单的提取维度就会有问题，比如把句子A的“太乱”和“规范”位置换一下，最终得到的序列仍然不变，即使意思已经相反，得到的结果就还是相似。这种可以直接进行比较的方式叫做词袋模型 1.2 TF-IDF除了位置之外，特征提取时，某些特征在所有样本均有出现，因此为了尽量忽略这些特征，于是有了TF-IDF模型 ![[Pasted image 20250313154401.png]] 当一个特征即使频率很高但大家都有时，这个特征的IDF几乎就为0了，不会像之前一样因为频率高而排到前面。 1.3 N-Gram对于位置对意思影响大的问题，又有了N-Gram的词频统计方式，主要是在于分割上 ![[Pasted image 20250313140814.png]] 这样去分割会产生更多的维度，自然也能表达更多的信息。假设一句话每个字是一个字母，那么不管多少文本列表，最终的特征也只能取出26个，而如果是二元或者三元，可能产生的特征单位就会很多，N值每提高一个，可能维度都是爆炸式的增长。 1.4 案例 [!capacities-body] 西雅图酒店数据集 https://github.com/susanli2016/Machine-Learning-with-Python/blob/master/Seattle_Hotels.csv![[Pasted image 20250313191444.png]] 字段： name,address,desc 需求：基于用户选择的酒店推荐相似度高的Top10个其他酒店 方法：计算当前酒店的向量特征与整个酒店特征矩阵的余弦相似度，取近似度最大的Top-k个 ![[Pasted image 20250313142426.png]] [!check]+ 代码地址：https://github.com/Jasper-zh/agi_study/tree/main/embeding/feature_extractor 2、Embedding上述使用的用来比较相似的方式不管是词袋还是TF-IDF,都会有一个问题那就是一个维度只表达一个具体的词，那么一个语料库形成的这个表示，维度就会特别高，当对一个新的句子按照这个表进行转化时，很多词可能都没有用过，用很高维来表达这个句子，但是大部分维度都是0，所以这些方式空间利用率太低。 于是就有了Word Embedding 在用一个比较小的维度下尽可能表达出所有词的关系，这样每个维度利用率很高，不会出现之前那种很多维度用不到的情况。 那么实际的工具比如Word2vec![[Pasted image 20250314143216.png]] 实际上就是找到一个特征空间，满足所有的输入。一开始定好维度，初始化每个词的向量值。 那么核心就是在于如何通过隐藏层，得到每个词的向量表示它们之间相似计算最终都能拟合实际的每个单词和其他单词的上下文关联度。具体就是涉及到优化算法，不停的迭代计算误差不停的梯度下降慢慢这个黑盒子越来越能拟合实际数据，将训练好的内容保存下来即可。 训练好后那么你后续的输入就能通过隐藏层找到对应的向量表示。 那么需要比较的句子就可以通过词嵌入的向量转化成句子的向量表示（简单平均，或者以词嵌入作为输入再去训练一个句子的模型比如RNN、Transformer） [!check]+ Word2Vec使用：https://github.com/Jasper-zh/agi_study/tree/main/embeding/word2vec 3、总结上述一开始是没有使用词嵌入来去表达两个句子的相似性，而是选择手动来去提取特征，进行简单的模型计算进行相似度比较。再之后则是通过word embedding的方式对语料库建立了特征空间。从这样一个角度去理解了一个变化过程，再到现在的大语言模型那么它内部的这种向量转化更加复杂，包含的信息量更大，属于模型套模型套n多层，最终通过庞大的语料库训练而成。基本上word embedding这种方式可以用在所有相似推荐的场景，不管是推荐商品还是推荐其他内容，比如商品推荐一个人先访问了什么后访问了什么，就是会形成上下文，这个和文本是一样的（一个文字前面可能是什么字后面可能是什么字）","categories":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/tags/LLM/"}]},{"title":"技术栈导致后续流式响应的坑","slug":"技术栈导致后续流式响应的坑","date":"2024-07-28T07:58:16.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2024/07/28/技术栈导致后续流式响应的坑/","link":"","permalink":"http://yournotes.cn/2024/07/28/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%BC%E8%87%B4%E5%90%8E%E7%BB%AD%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%E7%9A%84%E5%9D%91/","excerpt":"","text":"[toc] 前言之前无聊做了一款工具app，需要使用到流式响应 因为想着快速启动，所以选择了客户端用uniapp 服务端用uncloud云开发 后来在实现unicloud流式响应给uniapp时，发现没法自定义响应，unicloud的函数只能返回数据，响应动作只能由框架操作，将你云函数响应的数据进行send。 方案一：Uni-push后来查官网，发现也是有解决方案就是开通他们提供的uni-push服务，其中有一个信道对象ssechannel 我们可以在客户端创建信道，给信道绑定监听几种监听事件函数，比如信道接收消息事件、信道结束事件。 绑定了事件函数后，我们就可以把信道传给后端，后端拿到反序列化后，就可以通过send发送消息，通过end结束信道 这样在客户端那边的两个事件就可以接收到。 整天来说使用也很简单，如下： 1234567891011121314151617181920212223242526// 客户端代码export default &#123; data() &#123;&#125;, onLoad() &#123;&#125;, methods: &#123; async testSSE() &#123; const channel = new uniCloud.SSEChannel() // 创建消息通道 channel.on(&#x27;message&#x27;, (message) =&gt; &#123; // 监听message事件 console.log(&#x27;on message&#x27;, message); &#125;) channel.on(&#x27;end&#x27;, (message) =&gt; &#123; // 监听end事件，如果云端执行end时传了message，会在客户端end事件内收到传递的消息 console.log(&#x27;on end&#x27;, message); &#125;) await channel.open() // 等待通道开启 const res = await uniCloud.callFunction(&#123; name: &#x27;myapi&#x27;, data: &#123; channel: channel // 调用云函数时传入通道对象 &#125; &#125;) &#125; &#125;&#125; 123456789101112131415161718192021// 云函数myapi代码exports.main = async (event, context) =&gt; &#123; const channel = uniCloud.deserializeSSEChannel(event.channel) await channel.write(&#123; a: 1 &#125;) await channel.write(&#123; a: 2 &#125;) await channel.write(&#123; a: 3 &#125;) await channel.write(&#123; a: 4 &#125;) await channel.end(&#123; a: 5 &#125;) return &#123;&#125;&#125;; 在使用之后，也是实现了我的功能，接口实时写入，客户端可以相对实时接收。 但是后来发现一个问题：可能是且后台或者锁屏，或者就在使用中，各种各样的情况吧，可能会出现客户端接收不到了的情况，而且一但出现了这种情况后，客户端再第二次第三次触发testSSE…..也就是后续使用均不会收到消息。testSSE被触发，依然是新建信道传递给后端api，api依然进行写入没有任何异常，但是客户端就是监听不到，只能重启就好了。一但出现问题又只能重启，猜测可能是这个组件依赖在全局上有什么东西，一但断开就只能重启了。 方案二：接口迁移腾讯云开发断断续续查了几周没解决，想到迁移接口吧，于是乎到腾讯云也是开了一个云开发，接口的逻辑代码都调通，准备进行流式响应时，又又遇到了之前的问题，它没给我原始响应对象，不能进行自定义响应。于是乎问了下客户客服说不支持（这点比起uncloud还是很好的，有技术在线可以问） 方案三：接口迁移Serverless于是乎我又去开通了serverless之前没用过，发现它好像介于传统开发和云开发之间，它的代码就是原技术的代码，比如你选着nodejs 或者 java 得到的就是你正常开发的目录结构，不像云开发还会封装一层有一定学习成本。它控制台就是一个在线vscode，代码以及目录结构就是你选用的技术，写完直接部署就行了。会给一个公网地址映射到你的项目服务端口。因为就是原代码不像云开发的封装了一层，所以很简单就能实现流式响应标准接口，不管是什么后端技术本身都是支持http全部类型的，只是云开发封装了一层没给你原response对象 本来以为到这里就结束了，但是没想到客户端又不支持，本来从来没有想过客户端不支持的，以为解决了接口就行了。 客户端使用了三种，第一种uniapp提供的uni.request有个enableChunked: true的配置开启，但是好像只是支持小程序。到app就找不到监听函数 123456789101112131415161718192021222324252627 const response = uni.request(&#123; url: &#x27;Your requested address&#x27;, // 请求地址 method: &quot;Request method&quot;, // 你的请求方法 data: data, header: &#123; &quot;Accept&quot;: &#x27;text/event-stream&#x27;, &quot;Connection&quot;: &quot;keep-alive&quot; &#125;, responseType: &quot;text&quot;, enableChunked: true, // 开启流传输 success: (res) =&gt; &#123; resolve(res) &#125;, fail: (err) =&gt; &#123; reject(err) &#125;, &#125;) // 返回请求头信息 response.onHeadersReceived((e)=&gt;&#123; console.log(e); &#125;)// 成功回调 返回流传输信息 返回arrayBufferresponse.onChunkReceived((e)=&#123; console.log(e);&#125;) 第二种是fetch也是js自带的，在uniapp环境还是找不到 第三种用xhr完全没反应 12345678910111213141516171819202122232425262728293031323334const xhr = new XMLHttpRequest();let buffer = &#x27;&#x27;;xhr.open(&#x27;POST&#x27;, url, true);xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);xhr.setRequestHeader(&#x27;Accept&#x27;, &#x27;text/event-stream&#x27;);xhr.onprogress = function() &#123; const newData = xhr.responseText.substr(buffer.length); console.log(newData); buffer += newData; console.log(buffer);&#125;;xhr.onreadystatechange = function () &#123; if (xhr.readyState === XMLHttpRequest.LOADING) &#123; // 处理 HTTP 数据块 console.log(xhr.responseText) &#125;&#125;xhr.onload = function() &#123; if (xhr.status === 200) &#123; resolve(buffer); &#125; else &#123; reject(new Error(`HTTP error! status: $&#123;xhr.status&#125;`)); &#125;&#125;;xhr.onerror = function() &#123; console.log(&quot;error&quot;)&#125;;xhr.send(data ? JSON.stringify(data) : null); 后两种基本上就是想尝试用原生js的方式，也是失败告终. 方案四：换协议Websocket既然不行的话（虽然很离谱不应该不支持的呀），现在就只能用websocket了，这个uniapp客户端应该支持吧。OKOK那再把接口改成websocket的，然后把输出的地方都替换。 然后改下客户端连接websocket，不同的平台uni提供的接口函数可能都不一样，目前测试在鸿蒙上ok 12345678910111213141516171819202122232425262728293031let socket = uni.connectSocket(&#123; url: &#x27;wss://you_api_url&#x27;, success: function (res) &#123; console.log(&#x27;WebSocket 连接创建成功&#x27;); &#125;, fail: function (err) &#123; console.error(&#x27;WebSocket 连接创建失败&#x27;, err); &#125;, complete: function () &#123; console.log(&#x27;WebSocket 连接创建完成&#x27;); &#125;&#125;);socket.onOpen(function () &#123; console.log(&quot;连接到了&quot;) socket.send(&#123; data: &#x27;Hello from uni-app!&#x27; &#125;);&#125;);socket.onMessage(function (res) &#123; console.log(&#x27;收到服务器内容：&#x27; + JSON.stringify(res));&#125;);socket.onClose(function (res) &#123; console.log(&#x27;WebSocket 已关闭！&#x27;);&#125;);// 监听 WebSocket 错误事件socket.onError(function (res) &#123; console.error(&#x27;WebSocket 连接错误！&#x27;);&#125;); 总结总体来说有点沙雕，既然用websocket的话，那之前的云开发后端也应该可以，等于说绕了一大圈最终其实也可以不迁移这个接口。但问题是本来我的需要并不是一定要用websocket只是单向流式传输就行了，现在因为客户端的问题必须要用websocket，要是一开始无脑用websocket反而不用卡那么久有点逗了","categories":[],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"SpringSecurity详解","slug":"SpringSecurity详解","date":"2022-08-25T06:11:53.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2022/08/25/SpringSecurity详解/","link":"","permalink":"http://yournotes.cn/2022/08/25/SpringSecurity%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、SpringSecurity入门1.1 Spring Security简介​ Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于 Spring的应用程序的实际标准。Spring Security是一个框架，致力于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring Security的真正强大之处在于可以轻松扩展以满足自定义要求. 官网地址：https://spring.io/projects/spring-security 1.2 安全技术方案对比目前在整个Java开发的系统中,需要用于身份验证和访问控制框架的框架除了Spring Security, 还有一个就是Apache shiro框架. Shiro Shiro是一个强大而灵活的开源安全框架，能够非常清晰的处理认证、授权、管理会话以及密码加密。如下是它所具有的特点： 易于理解的 Java Security API； 简单的身份认证（登录），支持多种数据源（LDAP，JDBC，Kerberos，ActiveDirectory等） 对角色的简单的鉴权（访问控制），支持细粒度的鉴权； 支持一级缓存，以提升应用程序的性能； 内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境； 异构客户端会话访问； 非常简单的加密 API； 不跟任何的框架或者容器捆绑，可以独立运行。 Spring Security 除了不能脱离Spring，shiro的功能它都有。而且Spring Security对Oauth、OpenID也有支持,Shiro则需要自己手动实现。Spring Security的权限细粒度更高。 OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。 OpenID 系统的第一部分是身份验证，即如何通过 URI 来认证用户身份。目前的网站都是依靠用户名和密码来登录认证，这就意味着大家在每个网站都需要注册用户名和密码，即便你使用的是同样的密码。如果使用 OpenID ，你的网站地址（URI）就是你的用户名，而你的密码安全的存储在一个 OpenID 服务网站上（你可以自己建立一个 OpenID 服务网站，也可以选择一个可信任的 OpenID 服务网站来完成注册）。与OpenID同属性的身份识别服务商还有ⅥeID,ClaimID,CardSpace,Rapleaf,Trufina ID Card等，其中ⅥeID通用账户的应用最为广泛 1.3 Spring Security功能简介 认证: 用户登录, 解决的是”你是谁?” 授权: 判断用户拥有什么权限，可以访问什么资源. 解决的是”你能干什么?” 安全防护，防止跨站请求，session 攻击等 1.4 Spring Security应用场景 用户登录, 传统基于web开发的项目的登录功能. 用户授权, 在系统中用户拥有哪些操作权限 单一登录, 一个账号只能在同一时间只能在一个地方进行登录, 如果在其他地方进行第二次登录,则剔除之前登录操作 集成cas,做单点登录,即多个系统只需登录一次，无需重复登录 集成oauth2 ,做登录授权, 可以用于app登录和第三方登录(QQ,微信等), 也可以实现cas的功能. 1.5 Spring Security入门案例快速开始 1.5.1 IDEA创建工程 1.5.2 编写Controller 123456789101112package cn.yournotes.security_demo.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello world&quot;; &#125;&#125; 启动测试 1.5.3 加入Security依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 再次启动测试 我们可以先观察下表单页面 我们可以看到这个结构主要有三点： 表单的提交方式是post，接口地址是/login 有两个正常的input，且input参数名称分别是username和password 还有一个隐藏域的input，参数名是_csrf SpringBoot已经为SpringSecurity提供了默认配置，默认工程中所有资源都必须通过Security认证后才能访问。那么问题来了！此刻并没有连接数据库，也并未在内存中指定认证用户，如何认证呢？ 其实SpringBoot已经提供了默认用户名user，密码在项目启动时随机生成，如图： 认证通过继续访问处理器资源 二、SpringSecurity认证 说明：为方便学习，这里已经事先为准备好一个半成品的后台管理系统，而想要完善另一部分，就需要用到今天学习的内容SpringSecurity了！ 2.1 下载案例先下载相关资源代码以及SQL： 导入数据 创建个数据库security_management然后导入素材当中的sql文件： 导入工程 启动 2.2 SpringSecurity认证基本原理与两种方式现在在初始项目中是没有认证的，直接进入首页。那么现在我们给它加上Security依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2.2.1 过滤链介绍在使用SpringSecurity框架，该框架会默认自动地替我们将系统中的资源进行保护，每次访问资源的时候都必须经过一层身份的校验，如果通过了则重定向到我们输入的url中，否则访问是要被拒绝的。那么SpringSecurity框架是如何实现的呢? Spring Security功能的实现主要是由一系列过滤器相互配合完成。也称之为过滤器链. 过滤器是一种典型的AOP思想，下面简单了解下这些过滤器链,后续再源码剖析中在涉及到过滤器链之后再仔细讲解. org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter 根据请求封装获取WebAsyncManager，从WebAsyncManager获取&#x2F;注册的安全上下文可调用处理拦截器 org.springframework.security.web.context.SecurityContextPersistenceFilter SecurityContextPersistenceFilter主要是使用SecurityContextRepository在session中保存或更新一个SecurityContext，并将SecurityContext给以后的过滤器使用，来为后续fifilter建立所需的上下文。SecurityContext中存储了当前用户的认证以及权限信息。 org.springframework.security.web.header.HeaderWriterFilter 向请求的Header中添加相应的信息,可在http标签内部使用security:headers来控制 org.springframework.security.web.csrf.CsrfFilter csrf又称跨域请求伪造，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息，如果不包含，则报错。起到防止csrf攻击的效果。 org.springframework.security.web.authentication.logout.LogoutFilter 匹配URL为&#x2F;logout的请求，实现用户退出,清除认证信息。 org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter 表单认证操作全靠这个过滤器，默认匹配URL为&#x2F;login且必须为POST请求。 org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter 如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认认证页面。 org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter 由此过滤器可以生产一个默认的退出登录页面 org.springframework.security.web.authentication.www.BasicAuthenticationFilter 此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头信息。 org.springframework.security.web.savedrequest.RequestCacheAwareFilter 通过HttpSessionRequestCache内部维护了一个RequestCache，用于缓存HttpServletRequest org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter 针对ServletRequest进行了一次包装，使得request具有更加丰富的API org.springframework.security.web.authentication.AnonymousAuthenticationFilter 当SecurityContextHolder中认证信息为空,则会创建一个匿名用户存入到SecurityContextHolder中。spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。 org.springframework.security.web.session.SessionManagementFilter securityContextRepository限制同一用户开启多个会话的数量 org.springframework.security.web.access.ExceptionTranslationFilter 异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常 org.springframework.security.web.access.intercept.FilterSecurityInterceptor 获取所配置资源访问的授权信息，根据SecurityContextHolder中存储的用户信息来决定其是否有权限。 Spring Security默认会加载15个过滤器, 但是随着配置可以增加或者删除一些过滤器. 2.2.2 认证方式HttpBasic认证 HttpBasic登录验证模式是Spring Security实现登录验证最简单的一种方式，也可以说是最简陋的一种方式。它的目的并不是保障登录验证的绝对安全，而是提供一种“防君子不防小人”的登录验证。 在使用的Spring Boot早期版本为1.X版本,依赖的Security 4.X版本，那么就无需任何配置，启动项目访问则会弹出默认的httpbasic认证。现在使用的是spring boot2.0以上版本（依赖Security5.X版本），HttpBasic不再是默认的验证模式，在spring security 5.x默认的验证模式已经是表单模式。 HttpBasic模式要求传输的用户名密码使用Base64模式进行加密。如果用户名是 “admin” ，密码是“ admin”,则将字符串”admin:admin” 使用Base64编码算法加密。加密结果可能是：YWtaW46YWRtaW4&#x3D;。HttpBasic模式真的是非常简单又简陋的验证模式，Base64的加密算法是可逆的,想要破解并不难. FormLogin认证 Spring Security的HttpBasic模式，该模式比较简单，只是进行了通过携带Http的Header进行简单的登录验证，而且没有定制的登录页面，所以使用场景比较窄。对于一个完整的应用系统，与登录验证相关的页面都是高度定制化的，非常美观而且提供多种登录方式。这就需要Spring Security支持我们自己定制登录页面, spring boot2.0以上版本（依赖Security 5.X版本）默认会生成一个登录页面. 2.3 表单认证2.3.1 自定义表单登录页面编写SecurityConfiguration配置类 123456789101112@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启formLogin认证 .loginPage(&quot;/login.html&quot;) // 自定义登录页 .and() .authorizeRequests() // 选择哪些请求 .anyRequest() // 任意请求 .authenticated(); // 选择的请求请求需要认证 &#125;&#125; 启动后访问会发现有问题： 重定向次数过多 原因在于我们设置了对所有请求进行认证，因此访问login.html资源时也需要进行认证而认证页 又是访问login.html因此陷入死循环。它本身的登录不需要额外配就会过滤，但我们自己指定的登录页它不会帮我们去过滤掉，我们需要手动放行。 12345678910111213@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启formLogin认证 .loginPage(&quot;/login.html&quot;) // 自定义登录页 .and() .authorizeRequests() // 选择哪些请求 .antMatchers(&quot;/login.html&quot;).permitAll() //这个请求开允许 .anyRequest() // 任意请求 .authenticated(); // 选择的请求请求需要认证 &#125;&#125; 再次启动 404 因为在Springboot都是请求的方式path都是找controller，它不会去资源文件去加载，我们需要配置成接口路径在接口里面返回页面。 在项目里面已经有了这个接口，配置文件配置了前缀templats以及后缀.html 因此返回login就可在资源文件找到页面 12345678910111213@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启formLogin认证 .loginPage(&quot;/toLoginPage&quot;) // 自定义登录页 .and() .authorizeRequests() // 选择哪些请求 .antMatchers(&quot;/toLoginPage&quot;).permitAll() //这个请求开允许 .anyRequest() // 任意请求 .authenticated(); // 选择的请求请求需要认证 &#125;&#125; 修改后再次启动，这次会出现样式丢失的问题 样式丢失 这个很显然就是这些资源请求被拦截的问题，我们需要在Security配置当中通过WebSecurity去忽略指定的内容不参与安全控制。 123456789101112131415161718@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启formLogin认证 .loginPage(&quot;/toLoginPage&quot;) // 自定义登录页 .and() .authorizeRequests() // 选择哪些请求 .antMatchers(&quot;/toLoginPage&quot;).permitAll() //这个请求开允许 .anyRequest() // 任意请求 .authenticated(); // 选择的请求请求需要认证 &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/css/**&quot;, &quot;/images/**&quot;, &quot;/js/**&quot;, &quot;/favicon.ico&quot;); &#125;&#125; Spring Security中，安全构建器HttpSecurity和WebSecurity的区别是 : WebSecurity不仅通过HttpSecurity定义某些请求的安全控制，也通过其他方式定义其他某些请求可以忽略安全控制; HttpSecurity仅用于定义需要安全控制的请求(当然HttpSecurity也可以指定某些请求不需要安全控制); 可以认为HttpSecurity是WebSecurity的一部分，WebSecurity是包含HttpSecurity的更大的一个概念; 构建目标不同 WebSecurity构建目标是整个Spring Security安全过滤器FilterChainProxy, HttpSecurity的构建目标仅仅是FilterChainProxy中的一个SecurityFilterChain。 2.3.2 表单登录在上面过滤器链中我们知道有一个过滤器叫做UsernamePasswordAuthenticationFilter是处理表单登录的，那么现在来观察一下这个过滤器。 在源码当中可以看到，表单中两个input的name分别是username和password参数，路径为&#x2F;login，方式是POST。这些都可以修改为自定义的值 123456789101112131415@Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启formLogin认证 .loginPage(&quot;/toLoginPage&quot;) // 自定义登录页 .loginProcessingUrl(&quot;/login&quot;) // 登录接口url .usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;) //自定义表单name .successForwardUrl(&quot;/&quot;) //登录成功跳转 .and() .authorizeRequests() // 选择哪些请求 .antMatchers(&quot;/toLoginPage&quot;).permitAll() //这个请求开允许 .anyRequest() // 任意请求 .authenticated(); // 选择的请求请求需要认证 // 关闭scrf防护 http.csrf().disable(); &#125; 后端关于login接口的参数、路径、类型定义好后，那么自定义页面进行对应的请求即可。 配置完成重启进行登录用户名user、密码在后端控制台生成 登录完成发现还是有新问题，里面的内容是拒绝请求 问题在于，在首页最下面使用了iframe 发现行内框架iframe这里出现问题了. Spring Security下，X-Frame-Options默认为DENY，其实非SpringSecurity环境下，X-Frame-Options的默认大多也是DENY，这种情况下，浏览器拒绝当前页面加载任何Frame页面，设置含义如下： DENY：浏览器拒绝当前页面加载任何Frame页面 此选择是默认的. SAMEORIGIN：frame页面的地址只能为同源域名下的页面 那么需要响应时需要允许iframe的加载 1234567891011121314151617@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启formLogin认证 .loginPage(&quot;/toLoginPage&quot;) // 自定义登录页 .loginProcessingUrl(&quot;/login&quot;) // 登录接口url .usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;) //自定义表单name .successForwardUrl(&quot;/&quot;) //登录成功跳转 .and() .authorizeRequests() // 选择哪些请求 .antMatchers(&quot;/toLoginPage&quot;).permitAll() //这个请求开允许 .anyRequest() // 任意请求 .authenticated(); // 选择的请求请求需要认证 // 关闭scrf防护 http.csrf().disable(); // 允许iframe加载页面 http.headers().frameOptions().sameOrigin();&#125; 2.3.3 基于数据库实现认证功能目前认证使用的是默认的用户名user以及自动生成打印在控制台的秘密，那么现在要将用户凭证配置在数据库。 实现这样的功能就需要实现security当中的UserDetailsService接口，重写里面的loadUserByUsername进行自定义校验即可。 方法传进来的参数是用户名，拿去用自己的service去数据库查处用户实体 1234567891011121314151617181920212223242526@Servicepublic class MyUserDetailsService implements UserDetailsService &#123; @Autowired UserService userService; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; UserVo user = userService.findByUsername(s); if(user == null)&#123; throw new UsernameNotFoundException(&quot;没有找到这个用户名:&quot;+s); &#125; // 先声明一个权限集合,构造函数必须传值且不能为null,传个空集合即可 Collection&lt;? extends GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); // 需要返回一个SpringSecurity的UserDetails对象 UserDetails userDetails = new User( user.getUsername(), // 用户名 &quot;&#123;noop&#125;&quot;+user.getPassword(), //密码&#123;noop&#125;表示不加密 true, // 用户是否启用 true启用 true, // 用户是否过期 true没过期 true, // 用户凭证是否过期 true没过期 true, // 是否锁定 true未锁定 authorities ); return userDetails; &#125;&#125; 定义好我们的认证逻辑后，将这个逻辑配置到Security当中，一样还是在SecurityConfiguration的configure重载方法进行配置 1234@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(myUserDetailsService);&#125; 2.3.4 密码加密认证在基于数据库完成用户登录过程中，我们使用的密码是明文，给出UserDetails时密码使用了&#123;noop&#125;进行标记。那么下面对SpringSecurity中密码编码进行一些探讨。 SpringSecurity当中PasswordEncoder就是对我们密码进行编码的工具接口。该接口有两个功能：一个是匹配验证。另一个是密码编码。 BCrypt算法介绍 任何应用考虑到安全，绝不能明文的方式保存密码。密码应该通过哈希算法进行加密。 有很多标准的算法比如SHA或者MD5，结合salt(盐)是一个不错的选择。 Spring Security 提供了BCryptPasswordEncoder类,实现Spring的PasswordEncoder接口使用BCrypt强哈希方法来加密密码。BCrypt强哈希方法 每次加密的结果都不一样,所以更加的安全。 bcrypt算法相对来说是运算比较慢的算法，在密码学界有句常话：越慢的算法越安全。黑客破解成本越高.通过salt和const这两个值来减缓加密过程，它的加密时间（百ms级）远远超过md5（大概1ms左右）。对于计算机来说，Bcrypt 的计算速度很慢，但是对于用户来说，这个过程不算慢。bcrypt是单向的，而且经过salt和cost的处理，使其受攻击破解的概率大大降低，同时破解的难度也提升不少，相对于MD5等加密方式更加安全，而且使用也比较简单 bcrypt加密后的字符串形如：$2a$10$wouq9P/HNgvYj2jKtUN8rOJJNRVCWvn1XoWy55N3sCkEHZPo3lyWq 其中$是分割符，无意义；2a是bcrypt加密版本号；10是const的值；而后的前22位是salt值；再然后的字符串就是密码的密文了；这里的const值即生成salt的迭代次数，默认值是10，推荐值12。 在项目中使用BCrypt PasswordEncoder有很多实现类因此是提供了工厂方法模式去创建，通过指定不同的参数得到不同的具体编码器 此工厂类是PasswordEncoderFactories 之前我们在项目中密码使用的是明文的是noop , 代表不加密使用明文密码, 现在用BCrypt只需要将noop 换成bcrypt 即可 &#123;noop&#125; 改成 &#123;bcrypt&#125; 后也记得要将数据库的密码改为加密后的密码，否则在认证时对数据库密码进行解密就对不上了。 既然我们指定了&#123;bcrypt&#125; ，那就看看bcrypt编码器对指定的密码进行加密的结果，复制到数据库即可 登录成功 2.3.5 获取当前登录用户在传统web系统中, 我们将登录成功的用户放入session中, 在需要的时候可以从session中获取用户,那么Spring Security中我们如何获取当前已经登录的用户呢? SecurityContextHolder 保留系统当前的安全上下文SecurityContext，其中就包括当前使用系统的用户信息。 SecurityContext 安全上下文，获取当前经过身份验证的主体或者身份验证请求令牌 代码实现： 123456@RequestMapping(&quot;/loginUser&quot;)@ResponseBodypublic UserDetails getCurrentUser()&#123; UserDetails userDetails = (UserDetails)SecurityContextHolder.getContext().getAuthentication().getPrincipal(); return userDetails;&#125; 除了上述方法, Spring Security 还提供了2种方式可以获取. 123456789101112@RequestMapping(&quot;/loginUser01&quot;)@ResponseBodypublic UserDetails getCurrentUser(Authentication auth)&#123; UserDetails userDetails = (UserDetails)auth.getContext().getAuthentication().getPrincipal(); return userDetails;&#125;@RequestMapping(&quot;/loginUser02&quot;)@ResponseBodypublic UserDetails getCurrentUser(getCurrentUser(@AuthenticationPrincipal UserDetails userDetails)&#123; return userDetails;&#125; 2.3.6 remember me 记住我在大多数网站中，都会实现RememberMe这个功能，方便用户在下一次登录时直接登录，避免再次输入用户名以及密码去登录,Spring Security针对这个功能已经帮助我们实现。 下面我们来看下他的原理图： 2.3.6.1 简单生成Token方法 Token&#x3D;MD5(username+分隔符+expiryTime+分隔符+password) 注意: 这种方式不推荐使用, 有严重的安全问题. 就是密码信息在前端浏览器cookie中存放. 如果cookie被盗取很容易破解. 代码实现： 前端的选框按钮 123456&lt;div class=&quot;form-group&quot;&gt; &lt;div&gt; &lt;!--记住我 name为remember-me value值可选true yes 1 on 都行--&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;/&gt;记住我 &lt;/div&gt;&lt;/div&gt; 后端开启remember-me功能 123.and().rememberMe()//开启记住我功能.tokenValiditySeconds(1209600)// token失效时间默认2周.rememberMeParameter(&quot;remember-me&quot;)// 自定义表单name值 登录接口配置上面一段即可开启 1234567891011121314151617181920@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启formLogin认证 .loginPage(&quot;/toLoginPage&quot;) // 自定义登录页 .loginProcessingUrl(&quot;/login&quot;) // 登录接口url .usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;) //自定义表单name .successForwardUrl(&quot;/&quot;) //登录成功跳转 .and().rememberMe()//开启记住我功能 .tokenValiditySeconds(1209600)// token失效时间默认2周 .rememberMeParameter(&quot;remember-me&quot;)// 自定义表单name值 .and() .authorizeRequests() // 选择哪些请求 .antMatchers(&quot;/toLoginPage&quot;).permitAll() //这个请求开允许 .anyRequest() // 任意请求 .authenticated(); // 选择的请求请求需要认证 // 关闭scrf防护 http.csrf().disable(); // 允许iframe加载页面 http.headers().frameOptions().sameOrigin();&#125; 登录成功产生一条cookie 2.3.6.2 持久化的Token生成方法 存入数据库的Token包含： token: 随机生成策略,每次访问都会重新生成 series: 登录序列号，随机生成策略。用户输入用户名和密码登录时，该值重新生成。使用remember-me功能，该值保持不变 expiryTime: token过期时间。 Token &#x3D; encode(series+token) 代码实现 后端配置 同样也是在SecurityConfiguration进行配置 1234.and().rememberMe()//开启记住我功能.tokenValiditySeconds(1209600)// token失效时间默认2周.rememberMeParameter(&quot;remember-me&quot;)// 自定义表单name值.tokenRepository(getPersistentTokenRepository()) //设置token的存储库 123456789101112131415@AutowiredDataSource dataSource;/** * 持久化token,负责token与数据库之间的相关操作 * * @return */@Beanpublic PersistentTokenRepository getPersistentTokenRepository() &#123; JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl(); tokenRepository.setDataSource(dataSource); //设置数据源 // 启动时创建一张表, 第一次启动的时候创建, 第二次启动的时候需要注释掉, 否会保存 tokenRepository.setCreateTableOnStartup(true); return tokenRepository;&#125; 重新登录 表已创建就可以把 tokenRepository.setCreateTableOnStartup(true)去掉了 启动项目重新登录，数据库会插入记录。说明持久化token方式已经生效。 Cookie窃取伪造访问 使用网页登录系统，记录remember-me的值 在postman伪造cookie，进行请求 可以正常访问，而不是拦截到登录 安全验证 如果要禁止是记住我的token进行访问，可以进行控制 123456789101112@GetMapping(&quot;/&#123;id&#125;&quot;)@ResponseBodypublic UserVo getById(@PathVariable Integer id) &#123; //获取认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 判断认证信息是否来源于RememberMe if (RememberMeAuthenticationToken.class.isAssignableFrom(authentication.getClass())) &#123; throw new RememberMeAuthenticationException(&quot;认证信息来源于 RememberMe,请重新登录&quot;); &#125; UserVo user = userService.getById(id); return user;&#125; 所以在重要的步骤我们可以加以控制记住我的访问 2.3.7 自定义登录状态处理在某些场景下,用户登录成功或失败的情况下用户需要执行一些后续操作,比如登录日志的搜集,或者在现在目前前后端分离的情况下用户登录成功和失败后需要给前台页面返回对应的错误信息, 有前台主导登录成功或者失败的页面跳转.这个时候需要要到用到AuthenticationSuccessHandler与AnthenticationFailureHandler. 实现AuthenticationSuccessHandler接口，并重写onAnthenticationSuccesss()方法. 实现AuthenticationFailureHandler接口，并重写onAuthenticationFailure()方法； 代码实现 12345678910111213141516171819@Servicepublic class MyAuthHandle implements AuthenticationSuccessHandler, AuthenticationFailureHandler &#123; private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authentication) throws IOException, ServletException &#123; &#125; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;登录成功后续处理....&quot;); //重定向到index页 redirectStrategy.sendRedirect(request, response, &quot;/&quot;); &#125; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; System.out.println(&quot;登录失败后续处理....&quot;); //重定向到login页 redirectStrategy.sendRedirect(request, response, &quot;/toLoginPage&quot;); &#125;&#125; 在SecurityConfiguration配置上这些自定义处理 配置在登录表单后即可 12345678http.formLogin() // 开启formLogin认证 .loginPage(&quot;/toLoginPage&quot;) // 自定义登录页 .loginProcessingUrl(&quot;/login&quot;) // 登录接口url .usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;) //自定义表单name .successForwardUrl(&quot;/&quot;) //登录成功跳转 .successHandler(myAuthHandle) .failureHandler(myAuthHandle) // 略... 除了登录成功登陆失败这些节点还有其他的很多节点都可以进行自定义处理 123456789101112131415.and().formLogin() //开启登录.permitAll() //允许所有人访问.successHandler(myAuthHandle) // 登录成功逻辑处理.failureHandler(myAuthHandle) // 登录失败逻辑处理.and().logout() //开启注销.permitAll() //允许所有人访问.logoutSuccessHandler(myAuthHandle) //注销逻辑处理.deleteCookies(&quot;JSESSIONID&quot;) //删除cookie.and().exceptionHandling().accessDeniedHandler(myAuthHandle) //权限不足的时候的逻辑处理.authenticationEntryPoint(myAuthHandle) //未登录是的逻辑处理 各阶段处理器列举几个 阶段 实现接口 重写方法 登录成功时 AuthenticationSuccessHandler onAnthenticationSuccesss() 登录失败时 AuthenticationFailureHandler onAuthenticationFailure() 注销成功时 LogoutSuccessHandler onLogoutSuccess() 没有权限时 AccessDeniedHandler handle() 没有登录时 AuthenticationEntryPoint commence() 向上面不是一个前后端分离的例子，如果前后的分离结合这些自定义处理器就可以实现，比如 1234567@Overridepublic void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException &#123; //登录成功时返回给前端的数据 ApiResult result = ApiResult.result(ApiCode.SUCCESS, &quot;登录成功&quot;, &quot;&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(JSON.toJSONString(result));&#125; 123456789101112131415@Overridepublic void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException &#123; ApiResult result = null; if(e instanceof UsernameNotFoundException)&#123; result = ApiResult.result(ApiCode.FAIL_AUTH,&quot;用户名找不到&quot;,&quot;&quot;); &#125;else if(e instanceof BadCredentialsException)&#123; result = ApiResult.result(ApiCode.FAIL_AUTH,&quot;密码错误&quot;,&quot;&quot;); &#125;else &#123; result = ApiResult.fail(e.getMessage()); &#125; //处理编码方式，防止中文乱码的情况 response.setContentType(&quot;text/json;charset=utf-8&quot;); //返回给前台 response.getWriter().write(JSON.toJSONString(result));&#125; 就不一一举例了，实现接口重写好方法，在SecurityConfiguration进行配置即可 2.4 图形验证码1图形验证码一般是防止恶意，人眼看起来都费劲，何况是机器。不少网站为了防止用户利用机器人自动注册、登录、灌水，都采用了验证码技术。所谓验证码，就是将一串随机产生的数字或符号，生成一幅图片， 图片里加上一些干扰,。也有目前需要手动滑动的图形验证码，这种可以有专门去做的第三方平台.：比如极验(https://www.geetest.com/), 这里介绍的主要针对图形验证码。 Spring Security添加验证码大致可以分为三个步骤： 根据随机数生成验证码图片 将验证码图片显示到登录页面 认证流中加入验证码校验 Spring Security的认证校验是由UsernamePasswordAuthenticationFilter过滤器完成的，所以我们的验证码校验逻辑应该在这个过滤器之前。验证码通过后才能到后续的操作. 流程如下: 代码实现： 自定义验证码过滤器ValidateCodeFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.yournotes.config;import cn.yournotes.controller.ValidateCodeController;import cn.yournotes.exception.ValidateCodeException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.bind.ServletRequestBindingException;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 验证码验证filter 需要继承OncePerRequestFilter确保在一次请求只通过一次filter，而不 * 需要重复执行 */@Componentpublic class ValidateCodeFilter extends OncePerRequestFilter &#123; @Autowired MyAuthHandle myAuthHandle; @Autowired StringRedisTemplate stringRedisTemplate; @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; // 判断是否是登录请求,只有登录请求才去校验验证码 if (httpServletRequest.getRequestURI().equals(&quot;/login&quot;) &amp;&amp; httpServletRequest.getMethod().equalsIgnoreCase(&quot;post&quot;)) &#123; try &#123; validate(httpServletRequest); &#125; catch (ValidateCodeException e) &#123; myAuthHandle.onAuthenticationFailure(httpServletRequest, httpServletResponse, e); return; &#125; &#125; //如果不是登录请求，直接调用后面的过滤器链 filterChain.doFilter(httpServletRequest, httpServletResponse); &#125; private void validate(HttpServletRequest request) throws ValidateCodeException &#123; //获取ip String remoteAddr = request.getRemoteAddr(); //拼接redis的key String redisKey = ValidateCodeController.REDIS_KEY_IMAGE_CODE + &quot;-&quot; + remoteAddr; //从redis中获取imageCode String redisImageCode = stringRedisTemplate.boundValueOps(redisKey).get(); String imageCode = request.getParameter(&quot;imageCode&quot;); if (!StringUtils.hasText(imageCode)) &#123; throw new ValidateCodeException(&quot;验证码的值不能为空！&quot;); &#125; if (redisImageCode == null) &#123; throw new ValidateCodeException(&quot;验证码已过期！&quot;); &#125; if (!redisImageCode.equals(imageCode)) &#123; throw new ValidateCodeException(&quot;验证码不正确！&quot;); &#125; // 从redis中删除imageCode stringRedisTemplate.delete(redisKey); &#125;&#125; 自定义异常 12345public class ValidateCodeException extends AuthenticationException &#123; public ValidateCodeException(String msg)&#123; super(msg); &#125;&#125; 验证码生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import cn.yournotes.domain.ImageCode;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.imageio.ImageIO;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import java.util.concurrent.TimeUnit;/** * 处理生成验证码的请求 */@RestController@RequestMapping(&quot;/code&quot;)public class ValidateCodeController &#123; public final static String REDIS_KEY_IMAGE_CODE = &quot;REDIS_KEY_IMAGE_CODE&quot;; public final static int expireIn = 60; // 验证码有效时间 60s //使用sessionStrategy将生成的验证码对象存储到Session中，并通过IO流将生成的图片输出到登录页面上。 @Autowired public StringRedisTemplate stringRedisTemplate; @RequestMapping(&quot;/image&quot;) public void createCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; //获取访问IP String remoteAddr = request.getRemoteAddr(); //生成验证码对象 ImageCode imageCode = createImageCode(); //生成的验证码对象存储到redis中 KEY为REDIS_KEY_IMAGE_CODE+IP地址 stringRedisTemplate.boundValueOps(REDIS_KEY_IMAGE_CODE + &quot;-&quot; + remoteAddr) .set(imageCode.getCode(), expireIn, TimeUnit.SECONDS); //通过IO流将生成的图片输出到登录页面上 ImageIO.write(imageCode.getImage(), &quot;jpeg&quot;, response.getOutputStream()); &#125; /** * 用于生成验证码对象 * * @return */ private ImageCode createImageCode() &#123; int width = 100; // 验证码图片宽度 int height = 36; // 验证码图片长度 int length = 4; // 验证码位数 //创建一个带缓冲区图像对象 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //获得在图像上绘图的Graphics对象 Graphics g = image.getGraphics(); Random random = new Random(); //设置颜色、并随机绘制直线 g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); g.setFont(new Font(&quot;Times New Roman&quot;, Font.ITALIC, 20)); g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 155; i++) &#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x, y, x + xl, y + yl); &#125; //生成随机数 并绘制 StringBuilder sRand = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; String rand = String.valueOf(random.nextInt(10)); sRand.append(rand); g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110))); g.drawString(rand, 13 * i + 6, 16); &#125; g.dispose(); return new ImageCode(image, sRand.toString()); &#125; /** * 获取随机演示 * * @param fc * @param bc * @return */ private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) &#123; fc = 255; &#125; if (bc &gt; 255) &#123; bc = 255; &#125; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125;&#125; security配置 需要配置两个东西，一个是在UsernamePasswordAuthenticationFilter之前需要加一个过滤器进行验证码处理，第二是放行验证码接口让前端请求显示。记得把验证码接口地址放到html图片验证码处、redis也配置好 123456789101112http.addFilterBefore(validateCodeFilter,UsernamePasswordAuthenticationFilter.class);http.formLogin() // 开启formLogin认证 .loginPage(&quot;/toLoginPage&quot;) // 自定义登录页 .loginProcessingUrl(&quot;/login&quot;) // 登录接口url .usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;) //自定义表单name .successForwardUrl(&quot;/&quot;) //登录成功跳转 .successHandler(myAuthHandle) .failureHandler(myAuthHandle) .and().logout().logoutUrl(&quot;/logout&quot;)//设置退出url .logoutSuccessHandler(myAuthHandle)//自定义退出处理 .and().authorizeRequests() .antMatchers(&quot;/toLoginPage&quot;,&quot;/code/**&quot;).permitAll() 2.5 session管理Spring Security可以与Spring Session库配合使用，只需要做一些简单的配置就可以实现一些功能，如(会话过期、一个账号只能同时在线一个、集群session等) 2.5.1 会话超时 配置session会话超时时间，默认为30分钟，我们设置短些进行测试，但最小只能设置60s 1234# session设置# 当session超时后, 默认跳转到登录页面.# 配置session超时时间server.servlet.session.timeout=60 自定义设置session超时后地址 设置session管理和失效后跳转地址 1234// 设置session管理// session无效后跳转的路径,默认是登录页面。// 前后的分离的话就不需要配置这些跳转的相关配置了http.sessionManagement().invalidSessionUrl(&quot;/toLoginPage&quot;) 2.5.2 并发控制​ 并发控制即同一个账号同时在线个数,同一个账号同时在线个数如果设置为1表示，该账号在同一时间内只能有一个有效的登录，如果同一个账号又在其它地方登录，那么就将上次登录的会话过期，即后面的登录会踢掉前面的登录 修改超时时间 123#session设置#配置session超时时间server.servlet.session.timeout=600 设置最大会话数量 1234http.sessionManagement()//设置session管理 .invalidSessionUrl(&quot;/toLoginPage&quot;)// session无效后跳转的路径, 默认是登录页面 .maximumSessions(1)//设置session最大会话数量 ,1同一时间只能有一个用户登录 .expiredUrl(&quot;/toLoginPage&quot;);//设置session过期后跳转路径 使用第二个浏览器再进行登录时 ，第一个浏览器会失去登录信息访问会进入登录页 阻止用户第二次登录 sessionManagement也可以配置 maxSessionsPreventsLogin：boolean值，当达到maximumSessions设置的最大会话个数时阻止登录。 1234http.sessionManagement()//设置session管理 .invalidSessionUrl(&quot;/toLoginPage&quot;)// session无效后跳转的路径, 默认是登录页面 .maximumSessions(1)//设置session最大会话数量 ,1同一时间只能有一个用户登录 .expiredUrl(&quot;/toLoginPage&quot;);//设置session过期后跳转路径 2.5.3 集群session实际场景中一个服务会至少有两台服务器在提供服务，在服务器前面会有一个nginx做负载均衡，用户访问nginx，nginx再决定去访问哪一台服务器。当一台服务宕机了之后，另一台服务器也可以继续提供服务，保证服务不中断。如果我们将session保存在Web容器(比如tomcat)中，如果一个用户第一次访问被分配到服务器1上面需要登录，当某些访问突然被分配到服务器二上，因为服务器二上没有用户在服务器一上登录的会话session信息，服务器二还会再次让用户登录，用户已经登录了还让登录就感觉不正常了。 解决这个问题的思路是用户登录的会话信息不能再保存到Web服务器中，而是保存到一个单独的库 (redis、mongodb、jdbc等)中，所有服务器都访问同一个库，都从同一个库来获取用户的session信息，如用户在服务器一上登录，将会话信息保存到库中，用户的下次请求被分配到服务器二，服务器二从库中检查session是否已经存在，如果存在就不用再登录了，可以直接访问服务了。 引入依赖 12345&lt;!-- 基于redis实现session共享 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 设置session存储类型 12#使用redis共享sessionspring.session.store-type=redis 测试 121. 设置不同端口启动两个服务2. 访问第一个服务进行登录，第二服务就可以直接访问 2.6 csrf防护机制2.6.1 什么是csrf?​ CSRF（Cross-site request forgery），中文名称：跨站请求伪造 ​ 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 ​ CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成三个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 触发网站B中的一些元素 2.6.3 CSRF的防御策略在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。 验证 HTTP Referer 字段 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，在后台请求验证其 Referer 值，如果是以自身安全网站开头的域名，则说明该请求是是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 在请求地址中添加 token 并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 在 HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。 2.6.4 Security中的csrf防御机制org.springframework.security.web.csrf.CsrfFilter csrf又称跨站请求伪造，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息，如果不包含，则报错。起到防止csrf攻击的效果。(1. 生成token 2.验证token) 开启csrf防护 12//开启csrf防护, 可以设置哪些不需要防护http.csrf().ignoringAntMatchers(&quot;/user/xxx&quot;); 页面需要添加token值 1&lt;input type=&quot;hidden&quot; th:name=&quot;$&#123;_csrf.parameterName&#125;&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot;/&gt; 这样使用的前提是前后端不分离的项目，在同一个session里面取toke，每次都是随机生成的因此无法伪造。如果前后端分离token就又需要远程请求获取而不是直接在session里面取这又会不安全，如果是前后端分离该怎么设计这个暂时不探讨。 2.7 跨域与CORS2.7.1 跨域​ 跨域，实质上是浏览器的一种保护处理。如果产生了跨域，服务器在返回结果时就会被浏览器拦截(注意：此时请求是可以正常发起的，只是浏览器对其进行了拦截)，导致响应的内容不可用. 产生跨域的几种情况有一下: 协议不同（http&#x2F;https） 域名不同 端口号不同 2.7.2 解决跨域 JSONP 浏览器允许一些带src属性的标签跨域，也就是某些标签属性上写url地址是不会跨域产生跨域问题的 CORS解决跨域 CORS是一个W3C标准，全程是“跨域资源共享”（Cross-origin resource sharing）. CORS需要浏览器和服务器同时支持。目前所有浏览器都支持该功能，IE浏览器不能低于IE10 浏览器在发起真正的请求之前，会发起一个OPTIONS类型的预检请求，用于请求服务器是否允许跨域，在得到许可的情况下才会发起请求。 2.7.3 基于SpringSecurity的CORS支持 声明跨域配置源 1234567891011121314151617181920/** * 跨域配置信息源 * * @return */public CorsConfigurationSource corsConfigurationSource() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); // 设置允许跨域的站点 corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 设置允许跨域的http方法 corsConfiguration.addAllowedMethod(&quot;*&quot;); // 设置允许跨域的请求头 corsConfiguration.addAllowedHeader(&quot;*&quot;); // 允许带凭证 corsConfiguration.setAllowCredentials(true); // 对所有的url生效 UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); return source;&#125; 开启跨域支持 12//允许跨域http.cors().configurationSource(corsConfigurationSource()); 三、SpringSecurity授权3.1 授权简介​ 在第二部分中说明的都是用户认证, 不管是用户名密码,还是图形验证码等,最终的目的都是一个:让系统知道你到底是谁在访问你的系统, 解决的问题是, 你是谁? 这部分主要讲解你能在系统中做什么事情, 针对这个有的叫做: 授权, 有的叫做:鉴权, 还有叫权限控制. 最终的目的就是你能在系统中能过做什么? 3.1.1 SpringSecurity对授权的定义 安全控制问题其实就是控制是否能访问url 3.1.2 Spring Security授权原理 在我们应用系统里面，如果想要控制用户权限，需要有两部分数据 系统配置信息数据：记录系统里面有哪些URL，每个URL需要怎样的权限 用户权限信息：请求用户拥有的权限。 系统用户发送一个请求：系统配置信息和用户权限信息作对比，如果对比成功则允许访问。 当一个系统授权规则比较简单基本不变的时候，系统的权限配置可以写到我们的代码当中去。比如前台门户网站等权限比较单一，可以使用简单的授权配置即可完成，如果权限复杂比如办公OA，电商后台管理系统等就不能写在代码里面了。需要设计RBAC权限模型设计。 3.2 SpringSecurity授权3.2.1 内置权限表达式Spring Security 使用Spring EL来支持，主要用于Web访问和方法安全上, 可以通过表达式来判断是否具有访问权限. 下面是Spring Security常用的内置表达式. ExpressionUrlAuthorizationConfigurer定义了所有的表达式 表达式 说明 permitAll 任何人都允许访问 denyAll 任何人都不允许访问 anonymous 匿名用户允许访问 rememberMe 记住我的用户可以访问 authenticated 指定任何经过身份验证的用户都允许访问，不包括anonymous fullyAuthenticated 指定由经过身份验证的用户允许访问,不包含anonymous和rememberMe hasRole(role) 指定需要特定的角色的用户允许访问, 会自动在角色前面插入’ROLE_’ hasAnyRole([role1,role2]) 指定需要任意一个的角色的用户允许访问, 会自动在角色前面插入’ROLE_’ hasAuthority(authority) 需要有特定的权限允许访问 hasAnyAuthority([authority,authority]) 需要有其中任意一个的权限允许访问 hasIpAddress(ip) 需要特定的IP地址可以访问 3.2.2 URL安全表达式基于web访问使用表达式保护url请求路径. 设置url访问权限 123456// 设置/user/** 访问需要ADMIN角色http.authorizeRequests().antMatchers(&quot;/user/**&quot;).hasRole(&quot;ADMIN&quot;);// 设置/product/** 访问需要PRODUCT角色和IP地址为127.0.0.1. hasAnyRole(&quot;PRODUCT,ADMIN&quot;)http.authorizeRequests().antMatchers(&quot;/product/**&quot;).access(&quot;hasAnyRole(&#x27;ADMIN,PRODUCT&#x27;) and hasIpAddress(&#x27;127.0.0.1&#x27;)&quot;);// 设置自定义权限不足信息.http.exceptionHandling().accessDeniedHandler(myAuthHandle); 自定义权限不足处理(在之前上面的表格列举过了，实现AccessDeniedHandler重写handle方法即可,在上一步配上自己的实现类即可） 123456@Overridepublic void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123; httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN); httpServletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); httpServletResponse.getWriter().write(&quot;权限不足，请联系管理员!&quot;);&#125; 设置用户对应的角色权限在自定义的UserDetailService当中获取Security用户实体的过程里面给用户去加权限 1234567// 先声明一个权限集合,构造函数必须传值且不能为null,传个空集合即可Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();if (&quot;admin&quot;.equalsIgnoreCase(user.getUsername())) &#123; authorities.add(new SimpleGrantedAuthority(&quot;ROLE_ADMIN&quot;));&#125; else &#123; authorities.add(new SimpleGrantedAuthority(&quot;ROLE_PRODUCT&quot;));&#125; 3.2.3 在web安全表达式中引用自定义Bean授权 自定义授权类 123456789101112131415161718192021222324252627282930@Componentpublic class MyAuthService &#123; /** * 检查用户是否有对应的访问权限 * * @param authentication 登录用户 * @param request 请求对象 * @return */ public boolean check(Authentication authentication, HttpServletRequest request) &#123; User user = (User) authentication.getPrincipal(); // 获取用户所有权限 Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities(); // 获取用户名 String username = user.getUsername(); // 如果用户名为admin,则不需要认证 if (username.equalsIgnoreCase(&quot;admin&quot;)) &#123; return true; &#125; else &#123; // 循环用户的权限, 判断是否有ROLE_ADMIN权限, 有返回true for (GrantedAuthority authority : authorities) &#123; String role = authority.getAuthority(); if (&quot;ROLE_ADMIN&quot;.equals(role)) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 配置类 1234//使用自定义Bean授权http.authorizeRequests() .antMatchers(&quot;/user/**&quot;) .access(&quot;@myAuthService.check(authentication,request)&quot;); 若授权时还需要对路径变量需判断 123456789101112131415/** * 检查用户是否有对应的访问权限 * * @param authentication 登录用户 * @param request 请求对象 * @param id 参数ID * @return */public boolean check(Authentication authentication, HttpServletRequest request, Integer id) &#123; // 举个例子 if (id &gt; 10) &#123; return false; &#125; return true;&#125; 1234//使用自定义Bean授权,并携带路径参数http.authorizeRequests() .antMatchers(&quot;/user/delete/&#123;id&#125;&quot;) .access(&quot;@myAuthorizationService.check(authentication,request,#id)&quot;); 3.2.4 Method安全表达式向上面那样配的话，不同的接口不同的权限那么就要在http.authorizeRequests配置很多比较复杂，spring security提供了4种注解分别是@PreAuthorize @PostAuthorize @PreFilter @PostFilter 开启方法级别的注解配置 在security配置类中添加注解 123@EnableGlobalMethodSecurity(prePostEnabled = true)//开启注解支持@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; 在方法上使用注解使用这样的方式就比上面少了secuirty配置类当中的配置和自定义的授权类 ProAuthorize 注解适合进入方法前进行权限验证 123456789101112131415@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)@RequestMapping(&quot;/findAll&quot;)public String findAll(Model model) &#123; List&lt;UserVo&gt; userList = userService.list(); model.addAttribute(&quot;userList&quot;, userList); return &quot;user_list&quot;;&#125;@PreAuthorize(&quot;#id &lt; 10&quot;)@RequestMapping(&quot;/update/&#123;id&#125;&quot;)public String update(@PathVariable Integer id, Model model) &#123; UserVo user = userService.getById(id); model.addAttribute(&quot;user&quot;, user); return &quot;user_update&quot;;&#125; @PostAuthorize: 在方法执行后在进行权限验证，适合验证带有返回值的权限，Spring EL提供返回对象能够在表达式语言中获取到返回对象returnObject 12345678910111213@PostAuthorize(&quot;returnObject.username==authentication.principal.username&quot;)@GetMapping(&quot;/&#123;id&#125;&quot;)@ResponseBodypublic UserVo getById(@PathVariable Integer id) &#123; //获取认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 判断认证信息是否来源于RememberMe if (RememberMeAuthenticationToken.class.isAssignableFrom(authentication.getClass())) &#123; throw new RememberMeAuthenticationException(&quot;认证信息来源于 RememberMe,请重新登录&quot;); &#125; UserVo user = userService.getById(id); return user;&#125; @PreFilter: 可以用来对集合类型的参数进行过滤，将不符合条件的元素剔除集合 123456789// 过滤出偶数的，也就是剔除奇数的@PreFilter(filterTarget = &quot;ids&quot;,value = &quot;filterObject%2==0&quot;)@GetMapping(&quot;/delByIds&quot;)public String delByIds(@RequestParam(value = &quot;id&quot;) List&lt;Integer&gt; ids) &#123; for (Integer id : ids) &#123; System.out.println(id); &#125; return &quot;redirect:/user/findAll&quot;;&#125; @PostFilter: 可以用来对集合类型的返回值进行过滤，将不符合的元素剔除集合 12345678// 返回列表元素ID为偶数的保留@PostFilter(&quot;filterObject.id%2 == 0&quot;)@RequestMapping(&quot;/findAllTOJson&quot;)@ResponseBodypublic List&lt;UserVo&gt; findAllTOJson() &#123; List&lt;UserVo&gt; userList = userService.list(); return userList;&#125; 3.3 基于数据库的RBAC数据模型​ 回顾上面内容，第一在自定义产生secuirty用户的地方，我们去给用户添加权限写死或者在数据库查出来放进去。第二在用户访问资源时权限的校验通过配置资源URL加自定义授权器进行判断或者直接在资源上使用注解让security去判断用户和资源。这样的方式仅仅适合权限少的情况，如果系统权限不是只有一个两个权限就需要设计权限模型了。 ​ 我们开发一个系统，必然面临权限控制的问题，不同的用户具有不同的访问、操作、数据权限。形成理论的权限控制模型有：自主访问控制（DAC: Discretionary Access Control）、强制访问控制（MAC: Mandatory Access Control）、基于属性的权限验证（ABAC:Attribute-Based Access Control）等。最常被开发者使用也是相对易用、通用的就是RBAC权限模型（Role-Based Access Control） 3.3.1 RBAC权限模型简介RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。模型中有几个关键的术语： 用户：系统接口及访问的操作者 权限：能够访问某接口或者做某操作的授权资格 角色：具有一类一批权限的总称 RBAC权限模型核心授权逻辑如下： 某用户是什么角色？ 某用户具有什么权限？ 通过角色对应的权限推导出用户权限 3.3.2 RBAC的演化进程 用户与权限直接关联 想到权限控制，人们最先想到的一定是用户与权限直接关联的模式，简单地说就是：某个用户具有某些权限。如图： 张三具有所有权限它可能是一个超级管理员 李四,王五 具有添加商品和审核商品的权限有可能是一个普通业务员 这种模型能够清晰的表达用户与权限之间的关系，足够简单。但同时也存在问题： 现在用户是张三、李四，王五以后随着人员增加，每一个用户都需要重新授权 操作人员的他的权限发生变更后,需要对每个一个用户重新授予新的权限 用户角色关联 这样只需要维护角色和权限之间的关系就可以了. 如果业务员的权限发生变更, 只需要变动业务员角色和权限之前的关系进行维护就可以了. 用户和权限就分离开来了. 如下图 3.3.3 基于RBAC设计权限表结构 一个用户有一个或多个角色 一个角色可以被多个用户拥有 一个角色有多种权限 一个权限属于多个角色 3.3.4 基于Spring Security实现RBAC权限管理 动态查询数据库中用户应用的权限 123456789/** * 根据用户ID查询权限 * * @param id * @return */@Select(&quot;SELECT p.* FROM t_permission p,t_role_permission rp,t_role r,t_user_role ur,t_user u &quot; + &quot;WHERE p.id = rp.PID AND rp.RID = r.id AND r.id = ur.RID AND ur.UID = u.id AND u.id =#&#123;id&#125;&quot;)List&lt;Permission&gt; findByUserId(Integer id); 给登录用户授权 12345678// 先声明一个权限集合, 因为构造方法里面不能传入nullCollection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();// 查询用户对应所有权限List&lt;Permission&gt; permissions = permissionService.findByUserId(user.getId());for (Permission permission : permissions) &#123; // 授权 authorities.add(new SimpleGrantedAuthority(permission.getPermissionTag()));&#125; 设置访问权限 12345678// 查询数据库所有权限列表List&lt;Permission&gt; permissions = permissionService.list();for (Permission permission : permissions) &#123; //添加请求权限 http.authorizeRequests().antMatchers(permission.getPermissionUrl()).hasAuthority(permission.getPermissionTag());&#125;// 设置自定义权限不足信息.http.exceptionHandling().accessDeniedHandler(myAuthHandle); 这样就完成了动态的权限管理，第一部分在产生Security用户实体的service当中进行关联查询给当前用户填入权限。第二部分配置各资源权限：从数据库获取权限信息并配置资源path与对应权限。 总而言之如果是简单的认证限制就可以之前想之前一样简单写死配置在SecurityConfiguration或者配置在各个方法。否则就可以使用当前的设计进行权限管理。 3.4 基于页面标签的权限控制​ 简单记下吧，也不常用了 ​ 在jsp页面或者thymeleaf模板页面中我们可以使用spring security提供的权限标签来进行权限控制.要想使用thymeleaf为SpringSecurity提供的标签属性，首先需要引入thymeleaf-extras-springsecurity依赖支持。 在pom 文件中的引入springsecurity的标签依赖thymeleaf-extras-springsecurity5 123456&lt;!--添加thymeleaf为SpringSecurity提供的标签 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在html文件里面声明使用 12&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt; 3.4.1 常用SpringSecurity的标签属性介绍 判断用户是否已经登陆认证，引号内的参数必须是isAuthenticated()，sec:authorize&#x3D;”isAuthenticated()” 获得当前用户的用户名，引号内的参数必须是name，sec:authentication&#x3D;“name” 判断当前用户是否拥有指定的权限。引号内的参数为权限的名称，sec:authorize&#x3D;“hasRole(‘role’)” 3.4.2 SpringSecurity标签的使用1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;leftnav&quot;&gt; &lt;div class=&quot;leftnav-title&quot;&gt; &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; &lt;img src=&quot;images/y.jpg&quot; class=&quot;radius-circle rotate-hover&quot; height=&quot;50&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasAuthority(&#x27;user:findAll&#x27;)&quot;&gt; &lt;h2&gt;&lt;span class=&quot;icon-user&quot;&gt;&lt;/span&gt;系统管理&lt;/h2&gt; &lt;ul style=&quot;display:block&quot;&gt; &lt;li&gt;&lt;a href=&quot;/user/findAll&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caretright&quot;&gt; &lt;!--span--&gt;用户管理&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;toCors()&quot; target=&quot;right&quot;&gt; &lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;跨域测试&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasAuthority(&#x27;product:findAll&#x27;)&quot;&gt; &lt;h2&gt;&lt;span class=&quot;icon-pencil-square-o&quot;&gt;&lt;/span&gt;数据管理&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/product/findAll&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;iconcaret-right&quot;&gt;&lt;/span&gt;商品管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 四、源码分析4.1 过滤器链加载源码4.1.1 过滤器加载流程分析在上面第二部分的时候说springSecurity中主要功能是由过滤器链来完成的, 那么spring boot 是如何加载这个流程的呢? 4.1.2 过滤器链加载流程源码分析 spring boot启动自动配置中会加载spring.factories文件, 在文件中有对应针对Spring Security的过滤器链的配置信息 12# 安全过滤器自动配置org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration SecurityFilterAutoConfiguration类 12345678@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(&#123;SecurityProperties.class&#125;) //Security配置类@ConditionalOnClass(&#123;AbstractSecurityWebApplicationInitializer.class, SessionCreationPolicy.class&#125;)@AutoConfigureAfter(&#123;SecurityAutoConfiguration.class&#125;) //当前类加载完成后 加载SecurityAutofigurationpublic class SecurityFilterAutoConfiguration &#123; ... &#125; 主要两个部分第一加载security配置，当中会有两个东西一个一个是默认用户信息、一个是过滤器链的组建 第二就是随后去加载的SecurityAutoConfiguration，其中导入了web的安全配置WebSecurityEnablerConfiguration.class，如下 SecurityAutoConfiguration类 1234567891011121314@Configuration(proxyBeanMethods = false)@ConditionalOnClass(&#123;DefaultAuthenticationEventPublisher.class&#125;)@EnableConfigurationProperties(&#123;SecurityProperties.class&#125;)@Import(&#123;SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class, SecurityDataConfiguration.class&#125;)//web安全启用配置public class SecurityAutoConfiguration &#123; public SecurityAutoConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean(&#123;AuthenticationEventPublisher.class&#125;) public DefaultAuthenticationEventPublisher authenticationEventPublisher(ApplicationEventPublisher publisher) &#123; return new DefaultAuthenticationEventPublisher(publisher); &#125;&#125; WebSecurityEnablerConfiguration类 123456789@Configuration(proxyBeanMethods = false)@ConditionalOnBean(&#123;WebSecurityConfigurerAdapter.class&#125;)@ConditionalOnMissingBean(name = &#123;&quot;springSecurityFilterChain&quot;&#125;)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableWebSecuritypublic class WebSecurityEnablerConfiguration &#123; public WebSecurityEnablerConfiguration() &#123; &#125;&#125; @EnableWebSecurity注解有两个作用：1: 加载了WebSecurityConfiguration配置类, 配置安全认证策略。2: 加载了AuthenticationConfiguration 配置的认证信息。 WebSecurityConfiguration类 在webSecurityConfiguration当中生成了过滤器链 1234567891011121314151617@Configuration(proxyBeanMethods = false)public class WebSecurityConfiguration implements ImportAware, BeanClassLoaderAware &#123; ... // springSecurity过滤器声明 @Bean(name = &#123;&quot;springSecurityFilterChain&quot;&#125;) public Filter springSecurityFilterChain() throws Exception &#123; boolean hasConfigurers = this.webSecurityConfigurers != null &amp;&amp; !this.webSecurityConfigurers.isEmpty(); if (!hasConfigurers) &#123; WebSecurityConfigurerAdapter adapter = (WebSecurityConfigurerAdapter)this.objectObjectPostProcessor.postProcess(new WebSecurityConfigurerAdapter() &#123; &#125;); this.webSecurity.apply(adapter); &#125; return (Filter)this.webSecurity.build(); &#125; ...&#125; 4.2 认证流程源码4.2.1 认证流程分析​ 在整个过滤器链中, UsernamePasswordAuthenticationFilter是来处理整个用户认证的流程的, 所以下面我们主要针对用户认证来看下源码是如何实现的? 4.2.2 认证流程源码跟踪 UsernamePasswordAuthenticationFilter 1234567891011121314151617181920212223public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; // 1.检查是否是Post请求 if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123; throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod()); &#125; else &#123; // 2.获取用户名密码 String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) &#123; username = &quot;&quot;; &#125; if (password == null) &#123; password = &quot;&quot;; &#125; username = username.trim(); // 3.创建AuthenticationToken，此时是未认证状态 UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); // 4.调用AuthenticationManager进行认证 return this.getAuthenticationManager().authenticate(authRequest); &#125;&#125; UsernamePasswordAuthenticationToken 123456public UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123; super((Collection)null); this.principal = principal; this.credentials = credentials; this.setAuthenticated(false);&#125; AuthenticationManager–&gt;ProviderManager–&gt;AbstractUserDetailsAuthenticationProvider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; &#123; return this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;); &#125;); // 1.获取用户名 String username = this.determineUsername(authentication); // 2.尝试从缓存中提取 boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; // 检索User user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); &#125; ... &#125; try &#123; // 4.认证前检查user状态 this.preAuthenticationChecks.check(user); // 5.附加认证检查状态 this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (AuthenticationException var7) &#123; if (!cacheWasUsed) &#123; throw var7; &#125; cacheWasUsed = false; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; // 6.认证后检查user状态 this.postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (this.forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; // 7.创建认证成功的UsernamePasswordAuthenticationToken并将认证状态设置未true return this.createSuccessAuthentication(principalToReturn, authentication, user);&#125; 其中retrieveUser方法 1234567891011121314protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; this.prepareTimingAttackProtection(); try &#123; // 调用自定义UserDetailsService的loadUserByUsername方法 UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException(&quot;UserDetailsService returned null, which is an interface contract violation&quot;); &#125; else &#123; return loadedUser; &#125; &#125; ...&#125; 其中additionalAuthenticationChecks方法 1234567891011121314protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; if (authentication.getCredentials() == null) &#123; this.logger.debug(&quot;Failed to authenticate since no credentials provided&quot;); throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; else &#123; // 1.获取前端密码 String presentedPassword = authentication.getCredentials().toString(); // 2.与数据库密码进行对比 if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123; this.logger.debug(&quot;Failed to authenticate since password does not match stored value&quot;); throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; &#125;&#125; AbstractAuthenticationProcessingFilter–doFilter方法 1234567891011121314151617181920212223242526private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (!this.requiresAuthentication(request, response)) &#123; chain.doFilter(request, response); &#125; else &#123; try &#123; // 1.调用子类方法 Authentication authenticationResult = this.attemptAuthentication(request, response); if (authenticationResult == null) &#123; return; &#125; // 2.session策略验证 this.sessionStrategy.onAuthentication(authenticationResult, request, response); if (this.continueChainBeforeSuccessfulAuthentication) &#123; chain.doFilter(request, response); &#125; // 3.成功身份验证 this.successfulAuthentication(request, response, chain, authenticationResult); &#125; catch (InternalAuthenticationServiceException var5) &#123; this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, var5); this.unsuccessfulAuthentication(request, response, var5); &#125; catch (AuthenticationException var6) &#123; this.unsuccessfulAuthentication(request, response, var6); &#125; &#125;&#125; successfulAuthentication方法 1234567891011121314151617protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; SecurityContext context = SecurityContextHolder.createEmptyContext(); // 1.将认证的用户放入SecurityContext中 context.setAuthentication(authResult); SecurityContextHolder.setContext(context); this.securityContextRepository.saveContext(context, request, response); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authResult)); &#125; // 检查是不是记住我 this.rememberMeServices.loginSuccess(request, response, authResult); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass())); &#125; // 3.调用自定义的MyAuthHandle的onAuthenticationSuccess方法 this.successHandler.onAuthenticationSuccess(request, response, authResult);&#125; 4.3 记住我流程源码整个过滤器链中，RememberMeAuthenticationFilter是来处理记住我用户认证的流程的, 所以下面我们主要针对记住我看下源码是如何实现的? 4.3.1 记住我流程分析 4.3.2 记住我流程源码跟踪 AbstractAuthenticationProcessingFilter –》 successfulAuthentication方法 1234567891011121314151617protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; SecurityContext context = SecurityContextHolder.createEmptyContext(); // 1.将认证的用户放入SecurityContext中 context.setAuthentication(authResult); SecurityContextHolder.setContext(context); this.securityContextRepository.saveContext(context, request, response); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authResult)); &#125; // 检查是不是记住我 this.rememberMeServices.loginSuccess(request, response, authResult); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass())); &#125; // 3.调用自定义的MyAuthHandle的onAuthenticationSuccess方法 this.successHandler.onAuthenticationSuccess(request, response, authResult);&#125; loginSuccess方法 —》onLoginSuccess 1234567891011121314151617protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) &#123; // 1.获取用户名 String username = successfulAuthentication.getName(); this.logger.debug(LogMessage.format(&quot;Creating new persistent login for user %s&quot;, username)); // 2.创建persistenToken PersistentRememberMeToken persistentToken = new PersistentRememberMeToken(username, this.generateSeriesData(), this.generateTokenData(), new Date()); try &#123; // 3.插入数据库 this.tokenRepository.createNewToken(persistentToken); // 4.写入浏览器cookie this.addCookie(persistentToken, request, response); &#125; catch (Exception var7) &#123; this.logger.error(&quot;Failed to save persistent token &quot;, var7); &#125;&#125; RememberMeAuthenticationFilter 1234567891011121314151617181920212223242526private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (SecurityContextHolder.getContext().getAuthentication() != null) &#123; this.logger.debug(LogMessage.of(() -&gt; &#123; return &quot;SecurityContextHolder not populated with remember-me token, as it already contained: &#x27;&quot; + SecurityContextHolder.getContext().getAuthentication() + &quot;&#x27;&quot;; &#125;)); chain.doFilter(request, response); &#125; else &#123; // 1.检查是是否记住我，如果是完成自动登录 Authentication rememberMeAuth = this.rememberMeServices.autoLogin(request, response); if (rememberMeAuth != null) &#123; try &#123; // 2.调用authenticationManager再次认证 rememberMeAuth = this.authenticationManager.authenticate(rememberMeAuth); SecurityContext context = SecurityContextHolder.createEmptyContext(); // 3.将认证的用户在重新放入SecurityContext中 context.setAuthentication(rememberMeAuth); SecurityContextHolder.setContext(context); this.onSuccessfulAuthentication(request, response, rememberMeAuth); ... &#125; ... &#125; // 调用下一个过滤器 chain.doFilter(request, response); &#125;&#125; 其中autoLogin方法 123456789101112131415161718192021222324252627282930public final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) &#123; // 1.获取rememberMeCookie String rememberMeCookie = this.extractRememberMeCookie(request); // 2.检查是否存在 if (rememberMeCookie == null) &#123; return null; &#125; else &#123; this.logger.debug(&quot;Remember-me cookie detected&quot;); if (rememberMeCookie.length() == 0) &#123; this.logger.debug(&quot;Cookie was empty&quot;); this.cancelCookie(request, response); return null; &#125; else &#123; try &#123; // 3.解码Cookie String[] cookieTokens = this.decodeCookie(rememberMeCookie); // 4.根据cookie完成自动登录 UserDetails user = this.processAutoLoginCookie(cookieTokens, request, response); // 5.检查user状态 this.userDetailsChecker.check(user); this.logger.debug(&quot;Remember-me cookie accepted&quot;); // 6. 创建认证成功的RememberMeAuthenticationToken并将认证状态设置为true return this.createSuccessfulAuthentication(request, user); &#125; ... this.cancelCookie(request, response); return null; &#125; &#125;&#125; proccessAutoLoginCookie方法 1234567891011121314151617181920212223242526272829protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) &#123; if (cookieTokens.length != 2) &#123; throw new InvalidCookieException... &#125; else &#123; // 1.获取系列码和token String presentedSeries = cookieTokens[0]; String presentedToken = cookieTokens[1]; // 2.根据token去数据库中查询 PersistentRememberMeToken token = this.tokenRepository.getTokenForSeries(presentedSeries); if (token == null) &#123; ... &#125; else &#123; ... // 3.在创建一个新的token PersistentRememberMeToken newToken = new PersistentRememberMeToken(token.getUsername(), token.getSeries(), this.generateTokenData(), new Date()); try &#123; // 4.修改数据库token信息 this.tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); // 5. 写入浏览器 this.addCookie(newToken, request, response); &#125; catch (Exception var9) &#123; ... &#125; // 6.根据用户名调用UserDetailsService查询UserDetail return this.getUserDetailsService().loadUserByUsername(token.getUsername()); &#125; &#125;&#125; 4.4 CSRF流程源码在整个过滤器链中, CsrfFilter是起到csrf防护的, 所以下面我们主要针对记住我看下源码是如何实现的? CSRF流程分析 3.4.2 CSRF源码流程跟踪 Csrfilter 123456789101112131415161718192021222324252627282930313233343536373839protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; request.setAttribute(HttpServletResponse.class.getName(), response); // 1.取出token CsrfToken csrfToken = this.tokenRepository.loadToken(request); boolean missingToken = csrfToken == null; if (missingToken) &#123; // 2.如果没有token就重新生成token csrfToken = this.tokenRepository.generateToken(request); this.tokenRepository.saveToken(csrfToken, request, response); &#125; // 3.将csrfToken值放入request域中 request.setAttribute(CsrfToken.class.getName(), csrfToken); request.setAttribute(csrfToken.getParameterName(), csrfToken); // 4.匹配请求是否为post请求，否则放行 if (!this.requireCsrfProtectionMatcher.matches(request)) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Did not protect against CSRF since request did not match &quot; + this.requireCsrfProtectionMatcher); &#125; filterChain.doFilter(request, response); &#125; else &#123; String actualToken = request.getHeader(csrfToken.getHeaderName()); if (actualToken == null) &#123; // 5.从request请求参数中取出csrfToken actualToken = request.getParameter(csrfToken.getParameterName()); &#125; // 6.匹配两个token是否相等 if (!equalsConstantTime(csrfToken.getToken(), actualToken)) &#123; this.logger.debug(LogMessage.of(() -&gt; &#123; return &quot;Invalid CSRF token found for &quot; + UrlUtils.buildFullRequestUrl(request); &#125;)); AccessDeniedException exception = !missingToken ? new InvalidCsrfTokenException(csrfToken, actualToken) : new MissingCsrfTokenException(actualToken); this.accessDeniedHandler.handle(request, response, (AccessDeniedException)exception); &#125; else &#123; // 7.如果相等则放行 filterChain.doFilter(request, response); &#125; &#125;&#125; ​ 4.5 授权流程源码在整个过滤器链中，FilterSecurityInterceptor是来处理整个用户授权流程的，也是距离用户API最后一个非常重要的过滤器链，因此下面针对用户授权看下源码是如何实现的？ 4.5.1 授权流程分析 AffirmativeBased (基于肯定) ： 一票通过权 ConsensusBased（基于共识）：赞成票多于反对票则通过，反对多余赞成抛出AccessDeniedException UnanimousBased（基于一致）：一票否决权 4.5.2 授权流程源码跟踪 FilterSecurityInterceptor 1234567891011121314151617181920212223public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; this.invoke(new FilterInvocation(request, response, chain));&#125;/*------------*/public void invoke(FilterInvocation filterInvocation) throws IOException, ServletException &#123; if (this.isApplied(filterInvocation) &amp;&amp; this.observeOncePerRequest) &#123; filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse()); &#125; else &#123; if (filterInvocation.getRequest() != null &amp;&amp; this.observeOncePerRequest) &#123; filterInvocation.getRequest().setAttribute(&quot;__spring_security_filterSecurityInterceptor_filterApplied&quot;, Boolean.TRUE); &#125; // 前置调用 InterceptorStatusToken token = super.beforeInvocation(filterInvocation); try &#123; filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse()); &#125; finally &#123; super.finallyInvocation(token); &#125; // 后置调用 super.afterInvocation(token, (Object)null); &#125;&#125; AbstractSecurityInterceptor的beforeInvocation方法 12345678910111213141516171819202122protected InterceptorStatusToken beforeInvocation(Object object) &#123; Assert.notNull(object, &quot;Object was null&quot;); if (!this.getSecureObjectClass().isAssignableFrom(object.getClass())) &#123; ... &#125; else &#123; // 1.获取security的系统配置权限 Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource().getAttributes(object); if (CollectionUtils.isEmpty(attributes)) &#123; ... &#125; else &#123; ... // 2.获取用户认证信息 Authentication authenticated = this.authenticateIfRequired(); if (this.logger.isTraceEnabled()) &#123; this.logger.trace(LogMessage.format(&quot;Authorizing %s with attributes %s&quot;, object, attributes)); &#125; // 3.调用决策管理器，无权限则抛出accessDeniedException让ExceptionTranslationFilter捕获 this.attemptAuthorization(object, attributes, authenticated); ... &#125; &#125;&#125; attemptAuthoriztion–&gt;AffirmativeBase的decide方法 1234567891011121314151617181920212223public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123; int deny = 0; Iterator var5 = this.getDecisionVoters().iterator(); while(var5.hasNext()) &#123; AccessDecisionVoter voter = (AccessDecisionVoter)var5.next(); int result = voter.vote(authentication, object, configAttributes); // 一票否决 switch(result) &#123; case -1: ++deny; break; case 1: return; &#125; &#125; if (deny &gt; 0) &#123; throw new AccessDeniedException(this.messages.getMessage(&quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;)); &#125; else &#123; this.checkAllowIfAllAbstainDecisions(); &#125;&#125; ExceptionTranslationFilter 1234567891011121314151617181920212223242526private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; try &#123; // 1.调用下一个过滤器即FilterSecurityInterceptor chain.doFilter(request, response); &#125; catch (IOException var7) &#123; throw var7; &#125; catch (Exception var8) &#123; Throwable[] causeChain = this.throwableAnalyzer.determineCauseChain(var8); RuntimeException securityException = (AuthenticationException)this.throwableAnalyzer.getFirstThrowableOfType(AuthenticationException.class, causeChain); // 2.捕获FilterSecurityInterceptor并判断异常类型 if (securityException == null) &#123; securityException = (AccessDeniedException)this.throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain); &#125; if (securityException == null) &#123; this.rethrow(var8); &#125; if (response.isCommitted()) &#123; throw new ServletException(&quot;Unable to handle the Spring Security Exception because the response is already committed.&quot;, var8); &#125; // 3.如果是AccessDeniedException异常则处理Spring Security异常 this.handleSpringSecurityException(request, response, chain, (RuntimeException)securityException); &#125;&#125; handleSpringSecuirtyException方法 1234567891011121314151617181920212223242526272829303132private void handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception) throws IOException, ServletException &#123; if (exception instanceof AuthenticationException) &#123; this.handleAuthenticationException(request, response, chain, (AuthenticationException)exception); &#125; else if (exception instanceof AccessDeniedException) &#123; this.handleAccessDeniedException(request, response, chain, (AccessDeniedException)exception); &#125;&#125;private void handleAuthenticationException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AuthenticationException exception) throws ServletException, IOException &#123; this.logger.trace(&quot;Sending to authentication entry point since authentication failed&quot;, exception); this.sendStartAuthentication(request, response, chain, exception);&#125;private void handleAccessDeniedException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AccessDeniedException exception) throws ServletException, IOException &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); boolean isAnonymous = this.authenticationTrustResolver.isAnonymous(authentication); if (!isAnonymous &amp;&amp; !this.authenticationTrustResolver.isRememberMe(authentication)) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(LogMessage.format(&quot;Sending %s to access denied handler since access is denied&quot;, authentication), exception); &#125; this.accessDeniedHandler.handle(request, response, exception); &#125; else &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(LogMessage.format(&quot;Sending %s to authentication entry point since access is denied&quot;, authentication), exception); &#125; this.sendStartAuthentication(request, response, chain, new InsufficientAuthenticationException(this.messages.getMessage(&quot;ExceptionTranslationFilter.insufficientAuthentication&quot;, &quot;Full authentication is required to access this resource&quot;))); &#125;&#125;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"LeetCode初级算法之其他：268.缺失的数字","slug":"268.缺失的数字","date":"2022-06-20T03:18:18.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2022/06/20/268.缺失的数字/","link":"","permalink":"http://yournotes.cn/2022/06/20/268.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目信息给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 题目地址：https://leetcode.cn/problems/missing-number/ 示例 1： 123输入：nums = [3,0,1]输出：2解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 123输入：nums = [0,1]输出：2解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 123输入：nums = [9,6,4,2,3,5,7,0,1]输出：8解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 123输入：nums = [0]输出：1解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示： 1234n == nums.length1 &lt;= n &lt;= 1040 &lt;= nums[i] &lt;= nnums 中的所有数字都 独一无二 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 题解一也就是有从0到n共n+1个数字: 0 1 2 ... n 给出的数组是它们之间的n个数，缺少一个要找出来。（n个数是无序的） 如果是有序的那么哪个位置的数比前一个位置的数大2，那么说明缺少了一个数字，且数字的值和位置标相等。 如果排序去做很显然多此一举，我们要的只是那个数字，排序的消耗更大走了弯路。这组数字本身是一组连续的数字只是无序的摆放了且缺少一个。 因此我们可以准备一个原来的卡槽（n + 1个位置），将他们一一放进去，最后哪个位置留空那么就缺这个数字 实现当中容器用什么都可以我采用的数组，创建一个n+1的卡槽，初始化里面都是0，因此只需要把有值的改为1，完成后剩下只有一个位置为0，这个位置即是缺失的数字。 12345678910111213public int missingNumber(int[] nums) &#123; byte[] arr = new byte[nums.length + 1]; for(int i = 0; i &lt; nums.length; i++)&#123; int num = nums[i]; arr[num] = 1; &#125; for(int i = 0; i &lt; arr.length; i++)&#123; if(arr[i] == 0)&#123; return i; &#125; &#125; return -1;&#125; 因为我们的数组只存0&#x2F;1，节约空间所以使用byte类型（因为Java里面没有更小的类型了)，又想到可以用一个数字的每一位来存0&#x2F;1就不需要数组了。但最大的long也只有64位，题目当中的n最大是104.需要105个位置。 当前题解空间复杂度达到了n.满足不了进阶的要求。 题解二什么方法可以在当前给出的数组内部直接得到缺失谁呢。 一段连续的数字堆在一起，只少一个…连续的数字？ 求和…对就是求和，0到n的数字的和减去当前数组所有元素的和，差是多少就是多出来的数字。 12// 0到n数字的和(1+n) * n / 2 代码： 123456789public int missingNumber(int[] nums) &#123; int len = nums.length; int expect = (1 + len) * len / 2; for(int i = 0; i &lt; len; i++)&#123; // 减去每个数字 expect -= nums[i]; &#125; return expect;&#125; 题解三虽然解出了觉得比较满意的答案，但确实有预感是有更好的解法，从0到n连续的数字索引就是它们的值没必要额外去存储记录什么，可能性潜藏的已知条件太多了很有可能没有用上。 缺少一个数字的数组和原来的完整的n + 1的数字。合在一起就是一堆数字每个都是一对且只有一个落单，这么一堆数字进行累计异或最终双双相消就可以得到唯一的数字。 我们不需要额外的去创建一个这样的合成数组，因为数字和下标一一对应，循环一次0到n即可得到原来的这些数字进行异或，再对提供的数组进行异或即可。 12345678910public int missingNumber(int[] nums) &#123; int res = 0; for (int i = 0; i &lt;= nums.length; i++)&#123; res ^= i; &#125; for (int i : nums) &#123; res ^= i; &#125; return res;&#125; 总结这题是当前合集最后一个分类其他也是最后一题但它的类型偏向与数组，可以回顾数组的一些常规操作比如排序、哈希、原地交换等将原本数组进行整理得到新数组的手段. 异或题解参考了官方解题，想到了自己的曾经的总结异或运算找唯一，却在此题没有自主发现。没有充分的利用已知的数列与参数数组的关系。这和2020年9月21号解的只出现一次的元素异曲同工。 初级合集全部题解到此就完结了，原计划半年到现在两年了才完成，太过于懈怠了。合集过后对数组、链表以及树从生疏到现在确实有了更多的了解再次面对时充满了更多的思路。但数据结构仍有待加强，算法思想需体系学习。因此不会立马开启下一合集的题解系列，第一是有其他方向的内容需要学习和输出，第二是在算法这边开始进行系统的学习输入希望日后可以带来更好的内容。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之其他：20.有效括号","slug":"20.有效括号","date":"2022-05-30T04:48:09.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2022/05/30/20.有效括号/","link":"","permalink":"http://yournotes.cn/2022/05/30/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/valid-parentheses 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]&#123;&#125;&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 示例 4： 12输入：s = &quot;([)]&quot;输出：false 示例 5： 12输入：s = &quot;&#123;[]&#125;&quot;输出：true 题解一要满足括号的规则，那么一个括号里面不能有残缺的括号。 那么对于&#123;[]&#125; 它是一个括号且包含一个子括号，如果当当前括号完整时，子括号仍不完整即为false. 我们可以用包含自己和子节点的结构来去记录，就是一个链表，要必须按照顺序一个一个匹配完成，否则就false 123class Node&#123; Node child;&#125; 遍历到一个左括号，那么就产生了一个node,之后要么产生node作为child要么是消除。直到最后没有node 1234567891011([)]1 #左括号 1 2 #又一个左括号 1 fail #出现右括号但不匹配 &#123;[]&#125;1 #左括号 1 2 #又一个左括号 1 #出现右括号匹配消除success #出现右括号匹配消除，最后一个也消除了 还是画个动图吧 总而言之，如果是左括号就加到列表当中，如果是右括号就要和最头上的一个进行比较，能配上就消除否则false，最后消除完毕一个都不剩则满足true 代码一： 1234567891011121314151617181920212223242526272829303132333435363738class Node&#123; char value; Node next; Node(char value)&#123; this.value = value; &#125;&#125;public boolean isValid(String s) &#123; // 1.括号数据 Map&lt;Character,Integer&gt; left = new HashMap(); left.put(&#x27;(&#x27;,1); left.put(&#x27;[&#x27;,2); left.put(&#x27;&#123;&#x27;,3); Map&lt;Character,Integer&gt; right = new HashMap(); right.put(&#x27;)&#x27;,1); right.put(&#x27;]&#x27;,2); right.put(&#x27;&#125;&#x27;,3); // 2.自定义链表 Node cur = null; // 3.遍历处理 for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); // 如果左括号加节点，右括号看是否能消除 if(left.containsKey(c))&#123; // 入列 Node pre = new Node(c); pre.next = cur; cur = pre; &#125;else if(cur != null &amp;&amp; right.get(c).equals(left.get(cur.value)))&#123; // 消除 cur = cur.next; &#125;else&#123; return false; &#125; &#125; boolean result = cur == null ? true : false; return result;&#125; 这里相当于我们自己去实现了一个数据结构，每次只能拿到头部，当头部消除我们可以拿到头部的前一个（next），通过头插的方式来实现。 当然我们也可以直接用我们语言提供的现有的数据结构的库类，比如JAVA里有栈的实现Stack。思路是一样的，只不过封装好的栈结构我们直接拿来用push、pop等来完成我们的逻辑，不必实现基础的节点加入、消除等操作的具体节点关系的实现。 代码二： 12345678910111213141516171819202122232425public boolean isValid(String s)&#123; // 1.括号数据 Map&lt;Character,Integer&gt; left = new HashMap(); left.put(&#x27;(&#x27;,1); left.put(&#x27;[&#x27;,2); left.put(&#x27;&#123;&#x27;,3); Map&lt;Character,Integer&gt; right = new HashMap(); right.put(&#x27;)&#x27;,1); right.put(&#x27;]&#x27;,2); right.put(&#x27;&#125;&#x27;,3); // 2.栈 Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); // 3.遍历处理 for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); // 判定左括号还是右括号 if(left.containsKey(c))&#123; stack.push(c); &#125;else if(stack.isEmpty() || !right.get(c).equals(left.get(stack.pop())))&#123; return false; &#125; &#125; boolean result = stack.empty() ? true : false; return result;&#125; 代码逻辑都是大差不差，但对于括号的匹配我们是用map存储，且明显感到有冗余。都用值来去匹配感觉自己有点脑瘫了，直接key-value匹配就行少一个获取值的步骤了。 代码三： 1234567891011121314151617181920public boolean isValid(String s)&#123; // 1.括号数据 Map&lt;Character,Character&gt; map = new HashMap(); map.put(&#x27;(&#x27;,&#x27;)&#x27;); map.put(&#x27;[&#x27;,&#x27;]&#x27;); map.put(&#x27;&#123;&#x27;,&#x27;&#125;&#x27;); // 2.栈 Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); // 3.遍历处理 for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); // 判定左括号还是右括号 if(map.containsKey(c))&#123; stack.push(c); &#125;else if(stack.isEmpty() || !map.get(stack.pop()).equals(c))&#123; return false; &#125; &#125; return stack.empty();&#125; 在有限的条件范围，我们要追求更高的效率非要钻这个牛角尖的话，是有固定方式就是手动列举。当然其实没必要，举例下： 代码四： 123456789101112public boolean isValid(String s)&#123; Stack&lt;Character&gt; stack=new Stack&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(c==&#x27;(&#x27;||c==&#x27;[&#x27;||c==&#x27;&#123;&#x27;)&#123; stack.push(c); &#125;else if(stack.isEmpty()||c==&#x27;)&#x27;&amp;&amp;stack.pop()!=&#x27;(&#x27;||c==&#x27;]&#x27;&amp;&amp;stack.pop()!=&#x27;[&#x27;||c==&#x27;&#125;&#x27;&amp;&amp;stack.pop()!=&#x27;&#123;&#x27;)&#123; return false; &#125; &#125; return stack.empty();&#125; 那么有个问题，难道就没有一种方既可以直接比较得出是否是一对（不需要建立映射加扫描的方式），又不是手动去把情况都列出来。 那就是ascii码，好像很有道理，ascii不就是天然的字符映射关系么，我们拿这个映射的值能不能判断呢。 那么去找了一下ascii码，可以得到结论在这六个符号组成的字符串当中，它们之间的差值是1或者2，那么只有是一对括号才能出现。我们之前自己通过map构建映射关系现在其实字符本身就有映射内容且其实可以判断出来 代码五 12345678910111213141516public boolean isValid(String s)&#123; Stack&lt;Character&gt; stack=new Stack&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(c==&#x27;(&#x27;||c==&#x27;[&#x27;||c==&#x27;&#123;&#x27;)&#123; stack.push(c); &#125;else if(stack.empty())&#123; return false; &#125;else if(c-stack.peek()==1 || c-stack.peek()==2)&#123; stack.pop(); &#125;else&#123; return false; &#125; &#125; return stack.empty();&#125; 题解二题解二是在看了官方评论区了解的另一种思路，是从字符串着手的 123456789public boolean isValid(String s) &#123; while(true)&#123; int l=s.length(); s=s.replace(&quot;()&quot;,&quot;&quot;); s=s.replace(&quot;&#123;&#125;&quot;,&quot;&quot;); s=s.replace(&quot;[]&quot;,&quot;&quot;); if(s.length()==l)&#123;return l==0;&#125; &#125;&#125; 它效率可能不高，但确实没想到这个思路。它效率低的问题在于每次需要遍历三次字符串进行匹配替换，确实每次都遍历整个串进行替换完完全全的提高了一个维度变成2次方了相当于是走了弯路属于暴力解法。 总结虽然不难但其实还是有挺多有趣的想法，关于提高效率的定式以及两个字符匹配比较的核心由建立映射转移到天然映射ascii码的，在原有体会的情况下相当于再一次加深了印象抽取出思维方式。此题第一是一个解决过程的思路第二是过程知道了但在细节步骤里面是如何判断匹配这又会引发很多思考，首先想到的是map映射进行匹配两个字符，将没有关系的两个字符关联，但我们自己建立映射确实可以有更多的扩展，但我们有没有考虑字符本身就存在映射，天然的映射能不能为我所用这是专注一点的时候可以考虑到的。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"风吹麦浪","slug":"风吹麦浪","date":"2022-04-20T08:53:18.000Z","updated":"2025-04-17T08:34:52.025Z","comments":true,"path":"2022/04/20/风吹麦浪/","link":"","permalink":"http://yournotes.cn/2022/04/20/%E9%A3%8E%E5%90%B9%E9%BA%A6%E6%B5%AA/","excerpt":"","text":"《风吹麦浪》谱子收藏、全文查看👉","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"Elasticsearch详解","slug":"Lucene&Elasticsearch","date":"2022-03-22T03:58:17.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2022/03/22/Lucene&Elasticsearch/","link":"","permalink":"http://yournotes.cn/2022/03/22/Lucene&Elasticsearch/","excerpt":"","text":"超长警告！！！善用目录！！！ [TOC] 一、什么是全文检索1.1 数据分类我们生活中的数据总体分为两种：结构化数据和非结构化数据。 **结构化数据：**指具有固定格式或有限长度的数据，如数据库，元数据等。 **非结构化数据：**指不定长或无固定格式的数据，如邮件，word 文档等磁盘上的文件 1.2 结构化数据搜索常见的结构化数据也就是数据库中的数据。 在数据库中搜索很容易实现，通常都是使用 sql语句进行查询，而且能很快的得到查询结果 为什么数据库搜索很容易？ 因为数据库中的数据存储是有规律的，有行有列而且数据格式、数据长度都是固定的 1.3 非结构化数据查询方法1.3.1 顺序扫描法（Serial Scanning）用户搜索 → 文件 所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用 windows 的搜索也可以搜索文件内容，只是相当的慢。 1.3.2 全文检索（Full-text Search）用户通过查询索引库 → 生成索引 → 文档 全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方法。这个过程类似于通过字典的目录查字的过程。 将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。 例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。 这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-Text Search) 。虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。 建立索引 检索索引 1.4 如何实现全文索引可以使用 Lucene 实现全文检索。Lucene 是 apache 下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene 的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。 Lucene适用场景： 在应用中为数据库中的数据提供全文检索实现。 开发独立的搜索引擎服务、系统 Lucene的特性： 1）稳定、索引性能高 每小时能够索引150GB以上的数据 对内存的要求小，只需要1MB的堆内存 增量索引和批量索引一样快 索引的大小约为索引文本大小的20%~30% 2）高效、准确、高性能的搜索算法 良好的搜索排序 强大的查询方式支持：短语查询、通配符查询、临近查询、范围查询等 支持字段搜索（如标题、作者、内容） 可根据任意字段排序 支持多个索引查询结果合并 支持更新操作和查询操作同时进行 支持高亮、join、分组结果功能 速度快 可扩展排序模块，内置包含向量空间模型、BM25模型可选 可配置存储引擎 3）跨平台 纯java编写 作为Apache开源许可下的开源项目，你可以在商业或开源项目中使用 Lucene有多种语言实现版（如C，C++、Python等），不仅仅是JAVA Lucene架构： 1.5 全文检索的应用场景对于数据量大、数据结构不固定的数据可采用全文检索方式搜索， 单机软件的搜索：word、markdown 站内搜索：京东、淘宝、拉勾，索引源是数据库 搜索引擎：百度、Google，索引源是爬虫程序抓取的数据 二、Lucence实现全文检索的流程说明2.1 索引和搜索流程图 1、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括： 确定原始内容即要搜索的内容–&gt;采集文档–&gt;创建文档–&gt;分析文档–&gt;索引文档 2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括： 用户通过搜索界面–&gt;创建查询–&gt;执行搜索，从索引库搜索–&gt;渲染搜索结果 2.2 创建索引2.2.1 核心概念Document： 用户提供的源是一条条记录，它们可以是文本文件、字符串或者数据库表的一条记录等等。一条记录经过索引之后，就是以一个Document的形式存储在索引文件中的。用户进行搜索，也是以Document列表的形式返回。 Field： 一个Document可以包含多个信息域，例如一篇文章可以包含“标题”、“正文”、“最后修改时间”等信息域，这些信息域就是通过Field在Document中存储的。 Field有两个属性可选：存储和索引。通过存储属性你可以控制是否对这个Field进行存储；通过索引属性你可以控制是否对该Field进行索引。 如果对标题和正文进行全文搜索，所以我们要把索引属性设置为真，同时我们希望能直接从搜索结果中提取文章标题，所以我们把标题域的存储属性设置为真，但是由于正文域太大了，我们为了缩小索引文件大小，将正文域的存储属性设置为假，当需要时再直接读取文件；我们只是希望能从搜索解果中提取最后修改时间，不需要对它进行搜索，所以我们把最后修改时间域的存储属性设置为真，索引属性设置为假。上面的三个域涵盖了两个属性的三种组合，还有一种全为假的没有用到，事实上Field不允许你那么设置，因为既不存储又不索引的域是没有意义的。 Term： Term是搜索的最小单位，它表示文档的一个词语，Term由两部分组成：它表示的词语和这个词语所出现的Field的名称。 2.2.2 大致步骤以我的博客网站 木瓜煲鸡脚‘blog 的搜索为例，在网站上输入关键字搜索显示的内容不是直接从数据库中来的，而是从索引库中获取的，网站的索引数据需要提前创建的。以下是创建的过程： 第一步：获得原始文档：就是从mysql数据库中通过sql语句查询需要创建索引的数据 第二步：创建文档对象（Document），把查询的内容构建成lucene能识别的Document对象，获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档，文档中包括一个一个的域（Field），这个域对应就是表中的列。 注意：每个 Document 可以有多个 Field，不同的 Document 可以有不同的 Field，同一个Document可以有相同的 Field（域名和域值都相同）。每个文档都有一个唯一的编号，就是文档 id。 第三步：分析文档 将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。 123木瓜煲鸡脚’blogs -》 木瓜 鸡脚 blogs 分好的词会组成索引库中最小的单元：term，一个term由域名和词组成 **第四步：**创建索引 对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到 Document（文档）。 注意：**创建索引是对语汇单元索引**，通过词语找文档，这种索引的结构叫 **倒排索引结构**。倒排索引结构是根据内容（词语）找文档，倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。 2.3 倒排索引倒排索引记录每个词条出现在哪些文档，及在文档中的位置，可以根据词条快速定位到包含这个词条的文档及出现的位置。 文档：索引库中的每一条原始数据，例如一个商品信息、一个职位信息 词条：原始数据按照分词算法进行分词，得到的每一个词 创建倒排索引，分为以下几步： 1）创建文档列表 lucene首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表 2）创建倒排索引列表 对文档中数据进行分词，得到词条（分词后的一个又一个词）。对词条进行编号，以词条创建索引。然后记录下包含该词条的所有文档编号（及其它信息）。 搜索的过程： 当用户输入任意的词条时，首先对用户输入的数据进行分词，得到用户要搜索的所有词条，然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。然后根据这些编号去文档列表中找到文档 2.4 查询条件查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档 第一步：创建用户接口（用户输入关键字的地方） 第二步：创建查询 指定查询的域名和关键字 第三步：执行查询 第四步：渲染结果 （结果内容显示到页面上 关键字需要高亮） 三、Lucence实战3.1 需求说明生成职位信息索引库，从索引库检索数据 基础数据：创建数据库导入job-info.sql https://www.aliyundrive.com/s/wtZQfJYqYHi 3.2 准备开发环境1）引入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;artifactId&gt;ES&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--web模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--测试模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--pojo持久化--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;!--Lucene核心包以及分词包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）application配置 123456789101112131415server: port: 8080spring: application: name: es datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://xxx.xxx.xxx:3306/es?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: 1234mybatis-plus: configuration: map-underscore-to-camel-case: true 3）创建实体类 12345678910111213141516171819202122232425import lombok.Data;import javax.persistence.Id;import javax.persistence.Table;/** * @author hao * @date 2022/3/16 12:01 */@Data@Table(name = &quot;job_info&quot;)public class JobInfo &#123; @Id private long id; private String companyName; private String companyAddr; private String companyInfo; private String jobName; private String jobAddr; private String jobInfo; private long salaryMin; private long salaryMax; private String url; private String time;&#125; 4）创建mapper 1234567891011import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.hao.pojo.JobInfo;import org.apache.ibatis.annotations.Mapper;/** * @author hao * @date 2022/3/16 12:02 */@Mapperpublic interface JobInfoMapper extends BaseMapper&lt;JobInfo&gt; &#123;&#125; 5）创建service 12345678910111213141516@Servicepublic class JobInfoServiceImpl implements JobInfoService &#123; @Autowired JobInfoMapper jobInfoMapper; @Override public JobInfo selectById(Long id) &#123; return jobInfoMapper.selectById(id); &#125; @Override public List&lt;JobInfo&gt; selectAll() &#123; QueryWrapper&lt;JobInfo&gt; query = new QueryWrapper&lt;&gt;(); return jobInfoMapper.selectList(query); &#125;&#125; 6）进行测试 123456789101112@RunWith(SpringRunner.class)@SpringBootTest(classes = EsApplication.class)public class TestApplication &#123; @Autowired JobInfoService jobInfoService; @Test public void test()&#123; List&lt;JobInfo&gt; jobInfos = jobInfoService.selectAll(); System.out.println(jobInfos); &#125;&#125; 3.3 创建索引在单元测试当中，进行Lucene的使用测试 123456789101112131415161718192021222324252627282930@Testpublic void testCreateIndex() throws Exception &#123; // 1、指定索引文件存储的位置 D:\\class\\index Directory directory = FSDirectory.open(new File(&quot;D:\\\\class\\\\index&quot;)); // 2、配置版本和分词器 Analyzer analyzer = new StandardAnalyzer(); //标准分词器 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 3、创建一个用来创建索引的对象 IndexWriter indexWriter = new IndexWriter(directory, config); indexWriter.deleteAll(); //先删除索引 // 4、获取原始数据 List&lt;JobInfo&gt; jobInfoList = jobInfoService.selectAll(); // 有多少的数据就应该构建多少lucene的文档对象document for (JobInfo jobInfo : jobInfoList) &#123; Document document = new Document(); // 域名 值 源数据是否存储 document.add(new LongField(&quot;id&quot;, jobInfo.getId(), Field.Store.YES)); document.add(new TextField(&quot;companyName&quot;, jobInfo.getCompanyName(), Field.Store.YES)); document.add(new TextField(&quot;companyAddr&quot;, jobInfo.getCompanyAddr(), Field.Store.YES)); document.add(new TextField(&quot;jobName&quot;, jobInfo.getJobName(), Field.Store.YES)); document.add(new TextField(&quot;jobAddr&quot;, jobInfo.getJobAddr(), Field.Store.YES)); document.add(new LongField(&quot;salary&quot;, jobInfo.getSalaryMax(), Field.Store.YES)); document.add(new StringField(&quot;url&quot;, jobInfo.getUrl(), Field.Store.YES)); // StringField 不需要分词时使用 举例：url 、电话号码、身份证号 indexWriter.addDocument(document); &#125; // 关闭资源 indexWriter.close();&#125; 生成的索引目录：D:\\class\\index 索引(Index)： 在Lucene中一个索引是放在一个文件夹中的。 如下图，同一文件夹中的所有的文件构成一个Lucene索引。 段(Segment)： 按层次保存了从索引一直到词的包含关系：索引(Index) –&gt; 段(segment) –&gt; 文档(Document) –&gt; 域(Field) –&gt; 词(Term) 也即此索引包含了那些段，每个段包含了那些文档，每个文档包含了那些域，每个域包含了那些词。 一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。 如上图，具有相同前缀文件的属同一个段，图中共一个段 “_0” 。 segments.gen和segments_1是段的元数据文件，也即它们保存了段的属性信息。 Field的特性： Document(文档)是Field(域)的承载体, 一个Document由多个Field组成. Field由名称和值两部分组成,Field的值是要索引的内容,也是要搜索的内容. 是否分词(tokenized) 是: 将Field的值进行分词处理, 分词的目的是为了索引. 如: 商品名称, 商品描述. 这些内容用户会通过输入关键词进行查询, 由于内容多样, 需要进行分词处理建立索引. 否: 不做分词处理. 如: 订单编号, 身份证号, 是一个整体, 分词以后就失去了意义, 故不需要分词. 是否索引 是: 将Field内容进行分词处理后得到的词(或整体Field内容)建立索引, 存储到索引域. 索引的目的是为了搜索. 如: 商品名称, 商品描述需要分词建立索引. 订单编号, 身份证号作为整体建立索引. 只要可能作为用户查询条件的词, 都需要索引. 否: 不索引. 如: 商品图片路径, 不会作为查询条件, 不需要建立索引. 是否存储 是: 将Field值保存到Document中. 如: 商品名称, 商品价格. 凡是将来在搜索结果页面展现给用户的内容,都需要存储. 否: 不存储. 如: 商品描述. 内容多格式大, 不需要直接在搜索结果页面展现, 不做存储. 需要的时候可以从关系数据库取. 常用的Field类型 3.4 查询索引测试查询 123456789101112131415161718192021222324252627@Testpublic void testQueryIndex() throws Exception &#123; // 1、指定索引文件存储的位置 D:\\class\\index Directory directory = FSDirectory.open(new File(&quot;D:\\\\class\\\\index&quot;)); // 2、 创建一个用来加载索引的对象 IndexReader indexReader = DirectoryReader.open(directory); // 3、 创建一个用来查询索引的对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); // 使用term查询：指定查询的域名对应值的关键字 Query query = new TermQuery(new Term(&quot;companyName&quot;, &quot;北京&quot;)); TopDocs topDocs = indexSearcher.search(query, 100); //第二个参数：最多显示多 少条数据 int totalHits = topDocs.totalHits; //查询的总数量 System.out.println(&quot;符合条件的总数:&quot; + totalHits); ScoreDoc[] scoreDocs = topDocs.scoreDocs; //获取命中的文档 存储的是文档的id for (ScoreDoc scoreDoc : scoreDocs) &#123; int docID = scoreDoc.doc; // 根据id查询文档 Document document = indexSearcher.doc(docID); System.out.println(&quot;id:&quot; + document.get(&quot;id&quot;)); System.out.println(&quot;companyName:&quot; + document.get(&quot;companyName&quot;)); System.out.println(&quot;companyAddr:&quot; + document.get(&quot;companyAddr&quot;)); System.out.println(&quot;salary:&quot; + document.get(&quot;salary&quot;)); System.out.println(&quot;url:&quot; + document.get(&quot;url&quot;)); System.out.println(&quot;***********************************************************&quot;); &#125;&#125; 查看结果你会发现，居然没有数据，如果把查询的关键字“北京”那里改为“北”或“京”就可以，原因是因为中文会一个字一个字的分词（索引里面没有“北京”这个词条），显然是不合适的，所以我们需要使用可以合理分词的分词器，其中最有名的IKAnalyzer分词器 3.5 中文分词器的使用1）导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.janeluo&lt;/groupId&gt; &lt;artifactId&gt;ikanalyzer&lt;/artifactId&gt; &lt;version&gt;2012_u6&lt;/version&gt;&lt;/dependency&gt; 2）添加配置文件 3）创建索引时使用IKanalyzer 把原来的索引数据删除，将标准分词器换成IK分词器再重新生产索引文件，再使用关键字“北京”就可以查询到结果了 考虑一个问题：一个大型网站中的索引数据会很庞大的，所以使用lucene这种原生的写代码的方式就不合适了，所以需要借助一个成熟的项目或软件来实现，目前比较有名是solr和elasticSearch，所以接下来我们学习elasticSearch的使用。 四、Elasticsearch介绍与安装Elasticsearch是一个需要安装配置的软件。 ELK技术栈说明 Elastic有一条完整的产品线：Elasticsearch、Logstash、Kibana等，前面说的三个就是大家常说的ELK技术栈（开源实时日志分析平台）。 Logstash 的作用就是一个数据收集器，将各种格式各种渠道的数据通过它收集解析之后格式化输出到Elasticsearch ，最后再由 Kibana 提供的比较友好的 Web 界面进行汇总、分析、搜索。 ELK 内部实际就是个管道结构，数据从 Logstash 到 Elasticsearch 再到 Kibana 做可视化展示。这三个组件各自也可以单独使用，比如 Logstash 不仅可以将数据输出到Elasticsearch ，也可以到数据库、缓存等 4.1 简介4.1.1 ElasticElastic官网：https://www.elastic.co/cn/ Elastic公司有一条完整的产品线：Elasticsearch、Logstash、Kibana等，前面说的三个就是大家常说的ELK技术栈。 4.1.2 ElasticsearchElasticsearch官网：https://www.elastic.co/cn/products/elasticsearch 功能： 分布式的搜索引擎：百度、Google、站内搜索 全文检索：提供模糊搜索等自动度很高的查询方式，并进行相关性排名，高亮等功能 数据分析引擎（分组聚合）：电商网站—一周内手机销量Top10 对海量数据进行近乎实时处理：水平扩展，每秒钟可处理海量事件，同时能够自动管理索引和查询在集群中的分布方式，以实现极其流畅的操作。 如上所述，Elasticsearch具备以下特点： 高速、扩展性、最相关的搜索结果 分布式：节点对外表现对等，每个节点都可以作为入门，加入节点自动负载均衡 JSON：输入输出格式是JSON Restful风格，一切API都遵循Rest原则，容易上手 近实时搜索，数据更新在Elasticsearch中几乎是完全同步的，数据检索近乎实时 安装方便：没有其它依赖，下载后安装很方便，简单修改几个参数就可以搭建集群 支持超大数据：可以扩展到PB级别的结构化和非结构化数据 4.1.3 版本我这边直接用比较新的8.0.0https://www.elastic.co/cn/downloads/past-releases/elasticsearch-8-0-0 4.2 安装和配置为了快速看到效果我们直接在本地window下安装Elasticsearch。环境要求：JDK11及以上版本 1）下载解压 它这个版本还自带了JDK，如果电脑配置JAVA_HOME的环境变量那就使用JAVA_HOME的。如果没配那就使用自带的。如果有JAVA_HOME 也可以再配置个ES_JAVA_HOME（es优先使用）指向自带这个（自带的JDK版本是最适配的） 2）修改配置 修改索引数据和日志数据存储的路径 打开注释 修改索引数据存储路径，以及日志路径 3）进入bin目录启动bat 如果启动的失败的话，很大可能是需要修改虚拟机内存的大小，不过新版本应该不会出现这个问题默认的就可以。-Xms启动时分配的内存越大相对来说快当然也要结合你自身机器的内存情况，-Xmx运行期间最大也只给它分配的空间，实际超过了就会内存溢出 到config中找到jvm.options进行修改 4.3 访问 可以看到绑定了两个端口: 9300：集群节点间通讯接口，接收tcp协议 9200：客户端访问接口，接收Http协议 我们在浏览器中访问：http://127.0.0.1:9200 然后发现一直访问不了localhost:9200，是因为首次启动会开启一些配置。如下是从官网截图，那么我们可以去关掉或者使用https访问。 1received plaintext http traffic on an https channel, closing connection Netty4HttpChannel&#123;localAddress=/[0:0:0:0:0:0:0:1]:9200, remoteAddress=/[0:0:0:0:0:0:0:1]:59093&#125; 第二就是elastic的密码在控制台需要找到，然后发现死活找不到（因为只有第一次才会有）。 访问 https://127.0.0.1:9200 用户名：elastic 密码：ma9Uxd7nRUycKSBxFGbC （控制台上的） 4.4 安装Kibana4.4.1 什么是Kibanahttps://www.elastic.co/cn/kibana/ Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。 而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习Elasticsearch的语法。 4.4.2 安装因为Kibana依赖于node，需要在windows下先安装Node.js。我自己的node版本16.13.0 然后下载kibana，版本和elasticsearch保持一致。我就用8.0.0 https://www.elastic.co/cn/downloads/past-releases#kibana 4.4.3 配置运行进入安装目录下的config目录，配置kibana.yml 当中的 elasticsearch.hosts 为自己的elasticsearch服务地址 在安装目录bin下，使用kibana.bat启动。 4.4.4 控制台控制台可见默认端口是5601 去访问看看 http://localhost:5601 访问进去之后，它是要进行一个与elasticsearch的认证的配置，要输入token，也就是首次启动elasticsearch终端生成的 填入token确定之后，弹出个验证码。这时这个验证码会在kibana的控制台显示输出，也可以向上面提示的使用 kibana-verification-code.bat获取 我这边有个是token失效了，所以就通过手动配置登录 需要先通过elasticsearch生成一个kibnana_system的密码 1bin/elasticsearch-reset-password -u kibana_system 可以将这个密码配置到，kibana当中 填入密码之后就可以配置通过了，然后正式进入到了登录界面，终于可以使用管理员elastic用户进行登录了。 这时也可以把elastic的密码改掉了 现在这个版本确实和以前界面差距挺大 4.5 安装ik分词器Lucene的IK分词器早在2012年已经没有维护了，现在我们要使用的是在其基础上维护升级的版本，并且开发为Elasticsearch的集成插件了，与Elasticsearch一起维护升级，版本也保持一致，所以我这里下载8.0.0的 https://github.com/medcl/elasticsearch-analysis-ik/releases 下载解压到elasticsearch的plugs当中并重命名为ik 重新启动elasticsearch即可 测试 先不管这个查询语法，先测试下 在kibana控制台输入下面的请求： 12345GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 运行得到结果如下： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;我&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;是&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;中国人&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;中国&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;国人&quot;, &quot;start_offset&quot; : 3, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 &#125; ]&#125; 上面使用了 ik_max_word，对内容的分词是最大化。再测试下 ik_smart 12345GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 结果： 12345678910111213141516171819202122232425&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;我&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;是&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;中国人&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125; ]&#125; ik_smart模式是一个智能的识别，不会将语义中的词因为恰好其中的字和词前或者后的字也好像能组成词而去生成这个词条 4.6 Head插件4.6.1 elasticsearch-head简介elasticsearch-head是一个界面化的集群操作和管理工具，可以对集群进行傻瓜式操作。你可以通过插件把它集成到es（首选方式）,也可以安装成一个独立webapp。 es-head主要有三个方面的操作： 显示集群的拓扑,并且能够执行索引和节点级别操作 搜索接口能够查询集群中原始json或表格格式的检索数据 能够快速访问并显示集群的状态 官方的文档： https://github.com/mobz/elasticsearch-head 4.6.2 安装这个就不用 多说，谷歌浏览器或者火狐都可以在谷歌插件商店搜索名称安装即可（科学上网） https://chrome.google.com/webstore/category/extensions 界面如下 总之和kibana一样都是作为Elasticsearch的控制面板，不过这个可以更方便的查看集群状态。 五、使用Kibana对索引库操作5.1 基本概念5.1.1 节点、集群、分片及副本1）节点（node） 一个节点是一个Elasticsearch的实例 在服务器上启动Elasticsearch之后，就拥有了一个节点。如果在另一台服务器上启动Elasticsearch，这就是另一个节点。甚至可以通过启动多个Elasticsearch进程，在同一台服务器上拥有多个节点。 2）集群（cluster） 多个协同工作的Elasticsearch节点的集合被称为集群。 在多节点的集群上，同样的数据可以在多台服务器上传播。这有助于性能。这同样有助于稳定性，如果每个分片至少有一个副本分片，那么任何一个节点宕机后，Elasticsearch依然可以进行服务，返回所有数据。 但是它也有缺点：必须确定节点之间能够足够快速地通信，并且不会产生脑裂效应（集群的2个部分不能彼此交流，都认为对方宕机了）。 3）分片（shard） 索引可能会存储大量数据，这些数据可能超过单个节点的硬件限制。例如，十亿个文档的单个索引占用了1TB的磁盘空间，可能不适合单个节点的磁盘，或者可能太慢而无法单独满足来自单个节点的搜索请求。 为了解决此问题，Elasticsearch提供了将索引细分为多个碎片的功能。创建索引时，只需定义所需的分片数量即可。每个分片本身就是一个功能齐全且独立的“索引”，可以托管在群集中的任何节点上。 分片很重要，主要有两个原因： 它允许您水平分割&#x2F;缩放内容量 它允许您跨碎片（可能在多个节点上）分布和并行化操作，从而提高性能&#x2F;吞吐量 分片如何分布以及其文档如何聚合回到搜索请求中的机制完全由Elasticsearch管理，并且对您作为用户是透明的。 在随时可能发生故障的网络&#x2F;云环境中，非常有用，强烈建议您使用故障转移机制，以防碎片&#x2F;节点因某种原因脱机或消失。为此，Elasticsearch允许您将索引分片的一个或多个副本制作为所谓的副本分片（简称副本）。 4）副本（replica） 分片处理允许用户推送超过单机容量的数据至Elasticsearch集群。副本则解决了访问压力过大时单机无法处理所有请求的问题。 分片可以是主分片，也可以是副本分片，其中副本分片是主分片的完整副本。副本分片用于搜索，或者是在原有的主分片丢失后成为新的主分片。 注意：可以在任何时候改变每个分片的副本分片的数量，因为副本分片总是可以被创建和移除的。这并不适用于索引划分为主分片的数量，在创建索引之前，必须决定主分片的数量。过少的分片将限制可扩展性，但是过多的分片会影响性能。默认设置的5份是一个不错的开始。 5.1.2 文档、类型、索引及映射1）文档（document） Elasticsearch是面向文档的，这意味着索引和搜索数据的最小单位是文档。 在Elasticsearch中文档有几个重要的属性。 它是自我包含的。一篇文档同时包含字段和它们的取值。 它可以是层次的。文档中还包含新的文档，字段还可以包含其他字段和取值。例如，“location”字段可以同时包含“city”和“street“两个字段。 它拥有灵活的结构。文档不依赖于预先定义的模式。并非所有的文档都需要拥有相同的字段，它们不受限于同一个模式。 2）类型（type） 类型是文档的逻辑容器，类似于表格是行的容器。在不同的类型中，最好放入不同结构的文档。例如，可以用一个类型定义聚会时的分组，而另一个类型定义人们参加的活动。 3）索引（index） 索引是映射类型的容器。一个Elasticsearch索引是独立的大量的文档集合。 每个索引存储在磁盘上的同组文件中，索引存储了所有映射类型的字段，还有一些设置。 4）映射（mapping） 所有文档在写入索引前都将被分析，用户可以设置一些参数，决定如何将输入文本分割为词条，哪些词条应该被过滤掉，或哪些附加处理有必要被调用（比如移除HTML标签）。这就是映射扮演的角色：存储分析链所需的所有信息。 Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。 对比关系： 全文检索 关系型数据库 索引库（indices） Database 数据库 类型（type） Table 数据表 文档（document） Row 行 域字段（Field） Columns 列 映射配置（mappings） 每个列的约束（类型、长度） 详细说明： 概念 说明 索引库（indices） indices是index的复数，代表许多索引 索引/类型（type） 类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引（目前 6.X以后的版本只能有一个类型），类似数据库中的表概念。数据库表中有表 结构，也就是表中每个字段的约束信息；索引库的类型中对应表结构的叫做映射(mapping) ，用来定义每个字段的约束。 文档（document） 存入索引库原始的数据。比如每一条商品信息，就是一个文档 域字段（Field） 文档中的属性 映射配置（mappings） 字段的数据类型、属性、是否索引、是否存储等特性 5.2 创建索引5.2.1 语法Elasticsearch采用Rest风格API，因此其API就是一次http请求，你可以用任何工具发起http请求 创建索引的请求格式： 请求方式：PUT 请求路径：&#x2F;索引名 请求参数：json格式 12345&#123; &quot;settings&quot;: &#123; &quot;属性名&quot;: &quot;属性值&quot; &#125; &#125; settings：就是索引库设置，其中可以定义索引库的各种属性，目前我们可以不设置，都走默认。 5.2.3 使用Kibana创建kibana的控制台，可以对http请求进行简化，示例： 相当于是省去了elasticsearch的服务器地址，而且还有语法提示，非常舒服。 5.3 查看索引库 语法 Get请求可以帮我们查看索引信息，格式： 1GET /索引名 5.4 删除索引 语法 1DELETE /索引名 再次查看就找不到了 我们也可以用head插件来发个请求玩下 这个查询索引的接口是GET请求，我们直接用浏览器都可以发送 六、使用Kibana对类型及映射操作有了 索引库 ，等于有了数据库中的 database 。接下来就需要索引库中的 类型 了，也就是数据库中的表 。创建数据库表需要设置字段约束，索引库也一样，在创建索引库的类型时，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做 字段映射(mapping) 注意：Elasticsearch7.x取消了索引type类型的设置，不允许指定类型，默认为_doc，但字段仍然是有的，我们需要设置字段的约束信息，叫做字段映射（mapping） 字段的约束我们在学习Lucene中我们都见到过，包括到不限于： 字段的数据类型 是否要存储 是否要索引 是否分词 分词器是什么 一起来看下创建的语法 6.1 创建字段映射 语法 请求方式依然是PUT 如果版本是6版本，那么如上图，给指定索引创建一个类型，且定义类型当中有哪些字段，字段的约束等等。其实在6版本当中虽然可以指定类型名，但一个索引也只能有一个类型。在7版本之后将这个类型完全取消。即使是古老版本多类型映射字段也是属于索引（因为第二个类型不能创建已经存在的字段），也就是索引相当于表，类型只不过是按列分表而已，完全的不同结构的实体应分别创建索引。 现在我使用的是8版本，没有类型名指定。在创建索引的时候直接指定索引的字段映射即可。goods索引下就是mapping 12345678910111213141516171819PUT /goods&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;good_id&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;good_name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;index&quot;: true, &quot;analyzer&quot;:&quot;ik_max_word&quot; &#125;, &quot;good_img&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125; &#125; &#125;&#125; 已经创建了索引，怎么添加字段呢 上面我们是直接在创建一个索引时指定了字段映射，但如果已经创建了索引，现在要去给已存在的索引添加字段可通过如下接口进行 12345678PUT /goods/_mapping&#123; &quot;properties&quot;: &#123; &quot;price&quot;: &#123; &quot;type&quot;: &quot;float&quot; &#125; &#125;&#125; 6.2 查询映射关系 语法 1GET /索引名/_mapping 如果是6版本及以下版本还可以指定类型名 1GET /索引名/_mapping/类型名 示例 1GET /jasper/_mapping 6.3 映射属性详解6.3.1 typeElasticsearch中支持的数据类型非常丰富： 下面链接为官网的全部类型介绍 https://www.elastic.co/guide/en/elasticsearch/reference/8.0/mapping-types.html 一级分类 二级分类 具体类型 介绍 核心类型 字符串类型 text,keyword 结构化搜索，全文文本搜索、聚合、排序等 整数类型 interger,long,short,byte 字段的长度越短，索引和搜索的效率越高 浮点型 double,float.half_float,scaled_float 布尔型 boolean 日期型 date 范围型 range 二进制类型 binary 该binary类型接受二进制值作为Base64编码的字符串。该字段默认的情况下不存储（store）,并且不可搜索 复合类型 数组类型 array 对象类型 object 用于单个JSON对象 嵌套类型 nested 用于JSON对象数组 地理类型 地理坐标类型 geo_point 经纬度 地理地图 geo_shape 用于多边形等复杂形状 特殊类型 IP类型 ip 用于IPv4和IPv6 地理地图 geo_shape 用于多边形等复杂形状 地理地图 geo_shape 用于多边形等复杂形状 提几个关键的： 字符串类型又分两种： text：使用文本数据类型的字段，它们会被分词，文本字段不用于排序，很少用于聚合，如文章标题、正文。 keyword：关键字数据类型，用于索引结构化内容的字段，不会被分词，必须完整匹配的内容，如邮箱，身份证号。支持聚合 这两种类型都是比较常用的，但有的时候，对于一个字符串字段，我们可能希望他两种都支持，此时，可以利用其多字段特性 123456789101112&quot;properties&quot;:&#123; &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;fields&quot;:&#123; &quot;sort&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125; &#125;, &quot;index&quot;:true &#125;&#125; Numerical：数值类型，分两类 基本数据类型：long、interger、short、byte、double、float、half_float double 双精度64位 float 单精度32位 half_float 半精度16位 浮点数的高精度类型：scaled_float 带有缩放因子的缩放类型浮点数，依靠一个 long 数字类型通过一个固定的( double 类 型)缩放因数进行缩放. 需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。 Date：日期类型 elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。 Array数组类型 进行匹配时，任意一个元素满足，都认为满足 排序时，如果升序则用数组中的最小值来排序，如果降序则用数组中的最大值来排序 Object：对象 6.3.1 indexindex影响字段的索引情况。 true：字段会被索引，则可以用来进行搜索过滤。默认值就是true，只有当某一个字段的index值设置为true时，检索ES才可以作为条件去检索。 false：字段不会被索引，不能用来搜索 index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。 但是有些字段是我们不希望被索引的，比如商品的图片信息（URL），就需要手动设置index为false。 6.3.2 store是否将数据进行额外存储。 在学习lucene时，我们知道如果一个字段的store设置为false，那么在文档列表中就不会有这个字段的值，用户的搜索结果中不会显示出来。 但是在Elasticsearch中，即便store设置为false，也可以搜索到结果。 原因是Elasticsearch在创建文档索引时，会将文档中的原始数据备份，保存到一个叫做 _source 的属性中。而且我们可以通过过滤 _source 来选择哪些要显示，哪些不显示。 而如果设置store为true，就会在 _source 以外额外存储一份数据，多余，因此一般我们都会将store设置为false，事实上，store的默认值就是false。 在某些情况下，这对 store 某个领域可能是有意义的。例如，如果您的文档包含一个 title ，一个date 和一个非常大的 content 字段，则可能只想检索the title 和the date 而不必从一个大 _source字段中提取这些字段： 1234567891011121314151617181920PUT my_index&#123; &quot;mappings&quot;:&#123; &quot;_doc&quot;:&#123; &quot;properties&quot;:&#123; &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;store&quot;:true &#125;, &quot;date&quot;:&#123; &quot;type&quot;:&quot;date&quot;, &quot;store&quot;:true &#125;, &quot;content&quot;:&#123; &quot;type&quot;:&quot;text&quot; &#125; &#125; &#125; &#125;&#125; 6.3.3 boost网站权重:网站权重是指搜索引擎给网站（包括网页）赋予一定的权威值，对网站（含网页）权威的评估评价。一 个网站权重越高，在搜索引擎所占的份量越大，在搜索引擎排名就越好。提高网站权重，不但利于网站（包括网 页）在搜索引擎的排名更靠前，还能提高整站的流量，提高网站信任度。所以提高网站的权重具有相当重要的意 义。 权重即网站在SEO中的重要性，权威性。英文：Page Strength。1、权重不等于排名 2、权重对排名有着 非常大的影响 3、整站权重的提高有利于内页的排名。 权重，新增数据时，可以指定该数据的权重，权重越高，得分越高，排名越靠前。 12345678910111213141516PUT my_index&#123; &quot;mappings&quot;:&#123; &quot;_doc&quot;:&#123; &quot;properties&quot;:&#123; &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;boost&quot;:2 &#125;, &quot;content&quot;:&#123; &quot;type&quot;:&quot;text&quot; &#125; &#125; &#125; &#125;&#125; title 字段上的匹配项的权重是字段上的匹配项的权重的两倍 content ，默认 boost 值为 1.0 。提升仅适用于Term查询（不提升prefix，range和模糊查询）。 七、使用Kibana对文档操作文档，即索引库中某个类型下的数据，会根据规则创建索引，将来用来搜索。可以类比做数据库中的每一行数据。 7.1 新增文档7.1.1 新增并随机生成id通过POST请求，可以向一个已经存在的索引库中添加文档数据。 语法：如果是6版本把_doc换成类型名（在取消了类型的情况下，都是用 _doc 代替相当于默认类型） 1234POST /索引名/_doc&#123; “key&quot;:&quot;value&quot;&#125; 7.2 查看文档根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把刚刚生成数据的id带上。 通过kibana查看数据： 1GET /索引/_doc/文档id _source ：源文档信息，所有的数据都在里面。 _id ：这条文档的唯一标示 自动生成的id,长度为20个字符，URL安全，base64编码，GUID（全局唯一标识符）,分布式系统并行生成时不可能会发生冲突 在实际开发中不建议使用ES生成的ID，太长且为字符串类型，检索时效率低。建议：将数据表中唯一的ID，作为ES的文档ID 7.3 新增文档并自定义id如果我们想要自己新增的时候指定id，可以这么做： 1234POST /索引名/_doc/文档id&#123; ...&#125; 示例： 7.4 修改数据PUT：修改文档 POST：新增文档 把刚才新增的请求方式改为PUT，就是修改了。不过修改必须指定文档id id对应文档存在，则修改 id对应文档不存在，则新增 示例1： 指定文档id 002不存在，则PUT会新增 示例2： 指定的002存在则是修改 7.5 删除数据 语法 1DELETE /索引名/类型名/id值 示例 7.6 智能判断刚刚我们在新增数据时，添加的字段都是提前在类型中定义过的，如果我们添加的字段并没有提前定义过，能够成功吗？ 事实上Elasticsearch非常智能，你不需要给索引库设置任何mapping映射，它也可以根据你输入的数据来判断类型，动态添加数据映射。 测试一下： desc与date都是没有在映射里配置过的 看下现在goods索引的映射情况 添加了两条映射，且连类型都自动识别了。一般会选择同类型中最大的，比如你的字段值是整型，那么自动添加映射时会配置成long类型 当是字符串类型时，ES无法智能判断就会两个类型都设置 123456789&quot;desc&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125;&#125;, 这种智能映射，底层原理是动态模板映射，如果我们想修改这种智能映射的规则，其实只要修改动态模板即可！ 7.7 动态映射模板 1）模板名称，随便起 2）匹配条件，凡是符合条件的未定义字段，都会按照这个规则来映射 3）映射规则，匹配成功后的映射规则 举例，我们可以把所有未映射的string类型数据自动映射为keyword类型： 123456789101112131415PUT /goods/_mapping&#123; &quot;dynamic_templates&quot;:[ &#123; &quot;strings&quot;:&#123; &quot;match_mapping_type&quot;:&quot;string&quot;, &quot;mapping&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;index&quot;:false, &quot;store&quot;:true &#125; &#125; &#125; ]&#125; 如图给goods索引的映射配置了名为strings的动态映射模板，规则是只要是字符串类型，就将其设置为keyword类型且继续额外存储并不需要索引 测试 新增文档产生的新字段，配自动添加映射且和我们设定的一样而不是默认的text与keyword共存 八、查询（重点）8.1 基础查询 基本语法 12345678GET /索引名/_search &#123; &quot;query&quot;:&#123; &quot;查询类型&quot;:&#123; &quot;查询条件&quot;:&quot;查询条件值&quot; &#125; &#125; &#125; 这里的query代表一个查询对象，里面可以有不同的查询属性 查询类型： 例如： match_all ， match ， term ， range 等等 查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解 8.1.1 查询所有（match_all） 示例 123456GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; query：代表查询对象 match_all：代表查询所有 **took：**查询花费时间，单位是毫秒 **time_out：**是否超时 **_shards：**分片信息 **hits：**搜索结果总览对象 **total：**搜索到的总条数 **max_score：**所有结果中文档得分的最高分 **hits：**搜索结果的文档对象数组，每个元素是一条搜索到的文档信息 **_index：**索引库 **_type：**文档类型 **_id：**文档id **_score：**文档得分 **_source：**文档的源数据 文档得分：使用ES时，对于查询出的文档无疑会有文档相似度之别。而理想的排序是和查询条件相关性越高排序越靠前，而这个排序的依据就是_score 8.1.2 匹配查询（match）or关系 match 类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系 12345678GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;good_name&quot;: &quot;小米&quot; &#125; &#125;&#125; 匹配good_name”小米“很显然是可以匹配到之前的两条数据。但不能体系分词匹配最后在or的关系。我们这次匹配小米pro看效果 小米匹配到了两条，pro匹配到了一条。一共三条数据 and关系 某些情况下，我们需要更精确查找：比如在电商平台精确搜索商品时，我们希望这个关系（查询条件切分词之后的关系）变成 and （既要满足你，又要满足我），可以这样做： 1234567891011GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;good_name&quot;: &#123; &quot;query&quot;: &quot;小米pro&quot; , &quot;operator&quot;: &quot;and&quot; &#125; &#125; &#125;&#125; 这样也就是一条文档的good_name字段的值分词后得同时拥有小米以及pro词条才能被检索，当前是没有的 8.1.3 词条匹配（term）term 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些未分词的字符串. 反正一句话，不对搜索词进行分词，就用完整的搜索词匹配索引词条 如果搜索小米就用小米去匹配，预计匹配2条，如果搜索手机小米，就去匹配手机小米这个词条很显然查不到。因为文档的属性值即使包含手机小米但也会变成手机 小米 两个词条。 12345678GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;good_name&quot;: &quot;手机小米&quot; &#125; &#125;&#125; 因此如果我用term查询是不分词的，那么文档的字段内容是分词的就没有意义。所以才说一般用这个查的字段都是不分词的比如数字或者keyword这种字段 8.1.4 布尔组合（bool）bool 把各种其它查询通过 must （与）、 must_not （非）、 should （或）的方式进行组合 12345678910111213141516171819202122GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123;&quot;match&quot;: &#123; &quot;good_name&quot;: &quot;小米&quot; &#125;&#125; ], &quot;must_not&quot;: [ &#123;&quot;match&quot;: &#123; &quot;good_name&quot;: &quot;手机&quot; &#125;&#125; ], &quot;should&quot;: [ &#123;&quot;match&quot;: &#123; &quot;good_name&quot;: &quot;pro&quot; &#125;&#125; ] &#125; &#125;&#125; 匹配到小米的是必须的，匹配手机词条的必须没有，pro 有和没有都可以。最后得到的就是数码小米12而不会有手机小米 8.1.5 范围查询（range）range查询找出那些落在指定区间内的数字或者时间 1234567891011GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;gte&quot;: 4000, &quot;lt&quot;: 5000 &#125; &#125; &#125;&#125; range查询允许的操作符 操作符 说明 gt 大于 gte 大于等于 lt 小于 lte 小于等于 8.1.6 模糊查询（fuzzy）fuzzy查询是term查询的模糊等价，很少直接使用它 它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过1： 12345678GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;fuzzy&quot;: &#123; &quot;good_name&quot;: &quot;小米1&quot; &#125; &#125;&#125; 和term一样不分词查询，也就是查小米1，词条里面没有但最相似的是小米,误差是1可以算，那就是匹配到具有小米的document 8.2 结果过滤默认情况下，elasticsearch在搜索的结果中，会把文档中保存在 _source 的所有字段都返回。 如果我们只想获取其中的部分字段，我们可以添加 _source 的过滤 8.2.1 直接指定字段示例 1234567GET /goods/_search&#123; &quot;_source&quot;: [&quot;good_name&quot;,&quot;price&quot;], &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 8.2.2 指定includes和excludes我们也可以通过 includes：来指定想要显示的字段 excludes：来指定不想要显示的字段 123456789GET /goods/_search&#123; &quot;_source&quot;: &#123; &quot;includes&quot;: [&quot;good_name&quot;] &#125;, &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 8.3 过滤Elasticsearch 使用的查询语言（DSL）拥有一套查询组件，这些组件可以以无限组合的方式进行搭配。这套组件可以在以下两种情况下使用：过滤情况（filtering context）和查询情况（query context）。 如何选择查询与过滤 通常的规则是，使用查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)。 8.3.1 条件查询中进行过滤所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用 filter 方式： 12345678910111213141516171819202122GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123;&quot;match&quot;: &#123; &quot;good_name&quot;: &quot;小米&quot; &#125;&#125; ], &quot;filter&quot;: [ &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;gte&quot;: 4000, &quot;lte&quot;: 5000 &#125; &#125; &#125; ] &#125; &#125;&#125; 8.3.2 无条件查询，直接过滤如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用 constant_score 取代只有filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。 123456789101112GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;constant_score&quot;: &#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;good_name&quot;: &quot;小米&quot; &#125; &#125; &#125; &#125;&#125; 8.4 排序8.4.1 单个字段排序sort 可以让我们按照不同的字段进行排序，并且通过 order 指定排序的方式 123456789GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;price&quot;: &#123; &quot;order&quot;: &quot;asc&quot;&#125; &#125; ]&#125; 8.4.2 多字段排序假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序：（安装先后顺序进行以price排序，在price相同的先后顺序再由 _score决定） 123456789101112GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;good_name&quot;: &quot;小米手机pro&quot; &#125; &#125;, &quot;sort&quot;: [ &#123;&quot;price&quot;: &#123; &quot;order&quot;: &quot;asc&quot; &#125;&#125;, &#123;&quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125; ]&#125; 8.5 分页Elasticsearch中数据都存储在分片中，当执行搜索时每个分片独立搜索后，数据再经过整合返回。那么，如果要实现分页查询该怎么办呢？ elasticsearch的分页与mysql数据库非常相似，都是指定两个值： from：目标数据的偏移值（开始位置），默认from为0 size：每页大小 12345678GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 0, &quot;size&quot;: 2&#125; 8.6 高亮高亮原理： * 服务端搜索数据，得到搜索结果 * 把搜索结果中，搜索关键字都加上约定好的标签 * 前端页面提前写好标签的CSS样式，即可高亮 elasticsearch中实现高亮的语法比较简单： 在使用match查询的同时，在查询外加上一个highlight属性： pre_tags：前置标签 post_tags：后置标签 fields：需要高亮的字段 九、聚合aggregations聚合可以让我们极其方便的实现对数据的统计、分析。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。 9.1 基本概念Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫 桶 ，一个叫度量： 桶（bucket）类似于 group by 桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个 桶 ，例如我们根据国籍对人划分，可以得到 中国桶 、 英国桶 ， 日本桶 ……或者我们按照年龄段对人进行划分：010,1020,2030,3040等。 Elasticsearch中提供的划分桶的方式有很多： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似，需要知道分组的间隔（interval） Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 …. 综上所述，我们发现bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量 度量（metrics） 相当于聚合的结果 分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为 度量 比较常用的一些度量聚合方式 Avg Aggregation：求平均值 Max Aggregation：求最大值 Min Aggregation：求最小值 Percentiles Aggregation：求百分比 Stats Aggregation：同时返回avg、max、min、sum、count等 Sum Aggregation：求和 Top hits Aggregation：求前几 Value Count Aggregation：求总数 … 为了测试聚合，我们先批量导入一些数据 创建索引： 12345678910111213PUT /car &#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;color&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;make&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125; &#125; 注意：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词，必须使用keyword 或 数值类型 。这里我们将color和make这两个文字类型的字段设置为keyword类型，这个类型不会被分词，将来就可以参与聚合 导入数据，这里是采用批处理的API，直接复制到kibana运行即可： 注意：在6版本或者之前 接口是/index/type/_bulk,在我当前版本并不是把类型名换成_doc而是直接取消，要保证奇数行是分隔符偶数行为数据行 1234567891011121314151617POST /car/_bulk&#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 10000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;本田&quot;, &quot;sold&quot; : &quot;2020-10-28&quot; &#125; &#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 20000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;本田&quot;, &quot;sold&quot; : &quot;2020-11-05&quot; &#125; &#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 30000, &quot;color&quot; : &quot;绿&quot;, &quot;make&quot; : &quot;福特&quot;, &quot;sold&quot; : &quot;2020-05-18&quot; &#125; &#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 15000, &quot;color&quot; : &quot;蓝&quot;, &quot;make&quot; : &quot;丰田&quot;, &quot;sold&quot; : &quot;2020-07-02&quot; &#125; &#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 12000, &quot;color&quot; : &quot;绿&quot;, &quot;make&quot; : &quot;丰田&quot;, &quot;sold&quot; : &quot;2020-08-19&quot; &#125; &#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 20000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;本田&quot;, &quot;sold&quot; : &quot;2020-11-05&quot; &#125; &#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 80000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;宝马&quot;, &quot;sold&quot; : &quot;2020-01-01&quot; &#125; &#123; &quot;index&quot;: &#123;&#125;&#125; &#123; &quot;price&quot; : 25000, &quot;color&quot; : &quot;蓝&quot;, &quot;make&quot; : &quot;福特&quot;, &quot;sold&quot; : &quot;2020-02-12&quot; &#125; 9.2 聚合为桶首先，我们按照 汽车的颜色 color来 划分桶 ，按照颜色分桶，最好是使用TermAggregation类型，按照颜色的名称来分桶。 语法 12345678GET /car/_search&#123; &quot;aggs&quot;: &#123; &quot;NAME&quot;: &#123; &quot;AGG_TYPE&quot;: &#123;&#125; &#125; &#125;&#125; 示例 size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率 aggs：声明这是一个聚合查询，是aggregations的缩写 popular_colors：指定的分组结果名称，自定义 terms：聚合的类型，terms匹配 field：划分桶的依赖字段 hits：查询结果为空，因为我们设置了size为0 aggregations：聚合的结果 popular_colors：我们定义的聚合名称 buckets：查找到的桶，每个不同的color字段值都会形成一个桶 key：这个桶对应的color字段的值 doc_count：这个桶中的文档数量 通过聚合的结果我们发现，目前红色的小车比较畅销 9.3 桶类度量前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种颜色汽车的平均价格是多少？ 因此，我们需要告诉Elasticsearch 使用哪个字段 ， 使用何种度量方式 进行运算，这些信息要嵌套在 桶内， 度量 的运算会基于 桶 内的文档进行 现在，我们为刚刚的聚合结果添加 求价格平均值的度量： 123456789101112131415161718GET /car/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;popular_colors&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;color&quot; &#125;, &quot;aggs&quot;: &#123; &quot;avg_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125; &#125; &#125;&#125; **aggs：**我们在上一个aggs(popular_colors)中添加新的aggs。可见度量也是一个聚合 **avg_price：**聚合的名称 **avg：**度量的类型，这里是求平均值 **field：**度量运算的字段 可以看到每个桶中都有自己的 avg_price 字段，这是度量聚合的结果 十、Elasticsearch集群10.1 单点的问题单点的elasticsearch存在哪些可能出现的问题呢？ 单台机器存储容量有限，无法实现高存储 单服务器容易出现单点故障，无法实现高可用 单服务的并发处理能力有限，无法实现高并发 所以，为了应对这些问题，我们需要对elasticsearch搭建集群 10.2 集群的结构10.2.1 数据分片首先，我们面临的第一个问题就是数据量太大，单点存储量有限的问题。 大家觉得应该如何解决？ 没错，我们可以把数据拆分成多份，每一份存储到不同机器节点（node），从而实现减少每个节点数据量的目的。这就是数据的分布式存储，也叫做： 数据分片（Shard） 。 假如只有三个分片，可以将每一个分片放在不同的集群节点，以此实现存储 10.2.2 数据备份数据分片解决了海量数据存储的问题，但是如果出现单点故障，那么分片数据就不再完整，这又该如何解决呢？ 没错，就像大家为了备份手机数据，会额外存储一份到移动硬盘一样。我们可以给每个分片数据进行备份，存储到其它节点，防止数据丢失，这就是数据备份，也叫 数据副本（replica） 。 数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！ 为了在高可用和成本间寻求平衡，我们可以这样做： 首先对数据分片，存储到不同节点 然后对每个分片进行备份，放到对方节点，完成互相备份 这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例： 三个分片0、1、2分别存在三个节点上，第一个节点存的分片0的备份在节点2也存一个。节点2存的分片1的备份在节点3存一份，节点3存的分片2的备份在节点1存一份。 在这个集群中，如果出现单节点故障，并不会导致数据缺失，所以保证了集群的高可用，同时也减少了节点中数据存储量。并且因为是多个节点存储数据，因此用户请求也会分发到不同服务器，并发能力也得到了一定的提升。 10.3 集群搭建集群需要多台机器，我们这里用一台机器来模拟，因此我们需要在一台机器中部署多个elasticsearch节点，每个elasticsearch的端口都必须不一样。 一台机器进行模拟：将我们的ES的安装包复制三份，修改端口号，data和log存放位置的不同。 实际开发中：将每个ES节点放在不同的服务器上。 我们计划集群名称为：lagou-elastic，部署3个elasticsearch节点，分别是： node-01：http端口9201，TCP端口9301 node-02：http端口9202，TCP端口9302 node-03：http端口9203，TCP端口9303 http：表示使用http协议进行访问时使用端口，elasticsearch-head、kibana、postman请求端口号是9200。 tcp：集群间的各个节点进行通讯的端口，默认9300 1）复制三个ES出来 2）修改每个节点配置 三个节点的配置文件几乎一致，除了：node.name、path.data、path.log、http.port、transport.port 123456789cluster.name: MY_SOME_ESnode.name: ES01path.data: C:\\Users\\hao\\MySpace\\utils\\Elasticsearch\\elasticsearch-9201\\datas\\datapath.logs: C:\\Users\\hao\\MySpace\\utils\\Elasticsearch\\elasticsearch-9201\\datas\\lognetwork.host: 0.0.0.0http.port: 9201transport.port: 9301discovery.seed_hosts: [&quot;127.0.0.1:9301&quot;, &quot;127.0.0.1:9302&quot;, &quot;127.0.0.1:9303&quot;]cluster.initial_master_nodes: [&quot;ES01&quot;,&quot;ES02&quot;,&quot;ES03&quot;] 3）启动集群 把三个节点分别启动 使用head插件查看： 10.4 测试集群中创建索引库可以通过head插件界面创建，也可以用上面学习的命令。我们创建一个分片数为3副本为1的索引即可 1234567PUT /hao&#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 3, &quot;number_of_replicas&quot;: 1 &#125; &#125; 通过chrome浏览器的head查看，我们可以查看到分片的存储结构： 可以看到，ES01保存了0分片以及1分片的副本，ES02保存了2分片以及0分片的副本，ES03保存了1分片以及2分片的副本 10.5 集群的工作原理10.5.1 shad与replica机制（1）一个index包含多个shard,也就是一个index存在多个服务器上 （2）每个shard都是一个最小工作单元，承载部分数据，比如有三台服务器,现在有三条数据,这三条数据在三台服务器上各方一条. （3）增减节点时，shard会自动在nodes中负载均衡 （4）primary shard（主分片）和replica shard（副本分片），每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard （5）replica shard是primary shard的副本，负责容错，以及承担读请求负载 （6）primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改 （7）primary shard的默认数量是5，replica默认是1（每个主分片一个副本分片），默认有10个shard，5个primary shard，5个replica shard （8）primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上 10.5.2 集群写入数据 客户端选择一个node发送请求过去，这个node就是coordinating node (协调节点) coordinating node，对document进行路由，将请求转发给对应的node。（根据一定的算法选择对应的节点进行存储） 实际上的node上的primary shard处理请求，将数据保存在本地，然后将数据同步到replica node coordinating node，如果发现primary node和所有的replica node都搞定之后，就会返回请求到客户端 这个路由简单的说就是取模算法,比如说现在有3太服务器,这个时候传过来的id是5,那么5%3&#x3D;2,就放在第2台服务器 10.5.3 ES查询数据查询有个算法叫倒排序:简单的说就是:通过分词把词语出现的id进行记录下来,再查询的时候先去查到哪些id包含这个数据,然后再根据id把数据查出来 查询过程 客户端发送一个请求给coordinate node 协调节点将搜索的请求转发给所有的shard对应的primary shard 或replica shard query phase（查询阶段）：每一个shard 将自己搜索的结果（其实也就是一些唯一标识），返回给协调节点，有协调节点进行数据的合并，排序，分页等操作，产出最后的结果 fetch phase（获取阶段） ，接着由协调节点，根据唯一标识去各个节点进行拉取数据，最终返回给客户端 十一、JAVA客户端十一章节下面所有测试的代码，已上传gihub地址如下： https://github.com/Jasper-zh/Elasticsearch_Client_Test 11.1 客户端介绍在elasticsearch官网中提供了各种语言的客户端：https://www.elastic.co/guide/en/elasticsearch/client/index.html 进去选下其他版本，我是8.0.0 现在的版本是已经不推荐使用 High Level REST Client，而支持 Java_API_Client。我这里就使用Java_API_Client的方式（High Level REST Client市面上也有很多教程了） Java Api Client文档 https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/index.html 11.2 创建Demo工程11.2.1 初始化项目创建一个空白maven工程，安装文档引入依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;co.elastic.clients&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-java&lt;/artifactId&gt; &lt;version&gt;8.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 11.2.2 获取API_Client参照文档配置认证创建API_Client 123456789101112131415161718192021public static ElasticsearchClient getClient()&#123; // 1.创建凭证 CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(&quot;elastic&quot;, &quot;eA95WVi0HZarqp*LwoOa&quot;)); // 2.获取rest客户端，认证也在这部分解决 RestClientBuilder builder = RestClient.builder(new HttpHost(&quot;127.0.0.1&quot;,9201)) .setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() &#123; @Override public HttpAsyncClientBuilder customizeHttpClient( HttpAsyncClientBuilder httpClientBuilder) &#123; return httpClientBuilder .setDefaultCredentialsProvider(credentialsProvider); &#125; &#125;); RestClient restClient = builder.build(); // 3.获取transport客户端 ElasticsearchTransport transport = new RestClientTransport(restClient, new JacksonJsonpMapper()); // 4.获取 api 客户端 ElasticsearchClient client = new ElasticsearchClient(transport); return client;&#125; 11.3 索引操作上面获取到ElasticsearchClient，就可以尝试去创建索引了索引这个东西正常情况是直接在elasticsearch上创建定义好而不是在程序中，所以主要参考上面直接使用elasticsearch语法创建 1client.indices().create(c -&gt; c.index(&quot;user&quot;)); 注意：这里由一个问题就就是ES一直默认是开启的ssl，在上面的学习使用当中一直都是使用https访问，在现在的这个客户端构成当中创建的RestClient是请求时是http因此最终发送请求会出现Connetion is closed 的异常.我这里将xpack.security.http.ssl:关了重新启动了ES head插件查看 成功创建索引，默认的不分片和1个副本。那这是简单的创建索引，当然也可以去创建索引时配置field域与setting设置。就和数据库创建表同时配置字段和其他设置信息。虽然不会一般用程序创建但还是演示记录下。顺便记录下找接口的过程 官方接口文档：https://artifacts.elastic.co/javadoc/co/elastic/clients/elasticsearch-java/8.1.0/index.html 源码地址：https://github.com/elastic/elasticsearch-java/ 通过ElasticsearchClient的Indices实际上是拿到了ElasticsearchIndicesClient ElasticsearchIndicesClient的create方法是有重载两个，也就是传入CreateIndexRequest对象，创建这个对象需使用其构造器进行创建，第二个方法就是通过函数式接口那么我们只用写构造器构造链即可，它的方法里面会传入构造器执行我们的构造链得到CreateIndexRequest再调用之前的create方法。 第二个方法就是为了让第一个方法可以写的更方便提供了函数式接口直接使用lambda表达式 也就是通过构造器CreateIndexRequestBuilder调用index(“user”)创建的CreateIndexRequest 看看构造器是怎么创建的CreateIndexRequest对象 ![carbon20220322 (2)](https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/carbon20220322 (2).png) 就是一个再简化版也是最常用的一种构造器的写法，从这个构造器的代码中也能知道除了指定index名的属性之外还有各种各样的属性包括映射或者设置等等。 在创建时要配置映射，那么就通过mappings方法传入TypeMapping即可. 那么TypeMapping也是通过它的构造器进行构建且提供了函数式接口的方法 构建项中其中这三个是配置字段信息的。包含两个参数其中一个是字段名String类型另一个是这个字段的一些配置是Property类型。 Property它也是一个复杂对象，也提供了构造器。直接使用Property的构造器去创建，且也提供了函数式接口参数，就直接使用lambda去执行构造链即可。 如下示例：创建了一个名为product的索引且有一个“name”的映射字段，字段的属性设置了index(true）是否索引。 1client.indices().create(c -&gt; c.index(&quot;product&quot;).mappings(t -&gt; t.properties(&quot;name&quot;, p -&gt; p.text(text -&gt; text.index(true))))); ![carbon20220322 (3)](https://gitee-imagehost.oss-cn-beijing.aliyuncs.com/image_host/carbon20220322 (3)-16479309196482.png) 这种形式用的少的话写起来会有点绕，实际上就是先索引库名以及映射，然后在映射里面配置typeMappings实际是包含各个property，对于property里面除了字段名称还有字段的配置对象，text设置完index还可以继续设置分词器analyzer…. 除了添加还有删除以及索引其他的配置操作也都可以在官方Java文档中ElasticsearchIndicesClient类找到看就不一一演示了 基本上它提供的接口对象基本上都是完全应用了lambda以及构造器。因为之前写过一篇设计模式当中的构造器，因此代码看的还是比较舒适的，能够get到它的一个代码设计 11.4 文档操作根据上面的一些命名规则这里可以猜测一下它的文档操作可能是由一个叫做ElasticsearchDocsClien，去文档看一下 实际上不是的，就是ElasticsearchClient提供的操作 它这上面有很多，我就把关于添加、删除、获取、更新以及批量列出来演示下。 11.4.1 添加文档先看下添加，使用index方法传入IndexRequest对象，同样使用构造器，且这个方法也提供函数式接口，写一个构造链即可。 那么就看下IndexRequest有哪些属性需要提供，看下构造器提供的属性方法。 没有多少，项上面我们使用Kibana去添加文档就是使用POST请求然后接索引名然后（_doc 类型没有了）还有指定文档id，最后就请求体了也就是实体 对应到这里通过index(String)指定索引 id(String) 指定id。那么document(TDocument) 即作为请求头 1client.index(indexRequestBuild -&gt; indexRequestBuild.index(&quot;product&quot;).id(&quot;001&quot;).document(new Product(&quot;小米12&quot;,4699))); head插件查看，已经成功插入数据 11.4.2 获取文档然后看一下GET的，基本上也是差不多它的使用还是挺统一的。就是两个参数一个是GetRequest对象里面很多参数我们指定索引以及文档id即可，第二就是数据封装Java的class对象. 123GetResponse&lt;Product&gt; response = client.get(getRequestBuild -&gt; getRequestBuild.index(&quot;product&quot;).id(&quot;001&quot;),product.class);System.out.println(response.source()); 11.4.3 修改文档修改文档也是可以使用index方法，它即是添加也是更新，id存在则是更新，我们将刚刚的小米12更新下名称 1client.index(indexRequestBuild -&gt; indexRequestBuild.index(&quot;product&quot;).id(&quot;001&quot;).document(new Product(&quot;小米全新版本 15&quot;,4699))); 成功完成更新 也提供了update方法专为修改操作 对于index()方法而言是它的更新是全量更新，对于update方法它提供了多种更新配置：普通的doc()是提供了部分更新也可以设置docAsUpsert等等。当文档id不存在会抛出异常，不过也可以使用upset()方法就可以更新或添加了。 示例 更新参数Product对象属性name为空 price为2999. 完成更新后name为原来值仅更新price 1client.update(updateRequestBuild -&gt; updateRequestBuild.index(&quot;product&quot;).id(&quot;001&quot;).doc(new Product(2999)), Product.class); 11.4.4 删除文档写了上面几条之后删除操作都估计不用具体看文档即可猜出了 12// 构造器的参数名就不像上面写那么具体了直接用b表示client.delete(b -&gt; b.index(&quot;product&quot;).id(&quot;001&quot;)); 11.4.5 批量操作 对于BulkRequest来说主要就是操作一个哪个索引index(String)，二是请求体哪些内容也就是operations 那么operations里面就是各个BulkOperation，也就是批量里面每个实体的信息是在BulkOperation。那就看看它呗： BulkOperation内部的属性是包含各种增删改对象，而增删改对象里面就是实体。 接下来就试一试 我先准备3条数据，然后完成批量进行5个BulkOperation操作，分为3个添加2个删除1个修改 12345678910111213public static void bulkDoc() throws IOException &#123; ArrayList&lt;BulkOperation&gt; list = new ArrayList&lt;&gt;(); list.add(new BulkOperation.Builder().create(b -&gt; b.id(&quot;004&quot;).document(new Product(&quot;冰箱&quot;, 2999))).build()); list.add(new BulkOperation.Builder().create(b -&gt; b.id(&quot;005&quot;).document(new Product(&quot;电视&quot;, 3299))).build()); list.add(new BulkOperation.Builder().create(b -&gt; b.id(&quot;006&quot;).document(new Product(&quot;投影仪&quot;, 3999))).build()); list.add(new BulkOperation.Builder().delete(b -&gt; b.id(&quot;001&quot;)).build()); list.add(new BulkOperation.Builder().delete(b -&gt; b.id(&quot;002&quot;)).build()); boolean add = list.add(new BulkOperation.Builder().index(b -&gt; b.id(&quot;003&quot;).document(new Product(&quot;佳能M6II&quot;, 6900))).build()); // client执行bulk传入operations对象 EsClientUtil.getClient().bulk(b -&gt; b.index(&quot;product&quot;).operations(list)); // 关闭client EsClientUtil.closeClient();&#125; 添加了004到006、删除了001和002、以及修改了003的name以及price head插件查看：与预期一致 11.5 查询数据client的search方法用来进行查询 主要是构建查询请求对象SearchRequest，看下它的一些构建参数 11.5.1 查询所有match_all对于我们最简单的查询：查询全部 123456GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 需要指定的就是索引，以及查询实体里的query属性 对于这里来说构建SearchRequest对象，index(String)用来指定索引，query用来创建查询实体 我们可以看下query实体构建的属性，以下有非常多，其中就有matchAll 它里面是MatchQuery这些也都可以再去看。对于查询全部来说它里面的MatchQuery就两个属性可以指定一个是查询名称queryName还有个是权重boost 12345678public static void queryAll() throws IOException &#123; SearchResponse&lt;Product&gt; search = EsClientUtil.getClient().search(b -&gt; b.index(&quot;product&quot;).query( q -&gt; q.matchAll(m -&gt; m.queryName(&quot;一个查询&quot;)) ), Product.class); for(Hit&lt;Product&gt; obj : search.hits().hits())&#123; System.out.println(obj.source()); &#125;&#125; 11.5.2 关键词匹配match也是一样给search传入SearchRequest，只是这个对象的Query类型的属性值不一样 Query是具备两个属性一个是 _kind 一个是 _value，构造器的不同构建方法指定Quey查询类型（match、match_all、term等等），而参数对象指定这个查询下的多个配置所以对象包裹。 12345678public static void queryMatch() throws IOException &#123; SearchResponse&lt;Product&gt; search = EsClientUtil.getClient().search(b -&gt; b.index(&quot;product&quot;).query( q -&gt; q.match(m -&gt; m.field(&quot;name&quot;).query(&quot;佳能&quot;)) ), Product.class); for(Hit&lt;Product&gt; obj : search.hits().hits())&#123; System.out.println(obj.source()); &#125;&#125; 11.5.3 Term查询同样也可以尝试使用Term查询不对查询值进行分词 123456789public static void queryTerm() throws IOException &#123; SearchResponse&lt;Product&gt; search = EsClientUtil.getClient().search(b -&gt; b.index(&quot;product&quot;).query( q -&gt; q.term(m -&gt; m.field(&quot;name&quot;).value(&quot;佳能&quot;)) ), Product.class); EsClientUtil.closeClient(); for(Hit&lt;Product&gt; obj : search.hits().hits())&#123; System.out.println(obj.source()); &#125;&#125; 很明显查不到结果，因为文档的词条没有叫佳能的，佳能M6II 默认分词这个两个字会划分成两个词条。 11.5.4 范围查询Range也是一样找到query类，里面有range(xxx)方法进行配置range类型，传参是是一个对象包含比较符号以及值字段等属性内容 123456789public static void queryRange() throws IOException &#123; SearchResponse&lt;Product&gt; search = EsClientUtil.getClient().search(b -&gt; b.index(&quot;product&quot;).query( q -&gt; q.range(m -&gt; m.field(&quot;price&quot;).gte(JsonData.of(3000))) ), Product.class); EsClientUtil.closeClient(); for(Hit&lt;Product&gt; obj : search.hits().hits())&#123; System.out.println(obj.source()); &#125;&#125; 11.5.5 _source过滤一般查询就会返回命中文档的全部字段，如果我们只想要其中指定字段就可以使用_source过滤 在上面使用kibana请求是如下格式： 1234567GET /goods/_search&#123; &quot;_source&quot;: [&quot;name&quot;,&quot;price&quot;], &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 那么猜想这个客户端的设计，应该是给search方法传入的SearchRequest对象，是有多个字段属性。上面我们创建只指定了Query类型属性。 看文档： 那么source的主要内容配置在SourceConfig，查看SourceConfig，最终是配置在SourceFilter 查看SourceFilter，到这个地方我们就可以直接进行配置了也就是之前学的_source的excludes和includes 测试 就给上面的范围查询，加个过滤只查出name字段 123456789101112public static void queryFilter() throws IOException &#123; SearchResponse&lt;Product&gt; search = EsClientUtil.getClient().search( b -&gt; b.index(&quot;product&quot;) .source(s -&gt; s.filter(f -&gt; f.includes(&quot;name&quot;))) .query(q -&gt; q.range(m -&gt; m.field(&quot;price&quot;).gte(JsonData.of(3000))) ), Product.class); EsClientUtil.closeClient(); for(Hit&lt;Product&gt; obj : search.hits().hits())&#123; System.out.println(obj.source()); &#125;&#125; 11.6 排序一样的看下它本来的一个结构 123456789GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;price&quot;: &#123; &quot;order&quot;: &quot;asc&quot;&#125; &#125; ]&#125; 查询实体对象里面，除了query就是sort且sort是一个数组可以配置多个字段排序 看下文档searchRequest下，其中就是与sort() ，且传入的就是一个列表每个项是一个SortOptions对象。那么这个对象肯定应该包含字段名以及排序方式 看下SortOptions的构造，可以知道它的结构完全和上面REST请求例子一样。还分一个（字段）类型的对象里面包含排序方式order 看下面FieldSort的构造，里面就包含field和SortOrder，所以得再看下SortOrder 那么SortOrder就是个枚举，包含降序与升序 测试 价格从低到高 123456789101112public static void querySort() throws IOException &#123; SearchResponse&lt;Product&gt; search = EsClientUtil.getClient().search( b -&gt; b.index(&quot;product&quot;) .sort(s -&gt; s.field(v -&gt; v.field(&quot;price&quot;).order(SortOrder.Asc))) .query(q -&gt; q.matchAll(v -&gt; v.queryName(&quot;&quot;)) ), Product.class); EsClientUtil.closeClient(); for(Hit&lt;Product&gt; obj : search.hits().hits())&#123; System.out.println(obj.source()); &#125;&#125; sort是可以传List的或者多个的，我这里只传了一个 11.7 分页老样子看下原来的请求结构，基本上客户端的对象层级结构也一样。 12345678GET /goods/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 0, &quot;size&quot;: 2&#125; 这个看起来好像层级结构不多from和size直接对应了基本类型，看看Java客户端文档 果然在SearchRequest对象下这两个属性直接传整数型，而是向上面嵌套很多对象。 测试 12345678910111213public static void queryPage() throws IOException &#123; SearchResponse&lt;Product&gt; search = EsClientUtil.getClient().search( b -&gt; b.index(&quot;product&quot;) .from(0) .size(2) .query(q -&gt; q.matchAll(v -&gt; v.queryName(&quot;&quot;)) ), Product.class); EsClientUtil.closeClient(); for(Hit&lt;Product&gt; obj : search.hits().hits())&#123; System.out.println(obj.source()); &#125;&#125; 十二、Spring Data Elasticsearch上面通过了Java客户端的学习，从开始比较模糊到现在基本相对已经熟悉。但在真正使用还是需要进一步封装接下来可以开始学习Spring提供的elasticsearch组件：Spring Data Elasticsearch。 12.1 什么是SpringDataElasticsearchSpring Data Elasticsearch（以后简称SDE）是Spring Data项目下的一个子模块。 Spring Data 的使命是给各种数据访问提供POJO为核心的轻松的数据交互，不管是关系型数据库（如MySQL），还是非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提高开发效率。 Spring Data Elasticsearch的页面：https://spring.io/projects/spring-data-elasticsearch 特征： 支持Spring的基于 @Configuration 的java配置方式，或者XML配置方式 提供了用于操作ES的便捷工具类 ElasticsearchTemplate 。包括实现文档到POJO之间的自动智能映射。 利用Spring的数据转换服务实现的功能丰富的对象映射 基于注解的元数据映射方式，而且可扩展以支持更多不同的数据格式，可以定义JavaBean：类名、属性 根据持久层接口自动生成对应实现方法，无需人工编写基本操作代码（类似mybatis，根据接口自动得到实现）。当然，也支持人工定制查询 目前由于SpringBoot的版本还不支持ES8的版本不支持新的客户端，因此这一部分暂时暂停","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"轻松理解设计模式（结构型）：7、装饰器模式","slug":"轻松理解设计模式（结构型）：7、装饰器模式","date":"2022-03-09T01:54:27.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2022/03/09/轻松理解设计模式（结构型）：7、装饰器模式/","link":"","permalink":"http://yournotes.cn/2022/03/09/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%89%EF%BC%9A7%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 经过汇总的23种设计模式它是总结了面向对象设计当中最有价值的经验。对之前来讲可能是对其中部分设计模式还是相对来说熟悉的但仔细琢磨还是会有些疑问，正好在目前相对来说有更多的业余时间，可以来一次重新学习设计模式！ 本篇内容关于结构型设计模式中的装饰器模式的设计与实现。 定义 装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。——百度百科 在不改变原类文件下，去扩展功能其实大家都知道就是通过继承实现。这里相当于继承之外的另一种方式。百科定义说到扩展是通过用装饰来包裹真实的对象，这好像和前一篇适配器模式是比较相似的. 假设你最初去买碗面，那么通过选择的一个早餐店的获取一份早餐。最初早餐店只有面店只能创建面条后来你发现不行一点都不丰富多彩，你有可能早餐是选包子，或者是选一碗粥，豆饼等等。 扩展功能我们要怎么做就就很清楚了，就是继承。通过子类来对抽象的早餐店进行扩展，就有了如下各式各样的具体早餐店：看这不就解决了，通过子类有各式各样的早餐店，你选择面店你的获得早餐()就是使用的面店的造一碗面()，你选择包子店你的获取早餐实际上就是包子店的造包子()。 有人又说了，大早上吃这么单调，我吃一碗面加一笼包子加各式各样不行不。也就是说还要创建各种组合的店。这肯定不合理。 这样的情况（豆浆油条、胡辣汤、酸辣粉、豆汁儿、肠粉、烤馕、灌汤包、沙茶面、抄手）这排列组合子类数量直接爆炸。 采用继承的方式是直接写死，因为排列组合的情况很多，要在最初写死产生各种子类。你想选任意一个组合都有一个子类（店）的造早餐()能够都提供。 既然这样做子类数量爆炸，那有没有一个方法可以动态的去组合呢。不在一开始写死所有的组合功能的子类。而是可以动态添加上，这样其他的组合都可以在使用时动态获取拼装成最终想要的功能。 那就是组合，通过组合的方式我们也可以实现将对象1放到对象2当中。那么对象2可以在触发对象1的功能的情况下，再加入自己的内容。 我们有1、2、3这三种，那么就可能会有7种需求（1、2、3、1+2、1+3、2+3、1+2+3），如果就这样都实现子类会很多 通过组合进行扩展，1可能扩展2的部分，那么它们都是属于同一接口它们之间可以任意扩展，那么就可以有个基础产品0。1、2、3都可以对原先产品进行包裹扩展，也就是可以给基础0扩展个1得到新产品,因此1、2、3都可以随意选择且还可以继续包装，包装1再包装一个3，即得到了1+3的组合。在使用时灵活加一件或者减一件也就是装饰器如同衣服一样。 实现顶级早餐产品接口，之下具有两个实现一个是基础早餐，一个是对早餐进行装饰的抽象装饰器它和产品组件同属于一个抽象类型下。装饰器下有各种具体装饰器（馄饨、面条、粥） 1234567// 产品顶级接口public interface Breakfast &#123; /** * 造早餐 */ public void createBreakfast();&#125; 1234567// 基础产品public class MustBreakfast implements Breakfast&#123; @Override public void createBreakfast() &#123; System.out.println(&quot;喝一杯水&quot;); &#125;&#125; 1234567// 基础装饰器public abstract class BaseDecorator implements Breakfast&#123; Breakfast breakfast; public BaseDecorator(Breakfast breakfast)&#123; this.breakfast = breakfast; &#125;&#125; 1234567891011public class NoodlesDecorator extends BaseDecorator&#123; public NoodlesDecorator(Breakfast breakfast)&#123; super(breakfast); &#125; @Override public void createBreakfast() &#123; breakfast.createBreakfast(); // 完成原产品功能，之后加上额外功能 System.out.println(&quot;搞碗面条&quot;); &#125;&#125; 12345678910public class CongeeDecorator extends BaseDecorator&#123; public CongeeDecorator(Breakfast breakfast)&#123; super(breakfast); &#125; @Override public void createBreakfast() &#123; breakfast.createBreakfast(); System.out.println(&quot;搞碗粥&quot;); &#125;&#125; 12345678910public class WontonDecorator extends BaseDecorator&#123; public WontonDecorator(Breakfast breakfast)&#123; super(breakfast); &#125; @Override public void createBreakfast() &#123; breakfast.createBreakfast(); System.out.println(&quot;搞碗馄饨&quot;); &#125;&#125; 如此，可以灵活拿到各种扩展早餐 123456789public class Customer &#123; public void getBreakfast() &#123; Breakfast base = new MustBreakfast(); Breakfast a = new NoodlesDecorator(base); Breakfast b = new WontonDecorator(a); // 当前组件创建拿到的是（面条+馄饨）的早餐 b.createBreakfast(); &#125;&#125; 案例在Java I&#x2F;O库的设计当中就很好的使用装饰器这种设计模式，我们知道通过输入输出流可以去可以将源字节数据从一个地方导到另一个地方。那么实际我们需要使用的是有结构的数据比如字符、对象、数组等等。因此IO库的设计当中提供了叫做链接的机制。可以将原始流类的输出作为源再进行流处理得到需要的。原始流处理器都是直接对数做源，而链接流处理器则是在原始流处理器的基础上再做处理，以原始流处理器处理后的数据做源。 上面只列举了几个InputStream的例子，下面三个都同属于InputStream但只有FileInputStream是原始流处理器，在装饰器模式里扮演的角色则是组件下的基础组件，而装饰器和基础组件是同属于一个组件下。ObjectInputStream以及FilterInputStream都属于装饰器。 也就是和上面实现一样它们是内嵌了组件类型（InputStream）进去,可以传入各种基础组件。 FilterInputStream内嵌InputStream且read()方法就是掉原组件方法，等于啥都没干。也就是扮演了基础装饰器的角色，而它的各个子类重写达到对原组件的不同扩展 以下是BufferedInputStream 它对原本不具备缓存功能的InputStream提供了缓存读取，实际上就是通过基础组件的read(byte b[], int off, int len)加以实现。 平时使用FileInputStream从文件读取数据，一次一个字节效率低通过给FileInputStream加上一层BufferedInputStream即得到缓存读取功能的InputStream组件。 总结业务代码使用一个组件功能需要扩展，确实可以在业务代码进行，但耦合性差不满足单一职责原则。因此组件功能要单独封装提供出来，各式各样的功能各种扩展也就需要组件产生各式各样的子类。且很多新功能整个过程其实包含其他已经存在的功能，使用组合代替继承将功能划分最小，将许多不同行为的大类拆成各个基本基础行为的装饰器小类。即可在使用时动态灵活的获得想要的最终组件。妙，一般能够抽出没有先后影响的装饰行为可以适用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"轻松理解设计模式（结构型）：6、适配器模式","slug":"轻松理解设计模式（结构型）：6、适配器模式","date":"2022-03-04T03:13:52.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2022/03/04/轻松理解设计模式（结构型）：6、适配器模式/","link":"","permalink":"http://yournotes.cn/2022/03/04/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%89%EF%BC%9A6%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 经过汇总的23种设计模式它是总结了面向对象设计当中最有价值的经验。对之前来讲可能是对其中部分设计模式还是相对来说熟悉的但仔细琢磨还是会有些疑问，正好在目前相对来说有更多的业余时间，可以来一次重新学习设计模式！ 本篇内容关于结构型设计模式中的适配器模式的设计与实现。 定义 在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。——百度百科 就是说两个东西需要交互连接，或者客户端使用一个产品。但它们两方接口对不上没办法直接使用。这时候需要有一个适配器，让它们建立连接。适配器包裹产品，客户端与适配器进行交互。如下图 type-c与3.5mm的转接器就属于适配器，它可以说是包裹在耳机上，让使用的产品（耳机）提供了type-c的头。也就是让客户端手机可以使用，反过来说也可以。 总之是让客户端想使用的产品但使用不上的产品，通过包裹适配器之后，客户端可以通过适配器使用了原先的产品的功能。 实现先画个类图，结构大概如下： 上图就是一个简单的设计结构，对于客户端Client实际上想使用产品Product的功能，但对接不上。中间通过适配器，让客户端可以对接到适配器提供的方式，而适配器又能和Product打通。 代码： 12345class Product&#123; public void specialReceive()&#123; .... &#125;&#125; 1234567891011121314class Adapter&#123; public void receive();&#125;class Mydapter implements Adapter&#123; private Product product; public Mydapter(Product product)&#123; this.product = product; &#125; public void receive()&#123; // 可能前后有对结果数据进行格式转换，但绝不影响本身内容，只做适配不做增强 this.product.specialReceive(); &#125;&#125; 123456class Client&#123; public void use()&#123; Adapter adapter = new Myadapter(new Adapter()); adapter.receive(); &#125;&#125; 对于适配器来说并没有去增强产品的功能，比如只有type-c口的手机使用3.5mm插头的耳机。通过适配器可以使用上，但使用的就是产品本身的功能，适配器并不做额外的增强。 只是在客户端与产品可能它是属于不同的标准，无法去直接使用，所以需要通用标准的适配器去接收客户端标准的内容，再按产品的标准让其可以处理。 它可以适用在一些老旧的库，现在用新的标准去使用。但这些库的功能没必要重写一个新的库或者修改原有库。那么使用适配器是一个很好的选择。 总结适配器模式总体来说是个比较简单直接的结构型设计模式。它主要处理了，客户端与产品之间交接的部分不适配的问题。客户端通过适配器间接使用目标产品，适配器对与客户端和产品出入交接处进行处理，比如入参协议或者格式不一样。但最保证客户端正常使用产品功能得到产品处理结果，而不做任何对产品业务逻辑的再处理或者增强。对于不适配的两个体系（客户端、产品）加一个中间层。 单一职责原则，将接口或数据转换代码从程序主要业务逻辑中分离，而不是为了调不适配的接口要在客户端业务代码里面编写调整适配代码后再调用，把这些抽到适配器当中。 开闭原则。 只要客户端代码与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加或者修改新类型的适配器，新的适配规则。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"轻松理解设计模式（创建型）：5、原型模式","slug":"轻松理解设计模式（创建型）：5、原型模式","date":"2021-11-11T06:30:07.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/11/11/轻松理解设计模式（创建型）：5、原型模式/","link":"","permalink":"http://yournotes.cn/2021/11/11/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%89%EF%BC%9A5%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 经过汇总的23种设计模式它是总结了面向对象设计当中最有价值的经验。对之前来讲可能是对其中部分设计模式还是相对来说熟悉的但仔细琢磨还是会有些疑问，正好在目前相对来说有更多的业余时间，可以来一次重新学习设计模式！ 本篇内容关于原型模式。包含原型模式的设计与实现。 定义 原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。——维基百科 原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。 我们需要一系列对象，这些对象都是具有相同的特征，且它们都是独立的。就像马里奥里很多蘑菇人，它们是独立的不会踩一个全部都挂掉。但它们是相同特征也就是深拷贝。 避免手动去创建相同内容的对象因为第一复杂繁琐效率不高，第二在外面真不一定能创建一模一样的对象很多属性是私有的且没有公开方法方法。 对于一个马里奥怪物类，我们可以去手动创建蘑菇人对象，也可以创建乌龟对象。但我们再创建一个蘑菇人或者一百个就是通过原型模式的方法。只有定制化创建时去手动设计，之后再需要一模一样的对象就通过原型方法获取。达到定制一个批量复制。 自定义实现先画个结构图 首先是一个抽象接口，第二就是一个具体的原型类，去实现clone方法。具体原型类的实例通过使用clone方法就能产生一个一模一样的新对象 123interface Prototype&#123; Object clone();&#125; 12345678910111213141516class Guaiwu&#123; private String name; private String icon; public Guaiwu(String name,String icon)&#123; this.name = name; this.icon = icon; &#125; public Guaiwu(Guaiwu obj)&#123; this.name = obj.name; this.icon = obj.icon; &#125; @Override public object clone()&#123; return new Guaiwu(this); &#125;&#125; 指定一个对象 1Guaiwu wugui = new Guaiwu(&quot;小乌龟&quot;,&quot;乌龟样子&quot;); 批量复制 1234Guaiwu wugui1 = wugui.clone();Guaiwu wugui2 = wugui.clone();Guaiwu wugui3 = wugui.clone();... 以上呢就是一个简单的原型模式的一个自定义实现。 Object clone方法不过其实在Java当中已经提供了clone方法，它是一个Object的本地方法 也就是说每个对象都已经具备了clone方法，不需要像上面定义抽象标准再在每个具体原型类里面去实现。 12345678class Noodle&#123; String name; String size; public Noodle(String name,String size)&#123; this.name = name; this.size = name; &#125;&#125; 12345678910111213class Client&#123; public static void main(String[] args)&#123; // 指定原型对象 Noodle noodle = new Noodle(&quot;长寿面&quot;,&quot;超大份&quot;); // 批量复制 Noodle n1 = noodle.clone(); Noodle n2 = noodle.clone(); // 比较 System.out.println(n1); System.out.println(noodle == n1); System.out.println(n1 == n2); &#125;&#125; 结构也是符合预期的，确实n1与n2的内容是和noodle一样。且它三个确实是存在三个对象而不是一个。 但这个Object提供的clone对于我们的需要来说其实是存在问题的，它虽然是新建了对象和我们上面自己实现的clone()一样，但新建对象的属性内容是直接赋值过去。也就是说如果属性是一个非基本类型。那么clone出来的对象里的这个属性和原型的对象里的这个属性是指向同一个对象。也就是说它是浅拷贝。 Object的这个clone，其实就是和上面完全自定义写的那个一样，虽然是新建了对象n1,但n1的属性内容只是把noodle的内容挨个的赋值进去。导致非基本类型是引用相同对象而不是新对象。 我们需要的是完完全全的深拷贝 能怎么办，重写实现，针对当前原型类的属性，完善clone逻辑 12345678910111213141516171819202122// 佐料class Spice implements Cloneable&#123; String name; String type; ...&#125;// 面条（原型类）class Noodle implements Cloneable&#123; String name; String size; Spice spice; @Override public Noodle clone()&#123; // 先调用原来的clone，也就是得到属性都是直接复制的新对象 Noode noodle = (Noodle)super.clone(); // 再把spice复制个新对象，设置进去 noodle.spice = this.spice.clone(); return noodle; &#125;&#125; 这样就完成了clone方法对当前Noodle类型对象是完全拷贝，要注意的是访问clone方法是protected因此只能在java.lang访问。因此在外部非子类访问需要重写，且重写必须得实现Cloneable接口，说明如下： 这样写出来就比较复杂，为了进行深拷贝里面有复杂类型的属性，而属性里面可能还牵连很多其他的非基本类型。导致在原型对象类里面不停的嵌套去实现直到将所有属性的值都创建新对象。对于复杂类型复杂的组合依赖关系，上面的clone方法的实现就会复杂很多，要递归到只有基本类型为止，从最底层一个一个对象进行创建 序列化不过还好有序列化，可以利用序列化的方式来达到深拷贝 12345678910111213141516@Overridepublic Object clone() &#123; try&#123; // 写出 ByteArrayOutputStream aos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(aos); oos.writeObject(this); // 读取 ByteArrayInputStream ais = new ByteArrayInputStream(aos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(ais); return ois.readObject(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null;&#125; 最终还是可以一步到位的，里面的嵌套的非基本类型的属性，也都是新对象。使用序列化的方式就避免了手动去递归挖掘所有关联非基本类型的属性，进行新建拷贝内容再赋值的过程。 但怎么说还是得改写所有关联的属性的类以及下面不停嵌套的类，都要去实现序列化接口。只是对于clone方法的重写可以一步到位。 总结相对之前来说这个原型模式思想是比较简单的，它可能会用在需要复用很多对象，且要求保证独立安全。优点在于：第一客户代码可以直接通过模板对象调用clone就能得到新对象，免去对使用类的了解程度的门槛。第二有些情况下就是需要进行复制，在这样的情况下也就比直接创建效率要高。缺点也就是在于类的成员属性的类型的复杂程度，这时候复制的逻辑就比较复杂，或者说需要很注意。但无论怎么说其实都要去修改代码，不符合开闭原则。还得看具体场景吧实际使用的不多。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"LeetCode初级算法之其他：118.杨辉三角","slug":"118杨辉三角","date":"2021-11-10T02:02:11.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2021/11/10/118杨辉三角/","link":"","permalink":"http://yournotes.cn/2021/11/10/118%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/pascals-triangle/ 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 12输入: numRows = 5输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2: 12输入: numRows = 1输出: [[1]] 提示: 1 &lt;&#x3D; numRows &lt;&#x3D; 30 题解依题意知道当前数组的第j个值等于前一个数组的j-1的值加上j位的值，也就是 1arr[i][j] = arr[i-1][j-1] + arr[i-1][j]; 也就是通过双循环，第一层遍历各个数组，第二层遍历当前数组各个元素，中间元素的每个值通过上述公式计算 题解如下： 1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; // 结果集 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //遍历每层数组 for(int i = 0; i &lt; numRows; i++)&#123; // 第一层和第二层的边界情况 if(i == 0) &#123; result.add(Arrays.asList(1)); continue; &#125; if(i == 1) &#123; result.add(Arrays.asList(1,1)); continue; &#125; // 获取上一层数组 List&lt;Integer&gt; pre = result.get(i-1); //数组边界值 int[] cur = new int[i+1]; cur[0] = 1; cur[i] = 1; // 通过上一层数组的左右元素求当前元素 for(int j = 1; j &lt; i; j++)&#123; cur[j] = pre.get(j-1) + pre.get(j); &#125; // 数组转list result.add(Arrays.stream( cur ).boxed().collect(Collectors.toList())); &#125; return result;&#125; 依题意书写而成,边界处理需要优化,时间复杂度n^2是避免不了的。 边界的判断有点重复了。在开局两个判断第一个数组和第二个数组的特殊情况，又在循环中添加了每个数组头尾都是1的设置。一个索引它不属于首尾位置，那么它所属的数组就一定是三排以下. 代码结构调整： 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; // 结果集 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //遍历每层数组 for(int i = 0; i &lt; numRows; i++)&#123; // 定义当前数组 int[] cur = new int[i+1]; // 首位设置1，中间pre计算 for(int j = 0; j &lt;= i; j++)&#123; if(j == 0 || j == i)&#123; cur[j] = 1; continue; &#125; // 获取上一层数组 List&lt;Integer&gt; pre = result.get(i-1); cur[j] = pre.get(j-1) + pre.get(j); &#125; // 数组转list result.add(Arrays.stream( cur ).boxed().collect(Collectors.toList())); &#125; return result;&#125; 总结本题的话难度倒是没有什么，逻辑梳理完实现完，考虑下是否有冗余的情况。可能主要出现在各个算法课程里的前面章节用来熟悉代码实现的。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之其他：190.颠倒二进制位","slug":"LeetCode初级算法之其他：190-颠倒二进制位","date":"2021-10-27T01:59:25.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2021/10/27/LeetCode初级算法之其他：190-颠倒二进制位/","link":"","permalink":"http://yournotes.cn/2021/10/27/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E4%B9%8B%E5%85%B6%E4%BB%96%EF%BC%9A190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/reverse-bits/ 颠倒给定的 32 位无符号整数的二进制位。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 示例 1： 123输入：n = 00000010100101000001111010011100输出：964176192 (00111001011110000010100101000000)解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 123输入：n = 11111111111111111111111111111101输出：3221225471 (10111111111111111111111111111111)解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 提示：输入是一个长度为 32 的二进制字符串 题解一：挨个移位首先嘛肯定是要想出通过某种组合位运算的方式来达到目的，通过位运算是直接操作的这个数字在当前语言的二进制串，否则通过循环模拟二进制串对于Java还要分正负最终还转成数字过程就有点笨重了。 怎么组合位运算达到反转目的呢？草稿纸上试一试 1234567891011// 模拟一个长度为5的二进制串怎么反转10011// 取个位移到最高位10011 &amp; 1 &lt;&lt; 4 = 10000// ...1001 &amp; 1 &lt;&lt; 3 = 1000100 &amp; 1 &lt;&lt; 2 = 010 &amp; 1 &lt;&lt; 1 = 01 &amp; 1 &lt;&lt; 0 = 1result = 10000 | 1000 | 1 = 11001 虽然好像没有一次计算解决问题的方式，但可以通过与运算、位移运算进行取值再移到反转之后的位置，通过循环挨个挨个的反转。最终通过或运算合到一起. 注意是或运算变成搞成求和了 12345678public int reverseBits(int n) &#123; int result = 0; for(int i=31; i &gt;= 0; i--)&#123; result |= n &amp; 1 &lt;&lt; i; n = n &gt;&gt;&gt; 1; &#125; return result;&#125; 这题时间复杂度和空间复杂度就不谈了都是有限的常量,如果二进制串长度假设无限的可以设定为n，时间复杂度就是n，不过这里有优化的余地 1for(int i=31; i &gt;= 0 &amp;&amp; n ！= 0; i--) 。加上n !&#x3D; 0 的条件，固定的32位数字可能实际只有几位，高位之后全都是补0的就没必要管了。 题解二：分治法 分治将大问题递归划分成小问题，通过解决小问题最终解决大问题的思想 将32位二进制串反转，可划分为将前16位反转和将后16位反转然后调换两个16位，其中前后16位怎么反转，也可划分为前8和后8位。…..最终划分到两个数的反转。 问题划分： 解决问题： 动图偷懒一点，主要是表示如下过程： 12345671 2 3 4 5 6 7 8-&gt;21 43 65 87-&gt;4321 8765-&gt;87654321 正常来说需要递归函数传入一组内容，函数进行拆分两组然后分别调用自身之后进行拼接。直到最后传入的是一位数，直接返回。 在这里由于整数的范围二进制串的长度是32，因此不需要去递归探底判断什么时候结束。我们直接知道有5层log2(32) = 5。直接按照从底求解的顺序写5步操作即可 先看第一个目标就是把相邻的两两的数反转。怎么通过整数的位运算让它的值的二进制发生这个变化呢？ 打个草稿： 1234原数：10101101偶位：1 1 1 0奇位： 0 0 1 1希望：01011110 懂了，取到奇位与偶位的两组数其他位补0,两组一个左移一个右移之后进行或运算达到目的 怎么取到奇位和偶位就很简单了，分别和10101010、01010101这种进行与运算自然就把其他位清零把奇偶位保持它们自己。 1210101101 &amp; 10101010 = 10101000101011 &amp; 010101 = 00000101 第一步反转： 1(n &amp; 101010 &gt;&gt; 1) | (n &amp; 010101 &lt;&lt; 1) 后面第二步第三步…都差不多了 12(n &amp; 11001100 &gt;&gt; 2) | (n &amp; 00110011 &lt;&lt; 2)(n &amp; 11110000 &gt;&gt; 4) | (n &amp; 00001111 &lt;&lt; 4) 那对于我们32位的整数来说也是一样了，开始编码： 1234567891011121314151617public class Solution &#123; // 用16进制写得短一点😂 int g1 = 0x55555555; // 01010101010101010101010101010101 int g2 = 0x33333333; // 00110011001100110011001100110011 int g4 = 0x0f0f0f0f; // 00001111000011110000111100001111 int g8 = 0x00ff00ff; // 00000000111111110000000011111111 int g16 = 0x0000ffff; //00000000000000001111111111111111 public int reverseBits(int n) &#123; n = (n &amp; ~g1) &gt;&gt;&gt; 1 | (n &amp; g1) &lt;&lt; 1; n = (n &amp; ~g2) &gt;&gt;&gt; 2 | (n &amp; g2) &lt;&lt; 2; n = (n &amp; ~g4) &gt;&gt;&gt; 4 | (n &amp; g4) &lt;&lt; 4; n = (n &amp; ~g8) &gt;&gt;&gt; 8 | (n &amp; g8) &lt;&lt; 8; n = (n &amp; ~g16) &gt;&gt;&gt; 16 | (n &amp; g16) &lt;&lt; 16; return n; &#125;&#125; 两个解法效率差不多因为范围限制在32,一个计算次数小于等于32一个计算次数是log2(32)&#x3D;5. 总结题解一还是容易就顺下去就写成了，分治法的也是容易想得到，其实我们在写早期关于字符串反转这些的时候大致的思想都用过，挨个移位还有分治。在这里只是细节不一样从直接操作元素到用运算达到相同效果。在分治编码的时候有两个注意点一个是位移运算的优先级是最高的因此在代码前分析的时候(n &amp; 101010 &gt;&gt; 1) | (n &amp; 010101 &lt;&lt; 1)这样写是有问题的应该是(n &amp; 101010) &gt;&gt; 1 | (n &amp; 010101) &lt;&lt; 1 这样才保证先与运算再位移最后进行或运算。第二个就是右位移按照推理逻辑是左边补0，如果写成&gt;&gt;当值为负数时补的是1就不属于推理的思路了。解题感受还不错。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"轻松理解设计模式（创建型）：4、建造者模式","slug":"轻松理解设计模式（创建型）：4、建造者模式","date":"2021-10-27T01:57:55.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/10/27/轻松理解设计模式（创建型）：4、建造者模式/","link":"","permalink":"http://yournotes.cn/2021/10/27/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%89%EF%BC%9A4%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 经过汇总的23种设计模式它是总结了面向对象设计当中最有价值的经验。对之前来讲可能是对其中部分设计模式还是相对来说熟悉的但仔细琢磨还是会有些疑问，正好在目前相对来说有更多的业余时间，可以来一次重新学习设计模式！ 本篇内容关于建造者模式。包含建造者模式的设计、实现以及疑问点。 定义 建造者模式是设计模式的一种，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。——百度百科 一般在去创建一个类的对象，都是直接使用其构造器得到。但对于复杂的产品，里面可能是包含多且复杂的属性。在代码使用这个产品对象进行直接创建就需要了解这个类所有的属性及它的运作流程，才能正常创建出自己想要的。 对于建造者模式就是把产品对象的创建委托给一个叫做建造者的家伙，客户代码就通过建造者获取，也就是定义里的构建与表示分离。 对于一个复杂产品很多内容是客户代码方并不需要了解的，而有些是需要让客户代码指定的。建造者构建这个对象的内容时，有的是默认，有的是通过客户代码传参。 传统建造者下面用鸡公煲作为例子： 这里的客户代码需要的产品对象也就是鸡公煲，客户代码最终通过指挥者获取这个产品对象。客户代码是知道自己需要这个产品也知道其中的一些内容，这些内容由客户代码指定，但对于这个产品还有很多属性或者成分客户代码不想要去学习了解这些都是由建造者完善就好。 最终我们的客户代码通过指挥者的construct()方法指定自己要指定的产品的部分内容，就能得到需要的产品对象。 代码示意： 123456789// 产品类class ChickenPot&#123; private Qz qz; private Dyc dyc; private Td td; private Jzg jzg; //... // getter setter&#125; 1234567891011// 抽象建造者 （接口或抽象类）interface AbstractBuilder&#123; // 指定各个部分 void qz(Qz qz); void dyc(Dyc dyc); void td(Td td); void jzg(Jzg jzg); //... // 组装成品 ChickenPot build();&#125; 1234567891011121314151617181920212223242526272829// 具体建造者class Builder implements AbstractBuilder&#123; private Qz qz; private Dyc dyc; private Td td; private Jzg jzg; //... // 也可以将void换成this,方便链式调用 void qz(Qz qz)&#123; this.qz = qz; &#125; void dyc(Dyc dyc)&#123; this.dyc = dyc; &#125; void td(Td td)&#123; this.td = td; &#125; void jzg(Jzg jzg)&#123; this.jzg = jzg; &#125; ChickenPot build()&#123; ChickenPot chicken = new ChickenPot(); chicken.setQz(this.qz); chicken.setDyc(this.dyc); chicken.setTd(this.td); chicken.setJzg(this.jzg); return chicken; &#125;&#125; 12345678910111213class Director&#123; private AbstractBuilder builder; Director(AbstrctBuilder builder)&#123; this.builder = builder; &#125; public ChikenPot construct(Qz qz,Dyc dyc,Td td,Jzg jzg)&#123; builder.qz(qz); builder.dyc(dyc); builder.td(td); builder.jzg(jzg); return builder.build(); &#125;&#125; 以上就是一个简单的建造者模式的实现，主要是屏蔽客户代码直接面对构建顺序，或是指定对象全部内容复杂性。 上述代码其实表达了客户对于四个配菜是加的自己带的，自己指定千张、豆芽菜等等属性值，更多的情况这些其实是建造者默认给产品指定的。真正让客户代码传入内容的字段是少的。 简化版简化版本相当于是去掉指挥者这个环节，让客户代码直接使用建造者的方法完成获取产品对象。 在实际情况下可能并没有太复杂的对象属性的相互依赖，对于产品只用根据自己的需求构建需要指定内容的部分获得对象，不涉及依赖顺序，就可以不使用指挥者环节。 在Idea上也可安装【Builder Generator】即可一键生产这种建造者。 代码都是大同小异 客户代码直接去使用建造者 1ChickenPot chicken = new ChickenPotBuilder().withQz(&quot;xxx&quot;).withTd(&quot;xxx&quot;).build(); 问题 建造者模式和工厂模式有啥区别呢？ 在我看来最大的区别在于，一个是通过传入抽象描述工厂去创建一个抽象类下的哪个具体类的对象？另一个是传些内容创建一个具体类的怎样的对象？ 对于工厂模式客户代码需要了解产品的知识是要少于建造者模式的。客户代码只需要自己用什么。建造者返回一个具体类对象。 建造者模式种客户代码相对来说对自己要用的产品了解知识多一点，但不需要完全了解原理。一个具体类可产生各式各样的对象，客户代码去指导了部分内容，具体工作在建造者，最终完成对象构建。 工厂模式： 建造者模式： 客户代码为啥不直接用产品类的构造器或者Setter呢？ 简单的对象当然是无所谓的，针对复杂具体类使用构造器要么排列组合写出各种构造器，要么面对全部参数的构造器，这样就要去对产品类的了解知识增加了。第二就是属性依赖，对于一个属性内容它在使用上时需要依赖当前产品对象的其他属性，我们没办法了解这个产品其中运作细节，无法创建出正确的对象。在建造者就可以完成初始化工作，以及针对你的内容的进一步修饰才能组装到产品对象当中。 总结建造者模式是提供给客户代码获取复杂类型对象的一种新方式，比起原生的创建进行了封装，但也提供各个步骤有客户代码进行选择。通过提取抽象，建造者也能便于扩展，不同的建造者可对隐藏的细节操作以及客户传入内容的具体指定不同，为产品对象里面的组合属性提供更多的选择。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"cookies、sessionStorage、localStorage三者有啥区别","slug":"cookies、sessionStorage、localStorage三者有啥区别","date":"2021-10-18T07:11:58.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2021/10/18/cookies、sessionStorage、localStorage三者有啥区别/","link":"","permalink":"http://yournotes.cn/2021/10/18/cookies%E3%80%81sessionStorage%E3%80%81localStorage%E4%B8%89%E8%80%85%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前言 写项目用到了sessionStorage来存sessionid，之前一直都是用的cookie。调试又看到了还有localStorage。之前没有了解过好奇查了查，顺便在这里记录一下。 区别 cookies sessionStorage localStorage 存储空间 一般浏览器4KB 一般浏览器5MB 一般浏览器5MB 存储时效 默认是关闭浏览器失效，但可设置时间就以设置时间为准 仅在当前标签页，浏览器或者标签关闭则清除 永久保存，须手动删除 请求携带 请求时携带cookies在请求头 不携带 不携带 可见范围 同一主域 当前标签页 同一主域","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yournotes.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"失焦事件与回车事件冲突","slug":"失焦事件与回车事件冲突","date":"2021-09-29T07:27:42.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2021/09/29/失焦事件与回车事件冲突/","link":"","permalink":"http://yournotes.cn/2021/09/29/%E5%A4%B1%E7%84%A6%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81/","excerpt":"","text":"前言 在自己的小网盘的开发过程中，需要在新建文件夹时产生一个文件夹和一个文件名的输入框，需要在输入名称后回车或者鼠标点击外面完成文件夹创建 问题1234&lt;input @keyup.enter=&quot;confirmName(xxx)&quot; @blur=&quot;confirmName(xxx)&quot;/&gt; 问题在与两个事件都是一个功能确认名称，但绑定两个事件之后回车事件失效了。 解决解决方式是让回车事件的内容关联上失去焦点事件，毕竟都是触发同一个功能。 1234&lt;input @keyup.enter=&quot;$event.target.blur()&quot; @blur=&quot;confirmName(xxx)&quot;/&gt;","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"上传大文件失败","slug":"上传大文件失败","date":"2021-09-26T06:17:02.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/09/26/上传大文件失败/","link":"","permalink":"http://yournotes.cn/2021/09/26/%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"前言 前段时间搞的网盘的项目，初始化好了基本的登录以及上传下载的功能就一直没碰了。今天懒得搞算法和设计模式了，接着写下项目，目前网盘上传1M以上的文件会上传失败 问题1413 Entity Too Large 分析首先锁定在Nginx上面，部署后是nginx反向代理后台，web前端与nginx直接交互。且发现确实nginx默认是限制1M的请求实体。 因此就先配置下Nginx的大小限制 1client_max_body_size 1024M; // 我这里配成1024M也就是1G 这个东西可配置在http、server或者location下，我就直接配在location下的： 123456789101112131415161718server &#123; listen 80; listen [::]:80; server_name localhost; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location /api/ &#123; client_max_body_size 1024M; proxy_pass http://www.yournotes.cn:8080/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 重启nginx之后，上述问题消失，但仍上传不成功。等待一段时间后显示500的错 那就查看下后台的日志 1org.apache.tomcat.util.http.fileupload.impl.SizeLimitExceededException: the request was rejected because its size (22960862) exceeds the configured maximum (10485760) 1234@RequestMapping(&quot;upload&quot;)public JSONObject upload(MultipartFile file)&#123; ... &#125; 简单调试知道这个问题在Controller方法之前，和Controller当中代码无关。需要配置关于MultipartFile文件大小限制问题。 123456spring: servlet: multipart: enabled: true max-file-size: 100MB max-request-size: 100MB 这样配置之后就ok了。 总结有两点：第一点是nginx请求实体的限制、第二点是Spring对multipart的限制.","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"轻松理解设计模式（创建型）3、抽象工厂模式","slug":"轻松理解设计模式（创建型）3、抽象工厂模式","date":"2021-09-24T07:26:10.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/09/24/轻松理解设计模式（创建型）3、抽象工厂模式/","link":"","permalink":"http://yournotes.cn/2021/09/24/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%893%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 经过汇总的23种设计模式它是总结了面向对象设计当中最有价值的经验。对之前来讲可能是对其中部分设计模式还是相对来说熟悉的但仔细琢磨还是会有些疑问，正好在目前相对来说有更多的业余时间，可以来一次重新学习设计模式！ 本篇内容关于抽象工厂模式。包含抽象工厂模式的概念以及差异 定义 抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 —— 《Head First 设计模式》 按照这个定义的描述，好像是和工厂方法模式没有啥不同的。同样是提供一个抽象类或者接口，里面提供一个方法用于创建对象且不需要指明具体类。——关于工厂方法模式看这篇《轻松理解设计模式（创建型）2、工厂方法模式》 这里画一个抽象工厂大概的UML图： 就图的区别而言，工厂方法模式只提供一个创建实例的方法。而对于图上的结构一个具体工厂需要实现接口规定的多个创建实例方法。 客户代码最终获取的一系列产品的具体实例，取决于注入的具体工厂 12345678910public class Person &#123; FoodFactory factory = new 徐老师早餐店(); public void eat() &#123; // 获取食物 Food 老徐炒面 = factory.ceate面条(&quot;炒面&quot;); Food 老徐粉包 = factory.ceate包子(&quot;粉包&quot;); // 吃 System.out.println(&quot;我开吃啦&quot;+老徐炒面+老徐粉包); &#125;&#125; 疑问 按照上面所说确实抽象工厂多了方法，但工厂方法模式一样可以实现这样的功能，到底有什么区别呢？ 工厂方法模式只提供一个抽象的工厂方法，如果要和抽象工厂创建对象的范围一样的话，那么这个唯一的工厂方法的返回类型就要相对来说大一层。且由各个子类来提供具体创建的是这个大类型下的哪个具体类最终都由大类来接收。对于抽象方法来说是直接指定了需要创建的各个类型。这样这个类型既不是具体也不至于太抽象，便于使用，一套产品各自有各自的使用点。 工厂方法是由子类自行决定实例化那个类，而抽象工厂是自己决定实例化哪个类。 在Java当中有哪些地方使用过这些工厂模式呢？ 简单工厂 123public interface BeanFactory &#123; Object getBean(String beanName);&#125; Spring的BeanFactory就是简单工厂模式，通过getBean方法传入bean名称获取对应实例。具体实例是由一开始扫描配置时创建的并加载到map当中的，当getBean时取出返回。采用简单工厂的Map实现方式。 工厂方法 同样在Spring当中也有工厂方法模式的体现AbstractFactoryBean对象的其他操作都由其他方法完成，而具体的创建由其各个子类实现createInstance抽象方法。这些子类它们不需要管对象后续或者前置操作仅仅完成创建。而其他操作均可保证按照固定的流程，只是创建的对象具有多样性。 抽象工厂 比如在Java.sql包下有一个接口叫做Connection（工厂接口）也就是数据库连接对象应该都不陌生。需要各个数库厂商提供实现像MySQL、Oracle等 如下图所示： 这个接口它明确的指定了要创建的各个产品的方法，MySQL或者Oracle都对其有一套的实现来创建这一套产品家族的具体类的实例。且它们也对产品类也有一套具体的实现。当换成工厂实例是MySQL提供，那么创建的Statement（抽象的产品）就是MySQL的对于这个产品的具体类。而代码中永远使用的是抽象的，工厂只出现Connection这样的接口而没有具体的实现类，而代码中获取的产品Blob、Clob、Statement也是由这些接口接收。 当具体使用的一套产品的类型需要变化时，只需要配置新工厂生产现在要使用的一套产品即可。整个代码流程都是抽象的固定的。不需要具体的更改而改代码。 总结回顾整个工厂模式是用来封装对对象的创建，从而减少程序与具体类的耦合。它符合我们的依赖倒置原则——避免依赖具体类型，尽量依赖抽象。而工厂方法与抽象工厂各有不同，前者将类的实例化延迟到子类进行，后者更侧重于在接口规范一组产品类型，每个实现类或者子类是对其一套产品的创建进行实现。可以说工厂模式是面向抽象编程的一个最佳实践。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"LeetCode初级算法之其他：461.汉明距离","slug":"汉明距离","date":"2021-09-22T02:10:58.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2021/09/22/汉明距离/","link":"","permalink":"http://yournotes.cn/2021/09/22/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/hamming-distance/ 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。 示例 1： 1234567输入：x = 1, y = 4输出：2解释：1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 示例 2： 12输入：x = 3, y = 1输出：1 提示： 0 &lt;&#x3D; x, y &lt;&#x3D; 2^31 - 1 题解一这题看提示上面写了是正数，所以不用管负数补码。直接看数字的二进制比较即可。 很容易就能想到，肯定是哪种位运算能够get到二进制数字不同。那不就是异或和同或么，一个是不同为1相同为0，一个相反。 10101 ^ 0010 = 0111 我们使用异或运算，有几个不同，得到的结果就有几个1. 那岂不是上一题。直接搞过来： 123456789// 求位1的个数public int hammingWeight(int n) &#123; int num = 0; while(n != 0)&#123; n = n &amp; (n-1); num++; &#125; return num;&#125; 123public int hammingDistance(int x, int y) &#123; return hammingWeight(x ^ y)&#125; 这个时间复杂度也就是求为一的个数的复杂度，其实是n的长度也就是最大不过31是一个常数所以是O(1),空间复杂度也是O(1) 总结还没思考就已经写完了感觉水了一篇文章，看了官方解题咋一看还有多解，实际上全都是“位一的个数”这题的不同解再配上异或运算。所以关于位一的个数解的细节可以看我这篇。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"轻松理解设计模式（创建型）：2、工厂方法模式","slug":"轻松理解设计模式（创建型）：2、工厂方法模式","date":"2021-09-18T01:51:36.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/09/18/轻松理解设计模式（创建型）：2、工厂方法模式/","link":"","permalink":"http://yournotes.cn/2021/09/18/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%89%EF%BC%9A2%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 经过汇总的23种设计模式它是总结了面向对象设计当中最有价值的经验。对之前来讲可能是对其中部分设计模式还是相对来说熟悉的但仔细琢磨还是会有些疑问，正好在目前相对来说有更多的业余时间，可以来一次重新学习设计模式！ 本篇内容在工厂方法模式之前还加了一段关于简单工厂模式的介绍以及相关实现，再引入到工厂方法模式 简单工厂在聊工厂方法模式之前，先了解简单工厂模式，它虽然不属于23种之一但它是工厂模式家族里最基础的一种编码概念 简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。——《百度百科》 就是说设计一个工厂类来生产各种类的实例，根据你选择或者传入的参数工厂提供你需要的实例，通过这样的方式来解决一个类对于使用各种实例之前需要依赖这些实例对应的类的问题。 1234public abstract class Food&#123; //烹饪或者加热 public abstract void cooking();&#125; 123456public class Sandwich extends Food&#123; @Override public void cooking()&#123; System.out.print(&quot;做明治&quot;); &#125;&#125; 123456public class Noodle extends Food&#123; @Override public void cookie()&#123; System.out.print(&quot;煮面条&quot;); &#125;&#125; 123456public class Dumpling extends Food&#123; @Override public void cooking()&#123; System.out.print(&quot;煎饺子&quot;); &#125;&#125; 那么如上有三个具体类（三明治、面条、饺子）。这里画个图： 在不使用工厂模式的情况下我们要使用这些具体类的实例需要先创建实例也就是new出来。 如下伪代码 1234567891011121314public class Me &#123; public void eat() &#123; Food food = null; if(&quot;我想吃面&quot;)&#123; food = new Noodle(); &#125;else if(&quot;我想吃三明治&quot;)&#123; food = new Sandwich(); &#125;else(&quot;不知道吃啥&quot;) &#123; food = new Dumpling(); &#125; food.cooking(); System.out.println(&quot;我开吃啦&quot;+food); &#125;&#125; 如上因为我不可能只吃一种食物，导致类里需要绑定很多具体食物的类在代码当中。 并且食物的客户并非只有我（Me.class），还有你、她、他甚至餐馆。我们虽然用Food进行接收但new关键字后面仍是具体的类。 那么各个客户类里绑定着各种各样的具体类。一旦这一系列具体的类需要改变。那么客户代码都需要修改。 为了不惧怕改变，把创建实例的部分也就是写了具体类的部分代码抽取到工厂，由工厂进行提供。这样左边是抽象类或者接口接收，右边是统一的工厂供给各种具体类的实例。 12345678910class FoodFactory&#123; public Food createFood(String foodName)&#123; if(&quot;三明治&quot;.equals(foodName))&#123; return new Sandwich(); &#125;else if(&quot;面条&quot;.equals(foodName))&#123; return new Noodle(); &#125;else if ...... &#125;&#125; 1234567891011public class Me &#123; FoodFactory factory = new FoodFactory(); public void eat() &#123; // 拿到食物 Food food = factory.createFood(&quot;我想吃xxx&quot;); // 加热或按照标准烹饪 food.cooking(); // 吃 System.out.println(&quot;我开吃啦&quot;+food); &#125;&#125; 实际上这个工厂对象也应该是要动态的赋予到Me里面，上面是简单创建一个。总而言之变成如下的关系： 客户类之前为了使用各种类的实例，导致写死了很多具体类在代码当中。而通过这样的工厂，客户类同样可以获取各种类型的实例但代码里却只有FoodFactory一个具体类了 工厂方法模式那么到这里，可以发现简单工厂确实完成了实例创建与使用之间的解耦合，但它对于工厂类本身是不满足对修改关闭的原则，可能我要吃面一会儿吃清淡的一会儿吃麻辣的。因此一个类型的东西是有多个具体的类，我们需要使用一个类型的实例让工厂给我们，工厂给了这个类型的其中之一的具体类的实例，之后有可能需要换。 喜欢吃辣去找辣的菜馆，喜欢吃清淡找清淡的菜馆呗！ 如此说来确实菜馆就一个咋行呢？比如有两种菜馆（工厂），我吃辣就找HotFoodFactory吃清淡点就找MildFoodFactory 123456789public abstract class FoodFactory&#123; public Food cooking(String foodName)&#123; Food food = createFood(foodName); food.cooking(); .... return food; &#125; public abstract Food createFood(String foodName);&#125; 1234567891011public class HotFoodFactory extends FoodFactory&#123; @Override public Food createFood(String foodName)&#123; if(&quot;饺子&quot;.equals(foodName))&#123; return new HotDumpling(); &#125;else if(&quot;面条&quot;.equals(foodName))&#123; return new HotNoodle(); &#125;else if ...... &#125;&#125; 1234567891011public class MildFoodFactory extends FoodFactory&#123; @Override public Food createFood(String foodName)&#123; if(&quot;饺子&quot;.equals(foodName))&#123; return new MildDumpling(); &#125;else if(&quot;面条&quot;.equals(foodName))&#123; return new MildNoodle(); &#125;else if ...... &#125;&#125; 最终需要的具体类的实例找对应的工厂进行创建 123456789public class Me &#123; FoodFactory factory = new HotFoodFactory(); public void eat() &#123; // 获取食物 Food hotNoodle = factory.cooking(&quot;面条&quot;); // 吃 System.out.println(&quot;我开吃啦&quot;+hotNoodle); &#125;&#125; 123456789public class You &#123; FoodFactory 兰州拉面馆 = new 兰州拉面(); public void eat() &#123; // 获取食物 Food 兰州拉面 = 兰州拉面馆.cooking(&quot;面条&quot;); // 吃 System.out.println(&quot;我开吃啦&quot;+兰州拉面); &#125;&#125; 那么现在完成一个转变，比起之前的简单工厂模式所有的具体类都在一个工厂里面进行创建，责任过大且不好扩展。那么对于现在的工厂方法模式。可以分不同的工厂创建不同类型的实例。 当你所有面馆的面都吃厌了想吃新口味的面，可以由新开的面馆提供新的面类，而不至于将之前的某家面馆的产品进行推翻重新做产品毕竟这家面馆可能也被其他人喜欢。那么这样即做到了对修改关闭对扩展开放。 思考 简单工厂的写法，为啥有的会给创建方法加上static? 一般简单工厂基本上涉及的类型不会太多，也不大会发生变化。使用static修饰就可以直接类调用创建方法了。但如果考虑到该类之后要被继承可能重写创建方法那就不能用静态了 简单工厂用反射不就可以满足对修改关闭了么？ 这样的实现没有太多意义。先把这种实现代码列出来看一看： 12345public class Factory&#123; public static Food createFood(String className)&#123; return Class.forName(className).newInstance(); &#125;&#125; 123456public class Me&#123; public void eat()&#123; Food food1 = Factory.createFood(&quot;xx.xx.xx.Noodle&quot;); Food food2 = Factory.createFood(&quot;xx.xx.xx.Dumpling&quot;); &#125;&#125; 咋一看好像没问题，确实解决了一堆判断的问题，简单工厂的代码不用像之前一样加一个实例就加一个判断。 1new Noodle(); ==&gt; &quot;xx.xx.xx.Noodle&quot; 但想想工厂模式的设计到底是为了什么？不就是为了创建与使用解耦合么。为了在客户代码里使用的是抽象来换取具体实例，具体实例变动是和工厂有关。这样写又是在客户代码里具体化了。一变动需要变动的是全体客户代码。 这样写全限定名与直接new都是写到了可以被实例化的具体类，不同的是字符串我们可以从配置里去读取通过这样的方式解耦。 1包子=xx.xx.xx.牛肉包 1Food food = Factory.createFood(getProperties(&quot;包子&quot;)); 通过配置完成客户代码写抽象，最终获得具体的实例。当具体类发生变更只需要改配置当中引用的具体类即可。 但这种解耦不是工厂模式完成的。把具体丢给了客户代码。 客户代码用配置或者用其他工厂等其他方式来进行解耦了，再给这个工厂？。 那这个工厂是干啥的？ 工厂方法模式的每个具体工厂就等于一个简单工厂么？ 单个来看实现是差不多的，但对于工厂方法模式中的各个具体工厂他们不是独立的。他们是共同实现了一个抽象工厂，对这个工厂的抽象创建方法进行了各自不一样的实现。 总结 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 上面定义了一个工厂（菜馆）是抽象的。真正创建具体菜品实例的是他的抽象方法。这个抽象方法分发下去给各个子类进行实现。 工厂类作为中间人，完成了客户类与很多使用的实例对应的类解耦了。客户类只对工厂有依赖关系或者耦合关系。并且通过换具体工厂来解决某些使用实例变动的问题。其实是是将很多的耦合抽取了，变成了唯一的耦合。那么这个耦合就可以让启动器根据配置或者数据库来动态获取解决。 客户类： 12345678910public class Me &#123; FoodFactory factory; public void setFactory(FoodFactory factory)&#123; this.factory = factory; &#125; public void eat() &#123; Food food1 = factory.cooking(&quot;面条&quot;); Food food2 = factory.cooking(&quot;包子&quot;); &#125;&#125; 配置： 1早餐店=&quot;牛肉馆&quot; 123me.setFactory(get(&quot;早餐店&quot;));food1 = @&quot;牛肉面&quot;;food2 = @&quot;牛肉包子&quot;; 更改配置： 1早餐店=&quot;素食馆&quot; 123me.setFactory(get(&quot;早餐店&quot;));food1 = @&quot;清汤面&quot;;food2 = @&quot;素包子&quot;; 其优缺点基本上是相较于简单工厂而言，当客户类使用产品实例需要更改时，客户类通过工厂来获取因此其代码不变。变得是工厂创建实例使用的具体类。简单工厂模式就是在工厂代码里改变，而工厂方法模式将工厂抽象并新建另一个工厂，让客户代码去换工厂。它的缺点也是因为它的优点，当产品的类型结构越来越复杂，大类型与具体类型都越来越多。具体工厂类因此也越来愈多。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"LeetCode初级算法之其他：191.位1的个数","slug":"位1的个数","date":"2021-09-04T03:21:36.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/09/04/位1的个数/","link":"","permalink":"http://yournotes.cn/2021/09/04/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/number-of-1-bits/ 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。 示例 2： 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。 示例 3： 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。 提示： 输入必须是长度为 32 的 二进制串 。 进阶： 如果多次调用这个函数，你将如何优化你的算法？ 题解一：辗转相除首先理清主逻辑，判断一组个其中有多少个1，对二进制来说每个位只有0或者1，对我们熟悉的十进制来说有0，1，2 ~，9。如果是十进制怎么判断这个位是非0呢，立马就知道是除以10 12345678110 (十进制)先判断个位是0还是非0110除以10 可整除说明个位是0，留下11进一步判断1111除以10 不能整除说明非0的个数数加一 留下1... 也就是说我们一步一步去判断每个位是否是0即可，对二进制来说非0也就是1，那么1的计数加一。 123456789101112public int hammingWeight(int n) &#123; // 计数1的个数 int num = 0; while(n ！= 0)&#123; // 取余非0则余1，当前位是1 if(n%2 != 0) num++; // 迭代n,直到n最后一个非0在个位则出循环 n = n/2; &#125; //记下最后一位非0数 return ++num;&#125; 那么这里有个问题就是对于负数是错误的，因为负数的二进制以补码呈现，像上述测试用例是-3，按照我们的上述逻辑应该是两个一和正3一样，就算加上最高位符号位的负号1也只能是三个一，但实际上负数以补码呈现的就像上述结果实际上是31个一。 因此上述解只是在数字层面的二进制是没问题的，在代码里面因为一些编译的问题就对负数就不行了 题解二：位运算既然上述解是这样的问题，那我们就不去在数字层面弄，就按照它的规则去数一的个数，也不用转换什么的。其实是和解法一差不多的。因为把解法一翻译一下会变成如下： 12345678public int hammingWeight(int n) &#123; int num = 0; while(n = 0)&#123; if((n&amp;1) != 0) num++; n = n&gt;&gt;1; &#125; return ++num;&#125; 翻译就是把除运算换成位移运算，除以一个进制位就等于向右位移一次，对个位取余就等于与1进行与运算。这样逻辑上虽然和上面一样但是对于负数就不一样了 在代码中对于正数来说除以2和向右位移一位是一样的，负数就不一样了因为是一个补码串，你位移它就是用这个串去位移数的就是这个串，但你除以2得到的结果是和它的绝对值除2是一样的然后加个负号。如下： 123456783（8位）0000 0011-31111 1101按除以2来，-3的结果也就是两个一所以就用位运算，就不用管转换的问题了 但上面的代码是有问题的，上面的循环是为了循环到最高位的非0数，遍历完毕，这样不用遍历整个32位 对于负数来说就有问题，负数位移永远没有尽头，所以得改成for循环就循环这32位即可 12345678public int hammingWeight(int n) &#123; int num = 0; for(int i = 0; i &lt; 32; i++)&#123; if((n&amp;1) != 0) num++; n = n &gt;&gt; 1; &#125; return num;&#125; 时间与空间复杂度都是O（1） 题解三：位运算优化前面题解一不用遍历完32为比如00010100 只用遍历到最高位的1即可也就是遍历5个。到了题解二位运算不能去判断是因为负数的二进制一直往右位移也永远不会等于0会进入无限循环。 所以只能找另外的方式怎么一步一步的计数1的出现然后在数字里面去掉或者变为0，直到最后一个1处理完，整个数就是0了就没必要继续遍历了。这个方法就是n &amp; (n-1)，可以演示一下： 1234数字7也就是 01110111 &amp; 0110 = 01100110 &amp; 0101 = 01000100 &amp; 0011 = 0000 也就是所每次都会去掉一个一，这个时候就可以计数一下。直到最终是0了，也就统计完最后一个1了。 12345678public int hammingWeight(int n) &#123; int num = 0; while(n != 0)&#123; n = n &amp; (n-1); num++ &#125; return num;&#125; 空间上去了一点可能是少了for循环的i 总结这一题的话，主要是对于负数在Java里它的一个计算结果和常规是不一样的（这里不展开），因此就用位运算也就不存在转换。第二点就是对于一个int类型的整数它是32位，那么判断32位里有多少个1时，要不要遍历完32位才能出结果？这里就会有两个迭代方式一个是每次位移一个也就是丢掉最右边的数直到数字为0了后面也就不要遍历了，另一个是每次将最低位的1变为0，后者是更优的。因为001011对于第一种要遍历4次也就是每次丢一个直到最终数字为0，第二种方式只需要3次n &amp; (n-1)能直接跳到最低位的1处理成0，中间的0都是直接跳过。n &amp; (n-1)这个运算可以留意一下。还有一种最差的解法也就是转二进制串再数个数这样就没什么意义了相当与遍历了两次Integer.toBinaryString(n)。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"轻松理解设计模式（创建型）：1.单例模式","slug":"2分钟理解设计模式（创建型）：单例模式","date":"2021-09-03T11:08:58.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2021/09/03/2分钟理解设计模式（创建型）：单例模式/","link":"","permalink":"http://yournotes.cn/2021/09/03/2%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 经过汇总的23种设计模式它是总结了面向对象设计当中最有价值的经验。对之前来讲可能是对其中部分设计模式还是相对来说熟悉的但仔细琢磨还是会有些疑问，正好在目前相对来说有更多的业余时间，可以来一次重新学习设计模式！ 设计模式的一篇单例模式，内容包含2点一是模式的定义与目的，二是Java具体实现与疑问 定义对于单例模式大家应该还算比较熟悉，可能很多时候需要手写啊啥的。 先还是体会下最初的定义 单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：“保证一个类仅有一个实例，并提供一个访问它的全局访问点。” 我们可以从中得到两个信息： 保证一个类仅仅只能有一个实例 也就是不能被其他外界实例化。那么构造方法得私有private,且对象此实例属于类也就是static成员存在 并提供这个实例的全局访问点 提供public static方法给外界获取此成员 那么为什么要设计这样的单例类呢？ 比如网站点登录会有一个登录窗口，把这个登录窗口当成一个对象。那么每次点击登录都要创建这样一个登录窗口吗? 用完之后再销毁掉么？同样还有访问数据库，需要建立连接使用完毕销毁连接，但每次就是使用的这样一个一模一样的东西。 再比如全局的计数器，如果一个计数器，每次获取的是不一样的对象，那就没作用了。 两点：1.减少开销、2.共享资源 饿汉式综上定义所说实现单例模式的类有一下几点： 构造方法私有 作为静态成员存在 提供公开方法获取 那么很容易写出以下代码，就是熟悉的饿汉的实现 1234567public class Single&#123; private static final Single single = new Single(); private Single()&#123;&#125; public static Single getSingle()&#123; return single; &#125;&#125; 懒汉式对于单例的饿汉与懒汉大家也应该都清楚，一个是这个类加载的时候实例就创建了，另一个是等去调用getSingle()才去new，就像下面这样 12345678910public class Single&#123; private static Single single; private Single()&#123;&#125; public static Single getSingle()&#123; if(single == null)&#123; single = new Single(); &#125; return single; &#125;&#125; 好处就是避免了一开始的空间占用。问题就在于创建对象需要两步，一步是判断第二步是创建。因此存在线程安全问题导致多次创建违背了单例，如下： 可以看的到在前几个结果已经出现,新实例的情况.所以这个获取的这个操作是存在线程安全问题的。 那解决也很简单比如: 12345678910public class Single&#123; private static Single single; private Single()&#123;&#125; public synchronized static Single getSingle()&#123; if(single == null)&#123; single = new Single(); &#125; return single; &#125;&#125; 或 123456789101112public class Single&#123; private static Single single; private Single()&#123;&#125; public static Single getSingle()&#123; synchronized(Single.class)&#123; if(single == null)&#123; single = new Single(); &#125; &#125; return single; &#125;&#125; 也就是加上synchronized保证代码块的同步.但其实也就是第一次被外界获取是需要创建唯一的实例的,之后就都是返回已经存在的唯一实例,为了第一次的安全性锁住了全部包括之后每次获取都要走synchronized.是否是同步范围过大了?是不是没有这个必要? DCL实现了解多线程的都会熟悉双重检测锁(Double Check Lock)的写法,在这里一样DCL的单例实现 1234567891011121314public class Single&#123; private static Single single; private Single()&#123;&#125; public static Single getSingle()&#123; if(single == null)&#123; synchronized(Single.class)&#123; if(single == null)&#123; single = new Single(); &#125; &#125; &#125; return single; &#125;&#125; 其实就是在synchronized外面再判断一次,这样就保证实例创建完之后只用走个判断就返回不用保证同步,而因为首次创建进去的一批线程会在后面经过同步块与判空来让唯一的一个线程去创建. 了解过单例实现的，都知道对于这个实例成员还需加上volatile修饰，知道对于new对象并不是原子的，而是有大概如下的三步： 开辟空间 初始化对象到空间 将空间地址进行引用 当2与3步骤进行调换，也就是图上的字节码，21与24的地方。当完成字段赋值，判断则不为空，但如果21与24的指令交换了顺序，那么字段不为空时对象并没初始化。由于双重检测锁的实现第一个判断是开放的，也就是在一个线程在创建对象的过程中，另一个线程可以经过判断如果不为空直接返回. 1private static volatile Single single; 在后面疑问章节，可以不使用volatile达到同样的目的么？ 内部类实现懒汉式实现在使用到实例成员时才创建,那么除了像上面一样获取的时候进行判空来进行延迟创建,其实对于Java来说还有另一种方式就是内部类. 123456789public class Single&#123; private Single()&#123;&#125; private static class CreateSingle&#123; private static final Single SINGLE = new Single() &#125; public static Single getSingle()&#123; return CreateSingle.SINGLE; &#125;&#125; 这个是利用了Java内部类的特性： 外部类可以访问内部的私有成员 类被加载时不会加载其中的内部类，只有内部类被访问使用时才加载 那么这样就做到了延迟加载也就是懒汉式的单例，并且没有多步骤操作，是自然的线程安全. 枚举既然上面已经有较好的单例实现，为啥还要说枚举？ 它是Java特性天然的单例模式 123public enum EnumSingle &#123; SINGLE;&#125; 大家都知道枚举类型，是把实例确定了的类。如果使用枚举类型就限制了对应的值。因为对于枚举的实例是在枚举类里列出来确定好了，并且构造器也是私有的。 下面是枚举类反编译的删减版（其实就是去掉了一些方法，只留下构造器与与成员实例） 123456public final class EnumSingle extends Enum&#123; public static final EnumSingle SINGLE = new EnumSingle(&quot;SINGLE&quot;, 0); private EnumSingle(String s, int i)&#123; super(s, i); &#125;&#125; 疑问在开篇之前，是觉得这东西是很熟悉的。最终梳理完了感觉还是有很多疑问的，下面列出来疑问点以及我的想法： 为什么说单例的最佳实现是无状态的？（很多地方看到这句） 什么是无状态? 就是说类不具有成员属性信息，或者说没有可修改的成员属性。那么无状态的单例也就是完全的并发安全的，没有可供修改的内容，获取实例只是使用其中的方法，这样一般用来做工具类。第二种就是状态的单例，共享资源。比如全局计数器，那就要去保证线程安全提供安全的操作方法。 我们知道Java里面有发射机制,这些单例实现会被破坏么？ 如果使用反射的话是确实可以去破坏，通过反射可以获取构造器来创建新对象，比如像下面： 12345678910// 1.获取无参构造器Constructor&lt;Single&gt; constructor = Single.class.getDeclaredConstructor();// 2.关闭私有访问constructor.setAccessible(true);// 3.调用两次构造器获取对象Single single1 = constructor.newInstance();Single single2 = constructor.newInstance();// 4.测试System.out.println(single1);System.out.println(single2); 反射能去随意的使用单例类的构造器，因此确实可以破坏。但我们可以去点开newInstance方法 可以很惊喜的发现，如果是枚举类型就不允许通过反射来执行构造器，会抛出异常 1throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); 枚举这种方式它是属于饿汉式还是懒汉式？ 我们可以通过枚举实际的一个class代码，枚举的成员实际都是static final的、一开始就创建的。是属于饿汉式的。 1public static final EnumSingle SINGLE = new EnumSingle(&quot;SINGLE&quot;, 0); 但在查找资料时发现有的博客上写的是枚举是懒汉，理由是一句实际运行时会延迟加载。如果按照最终的执行的class反编译的代码它一定就是饿汉。抛开执行代码看看内存分析是否一致测试结果没问题和预期一样，类加载就会创建实例。枚举是饿汉。 经过序列化之后还是同一个实例么？ 其实我们大概都知道，进行序列化与反序列化它是一个深拷贝的过程，是产生另外一个属性内容都相同的新对象，所以如果一个单例类它可以被序列化，那么确实可以打破单例得到新对象。因此对于任何对象按照下面结果都是false 123456789// 进行序列化ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;));out.writeObject(Single.getSingle());File file = new File(&quot;tempFile&quot;);// 还原ObjectInputStream input = new ObjectInputStream(new FileInputStream(file));Object newInstance = input.readObject();//判断是否是同一个对象System.out.println(newInstance == Single.getSingle()); 但经过测试发现枚举是与众不同的 Java规范字规定，每个枚举类型及其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。在序列化的时候Java仅仅是将枚举对象的name属性输到结果中，反序列化的时候则是通过java.lang.Enum的valueOf()方法来根据名字查找枚举对象。也就是说，序列化的时候只将DATASOURCE这个名称输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同 —— 《Java编程思想》 抱着一探究竟的想法看了跟着看了readObject如下图，就想上面描述的一样，通过枚举的name属性获取到枚举类里存在的实例。 DCL实现可以不使用volatile么？ 理论上来讲是可以的，毕竟加这个volatile也是出于理论上，目前没有找到测试方法。 那么不加volatitle怎么保证不会拿到为初始化好的对象呢？很简单虽然对于JVM确实会可能进行指令的顺序调整提高效率，前提是调换顺序不影响结果才可能被重排序。 为了让其不被重排序除了volatile修饰成员之外。是不是可以让创建对象之后被依赖，通过依赖关系让JVM不对其进行重排序。将最终创建完整的对象再直接赋值给单例字段single 下面是我的猜想，让try-catch限制创建对象的指令完成之后再进行下面赋值操作。也就是原子操作给single。保证single字段不为空时，一定是个完整的对象。 123456try&#123; Single temp = new Single();&#125;catch(Exception e)&#123;&#125;single = temp; 当然这是猜想，关于指令重排序怎么测试出来，怎么追踪到JVM里面去看最终操作。目前没有找到合适的方法。 总结首先就是这种单例设计的思想，是比较好理解的全局唯一的对象。第二就是我们对这种思想落实到具体编码实现需要考虑的点：1.需要懒汉还是饿汉式？2.是否需要保证是否线程安全？3.是否有必要防反射序列化等等。对于优缺点而言就是有得必有舍得问题，比如它不能被继承不好扩展等。这些缺点就是为了实现单例得思想带来的因此必须是不能的。所以也不算缺点而是说这个使用场景是不是满足了使用单例的需要。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"LeetCode初级算法之数学问题：13.罗马数字转整数","slug":"罗马数字转整数","date":"2021-08-30T02:51:51.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/08/30/罗马数字转整数/","link":"","permalink":"http://yournotes.cn/2021/08/30/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/roman-to-integer/ 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例1： 12输入: &quot;III&quot;输出: 3 示例2： 12输入: &quot;IV&quot;输出: 4 示例3： 12输入: &quot;IX&quot;输出: 9 示例4： 123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例5： 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 1 &lt;= s.length &lt;= 15 s 仅含字符 (&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;) 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 题解解这题首先得梳理罗马数字转整数的具体逻辑，而不是像日常时的一知半解。通过题目的说明，大概可以知道罗马数字左边都是比右边大除非是刚好小一个数量级，比如下面代码块中的示例C比M小在左边因为一个是1000一个是100表达900或者IX表达9必须是刚好小一个数量级才能写左边表示减去，不可能有XM这样的数，因为990表达为CMXC 1234567891011121314151617181920212223242526// 示例CMXCIX// C比右边的数M小，所以C是被减的。/* * 当然这里不用去考虑像上面说的 * 是否是小一个数量级 * 因为它传进来就是合法的罗马数字 * 在这题只需要转整数而已 */C = 100M = 1000C &lt; M = 900// X需要被减因为比后面的C小X = 10C = 100X &lt; C = 90// I需要被减因为比后面的X小 I = 1X = 10I &lt; X = 9// 其他的都加起来就是结果 999 其实在纸上多推演几次基本上会了解，比后面小就是减其他就是加。 1234567// 示例32 = 30 + 230 = XXX2 = II32 = XXXII 1234567// 示例42 = 30 + 230 = XL 2 = II42 = XLII 这里还是画个动图 12345678910111213141516171819202122public int romanToInt(String s) &#123; // 1.记录这些罗马字符代表的数字 Map&lt;Character, Integer&gt; map = new HashMap(); map.put(&#x27;I&#x27;,1); map.put(&#x27;V&#x27;,5); map.put(&#x27;X&#x27;,10); map.put(&#x27;L&#x27;,50); map.put(&#x27;C&#x27;,100); map.put(&#x27;D&#x27;,500); map.put(&#x27;M&#x27;,1000); // 2.遍历字符累计数值 char[] arr = s.toCharArray(); int num = 0; for(int i = 0; i &lt; arr.length; i++)&#123; if(i+1 &lt; arr.length &amp;&amp; map.get(arr[i]) &lt; map.get(arr[i+1]))&#123; num -= map.get(arr[i]); &#125;else&#123; num += map.get(arr[i]); &#125; &#125; return num;&#125; 总结这题可能会出现的弯路是没有分清状态，在遍历每个字符想要结合后面的串来计算当前的值，觉得会被后面的位影响，所以产生了递归的解法。相对来说麻烦许多，有了递归就有相反的迭代，也就是保持这个叠加的思路不变，把从左向右遍历换成从右向左遍历会顺一些，碰到大的就加碰到小的就减。但之所以会产生这两种方式，就是没有分清当前的计算过程是否可以拆分为独立的单元，每个过程不关乎下一个结果，因为罗马的数字不会受位影响，从左到右也只需要当前数值。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之数学问题：326.3的幂","slug":"3的幂","date":"2021-08-29T04:48:09.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2021/08/29/3的幂/","link":"","permalink":"http://yournotes.cn/2021/08/29/3%E7%9A%84%E5%B9%82/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/power-of-three 给定一个整数，写一个函数来判断它是否是3 的幂次方。如果是，返回 true ；否则，返回 false 。整数 n 是 3 的幂次方需满足：存在整数 x 使得 n &#x3D;&#x3D; 3^x 示例1： 12输入：n = 27输出：true 示例2： 12输入：n = 0输出：false 示例3： 12输入：n = 9输出：true 示例4： 12输入：n = 45输出：false 提示： -2^31 &lt;= n &lt;= 2^31 - 1 进阶： 你能不使用循环或者递归来完成本题吗？ 题解一：迭代看到这题第一想法就是循环降幂（除3）一值可以到最终0次幂也就是等于1说明它是3的幂。 1234567891011public boolean isPowerOfThree(int n) &#123; if(n &lt;= 0) return false; while(n != 1)&#123; if(n%3 == 0)&#123; n = n/3; &#125;else&#123; return false; &#125; &#125; return true;&#125; 这个倒是挺顺利一次过，没有太多细节。时间复杂度规模每次是在上一次除三所以是log以3为底的次数，也就是O（logn）。空间上连变量都没有用，O（1） 题解二：数字范围那在题目提示上说可以不用循环来去做，循环这种它是基本的推演逻辑。现在应该是对于数字上它是否有什么规律，是否有总结公式这样去考虑。最后是参考了官解，主要有两点： 一个质数的幂次方，他的因数只会是这个质数的幂次方 int类型的范围 根据这两点是可以知道，从参数n的范围找到一个最大的3的幂次方max3。那么所有的幂次方都是可以被这个最大的max3整除。不能被max3整除的它就不是3的幂次方。 这里可以推演一下，用底数2来。假设指定n的范围是100以内。传入一个n判断它是不是2的幂次方？ 1234567891011一百以内的2的幂次方有：1 2 4 8 16 32 64传入一个n怎么判断是2的幂次方呢？也就是怎么判断是上面这些数之一呢？用64去除即可，它除上面这些数都可以整除，一百内其他的都没办法被64整除是因为质数是最小因数 回到题目，这里n最大是int类型的最大也就是2^31 - 1，那么在这个范围里面3^19（1162261467）是最大的3的幂次方。传入的n只要能被3^19整除那么它就是3的幂次方 1234public boolean isPowerOfThree(int n) &#123; if(n &lt;= 0) return false; return 1162261467%n == 0;&#125; 这个不用说时间与空间复杂度都是O（1） 总结这道题的话其实解法一效率就很高了，在官方题解里是有还有一种通过转换进制判断除了最高位之外其他位是否为0来判断它是否是幂集里，这种就是效率很低的偏离了解题走了弯路。大多情况下解法一与解法二效率差不多，但在数量级较大解法二会优一点。解法二的诞生利用隐藏特性，锁定范围进而减少解题步骤。无论是对于程序算法还是单纯的数学题，在解题之前确实需要尽量详尽的列出题目信息当中包含的所有已知条件，全部利用上才能给出当下这个场景下最好的最针对的解。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"RedisTemplate存储乱码问题","slug":"RedisTemplate存储乱码问题","date":"2021-08-28T07:14:38.000Z","updated":"2025-04-17T08:34:52.016Z","comments":true,"path":"2021/08/28/RedisTemplate存储乱码问题/","link":"","permalink":"http://yournotes.cn/2021/08/28/RedisTemplate%E5%AD%98%E5%82%A8%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言 这个东西以前也是经常处理，但是懒得记，今天弄自己网盘项目的登录用Redis也遇到这个，记录下自己常用的解决方式 问题比如像下面，存值存一个字符串类型 出现这个问题的原因是两边序列化不一致。 解决方式 配置RedisTemplate的序列化方式 如果key和value都是存字符串类型则设置序列化为StringRedisSerializer 123RedisSerializer stringSerializer = new StringRedisSerializer();redisTemplate.setKeySerializer(stringSerializer);redisTemplate.setValueSerializer(stringSerializer); 如果key参数放字符串，value放对象 12redisTemplate.setKeySerializer(new StringRedisSerializer());redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); 也可以在bean里配置 123456789101112@Configurationpublic class RedisConfig &#123; @Autowired private RedisTemplate redisTemplate; @Bean public RedisTemplate redisTemplateInit() &#123; RedisSerializer stringSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringSerializer); redisTemplate.setValueSerializer(stringSerializer); return redisTemplate; &#125;&#125; 除了配置序列化方式之外，如果是都存字符串可以在注入RedisTemplate时直接加上泛型 12@AutowiredRedisTemplate&lt;String,String&gt; redisTemplate; 总结自己一般是直接加泛型解决乱码问题，即使存值类型是对象含义也是转为json字符串来存。所以基本上key,value都是字符串类型。","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Spring Initializr加载失败","slug":"Spring-Initializr加载失败","date":"2021-08-11T04:14:45.000Z","updated":"2025-04-17T08:34:52.017Z","comments":true,"path":"2021/08/11/Spring-Initializr加载失败/","link":"","permalink":"http://yournotes.cn/2021/08/11/Spring-Initializr%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"前言 本来是看下SpringBoot几个基本组件引入的依赖，使用Idea的Spring Initializr进行初始化项目，但从他这个默认的地址去拉取父项目会有网络问题 解决方式最好就是用自定义地址，改成国内镜像地址，这里用阿里的：https://start.aliyun.com/ , 改完之后就比较快了","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Docker基础","slug":"Docker基础","date":"2021-08-01T10:15:54.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2021/08/01/Docker基础/","link":"","permalink":"http://yournotes.cn/2021/08/01/Docker%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、Docker简介 1.1 虚拟化技术虚拟化技术是一种计算机资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来。虚拟化技术打破了计算机实体结构间的，不可切割的障碍。使用户可以比原本的组态更好的方式，来应用这些资源。 虚拟化技术主要作用： 高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件 软件跨环境迁移问题(代码的水土不服) 在一台主机上实现多个操作系统，关键技术就是硬件的虚拟化。 1.2 什么是Docker首先，我们先来看几个问题： 1.合作开发的时候，在本机可以跑，别人的电脑跑不起来 ​ 这里我们拿Java Web应用程序举例，我们一个Java Web应用程序涉及很多东西，比如JDK、tomcat、spring等等。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序直接打包成镜像，直接运行在容器中即可。 2.服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了 ​ 这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。 3.公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器 在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给你跑多少容器，极大地提高了部署效率。 官网地址：https://www.Docker.com Debug your app，not your environment！ 调试你的应用程序，而不是你的开发环境 官网的介绍是“Docker is the world’s leading software container platform.”官方给Docker的定位是一个应用容器平台。 Docker 是一个开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc） Docker 可以让开发者打包他们的应用，以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。Docker容器是完全使用沙箱机制，相互隔离，性能开销也极低。 从 17.03 版本之后，Docker分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版） Docker通俗的讲是服务器中高性能的虚拟机，可以将一台物理机虚拟N多台虚拟机的机器，互相之间隔离，互不影响。 想要搞懂Docker，其实看它的两句口号就行。 第一句，是**“Build, Ship and Run”**。 也就是，“搭建、发送、运行”，三板斧。 举个例子： 我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。 结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。 但是，跑来一个老巫婆，教会我一种魔法。 这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。 等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。 怎么样？是不是很神奇？ 所以，Docker的第二句口号就是：“Build once，Run anywhere（搭建一次，到处能用）”。 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。 特点： 标准化交付：Docker将应用打包成标准化单元，用于交付、部署； 轻量级：容器及包含了软件运行所需的所有环境，而且非常轻量级 高可靠：容器化的应用程序，可以在任何Linux环境中始终如一的运行 隔离性：容器化的应用程序，具备隔离性，这样多团队可以共享同一Linux系统资源 1.3 容器与虚拟机比较下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见Docker是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生硬件 弱鸡 系统支持量 单机可跑几十个容器 单机几个虚拟OS 运行环境 主要在Linux 主要在window 相同：容器和虚拟机都是虚拟化技术，具备资源隔离和分配优势 不同： Docker虚拟化的是操作系统，虚拟机虚拟化的是硬件 传统虚拟机可以运行不同的操作系统，Docker主要运行同一类操作系统(Linux) 比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧 1.4 Docker基本概念 **宿主机：**安装Docker守护进程的Linux服务器，称之为宿主机； **镜像（Image）：**Docker 镜像，就相当于是一个 root 文件系统。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数。 **容器（Container）：**镜像运行之后的实体，镜像和容器的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 **仓库（Repository）：**仓库可看成一个镜像控制中心，用来保存镜像。 举例： 刚才例子里面，那个放在包里的“镜像”，就是Docker镜像。而我的背包，就是Docker仓库。我在空地上，用魔法造好的房子，就是一个Docker容器 说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。 每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！ 也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像 这么一来，我们可以交换镜像，你用我的，我用你的，是不是就很爽。 于是乎，就变成了一个大的公共仓库。 负责对Docker镜像进行管理的，是Docker Registry服务（类似仓库管理员）。 不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？ 所以，Docker Registry服务对镜像的管理是非常严格的。 最常使用的Registry公开服务，是官方的Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。 二、Docker安装与启动这里使用虚拟机演示，本地电脑安装虚拟机，虚拟机搭配Linux操作系统，在Linux操作系统上安装Docker容器。 Docker需要从镜像仓库下载镜像，需要联网。 提供的虚拟机网卡地址，我这里是：192.168.200.128 **准备工作：**确保Linux系统能够连接网络 调整虚拟网络编辑器： 桥接模式的虚拟机，就像一个在路由器”民政局”那里”上过户口”的成年人，有自己单独的居住地址，虽然和主机住在同一个大院里，但好歹是有户口的人，可以大摇大摆地直接和外面通信。 NAT模式的虚拟机，纯粹就是一个没上过户口的黑户，路由器”民政局”根本不知道有这么个人，自然也不会主动和它通信。即使虚拟机偶尔要向外面发送点的信件，都得交给主机以主机的名义转发出去，主机还专门请了一位叫做NAT的老大爷来专门负责这些虚拟机的发信、收信事宜。 仅主机模式的虚拟机，纯粹是一个彻彻底底的黑奴，不仅没有户口、路由器”民政局”不知道这么号人，还被主机关在小黑屋里，连信件也不准往外发。 其中这个仅主机模式能够保障我们在拔掉网线的情况下继续连接我们的虚拟机，不依靠公网连接，而是依靠物理机和虚拟机的关系连接。在断网的情况下，利用这个模式，我们可以继续连接虚拟机，实现我们的操作。 VMware Network Adapter VMnet8网卡设置 打开虚拟机文件： 提供的虚拟机文件已经安装了CentOS7，并且在CentOS7上已经安装了Docker环境，IP地址：192.168.200.128 连接到虚拟机 SSH、SecureCRT 2.1 安装 Docker官方建议在Ubuntu中安装Docker软件。因为Docker基于Ubuntu发布，而且Docker出现问题时，Ubuntu系统版本的一般是先打补丁。很多版本在CentOS中，是不支持更新最新补丁包的。没有好的解决方案。 但是，由于我们学习的环境都使用CentOS。因此，这里我们将Docker安装到CentOS上。注意，一定安装在CentOS 7.x及以上版本，CentOS6.x的版本中有Bug！ 请直接挂载课程配套资料的Centos7.x镜像 （1）查看电脑上已经已经安装Docker 1yum list installed | grep docker （2）安装docker 1yum -y install docker （3）安装后查看docker版本 1docker -v 2.2 Docker守护进程相关命令概要： 启动docker服务 停止docker服务 重启docker服务 查看docker服务状态 开机启动docker服务 查看docker概要信息 详解： systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 2.3 镜像加速的两个方案默认情况，将从docker hub（https://hub.docker.com/）下载docker镜像太慢，一般都会配置镜像加速器； 方案一：中科大中国科学技术大学(ustc)是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vim /etc/docker/daemon.json 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;] &#125; 方案二：阿里云如果中科大镜像加载速度很慢，建议配置阿里云镜像加速，这个镜像仓库如果不好使，可以自己从阿里云上申请！速度杠杠的~ 123&#123; &quot;registry-mirrors&quot;: [&quot;https://3ad96kxd.mirror.aliyuncs.com&quot;] &#125; 必须要注册，每个人分配一个免费的docker镜像加速地址，速度极快 配置完成记得刷新配置 12sudo systemctl daemon-reload sudo systemctl restart docker 三、Docker常用命令 3.1 镜像相关命令概要 查看镜像 docker images 搜索镜像 docker search imageName 拉取镜像 docker pull imageName：version 删除镜像 docker rmi imageId rmi–&gt;remove Image 3.1.1 查看镜像 查看本地所有镜像 1docker images 这些镜像都是存储在Docker宿主机的&#x2F;var&#x2F;lib&#x2F;docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索；&#x3D;&#x3D;注意，必须确保当前系统能联网&#x3D;&#x3D; 1docker search 镜像名称 3.1.3 拉取镜像拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 ​ 删除之前要确认此镜像已经没有被容器在使用，如果存在正在运行的docker容器，删除会报错“Error: container_delete: Impossible to remove a running container, please stop it fifirst” 12docker images -q #查看所有镜像的IDdocker rmi `docker images -q` #批量删除镜像 3.2 容器相关命令概要 查看容器 创建容器：交互式、守护式 进入容器 启动容器 停止容器 删除容器 3.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器（查看正在运行的和已经停止运行的） 12docker ps –adocker ps -all 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 3.2.2 创建与启动容器 创建容器命令： 1docker run 参数 镜像名称:镜像标签 /bin/bash 创建容器常用的参数说明： 1234567891011121314## 命令参数详解-i：表示运行容器,如果不加该参数那么只是通过镜像创建容器，而不启动。-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端(如果 只加it两个参数，创建后就会自动进去容器)。-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器）。--name :为创建的容器命名。-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录 或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射，例如： 可以将Docker中Tomcat容器的8080端口映射到宿主机上的某一个端口8080，那么以后访问tomcat只需 要：http://宿主机的IP：8080/进入容器之后，初始化执行的命令：/bin/bash；可写可不写 （1）交互式容器使用交互式运行容器，容器运行后直接进入到容器内部，退出容器内部后，容器直接关闭 只有第一次才会这样，以后再启动容器就是一个守护式的。 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式容器1docker run -di --name=容器名称 镜像名称(或镜像ID):标签 /bin/bash （3）登入容器&#x2F;进入容器目录1docker exec -it 容器名称 (或者容器ID) /bin/bash 注意：这里的登陆容器之后执行的脚本&#x2F;bin&#x2F;bash必须写 3.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将宿主机的文件拷贝到容器内可以使用cp命令 12345678docker cp 需要拷贝的文件或目录 容器名称:容器目录#新建一个空文件touch latou.html#拷贝到tomcat容器的webapps目录下docker cp lagou.html 59b35c0bbe6d:/usr/local/tomcat/webapps#切换到tomcat容器中查看docker exec -it tomcat容器ID /bin/bash 也可以将文件从容器内拷贝出来 1234docker cp 容器名称:容器目录 需要拷贝的文件或目录#将copy到tomcat容器的文件再copy出来docker cp 59b35c0bbe6d:/usr/local/tomcat/webapps/lagou.html ./ 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录 例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; 容器名称（容器ID） 3.2.7 删除容器删除指定的容器，正在运行的容器无法删除 1234#删除容器 docker rm 容器名称（容器ID） #删除镜像 docker rmi 镜像ID(镜像名称) 问题：是否可以删除正在运行的容器？ 四、Docker数据卷（Volumes）4.1 数据卷概述数据卷是宿主机中的一个目录或文件，当容器目录和数据卷目录绑定后，对方的修改会立即同步。 一个数据卷可以被多个容器同时挂载，一个容器也可以被挂载多个数据卷。 简单来说数据卷本质其实是共享文件夹，是宿主机与容器间数据共享的桥梁。 数据卷作用 容器数据持久化 外部机器和容器间接通信 容器之间数据交换 4.2 数据卷配置方式（1）1个容器挂载1个数据卷创建启动容器时，使用 –v 参数 设置数据卷 1docker run ... –v 宿主机目录(文件):容器内目录(文件) ... 注意事项： 目录必须是绝对路径 如果宿主机目录不存在，会自动创建 可以挂载多个数据卷 案例： 1234#拉取centos镜像docker pull centos:7#安装启动容器并挂载docker run -di --name=c1 -v /root/host_data1:/root/c1_data centos:7 /bin/bash （2）查看容器已挂载的数据集我们可以通过以下命令，查看容器中挂载的数据卷 1docker inspect 容器名称（容器ID） （3）1个容器挂载多个数据卷我们可以通过以下命令，挂载多个数据卷 1docker run -di --name=c1 -v /root/host_data1:/root/c1_data1 -v /root/host_data2:/root/c1_data2 centos:7 /bin/bash （4）多个容器挂载一个数据卷多个容器挂载1个数据卷，实现数据共享 12docker run -di --name=c2 -v /root/host_data_common:/root/c2_data centos:7docker run -di --name=c3 -v /root/host_data_common:/root/c3_data centos:7 多个容器挂载1个容器(这个容器挂载1个数据卷) 12345##创建启动c3数据卷容器，使用 –v 参数 设置数据卷docker run -di --name=c3 -v /root/host_data_common:/root/c3_data centos:7 /bin/bash##创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷docker run -di --name=c1 --volumes-from c3 centos:7 /bin/bashdocker run -di --name=c2 --volumes-from c3 centos:7 /bin/bash 五、在docker中部署软件5.1 MySQL部署5.1.1 实现步骤 搜索MySQL镜像 拉取MySQL镜像 创建容器、设置端口映射、设置数据卷 进入容器操作mysql 使用Navicat连接MySQL 5.1.2 实现过程 搜索mysql镜像 1docker search mysql 拉取mysql镜像 1docker pull mysql:5.7 创建容器，设置端口映射、目录映射 1docker run -di --name=mysql -p 3307:3306 -v /root/mysql/logs:/logs -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 参数说明： -p 3307:3306：将容器的 3306 端口映射到宿主机的 3307 端口。 -v &#x2F;root&#x2F;mysql&#x2F;logs:&#x2F;logs：将主机目录(&#x2F;root&#x2F;mysql)下的 logs 目录挂载到容器中的&#x2F;logs。日志目录 -v &#x2F;root&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ：将宿主机目录(&#x2F;root&#x2F;mysql)下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 。数据目录 **-e MYSQL_ROOT_PASSWORD&#x3D;123456：**初始化 root 用户的密码。 进入容器，操作mysql 1docker exec –it c_mysql /bin/bash 使用Navicat连接容器中的mysql 因为我们做了端口映射，所以连接的是192.168.200.128:3307 5.2 Tomcat部署5.2.1 实现步骤 搜索Tomcat镜像 拉取Tomcat镜像 创建容器、设置端口映射、设置数据卷 向Tomcat中部署服务 使用外部机器访问Tomcat，测试部署服务 5.2.2 实现过程 搜索tomcat镜像 1docker search tomcat 拉取tomcat镜像 1docker pull tomcat:8-jdk8 创建容器，设置端口映射、目录映射 1docker run -di --name=c_tomcat -p 8080:8080 -v /root/tomcat/webapps:/usr/local/tomcat/webapps tomcat:8-jdk8 参数说明： **-p 8080:8080：**将容器的8080端口映射到主机的8080端口 **-v &#x2F;root&#x2F;tomcat&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps：**将主机目录(&#x2F;root&#x2F;tomcat&#x2F;webapps)挂载到容器的webapps 向Tomcat中部署服务，使用FinalShell文件上传 使用外部机器访问Tomcat，测试部署服务 5.3 Nginx部署5.2.1 实现步骤 搜索Nginx镜像 1docker search Nginx 拉取Nginx镜像 1docker run -di --name=mynginx -p 80:80 nginx 测试访问：http://192.168.200.128:80 5.4 Redis部署5.2.1 实现步骤 搜索Redis镜像 拉取Redis镜像 创建容器、设置端口映射 使用外部机器连接Redis，测试 5.2.2 实现过程 搜索redis镜像 1docker search redis 拉取redis镜像 1docker pull redis 创建容器，设置端口映射 1docker run -id --name=c_redis -p 6379:6379 redis 使用外部机器连接redis，测试 六、备份与迁移应用场景： ​ 开发环境Docker，在Docker中安装很多的容器，进行对应的配置，将Docker中的运行的容器持久化为镜像，将对应的镜像安装到生产环境中。 将开发环境下的Docker中对应的容器持久化为镜像 将镜像保存为一个压缩包，发送到生产环境服务器中 生产环境中需要将压缩包–&gt;镜像–&gt;容器 6.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1234docker commit &#123;正在运行容器名称/容器ID&#125; &#123;镜像名称&#125;:&#123;镜像标签&#125; &#123;ImageName&#125; : &#123;Tag&#125;# 例如docker commit dbc261edcdff redis:version_lagou_1.0.0 镜像标签如果不写默认为latest 6.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 12345docker save -o &#123;压缩包存放路径&#125; &#123;镜像名称/镜像ID&#125;# 举例docker save -o redis.tar redis:version_lagou_1.0.0 #压缩包在生产环境下会还原为一个 image，还原之后的name和tag# -o :输出到的文件 6.3 镜像恢复与迁移首先我们先删除掉c_tomcat_bak镜像 然后执行此命令进行恢复 1234docker load -i &#123;备份的镜像文件&#125;# 举例docker load -i redis.tar# -i :指定导入的文件 执行后再次查看镜像，可以看到镜像已经恢复，可以再次运行测试 1docker run -di --name=mytomcat -p 8081:8080 -v /root/tomcat/webapps/:/usr/local/tomcat/webapps redis:version_lagou_1.0.0","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Drone+Github搭建自动化流水线","slug":"Drone-Github搭建自动化流水线","date":"2021-07-30T02:31:53.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2021/07/30/Drone-Github搭建自动化流水线/","link":"","permalink":"http://yournotes.cn/2021/07/30/Drone-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E6%B0%B4%E7%BA%BF/","excerpt":"","text":"一、前言 最近开始写一个自用网盘的小项目，准备会一直去做维护更新，正好去了解下这个做CI&#x2F;CD的整个流程，随便记录下第一次搭建过程 二、查看官网第一步的话还是先看看Drone的官方文档，地址：https://docs.drone.io/ 在上面看的到有结合Github的安装向导，打开就可以按照上面进行。 三、工具准备首先是需要安装docker，我这里会使用docker-compose进行编排，所以需要安装docker-compose 我这边环境是CentOS7.6 3.1 准备docker12# 查看电脑上已安装的dockeryum list installed | grep docker 我这边已经安装了，没安装使用下面命令进行安装 1234# 安装yum -y install docker# 查看版本docker -v 其他关于docker的了解，可以看这篇 https://yournotes.cn/2021/08/01/Docker%E5%9F%BA%E7%A1%80/ 3.2 准备docker-compose这里只介绍一个安装方式，也是比较方便快捷的。直接本地到github选择docker-compose版本 地址：https://github.com/docker/compose/releases 1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 选择版本修改指令里的版本号即可（1.29.2），也可直接下载传到服务器 12# 赋予执行权限sudo chmod +x /usr/local/bin/docker-compose 四、环境准备使用docker-compose安装Drone之前，先准备Drone服务的域名这个需要在配置Github认证的时候写入，只有这样在搭建好后域名访问Drone才会触发Github认证。 4.1 配置Drone服务域名 我这边就添加个drone.yournotes.cn的解析。 4.2 配置Github认证在设置里面有个开发者设置选中， 在OAuth Apps当中即可配置认证应用，我这边已经添加了 打开New OAuth App里面就几样东西 注册之后会有Client ID与Client secrets，复制保存下来之后在配置Drone会用 4.3 配置RPC密钥这个是Drone的runner与server交互需要配置的，通过openssl rand -hex 16指令生成密钥，在之后两边配置一样即可 五、开始安装先截取文档上的安装方式，如下图。它是使用docker进行拉取镜像然后带环境变量启动。下面我这边就用docker-compose进行统一编排。 Server安装 Runner安装 按照文档上这样也可以，分别用docker启动配置好服务地址、密钥等必备的参数。 我这边使用docker-compose，下面分别是.env文件与docker-compose.yml文件。把里面要配置的单独拿出来做了个环境变量的文件.env 将.env文件配置好，再把两个文件传入服务器在同一个文件夹下 执行docker-compose up -d 启动即可 12345678# .envDRONE_GITHUB_CLIENT_ID=你的github Client_IDDRONE_GITHUB_CLIENT_SECRET=你的github Client secrets DRONE_RPC_SECRET=你生成的RPC密钥DRONE_SERVER_HOST=你的Drone服务域名DRONE_SERVER_PROTO=http （可选https） DRONE_RPC_PROTO=http （可选https） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# docker-compose.ymlversion: &#x27;2&#x27;services: drone-server: image: drone/drone:latest container_name: drone-server networks: - dronenet # 让drone-server和drone-agent处于一个网络中，方便进行RPC通信 ports: - &#x27;10081:80&#x27; # Web管理面板的入口 PROTO=http 时使用该端口 - &#x27;10082:443&#x27; # Web管理面板的入口 PROTO=https 时使用该端口 - &#x27;10083:9000&#x27; # RPC服务端口 volumes: - /var/run/docker.sock:/var/run/docker.sock # docker.sock [1] - /var/data/drone/:/var/lib/drone # drone数据存放路径 environment: - DRONE_AGENTS_ENABLED=true # 使用Runner # github相关 - DRONE_GITHUB_SERVER=https://github.com # github的地址 - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125; # 上一步获得的ClientID - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125; # 上一步获得的ClientSecret # 上面三个及下面这三个是必备的 - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET&#125; # RPC秘钥 [2] - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST&#125; # RPC域名(在一个实例上可以不用) - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO&#125; # git webhook使用的协议(我建议http) - DRONE_OPEN=true # 开发drone - DRONE_DATABASE_DATASOURCE=/var/lib/drone/drone.sqlite # 数据库文件 - DRONE_DATABASE_DRIVER=sqlite3 # 数据库驱动，我这里选的sqlite - DRONE_DEBUG=true # 调试相关，部署的时候建议先打开 - DRONE_LOGS_DEBUG=true # 调试相关，部署的时候建议先打开 - DRONE_LOGS_TRACE=true # 调试相关，部署的时候建议先打开 - DRONE_USER_CREATE=username:TheWinds，admin:true # 初始管理员用户 - TZ=Asia/Shanghai # 时区 restart: always drone-agent: image: drone/agent:latest container_name: drone-agent networks: - dronenet # 让drone-server和drone-agent处于一个网络中，方便进行RPC通信 depends_on: - drone-server volumes: - /var/run/docker.sock:/var/run/docker.sock # docker.sock [1] environment: - DRONE_RPC_SERVER=http://drone-server # RPC服务地址 - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET&#125; # RPC秘钥 - DRONE_RPC_PROTO=$&#123;DRONE_RPC_PROTO&#125; # RPC协议(http || https) - DRONE_RUNNER_CAPACITY=2 # 最大并发执行的 pipeline 数 - DRONE_DEBUG=true # 调试相关，部署的时候建议先打开 - DRONE_LOGS_DEBUG=true # 调试相关，部署的时候建议先打开 - DRONE_LOGS_TRACE=true # 调试相关，部署的时候建议先打开 - TZ=Asia/Shanghai restart: alwaysnetworks: dronenet: # 让drone-server和drone-agent处于一个网络中，方便进行RPC通信 六、简单测试 按照上面成功启动Drone，接下来就可以访问看看了。我这边配置的http是10081端口。所以得加上端口号，注意阿里云上的安全组也要把这些端口放开。 首次访问应该是如上图，再选中继续就可进行GitHub认证，GitHub认证后会返回到之前在GitHub上填写的地址 因为我这边是10081端口，因此这里得写成 drone.yournotes.cn:10081/login ，否则就找不到了 这里选一个项目开启自动流水线，点击一个项目，进入如下页面点保存即可，它将在code仓库配置webhook，当代码仓库更新时会自动执行.drone.yml下的指令 保存后，我们在代码仓库添加一个.drone.yml的文件，做一个简单的在控制台打印hello world的操作 steps下就是安排的步骤，使用的镜像是alpine（一个轻量的Linux），使用这个linux执行了echo指令。 之后是做自动化的打包部署，因此步骤会有多个，也会用到maven镜像等，这里只是简单测试下，是否会执行安排的指令。 不出意外的话我们把文件提交，drone流水线就开始自动进行了 第一步就是clone代码，第二步就是在steps的第一个步骤greeting（alpine执行两个echo）","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"折腾","slug":"日常/折腾","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"日常折腾","slug":"日常折腾","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"}]},{"title":"Spring Cloud微服务详解","slug":"Spring-Cloud微服务详解","date":"2021-07-22T03:58:17.000Z","updated":"2025-04-17T08:34:52.017Z","comments":true,"path":"2021/07/22/Spring-Cloud微服务详解/","link":"","permalink":"http://yournotes.cn/2021/07/22/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"超长警告！！！善用目录！！！ [TOC] 一、微服务架构1.1 互联网应用架构演进随着互联⽹的发展，⽤户群体逐渐扩大，⽹站的流量成倍增⻓，常规的单体架构已⽆法满⾜请求压⼒和业务的快速迭代，架构的变化势在必⾏。下⾯我们就以拉勾网的架构演进为例，从最开始的单体架构分析，⼀步步的到现在的微服务架构。 淘宝：LAMP，Linux、Apache、MySQL、PHP 1.1.1 单体应用架构在诞⽣之初，拉勾的⽤户量、数据量规模都⽐较⼩，项目所有的功能模块都放在一个工程中编码、编译、打包并且部署在一个Tomcat容器中的架构模式就是单体应用架构，这样的架构既简单实 ⽤、便于维护，成本⼜低，成为了那个时代的主流架构⽅式。 优点： 高效开发：项⽬前期开发节奏快，团队成员少的时候能够快速迭代 架构简单：MVC架构，只需要借助IDE开发、调试即可 易于测试：只需要通过单元测试或者浏览器完成 易于部署：打包成单⼀可执⾏的jar或者打成war包放到容器内启动 单体架构的应用比较容易部署、测试， 在项目的初期，单体应用可以很好地运行。然而，随着需求的不断增加， 越来越多的人加入开发团队，代码库也在飞速地膨胀。慢慢地，单体应用变得越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高。 缺点： 可靠性差： 某个应用Bug，例如死循环、内存溢出等， 可能会导致整个应用的崩溃 复杂性高： 以一个百万行级别的单体应用为例，整个项目包含的模块多、模块的边界模糊、 依赖关系不清晰、 代码质量参差不齐、 混乱地堆砌在一起。使得整个项目非常复杂。 扩展能力受限： 单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU； 有的模块则是IO密集型的，需要更大的内存。 由于这些模块部署在一起，不得不在硬件的选择上做出妥协。 业务量上涨之后，单体应用架构进一步丰富变化，比如应用集群部署、使用Nginx进行负载均衡、增加缓存服务器、增加文件服务器、数据库集群并做读写分离等，通过以上措施增强应对高并发的能力、应对一定的复杂业务场景，但依然属于单体应用架构。 1.1.2 垂直应用架构为了避免上⾯提到的那些问题，开始做模块的垂直划分，做垂直划分的原则是基于现有的业务特性来做，核心目标标第⼀个是为了业务之间互不影响，第⼆个是在研发团队的壮⼤后为了提⾼效率，减少组件之间的依赖。 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进⾏优化 ⽅便⽔平扩展，负载均衡，容错率提⾼ 系统间相互独⽴，互不影响，新的业务迭代时更加⾼效 缺点： 服务之间相互调⽤，如果某个服务的端⼝或者ip地址发⽣改变，调⽤的系统得⼿动改变 搭建集群之后，实现负载均衡⽐较复杂，如：内⽹负载，在迁移机器时会影响调⽤⽅的路 由，导致线上故障 服务之间调⽤⽅式不统⼀，基于 httpclient 、 webservice ，接⼝协议不统⼀ 服务监控不到位：除了依靠端⼝、进程的监控，调⽤的成功率、失败率、总耗时等等这些监 控指标是没有的 1.1.3 SOA应用架构​ 在做了垂直划分以后，模块随之增多，维护的成本在也变⾼，⼀些通⽤的业务和模块重复的越来越多，为了解决上⾯提到的接⼝协议不统⼀、服务⽆法监控、服务的负载均衡，引⼊了阿⾥巴巴开源的Dubbo ，⼀款⾼性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。它提供了三⼤核⼼能力：⾯向接⼝的远程⽅法调⽤，智能容错和负载均衡，以及服务⾃动注册和发现。 ​ SOA (Service-Oriented Architecture)，即面向服务的架构。根据实际业务，把系统拆分成合适的、独立部署的模块，模块之间相互独立（通过Webservice&#x2F;Dubbo等技术进行通信）。 ​ 优点：分布式、松耦合、扩展灵活、可重用。 ​ 缺点：服务抽取粒度较大、服务调用方和提供方耦合度较高（接口耦合度） 1.1.4 微服务应用架构微服务架构可以说是SOA架构的一种拓展，这种架构模式下它拆分粒度更小、服务更独立。把应用拆分成为一个个微小的服务，不同的服务可以使用不同的开发语言和存储，服务之间往往通过Restful等轻量级通信。微服务架构关键在于微小、独立、轻量级通信。 微服务是在 SOA 上做的升华粒度更加细致，微服务架构强调的⼀个重点是业务需要彻底的组件化和服务化 微服务架构和SOA架构相似又不同 ​ 微服务架构和SOA架构很明显的一个区别就是服务拆分粒度的不同，但是对于拉勾的架构发展来说，我们所看到的SOA阶段其实服务拆分粒度相对来说已经比较细了（超前哦！），所以上述拉勾SOA到拉勾微服务，从服务拆分上来说变化并不大，只是引入了相对完整的新一代Spring Cloud微服务技术。自然，上述我们看到的都是拉勾架构演变的阶段结果，每一个阶段其实都经历了很多变化，拉勾的服务拆分其实也是走过了从粗到细，并非绝对的一步到位。 举个拉勾案例来说明SOA和微服务拆分粒度不同 ​ 在SOA架构的初期，“简历投递模块”和“人才搜索模块”都有简历内容展示的需求，只不过说可能略有区别，一开始在两个模块中各维护了一套简历查询和展示的代码；后期我们将服务更细粒度拆分，拆分出简历基础服务，那么不同模块调用这个基础服务即可。 1.2 微服务架构体现的思想及优缺点​ 微服务架构设计的核心思想就是**“微”**，拆分的粒度相对比较小，这样的话单一职责、开发的耦合度就会降低、微小的功能可以独立部署扩展、灵活性强，升级改造影响范围小。 微服务架构的优点： 微服务很小，便于特定业务功能的聚焦 微服务很小，每个微服务都可以被一个小团队单独实施（开发、测试、部署上线、运维），团队合作一定程度解耦，便于实施敏捷开发 微服务很小，便于重用和模块之间的组装 微服务很独立，那么不同的微服务可以使用不同的语言开发，松耦合 微服务架构下，我们更容易引入新技术 微服务架构的缺点 微服务架构下，分布式复杂难以管理，当服务数量增加，管理将越加复杂 微服务架构下，分布式链路跟踪难等 1.3 微服务架构当中的核心概念 服务注册与服务发现 列如： ​ 职位搜索 ——》简历服务 ​ 服务提供者 : 简历服务 ​ 服务消费者 : 职位搜索 **服务注册：**服务提供者将所提供服务的信息（服务器IP和端口、服务访问协议等）注册&#x2F;登记到注册中心 **服务发现：**服务消费者能够从注册中心获取到较为实时的服务列表，然后根究一定的策略选择一个服务访问 负载均衡 负载均衡即将请求压力分配到多个服务器（应用服务器、数据库服务器等），以此来提高服务的性能、可靠性 熔断 熔断即断路保护。微服务架构中，如果下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。 链路追踪 微服务架构越发流行，一个项目往往拆分成很多个服务，那么一次请求就需要涉及到很多个服务。不同的微服务可能是由不同的团队开发、可能使用不同的编程语言实现、整个项目也有可能部署在了很多服务器上（甚至百台、千台）横跨多个不同的数据中心。所谓链路追踪，就是对一次请求涉及的很多个服务链路进行日志记录、性能监控 API网关 微服务架构下，不同的微服务往往会有不同的访问地址，客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信可能出现： 1）客户端需要调用不同的url地址，增加了维护调用难度 2）在一定的场景下，也存在跨域请求的问题（前后端分离就会碰到跨域问题，原本我们在后端采用Cors就能解决，现在利用网关，那么就放在网关这层做好了） 3）每个微服务都需要进行单独的身份认证 那么，API网关就可以较好的统一处理上述问题，API请求调用统一接入API网关层，由网关转发请求。API网关更专注在安全、路由、流量等问题的处理上（微服务团队专注于处理业务逻辑即可），它的功能比如： 统一接入（路由） 安全防护（统一鉴权，负责网关访问身份认证验证，与“访问认证中心”通信，实际认证业务逻辑交移“访问认证中心”处理） 黑白名单（实现通过IP地址控制禁止访问网关功能，控制访问） 协议适配（实现通信协议校验、适配转换的功能） 流量管控（限流） 长短链接支持 容错能力（负载均衡） 二、Spring Cloud概述2.1 什么是Spring Cloud？**[百度百科]**Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 Spring Cloud是一系列框架的有序集合（Spring Cloud是一个规范） 开发服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等 利用Spring Boot的开发便利性简化了微服务架构的开发（自动装配） 这里，我们需要注意，Spring Cloud其实是一套规范，是一套用于构建微服务架构的规范，而不是一个可以拿来即用的框架（所谓规范就是应该有哪些功能组件，然后组件之间怎么配合，共同完成什么事情）。在这个规范之下第三方的Netflix公司开发了一些组件、Spring官方开发了一些框架&#x2F;组件，包括第三方的阿里巴巴开发了一套框架&#x2F;组件集合Spring Cloud Alibaba，这些才是Spring Cloud规范的实现。 Netflix搞了一套 ，简称SCN Spring Cloud 吸收了Netflix公司的产品基础之上自己也搞了几个组件 阿里巴巴在之前的基础上搞出了一堆微服务组件,Spring Cloud Alibaba（SCA） 2.2 Spring Cloud解决了什么问题？​ Spring Cloud 规范及实现意图要解决的问题其实就是微服务架构实施过程中存在的一些问题，比如微服务架构中的服务注册发现问题、网络问题（比如熔断场景）、统一认证安全授权问题、负载均衡问题、链路追踪等问题。 Distributed&#x2F;versioned configuration （分布式&#x2F;版本化配置） Service registration and discovery （服务注册和发现） Routing （智能路由） Service-to-service calls （服务调用） Load balancing （负载均衡） Circuit Breakers （熔断器） Global locks （全局锁） Leadership election and cluster state （ 选举与集群状态管理） Distributed messaging （分布式消息传递平台） 2.3 Spring Cloud架构​ 如前所述，Spring Cloud是一个微服务相关规范，这个规范意图为搭建微服务架构提供一站式服务，采用组件（框架）化机制定义一系列组件，各类组件针对性的处理微服务中的特定问题，这些组件共同来构成Spring Cloud微服务技术栈 2.3.1 Spring Cloud核心组件​ Spring Cloud 生态圈中的组件，按照发展可以分为第一代 Spring Cloud组件和第二代 SpringCloud组件。 组件 第一代Spring Cloud(Netflix,SCN) 第二代Spring Cloud(Alibaba,SCA) 注册中心 Netflix Eureka 阿里 Nacos 客户端负载均衡 Netflix Ribbon 阿里Dubbo LB、官方Loadbalancer 熔断器 Netflix Hystrix 阿里 Sentinel 网关 Netflix Zuul(性能一般未来将退出Spring Could生态圈) 官方Spring Cloud Gateway 配置中心 官方Spring Cloud Config 阿里Nacos、携程Apollo 服务调用 Netflix Feign 阿里Dubbo RPC 消息驱动 官方 Spring Cloud Stream 链路追踪 官方 Spring Cloud Sleuth/Zipkin 阿里 seata分布式事务方案 2.3.2 Spring Cloud体系结构（组件协同工作机制） Spring Cloud中的各组件协同工作，才能够支持一个完整的微服务架构。比如 注册中心负责服务的注册与发现，很好将各服务连接起来 API网关负责转发所有外来的请求 断路器负责监控服务之间的调用情况，连续多次失败进行熔断保护。 配置中心提供了统一的配置信息管理服务,可以实时的通知各个服务获取最新的配置信息 2.4 Spring Cloud与Dubbo进行对比​ Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，基于RPC调用，对于目前使用率较高的Spring Cloud Netflix来说，它是基于HTTP的，所以效率上没有Dubbo高，但问题在于Dubbo体系的组件不全，不能够提供一站式解决方案，比如服务注册与发现需要借助于Zookeeper等实现，而SpringCloud Netflix则是真正的提供了一站式服务化解决方案，且有Spring大家族背景。 ​ 前些年，Dubbo使用率高于SpringCloud，但目前Spring Cloud在服务化&#x2F;微服务解决方案中已经有了非常好的发展趋势。 2.5 Spring Cloud与Spring Boot的关系​ Spring Cloud 只是利用了Spring Boot 的特点，让我们能够快速的实现微服务组件开发，否则不使用Spring Boot的话，我们在使用Spring Cloud时，每一个组件的相关Jar包都需要我们自己导入配置以及需要开发人员考虑兼容性等各种情况。所以Spring Boot是我们快速把Spring Cloud微服务技术应用起来的一种方式。 三、案例准备3.1 案例说明本部分我们按照普通方式模拟一个微服务之间的调用，后续我们将一步步使用Spring Cloud的组件对案例进行改造。 需求： 完整业务流程图： 3.2 案例数据库环境准备商品信息表： 12345678910CREATE TABLE products( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50), #商品名称 price DOUBLE, flag VARCHAR(2), #上架状态 goods_desc VARCHAR(100), #商品描述 images VARCHAR(400), #商品图片 goods_stock INT, #商品库存 goods_type VARCHAR(20) #商品类型 ); 3.3 案例工程​ 我们基于SpringBoot来构造工程环境，我们的工程模块关系如下所示： 3.3.1 页面静态化微服务在Idea中新建module，命名为mycloud pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 &lt;packaging&gt;pom&lt;/packaging&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.3.2 公共组件微服务 在公共组件微服务中引入数据库驱动及mybatis-plus 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;mycloud&lt;/artifactId&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;service-common&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--pojo持久化使用--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 生成数据库实体类：com.hao.pojo.Product 12345678910111213141516171819202122232425package com.hao.pojo;import lombok.Data;import javax.persistence.Id;import javax.persistence.Table;/** * @author hao * @date 2022/3/10 11:55 */@Data@Table(name = &quot;product&quot;)public class Product &#123; @Id private Integer id; private String name; private double price; private String flag; private String goodsDesc; private String images; private long goodsStock; private String goodsType;&#125; 3.3.3 商品微服务商品微服务是服务提供者，页面静态化微服务是服务的消费者 创建商品微服务service-product，继承mycloud 1）在商品微服务的pom文件中，引入公共组件坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;artifactId&gt;service-common&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 2）在yml文件中配置端口、应用名、数据库连接等信息 12345678910server: port: 9000 # 后期该微服务多实例，9000（10个以内）Spring: application: name: service-product datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://xxx.xxx.xxx:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: 1234 3）Mapper接口开发 1234567891011121314151617package com.hao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.hao.pojo.Product;/** * @author hao * @date 2022/3/10 12:33 *//** * 现在使用的Mybatis-plus组件，该组件是Mybatis的加强版 * 能够与SpringBoot进行非常友好的整合，对比Mybatis框架只有使用便捷的改变 * 没有具体功能的改变 * 具体使用：让具体的Mapper接口继承BaseMapper即可 */ public interface ProductMapper extends BaseMapper&lt;Product&gt; &#123;&#125; 4）serive层开发 12345678910111213141516171819202122package com.hao.service.impl;import com.hao.mapper.ProductMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.hao.pojo.Product;import com.hao.service.ProductService;/** * @author hao * @date 2022/3/10 12:35 */@Servicepublic class ProductServiceImpl implements ProductService &#123; @Autowired ProductMapper productMapper; @Override public Product getProductById(Integer id) &#123; return productMapper.selectById(id); &#125;&#125; 5）controller层开发 1234567891011121314151617181920212223package com.hao.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.hao.pojo.Product;import com.hao.service.ProductService;/** * @author hao * @date 2022/3/10 12:37 */@RestController@RequestMapping(&quot;/product&quot;)public class ProductController &#123; @Autowired ProductService productService; @RequestMapping(&quot;/query/&#123;id&#125;&quot;) public Product getProduct(@PathVariable Integer id)&#123; return productService.getProductById(id); &#125;&#125; 6）启动类 123456789101112131415161718package com.hao;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author hao * @date 2022/3/10 12:43 */@SpringBootApplication@MapperScan(&quot;com.hao.mapper&quot;)public class ProductApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProductApplication.class); &#125;&#125; 3.3.4 页面静态化微服务1）在pom文件中，引入公共组件依赖 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;mycloud&lt;/artifactId&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;service-page&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;artifactId&gt;service-common&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）在yml文件中配置端口、应用名、数据库连接等信息 12345678910server: port: 9100 # 后期该微服务多实例，9000（10个以内）Spring: application: name: service-page datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://xxx.xxx.xxx:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: 1234 3）编写PageController，在PageController中调用商品微服务对应的URL 12345678910111213141516/** * @author hao * @date 2022/3/10 12:54 */@RestController@RequestMapping(&quot;/page&quot;)public class PageController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/getProduct/&#123;id&#125;&quot;) public Product getProductById(@PathVariable Integer id)&#123; Product product = restTemplate.getForObject(&quot;http://localhost:9000/product/query/&quot;+id,Product.class); System.out.println(&quot;当前是静态化服务，已从商品服务获得数据：&quot; + product); return product; &#125;&#125; 4）编写启动类，注入RestTemplate 1234567891011121314/** * @author hao * @date 2022/3/10 13:00 */@SpringBootApplicationpublic class PageApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PageApplication.class); &#125; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 3.4 案例代码问题分析我们在页面静态化微服务中使用RestTemplate调用商品微服务的商品状态接口时（Restful API 接口）。在微服务分布式集群环境下会存在什么问题呢？怎么解决？ 存在的问题： 在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护。 服务提供者只有一个服务，即便服务提供者形成集群，服务消费者还需要自己实现负载均衡。 在服务消费者中，不清楚服务提供者的状态。 服务消费者调用服务提供者时候，如果出现故障能否及时发现不向用户抛出异常页面？ RestTemplate这种请求调用方式是否还有优化空间？能不能类似于Dubbo那样玩？ 这么多的微服务统一认证如何实现？ 配置文件每次都修改好多个很麻烦！？ …. 上述分析出的问题，其实就是微服务架构中必然面临的一些问题： 服务管理：自动注册与发现、状态监管 服务负载均衡 熔断 远程过程调用 网关拦截、路由转发 统一认证 集中式配置管理，配置信息实时自动更新 这些问题，Spring Cloud 体系都有解决方案 四、第一代Spring Cloud核心组件说明：上面提到网关组件Zuul性能一般，未来将退出Spring Cloud 生态圈，所以这边直接就换成GateWay。 各组件整体结构如下： 从形式上来说，Feign一个顶三，Feign &#x3D; RestTemplate + Ribbon + Hystrix 4.1 Eureka服务注册中心常用的服务注册中心：Eureka、Nacos、Zookeeper、Consul 4.1.1 关于服务注册中心注意：服务注册中心本质上是为了解耦服务提供者和服务消费者。 服务消费者 → 服务提供者 服务消费者 → 服务注册中心 → 服务提供者 ​ 对于任何一个微服务，原则上都应存在或者支持多个提供者（比如商品微服务部署多个实例），这是由微服务的分布式属性决定的。 ​ 更进一步，为了支持弹性扩、缩容特性，一个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态负载均衡机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。 （1）注册中心实现原理 ​ 分布式微服务架构中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不再需要通过硬编码方式得到提供者的地址信息。消费者只需要知道当前系统发布了那些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。 服务提供者启动 服务提供者将相关服务信息主动注册到注册中心 服务消费者获取服务注册信息： pull模式：服务消费者可以主动拉取可用的服务提供者清单 push模式：服务消费者订阅服务（当服务提供者有变化时，注册中心也会主动推送更新后的服务清单给消费者 服务消费者直接调用服务提供者 另外，注册中心也需要完成服务提供者的健康监控，当发现服务提供者失效时需要及时剔除 （2）主流注册中心对比 Zookeeper Dubbo + Zookeeper Zookeeper它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 简单来说zookeeper本质 &#x3D; 存储 + 监听通知。 Zookeeper 用来做服务注册中心，主要是因为它具有节点变更通知功能，只要客户端监听相关服务节点，服务节点的所有变更，都能及时的通知到监听客户端，这样作为调用方只要使用Zookeeper 的客户端就能实现服务节点的订阅和变更通知功能了，非常方便。另外，Zookeeper可用性也可以，因为只要半数以上的选举节点存活，整个集群就是可用的，最少节点数为3。 Eureka 由Netflix开源，并被Pivatal集成到SpringCloud体系中，它是基于 RestfulAPI 风格开发的服务注册与发现组件。 Consul Consul是由HashiCorp基于Go语言开发的支持多数据中心分布式高可用的服务发布和注册服务软件， 采用Raft算法保证服务的一致性，且支持健康检查。 Nacos Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。简单来说Nacos 就是 注册中心 + 配置中心的组合，帮助我们解决微服务开发必会涉及到的服务注册 与发现，服务配置，服务管理等问题。Nacos 是 Spring Cloud Alibaba 核心组件之一，负责服务注册与发现，还有配置。 组件名 语言 CAP 对外暴露接口 Eureka Java AP（自我保护机制，保证可用） HTTP Consul Go CP HTTP/DNS Zookeeper Java CP 客户端 Nacos Java 支持AP/CP切换 HTTP CAP定理又称CAP原则，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），最多只能同时三个特性中的两个，三者不可兼得。 P：分区容错性：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务（一定的要满足的） C：数据一致性：all nodes see the same data at the same time A：高可用：Reads and writes always succeed CAP不可能同时满足三个，要么是AP，要么是CP 4.1.2 服务注册中心组件 Eureka服务注册中心的一般原理、对比了主流的服务注册中心方案，目光聚焦Eureka Eureka基础架构 Eureka交互原理 Eureka 包含两个组件：Eureka Server 和 Eureka Client，Eureka Client是一个Java客户端，用于简化与Eureka Server的交互；Eureka Server提供服务发现的能力，各个微服务启动时，会通过EurekaClient向Eureka Server 进行注册自己的信息（例如网络信息），Eureka Server会存储该服务的信息； 图中us-east-1c、us-east-1d，us-east-1e代表不同的区也就是不同的机房 图中每一个Eureka Server都是一个集群。 图中Application Service作为服务提供者向Eureka Server中注册服务，Eureka Server接受到注册事件会在集群和分区中进行数据同步，Application Client作为消费端（服务消费者）可以从Eureka Server中获取到服务注册信息，进行服务调用。 微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒，默认Eureka Server 90S会将还没有续约的给剔除）以续约自己的信息 Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒） 每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过复制的方式完成服务注册列表的同步 Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者 Eureka通过心跳检测、健康检查和客户端缓存等机制，提高系统的灵活性、可伸缩性和高可用性。 4.1.3 搭建单例Eureka Server服务注册中心实现过程 单实例Eureka Server—&gt;访问管理界面 服务提供者（商品微服务注册到集群） 服务消费者（页面静态化微服务注册到Eureka&#x2F;从Eureka Server获取服务信息） 完成调用 1、搭建Eureka Server服务 my-parent父工程中设置Spring Cloud依赖版本信息 Spring Cloud是一个综合项目，下面有很多子项目，比如Eureka子项目 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 2、my-cloud-eureka工程pom.xml中引入依赖 1234567&lt;dependencies&gt; &lt;!--Eureka server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、在yml文件中配置Eureka Server服务的端口，服务名等信息 1234567891011121314#Eureka server服务端口 server: port: 9200 spring: application: name: my-cloud-eureka # 应用名称，会在Eureka中作为服务的id标识 （serviceId） eureka: instance: hostname: localhost client: service-url: # 客户端与EurekaServer交互的地址，如果是集群，也需要写其它Server的地址 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ register-with-eureka: false # 自己就是服务不需要注册自己 fetch-registry: false #自己就是服务不需要从Eureka Server获取服务信息,默认为true，置为false 4、编写启动类，声明当前服务为Eureka注册中心 123456789101112package com.hao.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication //// 声明本项目是一个Eureka服务 @EnableEurekaServer public class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class,args); &#125;&#125; 5、访问9200端口 6、其他服务注册到Eureka 其他服务pom添加Eureka Client依赖 12345&lt;!--Eureka client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; yml配置Eureka服务端信息 123456789eureka: client: serviceUrl: # eureka server的路径 defaultZone: http://localhost:9200/eureka/ instance: #使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip） prefer-ip-address: true #自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@ 修改启动类 123456789101112@SpringBootApplication @EnableDiscoveryClient //@EnableEurekaClient public class OtherApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OtherApplication.class,args); &#125; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 4.1.4 搭建Eureka Server高可用集群在互联网应用当中，服务实例很少有单个的。 如果EurekaServer只有一个实例，该实例挂掉，正好微服务消费者本地缓存列表中的服务实例也不可用，那么这个时候整个系统都会受到影响。 在生产环境当中，我们会配置Eureka Server集群实现高可用。Eureka Server集群之中的节点通过点对点（P2P）通信的方式共享服务注册表。我们开启两台Eureka Server来搭建集群。 由于是在个人计算机中进行测试很难模拟多主机的情况，Eureka配置Server集群时需要执行host地址。所以需要修改个人电脑的host地址 12127.0.0.1 eurekaA127.0.0.1 eurekaB 将my-cloud-eureka复制一份为my-cloud-eureka9201 1、修改eureka服务的配置 eurekaA 12345678910111213server: port: 9200 spring: application: name: my-cloud-eureka # 应用名称，会在Eureka中作为服务的id标识 （serviceId） eureka: instance: hostname: eurekaA client: register-with-eureka: true fetch-registry: true serviceUrl: defaultZone: http://eurekaA:9200/eureka,http://eurekaB:9201/eureka eurekaB 12345678910111213server: port: 9201spring: application: name: my-cloud-eureka # 应用名称，会在Eureka中作为服务的id标识 （serviceId） eureka: instance: hostname: eurekaA client: register-with-eureka: true fetch-registry: true serviceUrl: defaultZone: http://eurekaA:9200/eureka,http://eurekaB:9201/eureka 商品微服务 123456789101112131415server: port: 9000Spring: application: name: service-product datasource: ...eureka: client: serviceUrl: # 把eureka集群中的所有url都填写了进来，也可以只写一台，因为各个 eureka server可以同步注册表 defaultZone: http://eurekaA:9200/eureka,http://eurekaB:9201/eureka instance: prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@ 页面静态化服务 1234567891011121314151617server: port: 9100Spring: application: name: service-page datasource: ...eureka: client: serviceUrl: # 把eureka集群中的所有url都填写了进来，也可以只写一台，因为各个 eureka server可以同步注册表 defaultZone: http://eurekaA:9200/eureka,http://eurekaB:9201/eureka instance: #使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip） prefer-ip-address: true #自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@ 消费者调用提供者 改造页面静态化微服务：之前是直接通过RestTemplate写死URL进行调用，现在通过Eureka方式进行调用。 123456789101112131415161718192021222324@RestController @RequestMapping(&quot;/page&quot;) public class PageController &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; @RequestMapping(&quot;/getProduct01/&#123;id&#125;&quot;) public Product findDataById(@PathVariable Integer id)&#123; //1.获得Eureka中注册的service-product实例集合 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;service-product&quot;); //2.获得实例集合中的第一个 ServiceInstance instance = instances.get(0); //3.根据实例信息拼接IP地址 String host = instance.getHost(); int port = instance.getPort(); String url = &quot;http://&quot;+host+&quot;:&quot;+port+&quot;/product/query/&quot;+id; //4.调用 Product product = restTemplate.getForObject(url, Product.class); System.out.println(&quot;从service-product获得product对象:&quot;+product); return product; &#125;&#125; 4.1.5 Eureka细节详解（1）Eureka元数据详解Eureka的元数据有两种：标准元数据和自定义元数据。 **标准元数据：**主机名、IP地址、端口号等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。 **自定义元数据：**可以使用eureka.instance.metadata-map配置，符合KEY&#x2F;VALUE的存储格式。这些元数据可以在远程客户端中访问。 12345678910instance: #使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip） prefer-ip-address: true #自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@ metadata-map: ip: 192.168.200.128 port: 10000 user: hao pwd: 123456 我们可以在程序中可以使用DiscoveryClient 获取指定微服务的所有元数据信息 12345678910111213141516171819202122@RestController @RequestMapping(&quot;/metadata&quot;) public class MetadataController &#123; @Autowired private DiscoveryClient discoveryClient; @RequestMapping(&quot;show&quot;) public String showMetadata()&#123; String result = &quot;&quot;; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;service-page&quot;); for (ServiceInstance instance:instances) &#123; //获取服务元数据 Map&lt;String, String&gt; metadata = instance.getMetadata(); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = metadata.entrySet(); for (Map.Entry&lt;String,String&gt; entry : entries)&#123; String key = entry.getKey(); String value = entry.getValue(); result+=&quot;key:&quot;+key+&quot;,value:&quot;+value; &#125; &#125; return result; &#125;&#125; 标准元素据直接在instance属性下，而自定义元素据在instances的metadata当中 （2）Eureka客户端详解服务提供者（也是Eureka客户端）要向EurekaServer注册服务，并完成服务续约等工作 服务注册详解（服务提供者） 当我们导入了eureka-client依赖坐标，配置Eureka服务注册中心地址 服务在启动时会向注册中心发起注册请求，携带服务元数据信息 Eureka注册中心会把服务的信息保存在Map中。 服务续约详解（服务提供者） 服务每隔30秒会向注册中心续约(心跳)一次（也称为报活），如果没有续约，租约在90秒后到期，然后服务会被失效。每隔30秒的续约操作我们称之为心跳检测 Eureka Client ：30S续约一次，在Eureka Server更新自己的状态 (Client端进行配置) Eureka Server：90S还没有进行续约，将该微服务实例从服务注册表（Map）剔除 (Client端进行配置) Eureka Client： 30S拉取服务最新的注册表并缓存到本地 (Client端进行配置) 往往不需要我们调整这两个配置 1234567#向Eureka服务中心集群注册服务 eureka: instance: # 租约续约间隔时间，默认30秒 lease-renewal-interval-in-seconds: 30 # 租约到期，服务时效时间，默认值90秒,服务超过90秒没有发生心跳，EurekaServer会将服务从列表移除 lease-expiration-duration-in-seconds: 90 获取服务列表（服务注册表）详解（服务消费者） 每隔30秒服务会从注册中心中拉取一份服务列表，这个时间可以通过配置修改。往往不需要我们调整 12345#向Eureka服务中心集群注册服务 eureka: client: # 每隔多久拉取一次服务列表 registry-fetch-interval-seconds: 30 服务消费者启动时，从 EurekaServer服务列表获取只读备份，缓存到本地 每隔30秒，会重新获取并更新数据 每隔30秒的时间可以通过配置eureka.client.registry-fetch-interval-seconds修改 （3）Eureka服务端详解服务下线： 当服务正常关闭操作时，会发送服务下线的REST请求给EurekaServer。 服务中心接受到请求后，将该服务置为下线状态 失效剔除 Eureka Server会定时（间隔值是eureka.server.eviction-interval-timer-in-ms，默认60s）进行检查，如果发现实例在在一定时间（此值由客户端设置的eureka.instance.lease-expiration-duration-in\u0002seconds定义，默认值为90s）内没有收到心跳，则会注销此实例。 自我保护机制 自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。 自我保护机制的工作机制是：如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制，此时会出现以下几种情况： Eureka Server不再从注册列表中移除长时间没收到心跳而应该过期的服务。 Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。 因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。 为什么会有自我保护机制？ 默认情况下，如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。 服务中心页面会显示如下提示信息 我们在单机测试的时候很容易满足心跳失败比例在 15 分钟之内低于 85%，这个时候就会触发 Eureka的保护机制，一旦开启了保护机制（默认开启），则服务注册中心维护的服务实例就不是那么准确了，此时我们通过修改Eureka Server的配置文件来关闭保护机制，这样可以确保注册中心中不可用的实例被及时的剔除（不推荐）。 123eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） 经验：建议生产环境打开自我保护机制 4.2 Ribbon负载均衡4.2.1 关于负载均衡负载均衡一般分为服务器端负载均衡和客户端负载均衡 所谓服务器端负载均衡，比如Nginx、F5这些，请求到达服务器之后由这些负载均衡器根据一定的算法将请求路由到目标服务器处理。 所谓客户端负载均衡，比如我们要说的Ribbon，服务消费者客户端会有一个服务器地址列表，调用方在请求前通过一定的负载均衡算法选择一个服务器进行访问，负载均衡算法的执行是在请求客户端进行。 Ribbon是Netflix发布的负载均衡器。Eureka一般配合Ribbon进行使用，Ribbon利用从Eureka中读取到服务信息，在调用服务提供者提供的服务时，会根据一定的算法进行负载。 4.2.2 Ribbon高级应用**需求：**复制商品微服务9001，在9000和9001编写Controller，返回服务实例端口。Page微服务中通过负载均衡策略调用service-product的controller 在微服务中使用Ribbon不需要额外导入依赖坐标，微服务中引入过eureka-client相关依赖，会自动引入Ribbon相关依赖坐标。 代码中使用如下，在RestTemplate上添加对应注解即可 12345678910111213@SpringBootApplication @EnableDiscoveryClient //@EnableEurekaClient public class PageApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PageApplication.class,args); &#125; @Bean //Ribbon负载均衡 @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; &#125; 创建serivce-product-9001微服务，创建ServerConfigController，定义方法返回当前微服务所使用的容器端口号 修改服务提供者api返回值，返回当前实例的端口号，便于观察负载情况 12345678910@RestController @RequestMapping(&quot;/product&quot;) public class ServerConfigController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @requestMapping(&quot;server&quot;) public String findServerPort()&#123; return serverPort; &#125;&#125; 在页面静态化微服务中调用server-product下的资源路径：http://server-product/product/server 12345@RequestMapping(&quot;/getPort&quot;) public String getProductServerPort()&#123; String url = &quot;http://service-product/server/query&quot;; return restTemplate.getForObject(url,String.class); &#125; 测试可以知道默认是一个轮询的负载均衡策略 4.2.3 Ribbon负载均衡策略Ribbon内置了多种负载均衡策略，内部负责复杂均衡的顶级接口为 com.netflix.loadbalancer.IRule ， 接口简介: 1234567package com.netflix.loadbalancer;public interface IRule&#123; public Server choose(Object key); public void setLoadBalancer(ILoadBalancer lb); public ILoadBalancer getLoadBalancer();&#125; 修改负载均衡策略： 1234#针对的被调用方微服务名称,不加就是全局生效 service-product: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #随机策略 1234#针对的被调用方微服务名称,不加就是全局生效 service-product: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #轮询策略 4.2.4 Ribbon核心源码刨析Ribbon工作原理 老规矩：SpringCloud充分利用了SpringBoot的自动装配特点，找spring.factories配置文件 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration LoadBalancerAutoConfiguration 类中配置 装配验证： 自动注入 注入RestTemplate定制器 为restTemplate对象设置loadBalancerInterceptor 到这里，我们明白，添加了注解的RestTemplate对象会被添加一个拦截器LoadBalancerInterceptor，该拦截器就是后续拦截请求进行负载处理的。 4.3 Hystrix熔断器属于一种容错机制 4.3.1 微服务当中的雪崩效应当山坡积雪内部的内聚力抗拒不了它所受到的重力拉引时，便向下滑动，引起大量雪体崩塌，人们把这种自然现象称作雪崩。 微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。 **服务雪崩效应：**是一种因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象。 扇入：代表着该微服务被调用的次数，扇入大，说明该模块复用性好 扇出：该微服务调用其他微服务的个数，扇出大，说明业务逻辑复杂 扇入大是一个好事，扇出大不一定是好事 在微服务架构中，一个应用可能会有多个微服务组成，微服务之间的数据交互通过远程过程调用完成。这就带来一个问题，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。 如图中所示，最下游商品微服务响应时间过长，大量请求阻塞，大量线程不会释放，会导致服务器资源耗尽，最终导致上游服务甚至整个系统瘫痪。 形成原因 服务雪崩的过程可以分为三个阶段： 服务提供者不可用 重试加大请求流量 服务调用者不可用 服务雪崩的每个阶段都可能由不同的原因造成： 4.3.2 雪崩效应解决方案从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段； 下面，我们介绍三种技术手段应对微服务中的雪崩效应，这三种手段都是从系统可用性、可靠性角度出发，尽量防止系统整体缓慢甚至瘫痪。 服务熔断 熔断机制是应对雪崩效应的一种微服务链路保护机制。我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务不可用或者响应时间太长时，熔断该节点微服务的调用，进行服务的降级，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。 注意： 服务熔断重点在**“断”**，切断对下游服务的调用 服务熔断和服务降级往往是一起使用的，Hystrix就是这样。 服务降级 通俗讲就是整体资源不够用了，先将一些不关紧的服务停掉（调用我的时候，给你返回一个预留的值，也叫做兜底数据），待渡过难关高峰过去，再把那些服务打开。 服务降级一般是从整体考虑，就是当某个服务熔断之后，服务器将不再被调用，此刻客户端可以自己准备一个本地的fallback回调，返回一个缺省值，这样做，虽然服务水平下降，但好歹可用，比直接挂掉要强。 服务限流 服务降级是当服务出问题或者影响到核心流程的性能时，暂时将服务屏蔽掉，待高峰或者问题解决后再打开；但是有些场景并不能用服务降级来解决，比如秒杀业务这样的核心功能，这个时候可以结合服务限流来限制这些场景的并发&#x2F;请求量 限流措施也很多，比如 限制总并发数（比如数据库连接池、线程池） 限制瞬时并发数（如nginx限制瞬时并发连接数） 限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率） 限制远程接口调用速率、限制MQ的消费速率等 4.3.3 Hystrix简介**[来自官网]**Hystrix(豪猪)，宣言“defend your application”是由Netflflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。Hystrix主要通过以下几点实现延迟和容错。 包裹请求：使用HystrixCommand包裹对依赖的调用逻辑。 页面静态化微服务方（@HystrixCommand 添加Hystrix控制） 跳闸机制：当某服务的错误率超过一定的阈值时，Hystrix可以跳闸，停止请求该服务一段时间。 资源隔离：Hystrix为每个依赖都维护了一个小型的线程池(舱壁模式)。如果该线程池已满， 发往该依赖的请求就被立即拒绝，而不是排队等待，从而加速失败判定。 监控：Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等。 回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。回退逻辑由开发人员自行提供，例如返回一个缺省值。 自我修复：断路器打开一段时间后，会自动进入“半开”状态（探测服务是否可用，如还是不可用，再次退回打开状态）。 4.3.4 Hystrix应用（1）熔断处理**目的：**商品微服务长时间没有响应，服务消费者—&gt;页面静态化微服务快速失败给用户提示 引入依赖： 服务消费者工程（静态化微服务）中引入Hystrix依赖坐标（也可以添加在父工程中） 12345&lt;!--熔断器Hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; **开启熔断：**服务消费者工程（静态化微服务）的启动类中添加熔断器开启注解 12345678910111213141516/** * 注解简化写法 * @SpringCloudApplication=@SpringBootApplication+@EnableDiscoveryClient+@EnableCircuitBreaker */@SpringBootApplication @EnableDiscoveryClient //@EnableEurekaClient @EnableCircuitBreaker // 开启熔断 public class PageApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PageApplication.class,args); &#125; @Bean @LoadBalanced//Ribbon负载均衡 public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; &#125; **定义服务降级的处理方式：**业务方法上使用@HystrixCommand的fallbackMethod属性关联到服务降级处理方法 1234567891011121314151617181920212223/** * 提供者模拟处理超时，调用方法添加Hystrix控制 */ // 使用@HystrixCommand注解进行熔断控制 @HystrixCommand( // 线程池标识，要保持唯一，不唯一的话就共用了 threadPoolKey = &quot;getProductServerPort2&quot;, // 线程池细节属性配置 threadPoolProperties = &#123; @HystrixProperty(name=&quot;coreSize&quot;,value = &quot;1&quot;), // 线程数 @HystrixProperty(name=&quot;maxQueueSize&quot;,value=&quot;20&quot;) // 等待队列长 度 &#125;, // commandProperties熔断的一些细节属性配置 commandProperties = &#123; // 每一个属性都是一个HystrixProperty @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value= &quot;2000&quot;) &#125; )@RequestMapping(&quot;/getPort2&quot;) public String getProductServerPort2()&#123; String url = &quot;http://service-product/product/server&quot;; return restTemplate.getForObject(url,String.class); &#125; 商品微服务模拟超时操作 123456789101112131415@RestController @RequestMapping(&quot;/product&quot;) public class ProductController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @RequestMapping(&quot;/server&quot;) public String findServerPort()&#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return serverPort; &#125; &#125; 对于没有配置HystrixCommand的方法getPort,经过10秒仍然可以最终获取到结果。方法getPort2设置熔断配置的是2秒响应时间超过直接熔断 （2）降级处理配置@HystrixCommand注解，定义降级处理方法 123456789101112131415161718192021222324252627282930313233343536@HystrixCommand( // 线程池标识，要保持唯一，不唯一的话就共用了 threadPoolKey = &quot;getProductServerPort3TimeoutFallback&quot;, // 线程池细节属性配置 threadPoolProperties = &#123; @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;2&quot;), // 线程数 @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;20&quot;) // 等待 队列长度 &#125;, // commandProperties熔断的一些细节属性配置 commandProperties = &#123; // 每一个属性都是一个HystrixProperty @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;), // hystrix高级配置，定制工作过程细节 // 统计时间窗口定义 @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;8000&quot;), // 统计时间窗口内的最小请求数 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;2&quot;), // 统计时间窗口内的错误数量百分比阈值 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;), // 自我修复时的活动窗口长度 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;3000&quot;) &#125;, fallbackMethod = &quot;myFallBack&quot; // 回退方法 )@RequestMapping(&quot;/getPort3&quot;) public String getProductServerPort3() &#123; String url = &quot;http://service-product/product/server&quot;; return restTemplate.getForObject(url, String.class); &#125;/** * 定义回退方法，返回预设默认值 * 注意：该方法形参和返回值与原始方法保持一致 */ public String myFallBack() &#123; return &quot;这个结果是调用超时进行熔断了哦&quot;; // 兜底数据 &#125; 4.3.5 Hystrix舱壁模式即线程池隔离策略 如果不进行任何设置，所有熔断方法使用同一个Hystrix线程池（10个线程），那么这样的话会导致问题，这个问题并不是扇出链路微服务不可用导致的，而是我们的线程机制导致的，如果方法A的请求把10个线程都用了，方法2请求处理的时候压根都没法去访问B，因为没有线程可用，并不是B服务不可用。 为了避免问题服务请求过多导致正常服务无法访问，Hystrix 不是采用增加线程数，而是单独的为每一个控制方法创建一个线程池的方式，这种模式叫做“舱壁模式”，也是线程隔离的手段 4.3.6 Hystrix工作流程与高级应用 当调用出现问题时，开启一个时间窗（10s） 在这个时间窗内，统计调用次数是否达到最小请求数？ 如果没有达到，则重置统计信息，回到第1步 如果达到了，则统计失败的请求数占所有请求数的百分比，是否达到阈值？ 如果达到，则跳闸（不再请求对应服务） 如果没有达到，则重置统计信息，回到第1步 如果跳闸，则会开启一个活动窗口（默认5s），每隔5s，Hystrix会让一个请求通过,到达那个问题服务，看是否调用成功，如果成功，重置断路器回到第1步，如果失败，回到第3步 12345678910111213141516/** * 8秒钟内，请求次数达到2个，并且失败率在50%以上，就跳闸 * 跳闸后活动窗口设置为3s */ @HystrixCommand( commandProperties = &#123; //统计窗口时间的设置 @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;,value = &quot;8000&quot;), //统计窗口内的最小请求数 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;2&quot;), //统计窗口内错误请求阈值的设置 50% @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;50&quot;), //自我修复的活动窗口时间 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;3000&quot;) &#125; ) 我们上述通过注解进行的配置也可以配置在配置文件中: 12345678910111213# 配置熔断策略： hystrix: command: default: circuitBreaker: # 强制打开熔断器，如果该属性设置为true，强制断路器进入打开状态，将会拒绝所有的请求。 默认false关闭的 forceOpen: false # 触发熔断错误比例阈值，默认值50% errorThresholdPercentage: 50 # 熔断后休眠时长，默认值5秒 sleepWindowInMilliseconds: 3000 # 熔断触发最小请求次数，默认值是20 requestVolumeThreshold: 2 execution: isolation: thread: # 熔断超时设置，默认为1秒 timeoutInMilliseconds: 2000 基于springboot的健康检查观察跳闸状态（自动投递微服务暴露健康检查细节） 123456789# springboot中暴露健康检查等断点接口 management: endpoints: web: exposure: include: &quot;*&quot; # 暴露健康接口的细节 endpoint: health: show-details: always 访问健康检查接口：http://localhost:9100/actuator/health 4.4 Feign远程调用组件在之前的案例中，服务消费者调用服务提供者的时候使用RestTemplate技术。 4.4.1 Feign简介Feign是Netﬂix开发的一个轻量级RESTful的HTTP服务客户端（用它来发起请求，远程调用的），是以Java接口注解的方式调用Http请求，而不用像Java中通过封装HTTP请求报文的方式直接调用，Feign被广泛应用在Spring Cloud 的解决方案中。 类似于Dubbo，服务消费者拿到服务提供者的接口，然后像调用本地接口方法一样去调用，实际发出的是远程的请求。 Feign可帮助我们更加便捷，优雅的调用HTTP API：不需要我们去拼接url然后呢调用restTemplate的api，在SpringCloud中，使用Feign非常简单，创建一个接口（在消费者–服务调用方这一端），并在接口上添加一些注解，代码就完成了 SpringCloud对Feign进行了增强，使Feign支持了SpringMVC注解（OpenFeign） 本质：封装了Http调用流程，更符合面向接口化的编程习惯，类似于Dubbo的服务调用 4.4.2 Feign配置应用在服务调用者工程（消费）创建接口（添加注解） Feign &#x3D; RestTemplate+Ribbon+Hystrix 服务消费者工程（页面静态化微服务）中引入Feign依赖（或者父类工程） 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 服务消费者工程（静态化微服务）启动类使用注解@EnableFeignClients添加Feign支持 12345678@SpringBootApplication @EnableDiscoveryClient // 开启服务发现 @EnableFeignClients // 开启Feign public class PageApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PageApplication.class,args); &#125; &#125; **注意：**此时去掉Hystrix熔断的支持注解@EnableCircuitBreaker即可包括引入的依赖，因为Feign会自动引入 在消费者微服务中创建Feign接口 1234567891011121314151617181920/** * @author hao * @date 2022/3/10 17:29 */@FeignClient(name = &quot;service-product&quot;)public interface ProductFeign &#123; /** * 通过id获取商品信息 * @param id * @return */ @RequestMapping(&quot;/product/query/&#123;id&#125;&quot;) public Product getProduct(@PathVariable Integer id); /** * 获得端口号 * @return */ @RequestMapping(&quot;/product/server&quot;) public String getPort();&#125; 注意： @FeignClient注解的name属性用于指定要调用的服务提供者名称，和服务提供者yml文件中spring.application.name保持一致 接口中的接口方法，就好比是远程服务提供者Controller中的Hander方法（只不过如同本地调用了），那么在进行参数绑定的时，可以使用@PathVariable、@RequestParam、@RequestHeader等，这也是OpenFeign对SpringMVC注解的支持，但是需要注意value必须设置，否则会抛出异常 @FeignClient(name &#x3D; “service-product”)，name在消费者微服务中只能出现一次。（升级Spring Boot 2.1.0 Spring Cloud Greenwich.M1 版本后，在2个Feign接口类内定义相同的名字， @FeignClient(name &#x3D; 相同的名字 就会出现报错，在之前的版本不会提示报错），所以最好将调用一个微服务的信息都定义在一个Feign接口中。 改造PageController中原有的调用方式 1234567891011121314@RestController @RequestMapping(&quot;/page&quot;) public class PageController &#123; @Autowired private ProductFeign productFeign; @RequestMapping(&quot;/getProduct2/&#123;id&#125;&quot;) public Product getProduct2(@PathVariable Integer id) &#123; return productFeign.getProduct(id); &#125; @RequestMapping(&quot;/getPort4&quot;) public String getPort() &#123; return productFeign.getPort(); &#125;&#125; 这里之前提供方的getPort做了10秒睡眠，这里的getPort4就直接失败了。说明使用feign在默认情况有超时的配置 4.4.3 Feign对负载均衡的支持Feign 本身已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖，可以通过ribbon.xx 来进 行全局配置,也可以通过服务名.ribbon.xx 来对指定服务进行细节配置配置（参考之前，此处略） Feign默认的请求处理超时时长1s，有时候我们的业务确实执行的需要一定时间，那么这个时候，我们就需要调整请求处理超时时长，Feign自己有超时设置，如果配置Ribbon的超时，则会以Ribbon的为准 1234567891011121314#针对的被调用方微服务名称,不加就是全局生效 service-product: ribbon: #请求连接超时时间 #ConnectTimeout: 2000 #请求处理超时时间 #ReadTimeout: 5000 #对所有操作都进行重试 OkToRetryOnAllOperations: true ####根据如上配置，当访问到故障请求的时候，它会再尝试访问一次当前实例（次数由 MaxAutoRetries配置）， ####如果不行，就换一个实例进行访问，如果还不行，再换一次实例访问（更换次数由 MaxAutoRetriesNextServer配置）， ####如果依然不行，返回失败信息。 MaxAutoRetries: 0 #对当前选中实例重试次数，不包括第一次调用 MaxAutoRetriesNextServer: 0 #切换实例的重试次数 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #负载策略 调整 4.4.4 Feign对熔断器的支持在Feign客户端工程配置文件（application.yml）中开启Feign对熔断器的支持 1234# 开启Feign的熔断功能 feign: hystrix: enabled: true Feign的超时时长设置那其实就上面Ribbon的超时时长设置 Hystrix超时设置（就按照之前Hystrix设置的方式就OK了） 注意 开启Hystrix之后，Feign中的方法都会被进行一个管理了，一旦出现问题就进入对应的回退逻辑处理 针对超时这一点，当前有两个超时时间设置（Feign（ribbon）&#x2F;hystrix），熔断的时候是根据这两个时间的最小值来进行的，即处理时长超过最短的那个超时时间了就熔断进入回退降级逻辑 1234567891011121314151617hystrix: command: default: circuitBreaker: # 强制打开熔断器，如果该属性设置为true，强制断路器进入打开状态，将会拒绝所有的请求。 默认false关闭的 forceOpen: false # 触发熔断错误比例阈值，默认值50% errorThresholdPercentage: 50 # 熔断后休眠时长，默认值5秒 sleepWindowInMilliseconds: 3000 # 熔断触发最小请求次数，默认值是20 requestVolumeThreshold: 2 execution: isolation: thread: # 熔断超时设置，默认为1秒 timeoutInMilliseconds: 5000 自定义FallBack处理类（需要实现FeignClient接口） 12345678910111213141516/** * @author hao * @date 2022/3/10 18:26 */@Componentpublic class ProductFeignFallBack implements ProductFeign&#123; @Override public Product getProduct(Integer id) &#123; return null; &#125; @Override public String getPort() &#123; return &quot;-1&quot;; &#125;&#125; 1234567891011121314151617181920/** * @author hao * @date 2022/3/10 17:29 */@FeignClient(name = &quot;service-product&quot;,fallback = ProductFeignFallBack.class)public interface ProductFeign &#123; /** * 通过id获取商品信息 * @param id * @return */ @RequestMapping(&quot;/product/query/&#123;id&#125;&quot;) public Product getProduct(@PathVariable Integer id); /** * 获得端口号 * @return */ @RequestMapping(&quot;/product/server&quot;) public String getPort();&#125; 4.4.5 Feign对请求压缩和响应压缩的支持Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数 即可开启请求与响应的压缩功能： 1234567891011feign: hystrix: enabled: true #开启请求和响应压缩 compression: request: enabled: true #默认不开启 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型， 此处也是默认值 min-request-size: 2048 # 设置触发压缩的大小下限，此处也是默认值 response: enabled: true #默认不开启 4.5 GateWay网关组件网关：微服务架构中的重要组成部分 局域网中就有网关这个概念，局域网接收或者发送数据出去通过这个网关，比如用Vmware虚拟机软件搭建虚拟机集群的时候，往往我们需要选择IP段中的一个IP作为网关地址。 我们学习的GateWay–&gt;Spring Cloud GateWay（它只是众多网关解决方案中的一种） 4.5.1 GateWay简介Spring Cloud GateWay是Spring Cloud的一个全新项目，目标是取代Netflix Zuul，它基于Spring5.0+SpringBoot2.0+WebFlux（基于高性能的Reactor模式响应式通信框架Netty，异步非阻塞模型）等技术开发，性能高于Zuul，官方测试，GateWay是Zuul的1.6倍，旨在为微服务架构提供一种简单有效的统一的API路由管理方式。 Spring Cloud GateWay不仅提供统一的路由方式（反向代理）并且基于 Filter(定义过滤器对请求过滤，完成一些功能) 链的方式提供了网关基本的功能，例如：鉴权、流量控制、熔断、路径重写、日志监控等。 网关在架构中的位置 4.5.2 GateWay核心概念Spring Cloud GateWay天生就是异步非阻塞的，基于Reactor模型（同步非阻塞的I&#x2F;O多路复用机制） 一个请求—&gt;网关根据一定的条件匹配—匹配成功之后可以将请求转发到指定的服务地址；而在这个过程中，我们可以进行一些比较具体的控制（限流、日志、黑白名单） 路由（route）： 网关最基础的部分，也是网关比较基础的工作单元。路由由一个ID、一个目标URL（最终路由到的地址）、一系列的断言（匹配条件判断）和Filter过滤器（精细化控制）组成。如果断言为true，则匹配该路由。 **断言（predicates）：**参考了Java8中的断言java.util.function.Predicate，开发人员可以匹配Http请求中的所有内容（包括请求头、请求参数等）（类似于nginx中的location匹配一样），如果断言与请求相匹配则路由。 **过滤器（filter）：**一个标准的Spring webFilter，使用过滤器，可以在请求之前或者之后执行业务逻辑。 4.5.3 GateWay如何工作 Spring 官方介绍： 客户端向Spring Cloud GateWay发出请求，然后在GateWay Handler Mapping中找到与请求相匹配的路由，将其发送到GateWay Web Handler；Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（pre）或者之后（post）执行业务逻辑。 Filter在“pre”类型过滤器中可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改、日志的输出、流量监控等。 4.5.4 GateWay应用使用网关对静态化微服务进行代理（添加在它的上游，相当于隐藏了具体微服务的信息，对外暴露的是网关） 创建工程cloud-gateway导入依赖 GateWay不需要使用web模块，它引入的是WebFlux（类似于SpringMVC）。注意依赖冲突，不能有web模块，可能继承的pom工程携带了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;mycloud&lt;/artifactId&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;service-page&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;artifactId&gt;service-common&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--熔断器Hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置 1234567891011121314151617181920212223242526272829server: port: 9300eureka: client: serviceUrl: # eureka server的路径 defaultZone: http://eurekaA:9200/eureka,http://eurekaB:9201/eureka instance: prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip- address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@spring: application: name: cloud-gateway #网关的配置 cloud: gateway: routes: #配置路由 - id: service-page-router uri: http://127.0.0.1:9100 predicates: #当断言成功后，交给某一个微服务处理时使用的是转发 - Path=/page/** - id: service-product-router uri: http://127.0.0.1:9000 predicates: - Path=/product/** filters: # http://127.0.0.1:9300/product/service/port --&gt; /service/port --&gt; 商品微服务 - StripPrefix=1 # 去掉uri中的第一部分，所以就要求我们通过网关访问的时候，把uri 的第一部分设置为product，从uri的第二部分开始才是真正的uri 启动类 1234567891011/** * @author hao * @date 2022/3/11 10:05 */@SpringBootApplication@EnableDiscoveryClientpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class,args); &#125;&#125; 测试 4.5.5 GateWay路由规则详解Spring Cloud GateWay 帮我们内置了很多 Predicates功能，实现了各种路由匹配规则（通过Header、请求参数等作为条件）匹配到对应的路由。 时间点后匹配 12345678spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] 时间点前匹配 12345678spring: cloud: gateway: routes: - id: before_route uri: https://example.org predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] 时间区间匹配 12345678spring: cloud: gateway: routes: - id: between_route uri: https://example.org predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver],2017-01- 21T17:42:47.789-07:00[America/Denver] 指定Cookie正则匹配指定值 12345678spring: cloud: gateway: routes: - id: cookie_route uri: https://example.org predicates: - Cookie=chocolate,ch.p 指定Header正则匹配指定值 12345678spring: cloud: gateway: routes: - id: header_route uri: https://example.org predicates: - Header=X-Request-Id, \\d+ 请求Host匹配指定值 12345678spring: cloud: gateway: routes: - id: host_route uri: https://example.org predicates: - Host=**.somehost.org,**.anotherhost.org 请求Method匹配指定请求方式 12345678spring: cloud: gateway: routes: - id: method_route uri: https://example.org predicates: - Method=GET,POST 请求路径正则匹配 12345678spring: cloud: gateway: routes: - id: path_route uri: https://example.org predicates: - Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125; 请求包含某参数 12345678spring: cloud: gateway: routes: - id: query_route uri: https://example.org predicates: - Query=green 请求包含某参数并且参数值匹配正则表达式 12345678spring: cloud: gateway: routes: - id: query_route uri: https://example.org predicates: - Query=red,gree. 远程地址匹配 12345678spring: cloud: gateway: routes: - id: remoteaddr_route uri: https://example.org predicates: - RemoteAddr=192.168.1.1/24 4.5.6 GateWay动态路由详解GateWay支持自动从注册中心中获取服务列表并访问，即所谓的动态路由 实现步骤如下 pom.xml中添加注册中心客户端依赖（因为要获取注册中心服务列表，eureka客户端已经引入） 动态路由配置 注意：动态路由设置时，uri以lb: &#x2F;&#x2F;开头（lb代表从注册中心获取服务），后面是需要转发到的服务名称 4.5.7 GateWay过滤器（1）GateWay过滤器简介从过滤器生命周期（影响时机点）的角度来说，主要有两个pre和post： 从过滤器类型的角度，Spring Cloud GateWay的过滤器分为GateWayFilter和GlobalFilter两种 如Gateway Filter可以去掉url中的占位后转发路由，比如 12345predicates: - id: xxx Path=/product/** filters: - StripPrefix=1 # 可以去掉product之后转发 注意：GlobalFilter全局过滤器是程序员使用比较多的过滤器，我们主要讲解这种类型 （2）自定义全局过滤器实现IP访问限制（黑白名单）请求过来时，判断发送请求的客户端的ip，如果在黑名单中，拒绝访问 自定义GateWay全局过滤器时，我们实现Global Filter接口即可，通过全局过滤器可以实现黑白名单、限流等功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @author hao * @date 2022/3/11 11:22 */@Slf4j@Componentpublic class BlackListFilter implements GlobalFilter, Ordered &#123; /** * 模拟黑名单（实际可以去数据库或者redis中查询） */ private static List&lt;String&gt; blackList = new ArrayList&lt;&gt;(); static &#123; /* * 模拟本机地址 */ blackList.add(&quot;0:0:0:0:0:0:0:1&quot;); blackList.add(&quot;127.0.0.1&quot;); &#125; /** * 过滤器核心方法 * @param exchange 封装了request和response对象的上下文 * @param chain 网关过滤器链（包含全局过滤器和单路由过滤器） * @return */ @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;....BlackListFilter....&quot;); // 思路：获取客户端ip，判断是否在黑名单中，在的话就拒绝访问，不在的话就放行 // 从上下文中取出request和response对象 ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); response.getHeaders().add(&quot;Content-Type&quot;,&quot;application/json;chartset=UTF-8&quot;); // 从request对象中获取客户端ip String clientIp = request.getRemoteAddress().getHostString(); // 拿着clientIp去黑名单中查询，存在的话就决绝访问 if(blackList.contains(clientIp)) &#123; // 决绝访问，直接return // 状态码 response.setStatusCode(HttpStatus.UNAUTHORIZED); log.info(&quot;=====&gt;IP:&quot; + clientIp + &quot; 在黑名单中，将被拒绝访问！&quot;); byte[] msg = &quot;Request be denied! 你被拉黑啦&quot;.getBytes(); DataBuffer wrap = response.bufferFactory().wrap(msg); return response.writeWith(Mono.just(wrap)); &#125; // 合法请求，放行，执行后续的过滤器 return chain.filter(exchange); &#125; /** * 返回值表示当前过滤器的顺序(优先级)，数值越小，优先级越高 * @return */ @Override public int getOrder() &#123; return 0; &#125;&#125; 4.5.8 GateWay高可用网关作为非常核心的一个部件，如果挂掉，那么所有请求都可能无法路由处理，因此我们需要做GateWay的高可用。 GateWay的高可用很简单：可以启动多个GateWay实例来实现高可用，在GateWay的上游使用Nginx等负载均衡设备进行负载转发以达到高可用的目的。 启动多个GateWay实例（假如说两个，一个端口9300，一个端口9301），剩下的就是使用Nginx等完成负载代理即可。示例如下： 12345678#配置多个GateWay实例 upstream gateway &#123; server 127.0.0.1:9301; server 127.0.0.1:9302; &#125;location / &#123; proxy_pass http://gateway; &#125; 4.6 Spring Cloud Config分布式配置中心4.6.1 分布式配置中心应用场景往往，我们使用配置文件管理一些配置信息，比如application.yml **单例应用架构：**配置信息的管理、维护并不会显得特别麻烦，手动操作就可以，因为就一个工程； **微服务架构，**因为我们的分布式集群环境中可能有很多个微服务，我们不可能一个一个去修改配置然后重启生效，在一定场景下我们还需要在运行期间动态调整配置信息，比如：根据各个微服务的负载情况，动态调整数据源连接池大小，我们希望配置内容发生变化的时候，微服务可以自动更新。 场景总结如下： 集中配置管理，一个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的（一次修改、到处生效） 不同环境不同配置，比如数据源配置在不同环境（开发dev,测试test,生产prod）中是不同的 运行期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小等配置修改后可自动更新 如配置内容发生变化，微服务可以自动更新配置 那么，我们就需要对配置文件进行集中式管理，这也是分布式配置中心的作用。 4.6.2 Spring Cloud Config（1）Config简介Spring Cloud Confifig是一个分布式配置管理方案，包含了 Server端和 Client端两个部分。 Server 端：提供配置文件的存储、以接口的形式将配置文件的内容提供出去，通过使用@EnableConfifigServer注解在 Spring boot 应用中非常简单的嵌入 Client 端：通过接口获取配置数据并初始化自己的应用 （2）Config分布式配置应用说明：Config Server是集中式的配置服务，用于集中管理应用程序各个环境下的配置。 默认使用Git存储配置文件内容，也可以SVN。 比如，我们要对“静态化微服务或者商品微服务”的application.yml进行管理（区分开发环境（dev）、测试环境(test)、生产环境(prod)） 登录GitHub，创建cloud-config 上传yml配置文件，命名规则如下： {application}-{profile}.yml 或者 {application}-{profile}.properties 其中，application为应用名称，profile指的是环境（用于区分开发环境，测试环境、生产环境等） 示例：service-page-dev.yml、service-page-test.yml、service-page-prod.yml 构建Config Server统一配置中心 新建SpringBoot工程，引入依赖坐标（需要注册自己到Eureka） 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;mycloud&lt;/artifactId&gt; &lt;groupId&gt;com.hao&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--eureka client 客户端依赖引入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--config配置中心服务端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置启动类，使用注解@EnableConfigServer开启配置中心服务器功能 12345678@SpringBootApplication@EnableDiscoveryClient@EnableConfigServerpublic class ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigApplication.class,args); &#125;&#125; application.yml 1234567891011121314151617181920212223242526server: port: 9400#注册到Eureka服务中心eureka: client: service-url: defaultZone: http://eurekaA:9200/eureka,http://eurekaB:9201/eureka instance: prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip- address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@spring: application: name: cloud-config cloud: config: server: git: uri: https://github.com/Jasper-zh/cloud-config.git #配置git服务地址 username: jasper-zh #配置git用户名 password: xxxxx #配置git密码 search-paths: - cloud-config default-label: main 测试（随便提交了个文件） http://127.0.0.1:9400/main/xx.txt main：分支名称 xx.txt：文件名称 构建Client客户端（在已有的静态化微服务基础上） 案例实现：在service-page微服务中动态获取config server的配置信息 已有工程中添加依赖坐标 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt; &lt;/dependency&gt; application.yml修改为bootstrap.yml配置文件 bootstrap.yml是系统级别的，优先级比application.yml高，应用启动时会检查这个配置文件，在这个配置文件中指定配置中心的服务地址，会自动拉取配置中心配置并且启用。 （主要是把与统一配置中心连接的信息放到bootstrap.yml） 它会读取spring.application.name与spring.cloud.config.profile拼接命名的配置，因此往github推送了service-page-dev.yml配置，且添加了两条测试配置person.name、person.age bootstrap.yml（部分） 12345678910spring: application: name: service-page datasource: ... cloud: config: #config客户端配置,和ConfigServer通信，并告知ConfigServer希望获取的配置信息在哪个文 件中 profile: dev #后缀名称 label: main #分支名称 uri: http://localhost:9400 controller测试 1234567891011121314@RestController@RequestMapping(&quot;/page&quot;)public class PageController &#123; @Value(&quot;$&#123;person.name&#125;&quot;) String name; @Value(&quot;$&#123;person.age&#125;&quot;) String age; @RequestMapping(&quot;/config&quot;) public String getConfig()&#123; return name + age; &#125;&#125; 4.6.3 Config配置手动刷新不用重启微服务，只需要手动的做一些其他的操作（访问一个地址&#x2F;refresh）刷新，之后再访问即可 此时，客户端取到了配置中心的值，但当我们修改GitHub上面的值时，服务端（Config Server）能实时获取最新的值，但客户端（Config Client）读的是缓存，无法实时获取最新值。Spring Cloud已 经为我们解决了这个问题，那就是客户端使用post去触发refresh，获取最新数据。 Client客户端添加依赖springboot-starter-actuator（已添加） Client客户端bootstrap.yml中添加配置（暴露通信端点） 123456789101112management: endpoints: web: exposure: include: refresh #也可以暴露所有的接口management: endpoints: web: exposure: include: &quot;*&quot; Client客户端使用到配置信息的类上添加@RefreshScope 123456789101112131415@RestController@RequestMapping(&quot;/page&quot;)@RefreshScope //手动刷新public class PageController &#123; @Value(&quot;$&#123;person.name&#125;&quot;) String name; @Value(&quot;$&#123;person.age&#125;&quot;) String age; @RequestMapping(&quot;/config&quot;) public String getConfig()&#123; return name + age; &#125;&#125; 手动向Client客户端发起POST请求，http://localhost:9100/actuator/refresh，刷新配置信息 注意：手动刷新方式避免了服务重启 思考：可否使用广播机制，一次通知，处处生效，方便大范围配置自动刷新？ 4.6.4 Config配置自动更新实现一次通知，处处生效 在微服务架构中，我们可以结合消息总线（Bus）实现分布式配置的自动更新（Spring CloudConfig + Spring Cloud Bus） （1）消息总线Bus所谓消息总线Bus，即我们经常会使用MQ消息代理构建一个共用的Topic，通过这个Topic连接各个微服务实例，MQ广播的消息会被所有在注册中心的微服务实例监听和消费。换言之就是通过一个主题连接各个微服务，打通脉络。 Spring Cloud Bus（基于MQ的，支持RabbitMq&#x2F;Kafka） 是Spring Cloud中的消息总线方案，Spring Cloud Config + Spring Cloud Bus 结合可以实现配置信息的自动更新。 （2）Config + Bus实现自动刷新MQ消息代理，我们还选择使用RabbitMQ，ConfigServer（配置中心）和ConfigClient（其他微服务）都添加都消息总线的支持以及与RabbitMq的连接信息 cloud-config和其他微服务（client）添加消息总线支持 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; cloud-config和客户端添加配置 123456spring: rabbitmq: host: 192.169.200.128 port: 5672 username: guest password: guest cloud-config微服务暴露接口 12345management: endpoints: web: exposure: include: refresh 重启各个服务，更改配置之后，向配置中心服务端发送post请求，各个客户端配置即可自动刷新 http://127.0.0.1:9400/actuator/bus-refresh Config Client测试 在广播模式下实现了一次请求，处处更新，如果我只想定向更新呢？ 在发起刷新请求的时候http://localhost:9004/actuator/bus-refresh/service-page:9100 即为最后面跟上要定向刷新的实例的 服务名:端口号即可 ​ 五、第二代SpringCloud核心组件（SCA）5.1 第二代介绍SpringCloud 是若干个框架的集合，包括 spring-cloud-config、spring-cloud-bus 等近 20 个子项目，提供了服务治理、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列、配置管理等领域的解决方案。Spring Cloud 通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。一般来说，Spring Cloud 包含以下组件，主要以 Netflix 开源为主。 同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。依托Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 5.1.1 阿里开源组件**Nacos：**一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 **Sentinel：**把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 **RocketMQ：**开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 **Dubbo：**这个就不用多说了，在国内应用非常广泛的一款高性能 Java RPC 框架。 **Seata：**阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 **Arthas：**开源的Java动态追踪工具，基于字节码增强技术，功能非常强大。 5.1.2 阿里商业化组件作为一家商业公司，阿里巴巴推出 Spring Cloud Alibaba，很大程度上市希望通过抢占开发者生态，来帮助推广自家的云产品。所以在开源社区，夹带了不少私货，阿里商业化组件，整体易用性和稳定性还是很高的。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的云存储服务。 Alibaba Cloud SchedulerX：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准的定时（基于 Cron 表达式）任务调度服务。 5.1.3 集成SpringCloud组件Spring Cloud Alibaba 作为整套的微服务解决组件，只依靠目前阿里的开源组件是不够的，更多的是集成当前的社区组件，所以 Spring Cloud Alibaba 可以集成 Zuul，GateWay等网关组件，也可继承Ribbon、OpenFeign等组件。 5.2 Nacos服务注册和配置中心5.2.1 Nacos介绍Nacos （Dynamic Naming and Configuration Service）是阿里巴巴开源的一个针对微服务架构中服务发现、配置管理和服务管理平台。 Nacos就是注册中心+配置中心的组合（Nacos&#x3D;Eureka + Config + Bus） 官网：https://nacos.io 下载地址：https://github.com/alibaba/Nacos Nacos功能特性 服务发现与健康检查 动态配置管理 动态DNS服务 服务和元数据管理（管理平台的角度，nacos也有一个ui页面，可以看到注册的服务及其实例信息（元数据信息）等），动态的服务权重调整、动态服务优雅下线，都可以去做 5.2.2 Nacos单例服务部署 下载解压安装包，执行命令启动（我用的 nacos-server-2.0.4.tar.gz） 12[root@hao nocas]# tar zxvf nacos-server-2.0.4.tar.gz[root@hao bin]# startup.sh -m standalone 12# 我是在个人服务器上部署的，如果要在本地windows启动也可以cmd startup.cmd 访问nacos控制台：http://ip:8848/nacos 默认端口8848，默认用户名密码nacos&#x2F;nacos 5.2.3 微服务注册到Nacos 在父pom中引入SCA依赖管理版本 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SCA --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 各微服务中（page、product）引入nacos客户端依赖，必须删除eureka-client依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; application.yml修改，添加nacos配置信息 在yml文件中需要删除调用config和eureka相关的配置，否则启动失败 12345spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 #nacos server 地址 启动商品微服务，观察nacos控制台 保护阈值：可以设置为0-1之间的浮点数，它其实是一个比例值（当前服务健康实例数&#x2F;当前服务总实例数） 场景： ​ 一般流程下，nacos是服务注册中心，服务消费者要从nacos获取某一个服务的可用实例信息，对于服务实例有健康&#x2F;不健康状态之分，nacos在返回给消费者实例信息的时候，会返回健康实例。这个时候在一些高并发、大流量场景下会存在一定的问题 ​ 如果服务A有100个实例，98个实例都不健康了，只有2个实例是健康的，如果nacos只返回这两个健康实例的信息的话，那么后续消费者的请求将全部被分配到这两个实例，流量洪峰到来，2个健康的实例也扛不住了，整个服务A 就扛不住，上游的微服务也会导致崩溃，产生雪崩效应。 ​ 保护阈值的意义在于当服务A健康实例数&#x2F;总实例数 &lt; 保护阈值 的时候，说明健康实例真的不多了，这个时候保护阈值会被触发（状态true） ​ nacos将会把该服务所有的实例信息（健康的+不健康的）全部提供给消费者，消费者可能访问到不健康的实例，请求失败，但这样也比造成雪崩要好，牺牲了一些请求，保证了整个系统的一个可用。 ​ **注意：**阿里内部在使用nacos的时候，也经常调整这个保护阈值参数。 5.2.4 负载均衡​ Nacos客户端引入的时候，会关联引入Ribbon的依赖包，我们使用OpenFeign的时候也会引入Ribbon的依赖，Ribbon包括Hystrix都按原来方式进行配置即可 ​ 此处，我们将商品微服务，再启动了一个9001端口，注册到Nacos上，便于测试负载均衡，我们通过后台也可以看出。 ​ 测试：启动两个提供者一个消费者，测试消费者的调用 http://localhost:9100/page/getPort 5.2.5 Nacos数据模型（领域模型）​ Namespace命名空间、Group分组、集群这些都是为了进行归类管理，把服务和配置文件进行归类，归类之后就可以实现一定的效果，比如隔离 ​ 比如，对于服务来说，不同命名空间中的服务不能够互相访问调用 Namespace：命名空间，对不同的环境进行隔离，比如隔离开发环境、测试环境和生产环境 Group：分组，将若干个服务或者若干个配置集归为一组，通常习惯一个系统归为一个组 Service：某一个服务，比如商品微服务 DataId：配置集或者可以认为是一个配置文件 Namespace + Group + Service 如同 Maven 中的GAV坐标，GAV坐标是为了锁定Jar，而这里是为了锁定服务 Namespace + Group + Data ID 如同 Maven 中的GAV坐标，GAV坐标是为了锁定Jar，而这里是为了锁定服务 最佳实践 ​ Nacos抽象出了Namespace、Group、Service、DataId等概念，具体代表什么取决于怎么用（非常灵活），推荐用法如下。上面配置的cloud-alibaba依赖2.1.0.RELEASE的版本是服务是配置不了分组，配置没有group属性，需要高版本的依赖，但高版本会和Mybatis-Plus有冲突导致无法启动,我自己改了提高Mybatis-plus的版本无法解决 5.2.6 Nacos配置中心回顾之前：Spring Cloud Config + Bus（配置的自动更新） Github 上添加配置文件 创建Config Server 配置中心—&gt;从Github上去下载配置信息 具体的微服务(最终使用配置信息的)中配置Config Client—&gt; ConfigServer获取配置信息 有Nacos之后，分布式配置就简单很多 Github不需要了（配置信息直接配置在Nacos server中），Bus也不需要了(依然可以完成动态刷新) 接下来 去Nacos server中添加配置信息 改造具体的微服务，使其成为Nacos Config Client，能够从Nacos Server中获取到配置信息 （1）Nacos Server添加配置 dataId的完整格式如下（创建时输入名称（DataID）别漏了文件后缀） 1$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125; （2）微服务中开启Nacos配置管理 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 微服务中如何锁定 Nacos Server 中的配置文件（dataId） 通过 Namespace + Group + dataId 来锁定配置文件，Namespace不指定就默认public，Group不指定就默认 DEFAULT_GROUP prefix 默认为 spring.application.name 的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。 spring.profile.active即为当前环境对应的 profile。 注意：当 spring.profile.active为空时，对应的连接符- 也将不存在dataId的拼接格式变成 ** ${prefix}.${file-**extension} file-exetension 为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension来配置。目前只支持 properties 和 yaml 类型。 123456789cloud: nacos: discovery: server-addr: xxx:8848 config: server-addr: xxx:8848 namespace: public #命名空间 group: DEFAULT_GROUP #如果使用的默认分组,可以不设置 file-extension: yaml 5.3 SCA Sentinel 分布式系统的流量防卫兵5.3.1 Sentinel 介绍Sentinel是一个面向云原生微服务的流量控制、熔断降级组件。替代Hystrix，针对问题：服务雪崩、服务降级、服务熔断、服务限流 Hystrix： 服务消费者（静态化微服务）—&gt;调用服务提供者（商品微服务） 在调用方引入Hystrix 自己搭建监控平台 dashboard 没有提供UI界面进行服务熔断、服务降级等配置（使用的是@HystrixCommand参数进行设置，代码入侵） Sentinel 独立可部署Dashboard&#x2F;控制台组件（其实就是一个jar文件，直接运行即可） 减少代码开发，通过UI界面配置即可完成细粒度控制 Sentinel 分为两个部分: 核心库：（Java 客户端）不依赖任何框架&#x2F;库，能够运行于所有 Java 运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。 控制台：（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。 Sentinel 具有以下特征: 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 SpringCloud、Dubbo的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。 Sentinel主要特性： Sentinel 的开源生态： 5.3.2 Sentinel 部署下载地址：https://github.com/alibaba/Sentinel/releases 我这里使用v1.8.1 启动：java -jar -Dserver.port=5000 sentinel-dashboard-1.8.1.jar 用户名&#x2F;密码：sentinel/sentinel 不使用-Dserver.port默认控制台端口是8080，我的8080已经占用了，所以指定一个.它连接的客户端端口默认是8719也可以通过-Dcsp.sentinel.dashboard.server指定 5.3.3 服务改造我们之前是使用的OpenFeign（Hystrix）来进行熔断降级，做的事情有第一应用配置开启hystrix第二在Controller当中注解配置了熔断降级的规则（或者在配置文件配置）。 现在我们使用sentinel则需要将之前的Hystrix相关配置去掉（为了不污染之前的代码，复制一个页面静态化微服务 service-page-9101） 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 修改application配置（也要暴露端点需要依赖actuator） 123456789101112spring: cloud: sentinel: transport: dashboard: xxx.xxx.xxx:5000 # 控制台的地址端口 port: 8719 # 客户端开放端口 clientIp: xxx # 不配置，默认就是当前的内网ipmanagement: endpoints: web:exposure: include: &quot;*&quot; 启动服务，发送请求即可看到监控信息。 这里有些小伙伴（自己）可能把sentinel部署在自己服务器了也就是线上，然后就会出现问题在sentinel控制台看得到自己的服务，但请求服务实时监控里面并不会有数据显示。因为你的本地idea启的服务可以往线上的sentinel注册，但线上的sentinel就访问不到你本地的客户端地址了。所以本地测试还是启个本地要么将本地地址映射个公网的然后配到clientIp 还有个问题就是它是懒加载，都正常的情况下它也不会显示已注册的服务，你把服务的接口访问一下才可以出现服务，实时监控也是一样 5.3.4 Sentinel 关键概念 5.3.5 Sentinel 流量规则模块系统并发能力有限，比如系统A的QPS支持1个，如果太多请求过来，那么A就应该进行流量控制了，比如其他请求直接拒绝 进行并发测试5条线程，其中四条被拒绝。 **资源名：**默认请求路径 **针对来源：**Sentinel可以针对调用者进行限流，填写微服务（消费者）名称，默认default（不区分来源） 阈值类型&#x2F;单机阈值 QPS：（每秒钟请求数量）当调用该资源的QPS达到阈值时进行限流 线程数：当调用该资源的线程数达到阈值的时候进行限流（线程处理请求的时候，如果说业务逻辑执行时间很长，流量洪峰来临时，会耗费很多线程资源，这些线程资源会堆积，最终可能造成服务不可用，进一步上游服务不可用，最终可能服务雪崩） **是否集群：**是否集群限流 流控模式： 直接：资源调用达到限流条件时，直接限流 关联：关联的资源调用达到阈值时候限流自己 链路：只记录指定链路上的流量 流控效果： 快速失败：直接失败，抛出异常 Warm Up：根据冷加载因子（默认3）的值，从阈值&#x2F;冷加载因子，经过预热时长，才达到设置的QPS阈值 排队等待：匀速排队，让请求匀速通过，阈值类型必须设置为QPS，否则无效 1）控流模式之关联限流关联的资源调用达到阈值时候限流自己，比如用户注册接口，需要调用身份证校验接口（往往身份证校验接口），如果身份证校验接口请求达到阈值，使用关联，可以对用户注册接口进行限流。 仅仅密集请求test01时，并不会限流。只有test02限流时test01才进行当前的限流配置 2）流控模式之链路限流链路指的是请求链路（调用链：A–&gt;B–C，D–&gt;E–&gt;C） 链路模式下会控制该资源所在的调用链路入口的流量。需要在规则中配置入口资源，即该调用链路入口的上下文名称。 一棵典型的调用树如下图所示： 上图中来自入口 Entrance1 和 Entrance2 的请求都调用到了资源 NodeA ，Sentinel 允许只根据某个调用入口的统计信息对资源限流。比如链路模式下设置入口资源为 Entrance1 来表示只有从入口Entrance1 的调用才会记录到 NodeA 的限流统计当中，而不关心经 Entrance2 到来的调用。 别的来源并不限流，只有从test02请求test01才限流 1）流控效果之Warm up当系统长期处于空闲的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮，比如电商网站的秒杀模块。 通过 Warm Up 模式（预热模式），让通过的流量缓慢增加，经过设置的预热时间以后，到达系统处理请求速率的设定值。 Warm Up 模式默认会从设置的 QPS 阈值的 1&#x2F;3 开始慢慢往上增加至 QPS 设置值。 流控效果之排队等待 排队等待模式下会严格控制请求通过的间隔时间，即请求会匀速通过，允许部分请求排队等待，通常用于消息队列削峰填谷等场景。需设置具体的超时时间，当计算的等待时间超过超时时间时请求就会被拒绝。 很多流量过来了，并不是直接拒绝请求，而是请求进行排队，一个一个匀速通过（处理），请求能等就等着被处理，不能等（等待时间&gt;超时时间）就会被拒绝 例如，QPS 配置为 5，则代表请求每 200 ms 才能通过一个，多出的请求将排队等待通过。超时时间代表最大排队时间，超出最大排队时间的请求将会直接被拒绝。排队等待模式下，QPS 设置值不要超过 1000（请求间隔 1 ms）。 5.3.6 Sentinel 降级规则模块流控是对外部来的大流量进行控制，熔断降级的视角是对内部问题进行处理。 Sentinel 降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断，这里的降级其实是Hystrix中的熔断。 策略 Sentinel不会像Hystrix那样放过一个请求尝试自我修复，就是明明确确按照时间窗口来，熔断触发后，时间窗口内拒绝请求，时间窗口后就恢复。 在窗口时间(统计时间)里达到了5个以上的请求，且最大的响应时间超过了200ms则记为慢调用，当慢调用的数量达到阈值比例（全部都超过才熔断则比例是1）则进行熔断，在熔断时长里都是处于熔断状态（不会进行重试） 修改test01加上线程睡眠时间为300ms，开启5个线程并发访问。这样最终的预期结果应该是全都超过200ms，进行熔断且之后5秒之内都是熔断状态 实际测试对于慢调用比例和异常比例完全不在预期，在正常应该5的并发可以达到熔断，实际不会且配置了更高的并发也是如此直到配置了1000的线程才熔断，熔断时间确实是如配置一样没有问题。但比例阈值、最小请求数以及统计时长无法修改。 **慢调用比例 ** 当 1s统计时长 内持续进入 &gt;&#x3D;5最小请求数 个请求，平均响应时间超过200ms最大RT（以 ms 为单位），则标记为慢调用，当慢调用请求的比例超过了比例阈值则进行熔断。注意Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。 异常比例 当资源的统计时间内请求量 &gt;&#x3D; 最小请求数，并且期间异常总数占通过量的比例超过阈值之后，资源进入降级状态知道熔断时长走完 异常数 当资源的统计时间内请求量 &gt;&#x3D; 最小请求数，并且期间异常总数超过阈值数量，资源进入降级状态知道熔断时长走完。 实际测试jmeter线程10循环1次，10次都没有进行熔断。但在下一次调用都已经是属于熔断状态。也就是说并发10的情况下它没有在前5个已经异常的情况下进行熔断，而是都通过了之后才熔断。可能是触发熔断但实际熔断有延迟，但最终确实熔断了。 在这个推论的情况下，降低并发就将线程设置为4进行测试，手动执行两次。在第五次会进行熔断。如果把第5次或者还有6次7次都放到一个线程组直接测试，那么就会都通过产生异常没有熔断，也许确实是在第5条时就熔断了但后面的7、8、9等都在熔断之前就通过了，以至于只有后面再次手动调用的才是在熔断之后的状态当中。 5.3.7 SCA 小结SCA实际上发展了三条线 第一条线：开源出来一些组件 第二条线：阿里内部维护了一个分支，自己业务线使用 第三条线：阿里云平台部署一套，付费使用 从战略上来说，SCA更是为了贴合阿里云。目前来看，开源出来的这些组件，推广及普及率不高，社区活跃度不高，稳定性和体验度上仍需进一步提升。","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"LeetCode初级算法之数学：204.计数质数","slug":"计数质数","date":"2021-07-06T13:07:07.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/07/06/计数质数/","link":"","permalink":"http://yournotes.cn/2021/07/06/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/count-primes/ 统计所有小于非负整数 n 的质数的数量。 示例1： 123输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例2： 12输入：n = 0输出：0 示例3： 12输入：n = 1输出：0 解法一：暴力枚举依题意需要统计0至n当中质数的个数，自然的就想的到去遍历0至n的每个数字，再判段每个数字是否是质数，如果是计数加一如果不是则不变，最终返回计数结果。 对于判断是否是质数，我们都知道是有且只能被自己与1整除的数是质数（1不算），那么判断7是不是质数需要判断它能否被2至6里面的数整除么，其实不需要因为一个数不可能整除大于自己一半的数。也就是说判断数字number是否为质数看看2到number&#x2F;2之间的整数能不能进行整除即可 了解之后我们先定义一个判断是否是质数的judge方法： 1234567public boolean judge(int number)&#123; // 遍历2到number/2之间的数字,看是否能被number整除 for(int i = 2; i&lt;=number/2; i++)&#123; if(number%i==0) return false; &#125; return true;&#125; 有了judge方法之后，再配合遍历计数，得到结果： 123456789public int countPrimes(int n) &#123; // 计数器初始化0 int result = 0; for (int i = 2; i &lt; n; i++)&#123; // 如果judge判断是质数则计数器加一,否则不变 result = judge(i) ? ++result : result; &#125; return result;&#125; **空间：**一个计数器变量，因此复杂度O(1)， **时间：**需要遍历0-n的每个数，而每个数进行判断是不是质数又需要遍历0-i&#x2F;2,复杂度是O(n^2) 提交结果： 可以看的到大部分测试用例通过，证明求解结果是没有问题的。但在面对499979这样的大数字计算次数过多导致超时，因此还需看看怎么优化时间复杂度。 其实可以发现判定一个数number是否可以被2到number-1的里面的数整除，我下意识想的是可以减少一半的规模只用判断2到number&#x2F;2即可。 但其实可以更缩小规模 1212 = 2 * 612 = 3 * 4 比如像这个12，没必要除到6，6与2是重复的。一个数除以一个数得到一个整数number&#x2F;x &#x3D; y，那么它的两个因数x * y是一大一小，我们只需要把小的一边都除以一下判断是否可以整除即可。也就是开根号。$$\\sqrt{number}$$像判断23是否是质数，判断2到4.79….$$\\sqrt{23}$$也就是只需要判断对2、3、4是否能整除即可，而不是像之前要从2到11。 123456789public Boolean judge(int number)&#123; // 边界条件0和1直接返回 if(number == 0 || number == 1) return false; // 遍历2到根号number之间的数字,看是否能被number整除 for (int i = 2; i*i&lt;=number; i++)&#123; if(number%i==0) return false; &#125; return true;&#125; 修改i &lt;= number/2 为 i * i &lt;=number,时间复杂度降低一个根号：O（nlogn）,结果依然还是不够，仍然会超时。 解法二：厄拉多塞筛法解法一的时候我们是通过两个遍历求解问题：一是遍历每个数字拿去进行判断，二是当前数字判断它是否是质数的过程需要遍历数字范围内的数进行除运算，时间复杂度很高，好在判断它是否是质数时我们从2到number-1的数字里面缩小了一半（平方）的范围。 尽管如此但仍然不够，判断质数的过程已经是最优化了。那么能优化的只能是第一个步骤也就是遍历每个数字拿去判断。 是否可以不需要每个都遍历去判断？ 在连续的数字里面质数出现是否有规律？ 是否这个数是质数的话那么谁谁谁都是质数？也就不需要都拿去判断了。 当时在纸上画了一些，没太找到什么规律可以帮助我解决这个，在网上看了这个厄拉多塞筛法加上数组进行应用确实很妙。 就是说一个质数的倍数它一定不是质数，比如x是质数但2x、3x、4x这些肯定不是质数，2x起码可以整除2、3x起码可以整除3。 但确实没想到来解决这个问题。主要的点是当我们从质数2开始一个一个遍历的时候，遍历的速度不会超过排除的速度，因此可以认为遍历到的当前数字没有被排除的话就是质数。下面手动枚举几个就可以看出： 123456789101112132 3 4 5 6 7 8 9比如现在找2-9的质数：从质数2开始，质数计数加一，并排除4、6、8不是质数。遍历到3质数，质数计数加一，并排除6、9不是质数。遍历到4，发现已被排除遍历到5质数，质数计数加一遍历到6，发现已被排除遍历到7质数，质数计数加一遍历到8，发现已被排除遍历到9，发现已被排除最终质数计数结果是4 还能看出有一点是需要优化的，每个数从它的两倍开始排除：2倍、3倍、4倍等等。可以发现2排除的数，3也排除了。也就是有些数在前面已经排除了，这边在做排除的时候不应该再去做多余的步骤，这就是优化的点。想想可以知道，3从2倍数走起。肯定在之前就被2的3倍走了。要不重复只能从比自己大的倍数走起，前面的早就被其他小的数字已经排除了。所以就像质数5再去排除不应该去排除2ⅹ5和3ⅹ5，因为它们早就被之前的数排除了。我们排除应该从自己的平方开始。 这里还是画个动图： 实现上其实就是两个循环，一个是遍历每个数字，另一个是对每个数字进行加一倍把得到的数字排除。数据结构上使用字节数组进行标记，是质数标0，被排除就改为1 123456789101112131415161718192021public int countPrimes(int n) &#123; // 计数器初始化0 int result = 0; /** * 定义数组,标记数字是否被排除 * 小于n的数字再排除0和1,共有n-1个需要判断 * 初始化数组默认都是0,等待从2开始的一次次标记 */ int[] arr = new int[n]; // 遍历每个数 for (int i = 2; i &lt; n; i++)&#123; // 是质数，进行倍数排除，从平方开始 if(arr[i] == 0)&#123; result++; for(int j = i * i; j &lt; n; j+=i)&#123; arr[j] = 1; &#125; &#125; &#125; return result;&#125; 这样就ok，测试一下发现居然在n&#x3D;499979的时候出现数组越界： 看程序没看出问题，毕竟 j &lt; n才能取 arr[ j ]，后来注意到越界的索引是 -2146737495 。是两个int的乘积超过了int也就是j类型的范围，j拿到一个负值进入循环。所以在得到 j 的时候给它升下级给个long类型，确认小于n之后，取值时再强转为int 这边顺便做一个空间优化，也就是数组只存 0或1，所以用空间小的byte数组来存 代码如下： 12345678910111213public int countPrimes(int n) &#123; int result = 0; byte[] arr = new byte[n]; for (int i = 2; i &lt; n; i++)&#123; if(arr[i] == 0)&#123; result++; for(long j = (long)i * i; j &lt; n; j+=i)&#123; arr[(int)j] = 1; &#125; &#125; &#125; return result;&#125; 虽然是两次循环，但实际在内循环处理的数在外循环就没有了，对于时间复杂度来应该是个多少倍的n 对于空间来说使用了字节数组，占用n个字节。复杂度O(n) 测试结果 解法三：线性筛选法在处理前面的埃氏筛选法也就是厄拉多的时候，其实就有疑问？我们通过筛选质数的平方之后的倍数得到的合数来避免前面的重复剔除 123456排除质数x构成的合数x * xx * ( x + 1 )x * ( x + 2 )x * ( x + 3 ).... 虽然它是避免了像2排除6，3也排除6的情况。因为3直接从9，12，15开始排除。但12仍然是既被2排除也被3排除。 解决了平方数之前数字的剔除重复，但之后的数字还是会有冲突会有重复剔除。 现在就想让每个合数被自己的很多对因数当中其中最小的因数给排除掉，别再被其他因数排除 合数 因数 4 2 6 2、3 8 2、4 9 3 10 2、5 12 2、3、4、6 采用线性筛选将每个数都参与排除，每次排除目前最近且和未来不冲突。它的要点是任何的合数它的一个最小因数一定是一个质数，因此将质数取出来对每个数进行乘积来进行排除。那么如何避免重复剔除呢？ 下面列举一些： 1234567892 排除 43 排除 6、94 排除 8 （4由2排除,因此它的3倍5倍都是应该被2解决）5 排除 10、15、256 排除 12（6可以被2排除,不需要解除其他倍）7 排除 14、21、35、498 排除 16（8是由2可以排除）9 排除 18、27（9是被3可排除）10 排除 20（10是被2排除的） 就像4排除8，为啥不排除12呢。因为4它最小因数是2。因此它的3倍或者5倍的数字也有因数2，也就是它后面会有一个数字的两倍是12由这个数字去排除。每次只排除最近的，是前面数字留下的，后面的给后面的数字留下。像9它最小因数是3，他应该把2x9与3x9排除。由2这个最小因数产生的18它的最近的就是9，而2不是9的最小因数它的最小因数是3，构成3排除且离9最近也就是3*9，之后不会有数字可以筛选出它了。 把最小因数筛选的数字往后传递，每次筛选出最近的一层，即可完成不重复且永远走在前面的筛选 代码如下： 1234567891011121314public int countPrimes(int n) &#123; // 标记筛选 byte[] arr = new byte[n]; // 最小因数（质数） List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; n; i++)&#123; if(arr[i] == 0) numbers.add(i); for(int j = 0; j &lt; numbers.size() &amp;&amp; numbers.get(j) * i &lt; n; j++)&#123; arr[numbers.get(j) * i] = 1; if(i % numbers.get(j) == 0) break; &#125; &#125; return numbers.size();&#125; 这种方式的话，时间与空间复杂度就都是O(n)了 看起来实际是比埃氏筛选法好像效率低一些，但这个东西主要是一些运算符的问题。 总结本题找到一个数以内的质数的数量，解法一大概就是第一反应也就是依题意的解法，虽然意识到这个解法是走了弯路但没有琢磨出筛选法，在网上看了埃氏筛选法确实是可以用来解题，虽然这个东西应该是每个人都知道的道理，但没有意识到把这个东西进行严格的推理。在这之后也能想到线性筛选，这两种就好似纵向与横向的推演。那么除了实现思路上，对于代码在空间与时间上的优化也是在最终实现思路之后的优化点。像筛选标记这种只需要去存0&#x2F;1也就是只占一位，如果我们只存8个用int数组的话就占用了8x32位。Java里面没有位数组，最小的是字节占8位也就是8x8位。没有位数组那么能不能8个0&#x2F;1只用8位的空间去存呢，我们可以不用数组只用一个字节数字byte它有8位每一位存一个0或1，这是可以考虑的点。第二个是时间上对于线性筛选法对比埃氏筛选法时间复杂度是有提升的只是说在Java里实现这个线性筛选的时候使用了一些像取余这样的运算符等等会影响到执行效率，这个时候我们在处理一些运算的时候可以往位运算上想想，有的可以换成位运算有的不可以。主要就是三点第一思路上在开发的学习与工作当中可能很多想法被束缚了，也许换成高中时期的状态很多东西都可以推理出来，第二就是关于空间对于标记类型的需要考虑到位，第三就是运算可不可以通过位运算达到同样的结果来提升实际效率。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"SpringBoot详解","slug":"SpringBoot","date":"2021-06-29T06:13:51.000Z","updated":"2025-04-17T08:34:52.018Z","comments":true,"path":"2021/06/29/SpringBoot/","link":"","permalink":"http://yournotes.cn/2021/06/29/SpringBoot/","excerpt":"","text":"超长警告！！！善用目录！！！ 一、SpringBoot基本应用1.1 约定优于配置 Build Anything with Spring Boot：Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. ​ 上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。SpringBoot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。 约定优于配置（Convention over Configuration），又称按约定编程，是一种软件设计范式。 本质上是说，系统、类库或框架应该假定合理的默认值，而非要求提供不必要的配置。比如说模型中有一个名为User的类，那么数据库中对应的表就会默认命名为user。只有在偏离这一个约定的时候，例如想要将该表命名为person，才需要写有关这个名字的配置。 比如平时架构师搭建项目就是限制软件开发随便写代码，制定出一套规范，让开发人员按统一的要求进行开发编码测试之类的，这样就加强了开发效率与审查代码效率。所以说写代码的时候就需要按要求命名，这样统一规范的代码就有良好的可读性与维护性了 约定优于配置简单来理解，就是遵循约定 1.2 SpringBoot概念1.2.1 Spring优缺点分析优点： Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise Java Bean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能 缺点： 虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配 置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入 了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。 所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。 除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度 SSM整合：Spring、Spring MVC、Mybatis、Spring-Mybatis整合包、数据库驱动，引入依赖的数量繁多、容易存在版本冲突。 1.2.2 SpringBoot解决上述问题SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑 业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短 了项目周期。 起步依赖 起步依赖本质上是一个Maven项目对象模型(Project Object Model，POM)，定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的依赖坐标打包到一起，并提供一些默认的功能。 自动配置 springboot的自动配置，指的是springboot，会自动将一些配置类的bean注册进ioc容器，我们可以需要的地方使用@autowired或者@resource等注解来使用它。 “自动”的表现形式就是我们只需要引我们想用功能的包，相关的配置我们完全不用管，springboot会自动注入这些配置bean，我们直接使用这些bean即可 springboot: 简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率 1.3 Spring Boot入门案例案例需求：请求Controller中的方法，并将返回值响应到页面 （1）依赖管理12345678910111213141516171819202122232425262728&lt;!-- 所用的springBoot项目都会直接或者间接的继承spring-boot-starter-parent 1.指定项目的编码格式为UTF-8 2.指定JDK版本为1.8 3.对项目依赖的版本进行管理，当前项目再引入其他常用的依赖时就需要再指定版本号，避免版本 冲突的问题 4.默认的资源过滤和插件管理 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!--引入Spring Web及Spring MVC相关的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--可以将project打包为一个可以执行的jar--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; （2）启动类123456789101112/** * SpringBoot的启动类通常放在二级包中，比如：com.lagou.SpringBootDemo1Application * 因为SpringBoot项目在做包扫描，会扫描启动类所在的包及其子包下的所有内容。 *///标识当前类为SpringBoot项目的启动类 @SpringBootApplication public class SpringBootDemo1Application &#123; public static void main(String[] args) &#123; //样板代码 SpringApplication.run(SpringBootDemo1Application.class,args); &#125;&#125; （3）Controller1234567891011package com.lagou.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController @RequestMapping(&quot;/hello&quot;) public class HelloController &#123; @RequestMapping(&quot;/boot&quot;) public String helloBoot()&#123; return &quot;Hello Spring Boot&quot;; &#125;&#125; 1.4 SpringBoot快速构建案例需求：请求Controller中的方法，并将返回值响应到页面 （1）使用Spring Initializr方式构建SpringBoot项目​ 本质上说，Spring Initializr是一个Web应用，它提供了一个基本的项目结构，能够帮助我们快速构建一个基础的Spring Boot项目 Project SDK”用于设置创建项目使用的JDK版本，这里，使用之前初始化设置好的JDK版本即可；在Choose Initializr Service URL（选择初始化服务地址）”下使用默认的初始化服务地址https://start.spring.io进行Spring Boot项目创建（注意使用快速方式创建Spring Boot项目时，所在主机须在联网状态下） Spring Boot项目就创建好了。创建好的Spring Boot项目结构如图： ​ 使用Spring Initializr方式构建的Spring Boot项目会默认生成项目启动类、存放前端静态资源和页面的文件夹、编写项目配置的配置文件以及进行项目单元测试的测试类 （2）创建一个用于WEB访问的Controller​ com.lagou包下创建名称为controller的包，在该包下创建一个请求处理控制类HelloController，并编写一个请求处理方法 (注意：将项目启动类SpringBootDemoApplication移动到com.lagou包下) 1234567@RestController // 该注解为组合注解，等同于Spring中@Controller+@ResponseBody注解 public class DemoController &#123; @RequestMapping(&quot;/demo&quot;) public String demo()&#123; return &quot;hello spring Boot&quot;; &#125;&#125; （3）运行项目运行主程序启动类SpringbootDemoApplication，项目启动成功后，在控制台上会发现SpringBoot项目默认启动的端口号为8080，此时，可以在浏览器上访问“http://localhost:8080/hello” 页面输出的内容是“hello Spring Boot”，至此，构建Spring Boot项目就完成了 1.5 单元测试与热部署1.5.1 单元测试开发中，每当完成一个功能接口或业务方法的编写后，通常都会借助单元测试验证该功能是否正确。Spring Boot对项目的单元测试提供了很好的支持，在使用时，需要提前在项目的pom.xml文件中添加spring-boot-starter-test测试依赖启动器，可以通过相关注解实现单元测试 演示： 添加spring-boot-starter-test测试依赖启动器 在项目的pom.xml文件中添加spring-boot-starter-test测试依赖启动器，示例代码如下 ： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 注意：使用Spring Initializr方式搭建的Spring Boot项目，会自动加入spring-boot-starter-test测试依赖启动器，无需再手动添加 编写单元测试类和测试方法 使用Spring Initializr方式搭建的Spring Boot项目，会在src.test.java测试目录下自动创建与项目主程序启动类对应的单元测试类 12345678910111213141516171819202122232425262728package com.lagou;import com.lagou.controller.HelloController;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.junit.runners.JUnit4;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.junit4.SpringRunner;/** * SpringJUnit4ClassRunner.class:Spring运行环境 * JUnit4.class:JUnit运行环境 * SpringRunner.class:Spring Boot运行环境 */@RunWith(SpringRunner.class) //@RunWith:运行器 @SpringBootTest //标记为当前类为SpringBoot测试类，加载项目的ApplicationContext上下文环境 class Springbootdemo2ApplicationTests &#123; /** * 需求：调用HelloController的hello方法 */ @Autowired private HelloController helloController; @Test void contextLoads() &#123; String result = helloController.hello(); System.out.println(result); &#125;&#125; 上述代码中，先使用@Autowired注解注入了DemoController实例对象，然后在contextLoads()方法中调用了DemoController类中对应的请求控制方法contextLoads()，并输出打印结果 1.5.2 热部署​ 在开发过程中，通常会对一段业务代码不断地修改测试，在修改之后往往需要重启服务，有些服务需要加载很久才能启动成功，这种不必要的重复操作极大的降低了程序开发效率。为此，Spring Boot框架专门提供了进行热部署的依赖启动器，用于进行项目热部署，而无需手动重启项目 。 **热部署：**在修改完代码之后，不需要重新启动容器，就可以实现更新。 使用步骤： 1）添加SpringBoot的热部署依赖启动器 2）开启Idea的自动编译 3）开启Idea的在项目运行中自动编译的功能 演示： 添加spring-boot-devtools热部署依赖启动器 在Spring Boot项目进行热部署测试之前，需要先在项目的pom.xml文件中添加spring-boot-devtools热部署依赖启动器 12345&lt;!-- 引入热部署依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 由于使用的是IDEA开发工具，添加热部署依赖后可能没有任何效果，接下来还需要针对IDEA开发工具进行热部署相关的功能设置 IDEA工具热部署设置 选择IDEA工具界面的【File】-&gt;【Settings】选项，打开Compiler面板设置页面 选择Build下的Compiler选项，在右侧勾选“Build project automatically”选项将项目设置为自动编译，单击【Apply】→【OK】按钮保存设置 在项目任意页面中使用组合快捷键Ctrl+Shift+Alt+/打开Maintenance选项框，选中并打开Registry页面，具体如下图所示 列表中找到“compiler.automake.allow.when.app.running”，将该选项后的Value值勾选，用于指定IDEA工具在程序运行过程中自动编译，最后单击【Close】按钮完成设置 热部署效果测试 启动chapter01http://localhost:8080/hello 页面原始输出的内容是“hello Spring Boot”。 为了测试配置的热部署是否有效，接下来，在不关闭当前项目的情况下，将DemoController 类中的请求处理方法hello()的返回值修改为“你好，Spring Boot”并保存，查看控制台信息会发现项目能够自动构建和编译，说明项目热部署生效 可以看出，浏览器输出了“你好，Spring Boot”，说明项目热部署配置成功 1.6 全局配置文件全局配置文件能够对一些默认配置值进行修改。Spring Boot使用一个application.properties或者application.yaml的文件作为全局配置文件，该文件存放在src/main/resource目录或者类路径的/config，一般会选择resource目录。接下来，将针对这两种全局配置文件进行讲解 ： Spring Boot配置文件的命名及其格式： application.properties application.yaml application.yml 1.6.1 application.properties配置文件使用Spring Initializr方式构建Spring Boot项目时，会在resource目录下自动生成一个空的application.properties文件，Spring Boot项目启动时会自动加载application.properties文件。 我们可以在application.properties文件中定义Spring Boot项目的相关属性，当然，这些相关属性可以是系统属性、环境变量、命令参数等信息，也可以是自定义配置文件名称和位置 1234567#修改tomcat的版本号 server.port=8888 #定义数据库的连接信息 JdbcTemplate spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/lagou spring.datasource.username=root spring.datasource.password=wu7787879 接下来，通过一个案例对Spring Boot项目中application.properties配置文件的具体使用进行讲解 演示： 预先准备了两个实体类文件，后续会演示将application.properties配置文件中的自定义配置属性注入到Person实体类的对应属性中 （1）先在项目的com.lagou包下创建一个pojo包，并在该包下创建两个实体类Pet和Person 1234public class Pet &#123; private String type; private String name; &#125; 12345678910@Component @ConfigurationProperties(prefix = &quot;person&quot;) public class Person &#123; private int id;//id private String name;//名称 private List hobby;//爱好 private String[] family;//家庭成员 private Map map; private Pet pet;//宠物&#125; @ConfigurationProperties(prefix &#x3D; “person”)注解的作用是将配置文件中以person开头的属性值通过setXX()方法注入到实体类对应属性中 @Component注解的作用是将当前注入属性值的Person类对象作为Bean组件放到Spring容器中，只有这样才能被@ConfigurationProperties注解进行赋值 （2）打开项目的resources目录下的application.properties配置文件，在该配置文件中编写需要对Person类设置的配置属性 123456789#自定义配置信息 person.id=1 person.name=王二麻子 person.hobby=read,write person.family=father,mather person.map.key1=value1 person.map.key2=value2 person.pet.type=dog person.pet.name=哈士奇 （3）查看application.properties配置文件是否正确，同时查看属性配置效果，打开通过IDEA工具创建的项目测试类，在该测试类中引入Person实体类Bean，并进行输出测试 1234567891011@RunWith(SpringRunner.class) // 测试启动器，并加载Spring Boot测试注解 @SpringBootTest // 标记为Spring Boot单元测试类，并加载项目的ApplicationContext上下文环 境class SpringbootDemoApplicationTests &#123; // 配置测试 @Autowired private Person person; @Test void configurationTest() &#123; System.out.println(person); &#125;&#125; 打印结果： 可以看出，测试方法configurationTest()运行成功，同时正确打印出了Person实体类对象。至此，说明application.properties配置文件属性配置正确，并通过相关注解自动完成了属性注入 （4）中文乱码问题解决 调整文件编码格式： 设置Tomcat及Http编码 12345#解决中文乱码 server.tomcat.uri-encoding=UTF-8 spring.http.encoding.force=true spring.http.encoding.charset=UTF-8 spring.http.encoding.enabled=true 1.6.2 application.yaml配置文件YAML文件格式是Spring Boot支持的一种JSON文件格式，相较于传统的Properties配置文件，YAML文件以数据为核心，是一种更为直观且容易被电脑识别的数据序列化格式。application.yaml配置文件的工作原理和application.properties是一样的，只不过yaml格式配置文件看起来更简洁一些。 YAML文件的扩展名可以使用.yml或者.yaml。 application.yml文件使用 “key:（空格）value”格式配置属性，使用缩进控制层级关系。 SpringBoot的三种配置文件是可以共存的： 这里，针对不同数据类型的属性值，介绍一下YAML （1）value值为普通数据类型（例如数字、字符串、布尔等） 当YAML配置文件中配置的属性值为普通数据类型时，可以直接配置对应的属性值，同时对于字符串类型的属性值，不需要额外添加引号，示例代码如下 1234server: port: 8080 servlet: context-path: /hello （2）value值为数组和单列集合 当YAML配置文件中配置的属性值为数组或单列集合类型时，主要有两种书写方式：缩进式写法和行内式写法。 其中，缩进式写法还有两种表示形式，示例代码如下 12345person: hobby: - play - read - sleep 或者使用如下示例形式 12345person: hobby: play, read, sleep 上述代码中，在YAML配置文件中通过两种缩进式写法对person对象的单列集合（或数组）类型的爱好hobby赋值为play、read和sleep。其中一种形式为“-（空格）属性值”，另一种形式为多个属性值之前加英文逗号分隔（注意，最后一个属性值后不要加逗号）。 12person: hobby: [play,read,sleep] 通过上述示例对比发现，YAML配置文件的行内式写法更加简明、方便。另外，包含属性值的中括号“[]”还可以进一步省略，在进行属性赋值时，程序会自动匹配和校对 （3）value值为Map集合和对象 当YAML配置文件中配置的属性值为Map集合或对象类型时，YAML配置文件格式同样可以分为两种书写方式：缩进式写法和行内式写法。 其中，缩进式写法的示例代码如下 1234person: map: k1: v1 k2: v2 对应的行内式写法示例代码如下 12person: map: &#123;k1: v1,k2: v2&#125; 在YAML配置文件中，配置的属性值为Map集合或对象类型时，缩进式写法的形式按照YAML文件格式编写即可，而行内式写法的属性值要用大括号“{}”包含。 接下来，在Properties配置文件演示案例基础上，通过配置application.yaml配置文件对Person对象进行赋值，具体使用如下 （1）在项目的resources目录下，新建一个application.yaml配置文件，在该配置文件中编写为Person类设置的配置属性 1234567891011121314151617#对实体类对象Person进行属性配置person: id: 1 name: 王二麻子 family: - 妻 - 妾 hobby: - play - read - sleep map: k1: value1 k2: value2 pet: type: 狗 name: 哈士奇 （2）再次执行测试 12345678Person&#123; id=1, name=&#x27;王二麻子&#x27;, hobby=[play, read, sleep], family=[妻, 妾], map=&#123;k1=value1,k2=value2&#125;, pet=Pet&#123;type=&#x27;狗&#x27;, name=&#x27;哈士奇&#x27;&#125;&#125; 可以看出，测试方法configurationTest()同样运行成功，并正确打印出了Person实体类对象。 需要说明的是，本次使用application.yaml配置文件进行测试时需要提前将application.properties配置文件中编写的配置注释，这是因为application.properties配置文件会覆盖application.yaml配置文件 1.7 配置文件属性注入配置文件的优先级如下： 从低到高 12345&lt;includes&gt; &lt;include&gt;**/application*.yml&lt;/include&gt; &lt;include&gt;**/application*.yaml&lt;/include&gt; &lt;include&gt;**/application*.properties&lt;/include&gt;&lt;/includes&gt; 使用Spring Boot全局配置文件设置属性时： 如果配置属性是Spring Boot已有属性，例如服务端口server.port，那么Spring Boot内部会自动扫描并读取这些配置文件中的属性值并覆盖默认属性。 如果配置的属性是用户自定义属性，例如刚刚自定义的Person实体类属性，还必须在程序中注入这些配置属性方可生效。 Spring Boot支持多种注入配置文件属性的方式，下面来介绍如何使用注解@ConfigurationProperties和@Value注入属性 1.7.1 使用@ConfigurationProperties注入属性Spring Boot提供的@ConfigurationProperties注解用来快速、方便地将配置文件中的自定义属性值批量注入到某个Bean对象的多个对应属性中。假设现在有一个配置文件，如果使用@ConfigurationProperties注入配置文件的属性，示例代码如下： 12345678910111213@Component //将配置文件中所有以person开头的配置信息注入当前类中 //前提1：必须保证配置文件中person.xx与当前Person类的属性名一致 //前提2：必须保证当前Person中的属性都具有set方法 @ConfigurationProperties(prefix = &quot;person&quot;) public class Person &#123; private int id; //id private String name; //名称 private List hobby; //爱好 private String[] family; //家庭成员 private Map map; private Pet pet; //宠物&#125; 上述代码使用@Component和@ConfigurationProperties(prefix &#x3D; “person”)将配置文件中的每个属性映射到person类组件中。 1.7.2 使用@Value注入属性 @Value注解是Spring框架提供的，用来读取配置文件中的属性值并逐个注入到Bean对象的对应属性中，Spring Boot框架从Spring框架中对@Value注解进行了默认继承，所以在Spring Boot框架中还可以使用该注解读取和注入配置文件属性值。使用@Value注入属性的示例代码如下 1234@Component public class Person &#123; @Value(&quot;$&#123;person.id&#125;&quot;) private int id;&#125; 上述代码中，使用@Component和@Value注入Person实体类的id属性。其中，@Value不仅可以将配置文件的属性注入Person的id属性，还可以直接给id属性赋值，这点@ConfigurationProperties不支持的 演示@Value注解读取并注入配置文件属性的使用: 在com.lagou.pojo包下新创建一个实体类Student，并使用@Value注解注入属性 12345678@Component public class Student &#123; @Value(&quot;$&#123;person.id&#125;&quot;) private int id; @Value(&quot;$&#123;person.name&#125;&quot;) private String name; //名称 //省略toString&#125; Student类使用@Value注解将配置文件的属性值读取和注入。 从上述示例代码可以看出，使用@Value注解方式需要对每一个属性注入设置，同时又免去了属性的setXX()方法 再次打开测试类进行测试 123456@Autowired private Student student;@Test public void studentTest() &#123; System.out.println(student);&#125; 打印结果： 可以看出，测试方法studentTest()运行成功，同时正确打印出了Student实体类对象。需要说明的是，本示例中只是使用@Value注解对实例中Student对象的普通类型属性进行了赋值演示，而@Value注解对于包含Map集合、对象以及YAML文件格式的行内式写法的配置文件的属性注入都不支持，如果赋值会出现错误 1.8 自定义配置​ spring Boot免除了项目中大部分的手动配置，对于一些特定情况，我们可以通过修改全局配置文件以适应具体生产环境，可以说，几乎所有的配置都可以写在application.yml文件中，Spring Boot会自动加载全局配置文件从而免除我们手动加载的烦恼。但是，如果我们自定义配置文件，Spring Boot是无法识别这些配置文件的，此时就需要我们手动加载。接下来，将针对Spring Boot的自定义配置文件及其加载方式进行讲解 1.8.1 使用@PropertySource加载配置文件对于这种加载自定义配置文件的需求，可以使用@PropertySource注解来实现。@PropertySource注解用于指定自定义配置文件的具体位置和名称当然，如果需要将自定义配置文件中的属性值注入到对应类的属性中，可以使用@ConfigurationProperties或者@Value注解进行属性值注入 演示： 打开Spring Boot项目的resources目录，在项目的类路径下新建一个test.properties自定义配置文件，在该配置文件中编写需要设置的配置属性 123#对实体类对象MyProperties进行属性配置 test.id=110 test.name=test 在com.lagou.pojo包下新创建一个配置类MyProperties，提供test.properties自定义配置文件中对应的属性，并根据@PropertySource注解的使用进行相关配置 123456789@Component // 自定义配置类 @PropertySource(&quot;classpath:test.properties&quot;) // 指定自定义配置文件位置和名称 @ConfigurationProperties(prefix = &quot;test&quot;) // 指定配置文件注入属性前缀 public class MyProperties &#123; private int id; private String name; // 省略属性getXX()和setXX()方法 // 省略toString()方法&#125; 主要是一个自定义配置类，通过相关注解引入了自定义的配置文件，并完成了自定义属性值的注入。针对示例中的几个注解，具体说明如下 : @PropertySource(“classpath:test.properties”)注解指定了自定义配置文件的位置和名称，此示例表示自定义配置文件为classpath类路径下的test.properties文件； @ConfigurationProperties(prefix &#x3D; “test”)注解将上述自定义配置文件test.properties中以test开头的属性值注入到该配置类属性中。 进行测试 123456@Autowired private MyProperties myProperties;@Test public void myPropertiesTest() &#123; System.out.println(myProperties);&#125; 打印结果： 1.8.2 使用@Configuration编写自定义配置类在Spring Boot框架中，推荐使用配置类的方式向容器中添加和配置组件 在Spring Boot框架中，通常使用@Configuration注解定义一个配置类，Spring Boot会自动扫描和识别配置类，从而替换传统Spring框架中的XML配置文件。 当定义一个配置类后，还需要在类中的方法上使用@Bean注解进行组件配置，将方法的返回对象注入到Spring容器中，并且组件名称默认使用的是方法名，当然也可以使用@Bean注解的name或value属性自定义组件的名称 演示： 在项目下新建一个com.lagou.config包，并在该包下新创建一个类MyService，该类中不需要编写任何代码 123public class MyService &#123;&#125; 创建了一个空的MyService类，而该类目前没有添加任何配置和注解，因此还无法正常被Spring Boot扫描和识别 在项目的com.lagou.config包下，新建一个类MyConfig，并使用@Configuration注解将该类声明一个配置类，内容如下： 1234567@Configuration // 定义该类是一个配置类public class MyConfig &#123; @Bean // 将返回值对象作为组件添加到Spring容器中，该组件id默认为方法名 public MyService myService()&#123; return new MyService(); &#125;&#125; MyConfig是@Configuration注解声明的配置类（类似于声明了一个XML配置文件），该配置类会被Spring Boot自动扫描识别；使用@Bean注解的myService()方法，其返回值对象会作为组件添加到了Spring容器中（类似于XML配置文件中的标签配置），并且该组件的id默认是方法名myService 测试类 123456@Autowired private ApplicationContext applicationContext;@Test public void iocTest() &#123; System.out.println(applicationContext.containsBean(&quot;myService&quot;));&#125; 上述代码中，先通过@Autowired注解引入了Spring容器实例ApplicationContext，然后在测试方法iocTest()中测试查看该容器中是否包括id为myService的组件。 执行测试方法iocTest() ，查看控制台输出效果，结果如下： 从测试结果可以看出，测试方法iocTest()运行成功，显示运行结果为true，表示Spirng的IOC容器中也已经包含了id为myService的实例对象组件，说明使用自定义配置类的形式完成了向Spring容器进行组件的添加和配置 二、SpringBoot原理深入及源码剖析​ 传统的Spring框架实现一个Web服务，需要导入各种依赖JAR包，然后编写对应的XML配置文件等，相较而言，Spring Boot显得更加方便、快捷和高效。那么，Spring Boot究竟如何做到这些的呢？ 接下来分别针对Spring Boot框架的依赖管理、自动配置通过源码进行深入分析 2.1 依赖管理**问题1：**为什么导入dependency时不需要指定版本？ 在Spring Boot入门程序中，项目pom.xml文件有两个核心依赖，分别是spring-boot-starter-parent和spring-boot-starter-web，关于这两个依赖的相关介绍具体如下： spring-boot-starter-parent依赖 在chapter01项目中的pom.xml文件中找到spring-boot-starter-parent依赖，示例代码如下: 1234567&lt;!-- Spring Boot父项目依赖管理 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 上述代码中，将spring-boot-starter-parent依赖作为Spring Boot项目的统一父项目依赖管理，并将项目版本号统一为2.2.2.RELEASE，该版本号根据实际开发需求是可以修改的 使用“Ctrl+鼠标左键”进入并查看spring-boot-starter-parent底层源文件，发现spring-boot-starter-parent的底层有一个父依赖spring-boot-dependencies，核心代码具体如下 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 继续查看spring-boot-dependencies底层源文件，核心代码具体如下： 1234567891011121314151617181920&lt;properties&gt; &lt;activemq.version&gt;5.15.11&lt;/activemq.version&gt; ... &lt;solr.version&gt;8.2.0&lt;/solr.version&gt; &lt;mysql.version&gt;8.0.18&lt;/mysql.version&gt; &lt;kafka.version&gt;2.3.1&lt;/kafka.version&gt; &lt;spring-amqp.version&gt;2.2.2.RELEASE&lt;/spring-amqp.version&gt; &lt;spring-restdocs.version&gt;2.0.4.RELEASE&lt;/spring-restdocs.version&gt; &lt;spring-retry.version&gt;1.2.4.RELEASE&lt;/spring-retry.version&gt; &lt;spring-security.version&gt;5.2.1.RELEASE&lt;/spring-security.version&gt; &lt;spring-session-bom.version&gt;Corn-RELEASE&lt;/spring-session-bom.version&gt; &lt;spring-ws.version&gt;3.0.8.RELEASE&lt;/spring-ws.version&gt; &lt;sqlite-jdbc.version&gt;3.28.0&lt;/sqlite-jdbc.version&gt; &lt;sun-mail.version&gt;$&#123;jakarta-mail.version&#125;&lt;/sun-mail.version&gt; &lt;tomcat.version&gt;9.0.29&lt;/tomcat.version&gt; &lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-extras-data-attribute.version&gt;2.0.1 &lt;/thymeleaf-extras-data- attribute.version&gt; ... &lt;/properties&gt; 从spring-boot-dependencies底层源文件可以看出，该文件通过标签对一些常用技术框架的依赖文件进行了统一版本号管理，例如activemq、spring、tomcat等，都有与Spring Boot 2.2.2版本相匹配的版本，这也是pom.xml引入依赖文件不需要标注依赖文件版本号的原因。 需要说明的是，如果pom.xml引入的依赖文件不是 spring-boot-starter-parent管理的，那么在pom.xml引入依赖文件时，需要使用标签指定依赖文件的版本号。 问题2： spring-boot-starter-parent父依赖启动器的主要作用是进行版本统一管理，那么项目运行依赖的JAR包是从何而来的？ spring-boot-starter-web依赖 查看spring-boot-starter-web依赖文件源码，核心代码具体如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 从上述代码可以发现，spring-boot-starter-web依赖启动器的主要作用是提供Web开发场景所需的底层所有依赖 正是如此，在pom.xml中引入spring-boot-starter-web依赖启动器时，就可以实现Web场景开发，而不需要额外导入Tomcat服务器以及其他Web依赖文件等。当然，这些引入的依赖文件的版本号还是由spring-boot-starter-parent父依赖进行的统一管理。 有哪些starter： https://github.com/spring-projects/spring-boot/tree/v2.1.0.RELEASE/spring-boot-project/spring-boot-starters https://mvnrepository.com/search?q=starter Spring Boot除了提供有上述介绍的Web依赖启动器外，还提供了其他许多开发场景的相关依赖，我们可以打开Spring Boot官方文档，搜索“Starters”关键字查询场景依赖启动器 列出了Spring Boot官方提供的部分场景依赖启动器，这些依赖启动器适用于不同的场景开发，使用时只需要在pox.xml文件中导入对应的依赖启动器即可。 需要说明的是，Spring Boot官方并不是针对所有场景开发的技术框架都提供了场景启动器，例如数据库操作框架MyBatis、阿里巴巴的Druid数据源等，Spring Boot官方就没有提供对应的依赖启动器。为了充分利用Spring Boot框架的优势，在Spring Boot官方没有整合这些技术框架的情况下，MyBatis、Druid等技术框架所在的开发团队主动与Spring Boot框架进行了整合，实现了各自的依赖启动器，例如mybatis-spring-boot-starter、druid-spring-boot-starter等。我们在pom.xml文件中引入这些第三方的依赖启动器时，切记要配置对应的版本号 2.2 自动配置概念：能够在我们添加jar包依赖的时候，自动为我们配置一些组件的相关配置，我们无需配置或者只需要少量配置就能运行编写的项目 问题：Spring Boot到底是如何进行自动配置的，都把哪些组件进行了自动配置？ Spring Boot应用的启动入口是@SpringBootApplication注解标注类中的main()方法， @SpringBootApplication ： SpringBoot 应用标注在某个类上说明这个类是 SpringBoot 的主配置类， SpringBoot 就应该运行这个类的 main() 方法启动 SpringBoot 应用。 下面，查看@SpringBootApplication内部源码进行分析 ，核心代码具体如下 123456@SpringBootApplication public class SpringbootDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDemoApplication.class, args); &#125;&#125; 进入到 @SpringBootApplication 内，观察其做了哪些工作： 123456789101112131415161718192021222324@Target(&#123;ElementType.TYPE&#125;) //注解的适用范围,Type表示注解可以描述在类、接口、注解或枚举中 @Retention(RetentionPolicy.RUNTIME) //表示注解的生命周期，Runtime运行时 @Documented //表示注解可以记录在javadoc中 @Inherited //表示可以被子类继承该注解 @SpringBootConfiguration // 标明该类为配置类@EnableAutoConfiguration // 启动自动配置功能 @ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; // 根据class来排除特定的类，使其不能加入spring容器，传入参数value类型是class类型。 @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; // 根据classname 来排除特定的类，使其不能加入spring容器，传入参数value类型是class的全 类名字符串数组。 @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default &#123;&#125;; // 指定扫描包，参数是包名的字符串数组。 @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default &#123;&#125;; // 扫描特定的包，参数类似是Class类型数组。 @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; &#125; 从上述源码可以看出，@SpringBootApplication注解是一个组合注解，前面 4 个是注解的元数据信息， 我们主要看后面 3 个注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个核心注解，关于这三个核心注解的相关说明具体如下： 2.2.1 @SpringBootConfiguration注解@SpringBootConfiguration : SpringBoot 的配置类，标注在某个类上，表示这是一个 SpringBoot的配置类。 查看@SpringBootConfiguration注解源码，核心代码具体如下。 12345678@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration // 配置类的作用等同于配置文件，配置类也是容器中的一个对象 public @interface SpringBootConfiguration &#123; &#125; 从上述源码可以看出，@SpringBootConfiguration注解内部有一个核心注解@Configuration，该注解是Spring框架提供的，表示当前类为一个配置类（XML配置文件的注解表现形式），并可以被组件扫描器扫描。由此可见，@SpringBootConfiguration注解的作用与@Configuration注解相同，都是标识一个可以被组件扫描器扫描的配置类，只不过@SpringBootConfiguration是被Spring Boot进行了重新封装命名而已 2.2.2 @EnableAutoConfiguration注解@EnableAutoConfiguration : 开启自动配置功能，以前由我们需要配置的东西，现在由 SpringBoot帮我们自动配置，这个注解就是 Springboot 能实现自动配置的关键。 同样，查看该注解内部查看源码信息，核心代码具体如下 12345678910111213// 自动配置包@AutoConfigurationPackage// Spring的底层注解@Import，给容器中导入一个组件// 导入的组件是AutoConfigurationPackages.Registrar.class@Import(AutoConfigurationImportSelector.class)// 告诉SpringBoot开启自动配置功能，这样自动配置才能生效。public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; // 返回不会被导入到 Spring 容器中的类 Class&lt;?&gt;[] exclude() default &#123;&#125;; // 返回不会被导入到 Spring 容器中的类名 String[] excludeName() default &#123;&#125;;&#125; 可以发现它是一个组合注解， Spring 中有很多以 Enable 开头的注解，其作用就是借助 @Import来收集并注册特定场景相关的 Bean ，并加载到 IOC 容器。@EnableAutoConfiguration就是借助@Import来收集所有符合自动配置条件的bean定义，并加载到IoC容器。 下面，对这两个核心注解分别讲解 : @AutoConfigurationPackage注解 查看@AutoConfigurationPackage注解内部源码信息，核心代码具体如下： 1234567@Target(&#123;ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Import(&#123;Registrar.class&#125;) // 导入Registrar中注册的组件public @interface AutoConfigurationPackage &#123; &#125; 从上述源码可以看出，@AutoConfigurationPackage注解的功能是由@Import注解实现的，它是spring框架的底层注解，它的作用就是给容器中导入某个组件类，例如@Import(AutoConfigurationPackages.Registrar.class)，它就是将Registrar这个组件类导入到容器中，可查看Registrar类中registerBeanDefinitions方法，这个方法就是导入组件类的具体实现 : 从上述源码可以看出，在Registrar类中有一个registerBeanDefinitions()方法，使用Debug模式启动项目，可以看到选中的部分就是com.lagou。也就是说，@AutoConfigurationPackage注解的主要作用就是将主程序类所在包及所有子包下的组件到扫描到spring容器中。 因此 在定义项目包结构时，要求定义的包结构非常规范，项目主程序启动类要定义在最外层的根目录位置，然后在根目录位置内部建立子包和类进行业务开发，这样才能够保证定义的类能够被组件扫描器扫描 @Import({AutoConfigurationImportSelector.class})注解 将 AutoConfigurationImportSelector 这个类导入到 Spring 容器中，AutoConfigurationImportSelector可以帮助 Springboot 应用将所有符合条件的的 @Configuration配置都加载到当前创建并使用的 IOC 容器( ApplicationContext )中。 继续研究AutoConfigurationImportSelector这个类，通过源码分析这个类中是通过selectImports这个方法告诉springboot都需要导入那些组件： 深入研究loadMetadata方法 AutoConfigurationImportSelector类 getAutoConfigurationEntry方法 123456789101112131415161718192021protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; //判断EnabledAutoConfiguration注解有没有开启,默认开启 if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; //获得注解的属性信息 AnnotationAttributes attributes = getAttributes(annotationMetadata); //获取默认支持的自动配置类列表 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //去重 configurations = removeDuplicates(configurations); //去除一些多余的配置类，根据EnabledAutoConfiguratio的exclusions属性进行排除 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); //根据pom文件中加入的依赖文件筛选中最终符合当前项目运行环境对应的自动配置类 configurations = filter(configurations, autoConfigurationMetadata); //触发自动配置导入监听事件 fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);&#125; 深入getCandidateConfigurations方法 这个方法中有一个重要方法loadFactoryNames，这个方法是让SpringFactoryLoader去加载一些组件的名字。 继续点开loadFactory方法 123456789101112131415161718192021222324252627282930313233343536public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; //获取出入的键 String factoryClassName = factoryClass.getName(); return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; //如果类加载器不为null，则加载类路径下spring.factories文件，将其中设置的 配置类的全路径信息封装 为Enumeration类对象 Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result = new LinkedMultiValueMap(); //循环Enumeration类对象，根据相应的节点信息生成Properties对象，通过传入的 键获取值，在将值切割为一个个小的字符串转化为Array，方法result集合中 while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for (int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; &#125;&#125; 会去读取一个 spring.factories 的文件，读取不到会表这个错误，我们继续根据会看到，最终路径的长这样，而这个是spring提供的一个工具类 123public final class SpringFactoriesLoader &#123; public static final String FACTORIES_RESOURCE_LOCATION = &quot;META- INF/spring.factories&quot;; &#125; 它其实是去加载一个外部的文件，而这文件是在 @EnableAutoConfiguration就是从classpath中搜寻META-INF&#x2F;spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（JavaRefletion）实例化为对应的标注了@Configuration的JavaConfig形式的配置类，并加载到IOC容器中 以刚刚的项目为例，在项目中加入了Web环境依赖启动器，对应的WebMvcAutoConfiguration自动配置类就会生效，打开该自动配置类会发现，在该配置类中通过全注解配置类的方式对Spring MVC运行所需环境进行了默认配置，包括默认前缀、默认后缀、视图解析器、MVC校验器等。而这些自动配置类的本质是传统Spring MVC框架中对应的XML配置文件，只不过在Spring Boot中以自动配置类的形式进行了预先配置。因此，在Spring Boot项目中加入相关依赖启动器后，基本上不需要任何配置就可以运行程序，当然，我们也可以对这些自动配置类中默认的配置进行更改 总结 因此springboot底层实现自动配置的步骤是： springboot应用启动 @SpringBootApplication起作用 @EnableAutoConfiguration @AutoConfigurationPackage：这个组合注解主要是@Import(AutoConfigurationPackages.Registrar.class)，它通过将Registrar类导入到容器中，而Registrar类作用是扫描主配置类同级目录以及子包，并将相应的组件导入到springboot创建管理的容器中； @Import(AutoConfigurationImportSelector.class)：它通过将AutoConfigurationImportSelector类导入到容器中，AutoConfigurationImportSelector类作用是通过selectImports方法执行的过程中，会使用内部工具类SpringFactoriesLoader，查找classpath上所有jar包中的META\u0002INF&#x2F;spring.factories进行加载，实现将配置类信息交给SpringFactory加载器进行一系列的容器创建过程 2.2.3 @ComponentScan注解@ComponentScan注解具体扫描的包的根路径由Spring Boot项目主程序启动类所在包位置决定，在扫描过程中由前面介绍的@AutoConfigurationPackage注解进行解析，从而得到Spring Boot项目主程序启动类所在包的具体位置 总结： @SpringBootApplication 的注解的功能就分析差不多了， 简单来说就是 3 个注解的组合注解： 123456|- @SpringBootConfiguration |- @Configuration //通过javaConfig的方式来添加组件到IOC容器中|- @EnableAutoConfiguration |- @AutoConfigurationPackage //自动配置包，与@ComponentScan扫描到的添加到IOC |- @Import(AutoConfigurationImportSelector.class) //到META- INF/spring.factories中定义的bean添加到IOC容器中|- @ComponentScan //包扫描 三、SpringBoot数据访问3.1 SpringBoot整合MybatisMyBatis 是一款优秀的持久层框架，Spring Boot官方虽然没有对MyBatis进行整合，但是MyBatis团队自行适配了对应的启动器，进一步简化了使用MyBatis进行数据的操作 因为Spring Boot框架开发的便利性，所以实现Spring Boot与数据访问层框架（例如MyBatis）的整合非常简单，主要是引入对应的依赖启动器，并进行数据库相关参数设置即可 3.1.1 基础环境搭建 数据准备 在MySQL中，先创建了一个数据库springbootdata，然后创建了两个表t_article和t_comment并向表中插入数据。其中评论表t_comment的a_id与文章表t_article的主键id相关联 12345678910111213141516171819202122232425262728# 创建数据库CREATE DATABASE springbootdata;# 选择使用数据库USE springbootdata;# 创建表t_article并插入相关数据DROP TABLE IF EXISTS t_article;CREATE TABLE t_article( id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;文章id&#x27;, title varchar(200) DEFAULT NULL COMMENT &#x27;文章标题&#x27;, content longtext COMMENT &#x27;文章内容&#x27;, PRIMARY KEY(id)) ENGINE = InnoDB AUTO_INCREMENT = 2 DEFAULT CHARSET = utf8;INSERT INTO t_article VALUES (&#x27;1&#x27;, &#x27;Spring Boot基础入门&#x27;, &#x27;从入门到精通讲解...&#x27;);INSERT INTO t_article VALUES (&#x27;2&#x27;, &#x27;Spring Cloud基础入门&#x27;, &#x27;从入门到精通讲 解...&#x27;);# 创建表t_comment并插入相关数据DROP TABLE IF EXISTS t_comment;CREATE TABLE t_comment ( id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;评论id&#x27;, content longtext COMMENT &#x27;评论内容&#x27;, author varchar(200) DEFAULT NULL COMMENT &#x27;评论作者&#x27;, a_id int(20) DEFAULT NULL COMMENT &#x27;关联的文章id&#x27;, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;INSERT INTO t_comment VALUES (&#x27;1&#x27;, &#x27;很全、很详细&#x27;, &#x27;lucy&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;2&#x27;, &#x27;赞一个&#x27;, &#x27;tom&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;3&#x27;, &#x27;很详细&#x27;, &#x27;eric&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;4&#x27;, &#x27;很好，非常详细&#x27;, &#x27;张三&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;5&#x27;, &#x27;很不错&#x27;, &#x27;李四&#x27;, &#x27;2&#x27;); 创建项目，引入相应的启动器 编写与数据库表t_comment和t_article对应的实体类Comment和Article 123456public class Comment &#123; private Integer id; private String content; private String author; private Integer aId; &#125; 12345public class Article &#123; private Integer id; private String title; private String content; &#125; 编写配置文件 application.properties 123456# MySQL数据库连接配置spring: datasource: url: jdbc:mysql://localhost:3306/springbootdata? serverTimezone=UTC&amp;characterEncoding=UTF-8 username: root password: 123456 3.1.2 注解方式整合Mybatis 创建一个对t_comment表数据操作的接口CommentMapper 1234public interface CommentMapper &#123; @Select(&quot;SELECT * FROM t_comment WHERE id =#&#123;id&#125;&quot;) public Comment findById(Integer id); &#125; 在Spring Boot项目启动类上添加@MapperScan(“xxx”)注解 1234567@SpringBootApplication @MapperScan(&quot;com.lagou.mapper&quot;) public class Springboot02MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot02MybatisApplication.class, args); &#125; &#125; 编写测试方法 1234567891011@RunWith(SpringRunner.class) @SpringBootTest class SpringbootPersistenceApplicationTests &#123; @Autowired private CommentMapper commentMapper; @Test void contextLoads() &#123; Comment comment = commentMapper.findById(1); System.out.println(comment); &#125;&#125; 打印结果 控制台中查询的Comment的aId属性值为null，没有映射成功。这是因为编写的实体类Comment中使用了驼峰命名方式将t_comment表中的a_id字段设计成了aId属性，所以无法正确映射查询结果。 为了解决上述由于驼峰命名方式造成的表字段值无法正确映射到类属性的情况，可以在Spring Boot全局配置文件application.properties中添加开启驼峰命名匹配映射配置，示例代码如下 1234#开启驼峰命名匹配映射mybatis: configuration: map-underscore-to-camel-case: true 再次打印 3.1.3 配置文件方式整合Mybatis第一、二步骤使用Free Mybatis plugin插件生成 创建一个用于对数据库表t_article数据操作的接口ArticleMapper 123@Mapper public interface ArticleMapper &#123; public Article selectArticle(Integer id); &#125; 创建XML映射文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.lagou.mapper.ArticleMapper&quot;&gt; &lt;select id=&quot;selectArticle&quot; resultType=&quot;Article&quot;&gt; select * from Article &lt;/select&gt; &lt;/mapper&gt; 配置XML映射文件路径 在项目中编写的XML映射文件，Spring Boot并无从知晓，所以无法扫描到该自定义编写的XML配置文件，还必须在全局配置文件application.properties中添加MyBatis映射文件路径的配置，同时需要添加实体类别名映射路径，示例代码如下 12345mybatis: #配置MyBatis的xml配置文件路径 mapper-locations: classpath:mapper/*.xml #配置XML映射文件中指定的实体类别名路径 type-aliases-package: com.lagou.base.pojo 编写单元测试进行接口方法测试 1234567@Autowired private ArticleMapper articleMapper;@Test void contextLoads2() &#123; Article article = articleMapper.selectByPrimaryKey(1); System.out.println(article);&#125; 打印结果 3.2 SpringBoot整合Redis 添加Redis依赖包 在项目的pom.xml中添加如下： 1234&lt;!-- redis依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 配置Redis数据库连接 在application.properties中配置redis数据库连接信息，如下： 1234567891011121314151617#redis配置 #Redis服务器地址 spring.redis.host=127.0.0.1 #Redis服务器连接端口 spring.redis.port=6379#Redis数据库索引（默认为0） spring.redis.database=0 #连接池最大连接数（使用负值表示没有限制） spring.redis.jedis.pool.max-active=50 #连接池最大阻塞等待时间（使用负值表示没有限制） spring.redis.jedis.pool.max-wait=3000 #连接池中的最大空闲连接 spring.redis.jedis.pool.max-idle=20 #连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=2 #连接超时时间（毫秒） spring.redis.timeout=5000 编写Redis操作工具类 将RedisTemplate实例包装成一个工具类，便于对redis进行数据操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lagou.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import java.util.concurrent.TimeUnit;@Component public class RedisUtils &#123; @Autowired private RedisTemplate redisTemplate; /*** 读取缓存 ** @param key * @return */ public Object get(final String key) &#123; return redisTemplate.opsForValue().get(key); &#125; /*** 写入缓存 */ public Boolean set( String key, Object value) &#123; Boolean result = false; try &#123; redisTemplate.opsForValue().set(key, value,1, TimeUnit.DAYS); result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /*** 更新缓存 */ public Boolean getAndSet(final String key, String value) &#123; Boolean result = false; try &#123; redisTemplate.opsForValue().getAndSet(key, value); result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /*** 删除缓存 */ public Boolean delete(final String key) &#123; Boolean result = false; try &#123; redisTemplate.delete(key); result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125; 测试 写一个测试用例类来完成对redis的整合 123456789101112131415161718@RunWith(SpringRunner.class) @SpringBootTest class Springboot02MybatisApplicationTests &#123; @Autowired private RedisUtils redisUtils; @Autowired private CommentMapper commentMapper; @Test public void setRedisData() &#123; redisUtils.set(&quot;article_1&quot;,articleMapper.selectByPrimaryKey(1)); System.out.println(&quot;success&quot;); &#125; @Test public void getRedisData() &#123; Article article = (Article) redisUtils.get(&quot;article_1&quot;); System.out.println(article); &#125;&#125; 四、SpringBoot视图技术4.1 支持的视图技术前端模板引擎技术的出现，使前端开发人员无需关注后端业务的具体实现，只关注自己页面的呈现效果即可，并且解决了前端代码错综复杂的问题、实现了前后端分离开发。Spring Boot框架对很多常用的模板引擎技术（如：FreeMarker、Thymeleaf、Mustache等）提供了整合支持 Spring Boot不太支持常用的JSP模板，并且没有提供对应的整合配置，这是因为使用嵌入式Servlet容器的Spring Boot应用程序对于JSP模板存在一些限制 ： 在Jetty和Tomcat容器中，Spring Boot应用被打包成war文件可以支持JSP。但Spring Boot默认使用嵌入式Servlet容器以JAR包方式进行项目打包部署，这种JAR包方式不支持JSP。 如果使用Undertow嵌入式容器部署Spring Boot项目，也不支持JSP模板。（Undertow 是红帽公司开发的一款基于 NIO 的高性能 Web 嵌入式服务器） Spring Boot默认提供了一个处理请求路径“&#x2F;error”的统一错误处理器，返回具体的异常信息。使用JSP模板时，无法对默认的错误处理器进行覆盖，只能根据Spring Boot要求在指定位置定制错误页面。 上面对Spring Boot支持的模板引擎进行了介绍，并指出了整合JSP模板的一些限制。接下来，对其中常用的Thymeleaf模板引擎进行介绍，并完成与Spring Boot框架的整合实现 4.2 ThymeleafThymeleaf是一种现代的基于服务器端的Java模板引擎技术，也是一个优秀的面向Java的XML、XHTML、HTML5页面模板，它具有丰富的标签语言、函数和表达式，在使用Spring Boot框架进行页面设计时，一般会选择Thymeleaf模板 4.2.1 Thymeleaf语法 常用标签 在HTML页面上使用Thymeleaf标签，Thymeleaf 标签能够动态地替换掉静态内容，使页面动态展示。 为了大家更直观的认识Thymeleaf，下面展示一个在HTML文件中嵌入了Thymeleaf的页面文件，示例代码如下： 123456789&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; href=&quot;../../css/gtvg.css&quot; th:href=&quot;@&#123;/css/gtvg.css&#125;&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=&quot;$&#123;hello&#125;&quot;&gt;欢迎进入Thymeleaf的学习&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 上述代码中，“xmlns:th&#x3D;”","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"RabbitMQ详解","slug":"RabbitMQ详解","date":"2021-06-22T07:25:09.000Z","updated":"2025-04-17T08:34:52.016Z","comments":true,"path":"2021/06/22/RabbitMQ详解/","link":"","permalink":"http://yournotes.cn/2021/06/22/RabbitMQ%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"超长警告！！！善用目录！！！ 1. 什么是RabbitMQ1.1 MQ（Message Queue）消息队列 消息队列中间件，是分布式系统中的重要组件 主要解决，异步处理，应用解耦，流量削峰等问题 从而实现高性能，高可用，可伸缩和最终一致性的架构 使用较多的消息队列产品：RabbitMQ，RocketMQ，ActiveMQ，ZeroMQ，Kafka等 1.1.1 异步处理 用户注册后，需要发送验证邮箱和手机验证码； 将注册信息写入数据库，发送验证邮件，发送手机，三个步骤全部完成后，返回给客户端 1.1.2 应用解耦 场景：订单系统需要通知库存系统 如果库存系统异常，则订单调用库存失败，导致下单失败 原因：订单系统和库存系统耦合度太高 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户，下单成功； 库存系统：订阅下单的消息，获取下单信息，库存系统根据下单信息，再进行库存操作； 假如：下单的时候，库存系统不能正常运行，也不会影响下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了，实现了订单系统和库存系统的应用解耦； 所以说，消息队列是典型的：生产者消费者模型 生产者不断的向消息队列中生产消息，消费者不断的从队列中获取消息 因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的入侵，这样就实现了生产者和消费者的解耦 1.1.3 流量削峰 抢购，秒杀等业务，针对高并发的场景 因为流量过大，暴增会导致应用挂掉，为解决这个问题，在前端加入消息队列 用户的请求，服务器接收后，首先写入消息队列，如果超过队列的长度，就抛弃，甩一个秒杀结束的页面！ 说白了，秒杀成功的就是进入队列的用户； 1.2 背景知识介绍1.2.1 AMQP高级消息队列协议 即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议 协议：数据在传输的过程中必须要遵守的规则 基于此协议的客户端可以与消息中间件传递消息 1.2.2 JMS Java Message Server，Java消息服务应用程序接口， 一种规范，和JDBC担任的角色类似 是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信 1.2.3 二者的联系 JMS是定义了统一接口，统一消息操作；AMQP通过协议统一数据交互格式 JMS必须是java语言；AMQP只是协议，与语言无关 1.2.4 Erlang语言 Erlang（[‘ə:læŋ]）是一种通用的面向并发的编程语言，它由瑞典电信设备制造商爱立信所辖的CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言和运行环境 最初是由爱立信专门为通信应用设计的，比如控制交换机或者变换协议等，因此非常适合构建分布式，实时软并行计算系统 Erlang运行时环境是一个虚拟机，有点像Java的虚拟机，这样代码一经编译，同样可以随处运行 1.3 为什么选择RabbitMQ 我们开篇说消息队列产品那么多，为什么偏偏选择RabbitMQ呢？ 先看命名：兔子行动非常迅速而且繁殖起来也非常疯狂，所以就把Rabbit用作这个分布式软件的命名（就是这么简单） Erlang开发，AMQP的最佳搭档，安装部署简单，上手门槛低 企业级消息队列，经过大量实践考验的高可靠，大量成功的应用案例，例如阿里、网易等一线大厂都有使用 有强大的WEB管理页面 强大的社区支持，为技术进步提供动力 支持消息持久化、支持消息确认机制、灵活的任务分发机制等，支持功能非常丰富 集群扩展很容易，并且可以通过增加节点实现成倍的性能提升 总结：如果你希望使用一个可靠性高、功能强大、易于管理的消息队列系统那么就选择RabbitMQ，如果你想用一个性能高，但偶尔丢点数据不是很在乎可以使用kafka或者zeroMQ kafka和zeroMQ的性能爆表，绝对可以压RabbitMQ一头！ 1.4 RabbitMQ各组件功能 Broker：消息队列服务器实体 Virtual Host：虚拟主机 标识一批交换机、消息队列和相关对象，形成的整体 虚拟主机是共享相同的身份认证和加密环境的独立服务器域 每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制 vhost是AMQP概念的基础，RabbitMQ默认的vhost是 &#x2F;，必须在链接时指定 Exchange：交换器（路由） 用来接收生产者发送的消息并将这些消息路由给服务器中的队列 Queue：消息队列 用来保存消息直到发送给消费者。 它是消息的容器，也是消息的终点。 一个消息可投入一个或多个队列。 消息一直在队列里面，等待消费者连接到这个队列将其取走。 Banding：绑定，用于消息队列和交换机之间的关联。 Channel：通道（信道） 多路复用连接中的一条独立的双向数据流通道。 信道是建立在真实的TCP连接内的 虚拟链接 AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信 道完成的 因为对于操作系统来说，建立和销毁TCP连接都是非常昂贵的开销，所以引入了信道的概 念，用来复用TCP连接。 Connection：网络连接，比如一个TCP连接。 Publisher：消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Consumer：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Message：消息 消息是不具名的，它是由消息头和消息体组成。 消息体是不透明的，而消息头则是由一系列的可选属性组成，这些属性包括routing-key(路由键)、priority(优先级)、delivery-mode(消息可能需要持久性存储[消息的路由模式])等。 2. 怎么用RabbitMQ 想要安装RabbitMQ，必须先安装erlang语言环境，类似安装tomcat，必须先安装JDK 查看匹配的版本：https://www.rabbitmq.com/which-erlang.html 2.1 RabbitMQ安装启动erlang下载：https://dl.bintray.com/rabbitmq-erlang/rpm/erlang socat下载：http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm RabbitMQ下载：https://www.rabbitmq.com/install-rpm.html#downloads 2.1.1 安装1rpm -ivh erlang-21.3.8.16-1.el7.x86_64.rpm 1rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm 1rpm -ivh rabbitmq-server-3.8.6-1.el7.noarch.rpm 2.1.2 启动后台管理插件1[root@localhost opt]# rabbitmq-plugins enable rabbitmq_management 2.1.3 启动RabbitMQ1234[root@localhost opt]# systemctl start rabbitmq-server.service [root@localhost opt]# systemctl status rabbitmq-server.service [root@localhost opt]# systemctl restart rabbitmq-server.service [root@localhost opt]# systemctl stop rabbitmq-server.service 2.1.4 查看进程1[root@localhost opt]# ps -ef | grep rabbitmq 2.1.5 测试 关闭防火墙： systemctl stop firewalld 浏览器输入：http://ip:15672 默认帐号密码：guest，guest用户默认不允许远程连接 创建账号 1[root@localhost opt]# rabbitmqctl add_user laosun 123456 设置用户角色 1[root@localhost opt]# rabbitmqctl set_user_tags laosun administrator 设置用户权限 1[root@localhost opt]# rabbitmqctl set_permissions -p &quot;/&quot; laosun &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 查看当前用户和角色 1[root@localhost opt]# rabbitmqctl list_users 查看当前用户和角色 1[root@localhost opt]# rabbitmqctl change_password laosun 123123 管理界面介绍 overview：概览 connections：查看链接情况 channels：信道（通道）情况 Exchanges：交换机（路由）情况，默认4类7个 Queues：消息队列情况 Admin：管理员列表 端口： 5672：RabbitMQ提供给编程语言客户端链接的端口 15672：RabbitMQ管理界面的端口 25672：RabbitMQ集群的端口 2.2 RabbitMQ快速入门2.2.1 依赖123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2.2 日志依赖log4j（可选项）123456789log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%n log4j.appender.file=org.apache.log4j.FileAppender log4j.appender.file.File=rebbitmq.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n log4j.rootLogger=debug, stdout,file 2.2.3 创建连接先创建好虚拟主机 12345678910111213141516171819202122232425262728package util;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * @BelongsProject: lagou-rabbitmq * @Author: GuoAn.Sun * @Description: 专门与RabbitMQ获得连接 */public class ConnectionUtil &#123; public static Connection getConnection() throws Exception&#123; //1.创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); //2.在工厂对象中设置MQ的连接信息（ip,port,vhost,username,password） factory.setHost(&quot;192.168.204.141&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/lagou&quot;); factory.setUsername(&quot;laosun&quot;); factory.setPassword(&quot;123123&quot;); //3.通过工厂获得与MQ的连接 Connection connection = factory.newConnection(); return connection; &#125; public static void main(String[] args) throws Exception&#123; Connection connection = getConnection(); System.out.println(&quot;connection = &quot; + connection); connection.close(); &#125;&#125; 2.3 RabbitMQ模式 RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此我们只学习前5种 在线手册：https://www.rabbitmq.com/getstarted.html 5种消息模型，大体分为两类： 1和2属于点对点 3、4、5属于发布订阅模式（一对多） 点对点模式：P2P（point to point）模式包含三个角色： 消息队列（queue），发送者（sender），接收者（receiver） 每个消息发送到一个特定的队列中，接收者从中获得消息 队列中保留这些消息，直到他们被消费或超时 特点： 每个消息只有一个消费者，一旦消费，消息就不在队列中了 发送者和接收者之间没有依赖性，发送者发送完成，不管接收者是否运行，都不会影响消息发送到队列中（我给你发微信，不管你看不看手机，反正我发完了） 接收者成功接收消息之后需向对象应答成功（确认） 如果希望发送的每个消息都会被成功处理，那需要P2P 发布订阅模式：publish（Pub）&#x2F;subscribe（Sub） pub&#x2F;sub模式包含三个角色：交换机（exchange），发布者（publisher），订阅者（subcriber） 多个发布者将消息发送交换机，系统将这些消息传递给多个订阅者 特点： 每个消息可以有多个订阅者 发布者和订阅者之间在时间上有依赖，对于某个交换机的订阅者，必须创建一个订阅后，才能消费发布者的消息 为了消费消息，订阅者必须保持运行状态；类似于，看电视直播。 如果希望发送的消息被多个消费者处理，可采用本模式 2.3.1 简单模式下面引用官网的一段介绍： Introduction RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be surethat Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy,RabbitMQ is a post box, a post office and a postman. 译文：RabbitMQ是一个消息代理:它接收和转发消息。你可以把它想象成一个邮局:当你把你想要寄的邮件放到一个邮箱里，你可以确定邮递员先生或女士最终会把邮件送到你的收件人那里。在这个类比中，RabbitMQ是一个邮箱、一个邮局和一个邮递员。 RabbitMQ本身只是接收，存储和转发消息，并不会对信息进行处理！ 类似邮局，处理信件的应该是收件人而不是邮局！ 生产者P 123456789101112131415161718192021222324252627282930313233343536373839package simplest;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import util.ConnectionUtil;/** * @BelongsProject: lagou-rabbitmq * @Author: GuoAn.Sun * @Description: 消息生产者 */public class Sender &#123; public static void main(String[] args) throws Exception &#123; String msg = &quot;老孙：Hello,RabbitMQ!&quot;; // 1.获得连接 Connection connection = ConnectionUtil.getConnection(); // 2.在连接中创建通道（信道） Channel channel = connection.createChannel(); // 3.创建消息队列(1,2,3,4,5) /* 参数1:队列的名称 参数2:队列中的数据是否持久化 参数3:是否排外（是否支持扩展，当前队列只能自己用，不能给别人用） 参数4:是否自动删除（当队列的连接数为0时，队列会销毁，不管队列是否还存保存数据） 参数5:队列参数（没有参数为null） */ channel.queueDeclare(&quot;queue1&quot;,false,false,false,null); // 4.向指定的队列发送消息(1,2,3,4) /* 参数1:交换机名称，当前是简单模式，也就是P2P模式，没有交换机，所以名称为&quot;&quot; 参数2:目标队列的名称 参数3:设置消息的属性（没有属性则为null） 参数4:消息的内容(只接收字节数组) */ channel.basicPublish(&quot;&quot;,&quot;queue1&quot;,null,msg.getBytes()); System.out.println(&quot;发送：&quot; + msg); // 5.释放资源 channel.close(); connection.close(); &#125;&#125; 启动生产者，即可前往管理端查看队列中的信息，会有一条信息没有处理和确认 消费者C 1234567891011121314151617181920212223242526272829package simplest;import com.rabbitmq.client.*;import util.ConnectionUtil;import java.io.IOException;/** * @BelongsProject: lagou-rabbitmq * @Author: GuoAn.Sun * @Description: 消息接收者 */public class Recer &#123; public static void main(String[] args) throws Exception &#123; // 1.获得连接 Connection connection = ConnectionUtil.getConnection(); // 2.获得通道（信道） Channel channel = connection.createChannel(); // 3.从信道中获得消息 DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override //交付处理（收件人信息，包裹上的快递标签，协议的配置，消息） public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; // body就是从队列中获取的消息 String s = new String(body); System.out.println(&quot;接收 = &quot; + s); &#125; &#125;; // 4.监听队列 true:自动消息确认 channel.basicConsume(&quot;queue1&quot;, true,consumer); &#125;&#125; 启动消费者，前往管理端查看队列中的信息，所有信息都已经处理和确认，显示0 消息确认机制ACK 通过刚才的案例可以看出，消息一旦被消费，消息就会立刻从队列中移除 RabbitMQ如何得知消息被消费者接收？ 如果消费者接收消息后，还没执行操作就抛异常宕机导致消费失败，但是RabbitMQ无从得知，这样消息就丢失了 因此，RabbitMQ有一个ACK机制，当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收 ACK：(Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误我们在使用http请求时，http的状态码200就是告诉我们服务器执行成功 整个过程就想快递员将包裹送到你手里，并且需要你的签字，并拍照回执 不过这种回执ACK分为两种情况： 自动ACK：消息接收后，消费者立刻自动发送ACK（快递放在快递柜） 手动ACK：消息接收后，不会发送ACK，需要手动调用（快递必须本人签收） 两种情况如何选择，需要看消息的重要性： 如果消息不太重要，丢失也没有影响，自动ACK会比较方便 如果消息非常重要，最好消费完成手动ACK，如果自动ACK消费后，RabbitMQ就会把消息从队列中删除，如果此时消费者抛异常宕机，那么消息就永久丢失了 修改手动消息确认 12// false：手动消息确认 channel.basicConsume(&quot;queue1&quot;, false, consumer); 结果如下 解决问题 12345678910111213141516171819202122public class RecerByACK &#123; public static void main(String[] args) throws Exception &#123; // 1.获得连接 Connection connection = ConnectionUtil.getConnection(); // 2.获得通道（信道） final Channel channel = connection.createChannel(); // 3.从信道中获得消息 DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override //交付处理（收件人信息，包裹上的快递标签，协议的配置，消息） public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; // body就是从队列中获取的消息 String s = new String(body); System.out.println(&quot;接收 = &quot; + s); // 手动确认（收件人信息，是否同时确认多个消息） channel.basicAck(envelope.getDeliveryTag(),false); &#125; &#125; ; // 4.监听队列，false:手动消息确认 channel.basicConsume(&quot;queue1&quot;, false,consumer); &#125;&#125; 2.3.2 工作队列模式 之前我们学习的简单模式，一个消费者来处理消息，如果生产者生产消息过快过多，而消费者的能力有限，就会产生消息在队列中堆积（生活中的滞销） 一个烧烤师傅，一次烤50支羊肉串，就一个人吃的话，烤好的肉串会越来越多，怎么处理？ 多招揽客人进行消费即可。当我们运行许多消费者程序时，消息队列中的任务会被众多消费者共享，但其中某一个消息只会被一个消费者获取（100支肉串20个人吃，但是其中的某支肉串只能被一个人吃） 2.3.2.1 生产者P123456789101112131415public class MessageSender &#123; public static void main(String[] args) throws Exception&#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列（此处为生产者，创建队列）注明出餐口位置，通知大家来排队 channel.queueDeclare(&quot;test_work_queue&quot;,false,false,false,null); for (int i = 1;i&lt;=100;i++) &#123; String msg = &quot;羊肉串 --&gt; &quot;+i; channel.basicPublish(&quot;&quot;, &quot;test_work_queue&quot;, null, msg.getBytes()); System.out.println(&quot;师傅烤好：&quot; + msg); &#125; channel.close(); connection.close(); &#125;&#125; 2.3.2.2 消费者112345678910111213141516171819202122232425public class MessageReceiver1 &#123; static int i = 1; // 记录执行次数 public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtil.getConnection(); final Channel channel = connection.createChannel(); // 声明队列（此处为消费者，不是声明创建队列，而且获取，二者代码相同）出餐口排队 channel.queueDeclare(&quot;test_work_queue&quot;,false,false,false,null); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg = new String(body); System.out.println(&quot;【顾客1】吃掉 &quot; + msg+&quot; ! 共吃【&quot;+i++ +&quot;】串&quot;); // 撸一会，有延迟 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e)&#123; &#125; channel.basicAck(envelope.getDeliveryTag(),false); &#125; &#125;; channel.basicConsume(&quot;test_work_queue&quot;, false, consumer); &#125;&#125; 2.3.2.3 消费者21234567891011121314151617181920212223242526public class MessageReceiver2 &#123; static int i = 1; // 记录执行次数 public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtil.getConnection(); final Channel channel = connection.createChannel(); // 声明队列（此处为消费者，不是声明创建队列，而且获取，二者代码相同）出餐口排队 channel.queueDeclare(&quot;test_work_queue&quot;,false,false,false,null); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg = new String(body); System.out.println(&quot;【顾客2】吃掉 &quot; + msg+&quot; ! 共吃【&quot;+i++ +&quot;】串&quot;); // 撸一会，有延迟 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e)&#123; &#125; channel.basicAck(envelope.getDeliveryTag(),false); &#125; &#125; ; channel.basicConsume(&quot;test_work_queue&quot;, false, consumer); &#125;&#125; 先运行2个消费者，排队等候消费（取餐），再运行生产者开始生产消息（烤肉串） 虽然两个消费者的消费速度不一致（线程休眠时间），但是消费的数量却是一致的，各消费50个消息 例如：工作中，A同学编码速率高，B同学编码速率低，两个人同时开发一个项目，A10天完成，B30天完成，A完成自己的编码部分，就无所事事了，等着B完成就可以了，这样是不可以的，应该遵循“能者多劳” 效率高的多干点，效率低的少干点 看下面官网是如何给出解决思路的： 公平的分配 您可能已经注意到分派仍然不能完全按照我们的要求工作。例如，如果有两个员工，当所有奇怪的消息都很重，甚至消息都很轻时，一个员工会一直很忙，而另一个人几乎什么工作都不做。好吧，RabbitMQ对此一无所知，它仍然会均匀地分派消息。 这是因为RabbitMQ只在消息进入队列时发送消息。它不查看用户未确认消息的数量。它只是盲目地将每条第n个消息分派给第n个消费者。为了克服这个问题，我们可以使用设置为prefetchCount &#x3D; 1的basicQos方法。这告诉 RabbitMQ一次不要给一个worker发送一条以上的消息。或者，换句话说，在worker处理并确认前一个消息之前，不要向它发送新消息。相反，它将把它分派到下一个不繁忙的worker。 1234// 声明队列（此处为消费者，不是声明创建队列，而且获取，二者代码相同）出餐口排队 channel.queueDeclare(&quot;test_work_queue&quot;,false,false,false,null); // 可以理解为：快递一个一个送，送完一个再送下一个，速度快的送件就多 channel.basicQos(1); 能者多劳必须要配合手动的ACK机制才生效 2.3.2.4 面试题：避免消息堆积？ workqueue，多个消费者监听同一个队列 接收到消息后，通过线程池，异步消费 2.3.3 发布订阅模式看官网： Publish&#x2F;Subscribe In the previous tutorial we created a work queue. The assumption behind a work queueis that each task is delivered to exactly one worker. In this part we’ll do something completely different – we’ll deliver a message to multiple consumers. This pattern is known as “publish&#x2F;subscribe”. To illustrate the pattern, we’re going to build a simple logging system. It will consist of two programs – the first will emit log messages and the second will receive and print them. In our logging system every running copy of the receiver program will get the messages.That way we’ll be able to run one receiver and direct the logs to disk; and at the same time we’ll be able to run another receiver and see the logs on the screen. Essentially, published log messages are going to be broadcast to all the receivers. 发布-订阅 在上一篇教程中，我们创建了一个工作队列。工作队列背后的假设是，每个任务都被准确地交付给一个工作者。在这一部分中，我们将做一些完全不同的事情——将消息传递给多个消费者。此模式称为“发布&#x2F;订阅”。 为了演示这个模式，我们将构建一个简单的日志记录系统。它将由两个程序组成——第一个将发送日志消息，第二个将接收和打印它们。 在我们的日志系统中，接收程序的每一个正在运行的副本都将获得消息。这样我们就可以运行 一个接收器并将日志指向磁盘;与此同时，我们可以运行另一个接收器并在屏幕上看到日志。 基本上，发布的日志消息将广播到所有接收方。 生活中的案例：就是玩抖音快手，众多粉丝关注一个视频主，视频主发布视频，所有粉丝都可以得到视频通知 上图中，X就是视频主，红色的队列就是粉丝。binding是绑定的意思（关注） P生产者发送信息给X路由，X将信息转发给绑定X的队列 X队列将信息通过信道发送给消费者，从而进行消费 整个过程，必须先创建路由 路由在生产者程序中创建 因为路由没有存储消息的能力，当生产者将信息发送给路由后，消费者还没有运行，所以没有队列，路由并不知道将信息发送给谁 运行程序的顺序： MessageSender MessageReceiver1和MessageReceiver2 MessageSender 2.3.3.1 生产者1234567891011121314public class Sender &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明路由(路由名，路由类型) // fanout：不处理路由键（只需要将队列绑定到路由上，发送到路由的消息都会被转发到与该 路由绑定的所有队列上） channel.exchangeDeclare(&quot;test_exchange_fanout&quot;, &quot;fanout&quot;); String msg = &quot;hello，大家好！&quot;; channel.basicPublish(&quot;test_exchange_fanout&quot;, &quot;&quot;, null, msg.getBytes()); System.out.println(&quot;生产者：&quot; + msg); channel.close(); connection.close(); &#125;&#125; 2.3.3.2 消费者112345678910111213141516171819public class Recer1 &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(&quot;test_exchange_fanout_queue_1&quot;,false,false,false,null); // 绑定路由（关注） /*参数1：队列名 参数2：交换器名称 参数3：路由key（暂时无用，&quot;&quot;即可） */ channel.queueBind(&quot;test_exchange_fanout_queue_1&quot;, &quot;test_exchange_fanout&quot;, &quot;&quot;); DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String s = new String(body); System.out.println(&quot;【消费者1】 = &quot; + s); &#125; &#125;; // 4.监听队列 true:自动消息确认 channel.basicConsume(&quot;test_exchange_fanout_queue_1&quot;, true,consumer); &#125;&#125; 2.3.3.3 消费者2 将消费者1代码中的1修改为2即可，具体代码略 2.3.4 路由模式 路由会根据类型进行定向分发消息给不同的队列，如图所示 可以理解为是快递公司的分拣中心，整个小区，东面的楼小张送货，西面的楼小王送货 2.3.4.1 生产者1234567891011121314public class Sender &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明路由(路由名，路由类型) // direct：根据路由键进行定向分发消息 channel.exchangeDeclare(&quot;test_exchange_direct&quot;, &quot;direct&quot;); String msg = &quot;用户注册，【userid=S101】&quot;; channel.basicPublish(&quot;test_exchange_direct&quot;, &quot;insert&quot;, null, msg.getBytes()); System.out.println(&quot;[用户系统]：&quot; + msg); channel.close(); connection.close(); &#125;&#125; 2.3.4.2 消费者1123456789101112131415161718192021public class Recer1 &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(&quot;test_exchange_direct_queue_1&quot;,false,false,false,null); // 绑定路由（如果路由键的类型是 添加，删除，修改 的话，绑定到这个队列1上） channel.queueBind(&quot;test_exchange_direct_queue_1&quot;, &quot;test_exchange_direct&quot;, &quot;insert&quot;); channel.queueBind(&quot;test_exchange_direct_queue_1&quot;, &quot;test_exchange_direct&quot;, &quot;update&quot;); channel.queueBind(&quot;test_exchange_direct_queue_1&quot;, &quot;test_exchange_direct&quot;, &quot;delete&quot;); DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String s = new String(body); System.out.println(&quot;【消费者1】 = &quot; + s); &#125; &#125;; // 4.监听队列 true:自动消息确认 channel.basicConsume(&quot;test_exchange_direct_queue_1&quot;, true,consumer); &#125;&#125; 2.3.4.3 消费者212345678910111213141516171819public class Recer2 &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(&quot;test_exchange_direct_queue_2&quot;,false,false,false,null); // 绑定路由（如果路由键的类型是 查询 的话，绑定到这个队列2上） channel.queueBind(&quot;test_exchange_direct_queue_2&quot;, &quot;test_exchange_direct&quot;, &quot;select&quot;); DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String s = new String(body); System.out.println(&quot;【消费者2】 = &quot; + s); &#125; &#125;; // 4.监听队列 true:自动消息确认 channel.basicConsume(&quot;test_exchange_direct_queue_2&quot;, true,consumer); &#125;&#125; 记住运行程序的顺序，先运行一次sender（创建路由器）， 有了路由器之后，在创建两个Recer1和Recer2，进行队列绑定 再次运行sender，发出消息 2.3.5 通配符模式 和路由模式90%是一样的。 唯独的区别就是路由键支持模糊匹配 匹配符号 *：只能匹配一个词（正好一个词，多一个不行，少一个也不行） #：匹配0个或更多个词 看一下官网案例： Q1绑定了路由键 .orange. Q2绑定了路由键 ..rabbit 和 lazy.# 下面生产者的消息会被发送给哪个队列？ 12345678quick.orange.rabbit # Q1 Q2 lazy.orange.elephant # Q1 Q2 quick.orange.fox # Q1 lazy.brown.fox # Q2 lazy.pink.rabbit # Q2 quick.brown.fox # 无 orange # 无 quick.orange.male.rabbit # 无 2.3.5.1 生产者1234567891011121314public class Sender &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明路由(路由名，路由类型) // topic：模糊匹配的定向分发 channel.exchangeDeclare(&quot;test_exchange_topic&quot;, &quot;topic&quot;); String msg = &quot;商品降价&quot;; channel.basicPublish(&quot;test_exchange_topic&quot;, &quot;product.price&quot;, null, msg.getBytes()); System.out.println(&quot;[用户系统]：&quot; + msg); channel.close(); connection.close(); &#125;&#125; 2.3.5.2 消费者112345678910111213141516171819public class Recer1 &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(&quot;test_exchange_topic_queue_1&quot;,false,false,false,null); // 绑定路由（绑定 用户相关 的消息） channel.queueBind(&quot;test_exchange_topic_queue_1&quot;, &quot;test_exchange_topic&quot;, &quot;user.#&quot;); DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String s = new String(body); System.out.println(&quot;【消费者1】 = &quot; + s); &#125; &#125;; // 4.监听队列 true:自动消息确认 channel.basicConsume(&quot;test_exchange_topic_queue_1&quot;, true,consumer); &#125;&#125; 2.3.5.3 消费者2123456789101112131415161718192021public class Recer2 &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(&quot;test_exchange_topic_queue_2&quot;,false,false,false,null); // 绑定路由（绑定 商品和订单相关 的消息） channel.queueBind(&quot;test_exchange_topic_queue_2&quot;, &quot;test_exchange_topic&quot;, &quot;product.#&quot;); channel.queueBind(&quot;test_exchange_topic_queue_2&quot;, &quot;test_exchange_topic&quot;, &quot;order.#&quot;); DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String s = new String(body); System.out.println(&quot;【消费者2】 = &quot; + s); &#125; &#125; ; // 4.监听队列 true:自动消息确认 channel.basicConsume(&quot;test_exchange_topic_queue_2&quot;, true,consumer); &#125;&#125; 2.4 持久化 消息的可靠性是RabbitMQ的一大特色，那么RabbitMQ是如何避免消息丢失？ 消费者的ACK确认机制，可以防止消费者丢失消息 万一在消费者消费之前，RabbitMQ服务器宕机了，那消息也会丢失 想要将消息持久化，那么 路由和队列都要持久化 才可以 2.4.1 生产者1234567891011121314public class Sender &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明路由(路由名，路由类型，持久化) channel.exchangeDeclare(&quot;test_exchange_topic&quot;, &quot;topic&quot;,true); String msg = &quot;商品降价&quot;; // 发送消息(第三个参数作用是让消息持久化) channel.basicPublish(&quot;test_exchange_topic&quot;, &quot;product.price&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes()); System.out.println(&quot;[用户系统]：&quot; + msg); channel.close(); connection.close(); &#125;&#125; 2.4.2 消费者1234567891011121314151617public class Recer1 &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列( 第二个参数为true：支持持久化) channel.queueDeclare(&quot;test_exchange_topic_queue_1&quot;,true,false,false,null); channel.queueBind(&quot;test_exchange_topic_queue_1&quot;, &quot;test_exchange_topic&quot;, &quot;user.#&quot;); DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String s = new String(body); System.out.println(&quot;【消费者1】 = &quot; + s); &#125; &#125;; channel.basicConsume(&quot;test_exchange_topic_queue_1&quot;, true,consumer); &#125;&#125; 2.5 Spring整合RabbitMQ 五种消息模型，在企业中应用最广泛的就是最后一种：定向匹配topic Spring AMQP 是基于 Spring 框架的AMQP消息解决方案，提供模板化的发送和接收消息的抽象层，提供基于消息驱动的 POJO的消息监听等，简化了我们对于RabbitMQ相关程序的开发。 2.5.1 生产端工程 依赖 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; spring-rabbitmq-producer.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;&gt; &lt;!-- 1.配置连接 --&gt; &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;192.168.204.141&quot; port=&quot;5672&quot; username=&quot;laosun&quot; password=&quot;123123&quot; virtual-host=&quot;/lagou&quot; /&gt; &lt;!-- 2.配置队列 --&gt; &lt;rabbit:queue name=&quot;test_spring_queue_1&quot;/&gt; &lt;!-- 3.配置rabbitAdmin：主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删 除队列与交换机，发送消息等 --&gt; &lt;rabbit:admin connection-factory=&quot;connectionFactory&quot;/&gt; &lt;!-- 4.配置topic类型exchange；队列绑定到交换机 --&gt; &lt;rabbit:topic-exchange name=&quot;spring_topic_exchange&quot;&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue=&quot;test_spring_queue_1&quot; pattern=&quot;msg.#&quot;/&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt; &lt;!-- 5. 配置消息对象json转换类 --&gt; &lt;bean id=&quot;jsonMessageConverter&quot; class=&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;/&gt; &lt;!-- 6. 配置RabbitTemplate（消息生产者） --&gt; &lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;connectionFactory&quot; exchange=&quot;spring_topic_exchange&quot; message-converter=&quot;jsonMessageConverter&quot; /&gt;&lt;/beans&gt; 发消息 1234567891011121314public class Sender &#123; public static void main(String[] args) &#123; // 1.创建spring容器 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/spring-rabbitmq-producer.xml&quot;); // 2.从容器中获取对象 RabbitTemplate template = context.getBean(RabbitTemplate.class); // 3.发送消息 Map&lt;String, String&gt; map = new HashMap(); map.put(&quot;name&quot;, &quot;大佬孙&quot;); map.put(&quot;email&quot;, &quot;19998539@qq.com&quot;); template.convertAndSend(&quot;msg.user&quot;, map); context.close(); &#125;&#125; 2.5.2 消费端工程 依赖与生产者一致 spring-rabbitmq-consumer.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 1. 配置连接 --&gt; &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;192.168.204.141&quot;port=&quot;5672&quot; username=&quot;laosun&quot; password=&quot;123123&quot; virtual-host=&quot;/lagou&quot; /&gt; &lt;!-- 2. 配置队列 --&gt; &lt;rabbit:queue name=&quot;test_spring_queue_1&quot;/&gt; &lt;!-- 3.配置rabbitAdmin --&gt; &lt;rabbit:admin connection-factory=&quot;connectionFactory&quot;/&gt; &lt;!-- 4.springIOC注解扫描包--&gt; &lt;context:component-scan base-package=&quot;listener&quot;/&gt; &lt;!-- 5.配置监听 --&gt; &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot;&gt; &lt;rabbit:listener ref=&quot;consumerListener&quot; queue- names=&quot;test_spring_queue_1&quot; /&gt; &lt;/rabbit:listener-container&gt;&lt;/beans&gt; 消费者 MessageListener接口用于spring容器接收到消息后处理消息 如果需要使用自己定义的类型 来实现 处理消息时，必须实现该接口，并重写onMessage()方法 当spring容器接收消息后，会自动交由onMessage进行处理 1234567891011121314151617@Component public class ConsumerListener implements MessageListener &#123; // jackson提供序列化和反序列中使用最多的类，用来转换json的 private static final ObjectMapper MAPPER = new ObjectMapper(); public void onMessage(Message message) &#123; try &#123; // 将message对象转换成json JsonNode jsonNode = MAPPER.readTree(message.getBody()); String name = jsonNode.get(&quot;name&quot;).asText(); String email = jsonNode.get(&quot;email&quot;).asText(); System.out.println(&quot;从队列中获取：【&quot;+name+&quot;的邮箱是:&quot;+email+&quot;】&quot;); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 启动项目 12345678public class TestRunner &#123; public static void main(String[] args) throws Exception &#123; // 获得容器 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/spring-rabbitmq-consumer.xml&quot;); // 让程序一直运行，别终止 System.in.read(); &#125;&#125; 2.6 消息成功确认机制在实际场景下，有的生产者发送的消息是必须保证成功发送到消息队列中，那么如何保证成功投递呢？ 事务机制 发布确认机制 2.6.1 事务机制 AMQP协议提供的一种保证消息成功投递的方式，通过信道开启 transactional 模式 并利用信道 的三个方法来实现以事务方式 发送消息，若发送失败，通过异常处理回滚事务，确保消息成功投递 channel.txSelect()： 开启事务 channel.txCommit() ：提交事务 channel.txRollback() ：回滚事务 Spring已经对上面三个方法进行了封装，所以我们只能使用原始的代码演示 2.6.1.1 生产者123456789101112131415161718192021222324252627public class Sender &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(&quot;test_transaction&quot;, &quot;topic&quot;); channel.txSelect(); // 开启事务 try &#123; channel.basicPublish(&quot;test_transaction&quot;, &quot;product.price&quot;, null, &quot;商品 降价1&quot;.getBytes()); // System.out.println(1/0); // 模拟异常！ channel.basicPublish(&quot;test_transaction&quot;, &quot;product.price&quot;, null, &quot;商品 降价2&quot;.getBytes()); System.out.println(&quot;消息全部发出！&quot;); channel.txCommit(); // 事务提交 &#125; catch (Exception e)&#123; System.out.println(&quot;由于系统异常，消息全部撤回！&quot;); channel.txRollback(); // 事务回滚 e.printStackTrace(); &#125; finally &#123; channel.close(); connection.close(); &#125; &#125;&#125; 2.6.1.2 消费者12345678910111213141516public class Recer &#123; public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;test_transaction_queue&quot;,false,false,false,null); channel.queueBind(&quot;test_transaction_queue&quot;, &quot;test_transaction&quot;, &quot;product.#&quot;); DefaultConsumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String s = new String(body); System.out.println(&quot;【消费者】 = &quot; + s); &#125; &#125;; channel.basicConsume(&quot;test_transaction_queue&quot;, true,consumer); &#125;&#125; 2.6.2 Confirm发布确认机制 RabbitMQ为了保证消息的成功投递，采用通过AMQP协议层面为我们提供事务机制的方案，但是采用事务会大大降低消息的吞吐量 老孙我本机SSD硬盘测试结果10w条消息未开启事务，大约8s发送完毕；而开启了事务后，需要将近310s，差了30多倍。 接着翻阅官网，发现官网中已标注 Using standard AMQP 0-9-1, the only way to guarantee that a message isn’t lost is by using transactions – make the channel transactional then for each message or set of messages publish, commit. In this case, transactions are unnecessarily heavy weightand decrease throughput by a factor of 250. To remedy this, a confirmation mechanism was introduced. It mimics the consumer acknowled gements mechanismalready present in the protocol. 关键性译文：开启事务性能最大损失超过250倍 那么有没有更加高效的解决方式呢？答案就是采用Confirm模式。 事务效率为什么会这么低呢？试想一下：10条消息，前9条成功，如果第10条失败，那么9条消息要全部撤销回滚。太太太浪费 而confirm模式则采用补发第10条的措施来完成10条消息的送达 2.6.2.1 在spring中应用 spring-rabbitmq-producer.xml 12345678910111213141516&lt;!--1.配置连接，启动生产者确认机制: publisher-confirms=&quot;true&quot;--&gt;&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;192.168.204.141&quot; port=&quot;5672&quot; username=&quot;laosun&quot; password=&quot;123123&quot; virtual-host=&quot;/lagou&quot; publisher-confirms=&quot;true&quot; /&gt;&lt;!--6.配置rabbitmq的模版,添加确认回调处理类:confirm- callback=&quot;msgSendConfirmCallback&quot;--&gt;&lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;connectionFactory&quot; exchange=&quot;spring_topic_exchange&quot; message- converter=&quot;jsonMessageConverter&quot; confirm- callback=&quot;msgSendConfirmCallback&quot;/&gt;&lt;!--7.确认机制处理类--&gt;&lt;bean id=&quot;msgSendConfirmCallback&quot; class=&quot;confirm.MsgSendConfirmCallback&quot;/&gt; 消息确认处理类 12345678910111213141516171819202122package confirm;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.amqp.rabbit.support.CorrelationData;import org.springframework.stereotype.Component;import java.io.IOException;/** * @BelongsProject: spring-rabbitmq-producer * @Author: GuoAn.Sun * @Description: 确认机制 */@Component public class MsgSendConfirmCallback implements RabbitTemplate.ConfirmCallback &#123; public void confirm(CorrelationData correlationData, Boolean b, String s) &#123; if (b)&#123; System.out.println(&quot;消息确认成功！！&quot;); &#125; else &#123; System.out.println(&quot;消息确认失败...&quot;); // 如果本条消息一定要发送到队列中，例如下订单消息，我们可以采用消息补发 // 采用递归（固定次数，不可无限）或 redis+定时任务 &#125; &#125;&#125; log4j.properties 1234567log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%n log4j.appender.file=org.apache.log4j.FileAppender log4j.appender.file.File=rabbitmq.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n log4j.rootLogger=debug, stdout,file 发送消息 123456789101112131415public class Sender &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/spring-rabbitmq-producer.xml&quot;); RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class); Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;name&quot;, &quot;吕布&quot;); map.put(&quot;email&quot;, &quot;666@qq.com&quot;); // 第一个参数是路由名称， // 不写，则使用spring容器中创建的路由 // 乱写一个，因为路由名错误导致报错，则进入消息确认失败流程 rabbitTemplate.convertAndSend(&quot;x&quot;,&quot;msg.user&quot;,map); System.out.println(&quot;ok&quot;); context.close(); &#125;&#125; 2.7 消费端限流 在沙漠中行走，3天不喝水，突然喝水，如果使劲喝，容易猝死，要一口一口慢慢喝 我们 Rabbitmq 服务器积压了成千上万条未处理的消息，然后随便打开一个消费者客户端，就会出现这样的情况: 巨量的消息瞬间全部喷涌推送过来，但是单个客户端无法同时处理这么多数据，就会被压垮崩溃 所以，当数据量特别大的时候，我们对生产端限流肯定是不科学的，因为有时候并发量就是特别大，有时候并发量又特别少，这是用户的行为，我们是无法约束的 所以我们应该对消费端限流，用于保持消费端的稳定 例如：汽车企业不停的生产汽车，4S店有好多库存车卖不出去，但是也不会降价处理，就是要保证市值的稳定，如果生产多少台，就卖多少台，不管价格的话，市场就乱了，所以我们要用不变的价格来稳住消费者购车，才能平稳发展 RabbitMQ 提供了一种 Qos （Quality of Service，服务质量）服务质量保证功能 即在非自动确认消息的前提下，如果一定数目的消息未被确认前，不再进行消费新的消息 生产者使用循环发出多条消息 1234for (int i = 1;i&lt;=10;i++) &#123; rabbitTemplate.convertAndSend(&quot;msg.user&quot;, map); System.out.println(&quot;消息已发出...&quot;);&#125; 生产10条堆积未处理的消息 消费者进行限流处理 123456&lt;!--5.配置监听--&gt;&lt;!-- prefetch=&quot;3&quot; 一次性消费的消息数量。会告诉 RabbitMQ 不要同时给一个消费者推送多于 N 个消息，一旦有 N 个消息还没有ack，则该 consumer 将阻塞，直到消息被ack--&gt;&lt;!-- acknowledge-mode: manual 手动确认--&gt;&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; prefetch=&quot;3&quot; acknowledge=&quot;manual&quot;&gt; &lt;rabbit:listener ref=&quot;consumerListener&quot; queue-names=&quot;test_spring_queue_1&quot; /&gt;&lt;/rabbit:listener-container&gt; 12345678910111213141516171819202122232425262728// AbstractAdaptableMessageListener用于在spring容器接收到消息后用于处理消息的抽象 基类@Component public class ConsumerListener extends AbstractAdaptableMessageListener &#123; // jackson提供序列化和反序列中使用最多的类，用来转换json的 private static final ObjectMapper MAPPER = new ObjectMapper(); public void onMessage(Message message, Channel channel) throws Exception &#123; try &#123; // String str = new String(message.getBody()); // 将message对象转换成json JsonNode jsonNode = MAPPER.readTree(message.getBody()); String name = jsonNode.get(&quot;name&quot;).asText(); String email = jsonNode.get(&quot;email&quot;).asText(); System.out.println(&quot;从队列中获取：【&quot;+name+&quot;的邮箱是:&quot;+email+&quot;】&quot;); long deliveryTag = message.getMessageProperties().getDeliveryTag(); //确认收到(参数1,参数2) /* 参数1：RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID，是一个单调递 增的正整数，delivery_tag 的范围仅限于 Channel 参数2：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以 一次性确认 delivery_tag 小于等于传入值的所有消息 */ channel.basicAck(deliveryTag , true); Thread.sleep(3000); System.out.println(&quot;休息三秒然后再接收消息&quot;); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 每次确认接收3条消息 2.8 过期时间TTL Time To Live：生存时间、还能活多久，单位毫秒 在这个周期内，消息可以被消费者正常消费，超过这个时间，则自动删除（其实是被称为deadmessage并投入到死信队列，无法消费该消息） RabbitMQ可以对消息和队列设置TTL 通过队列设置，队列中所有消息都有相同的过期时间 对消息单独设置，每条消息的TTL可以不同（更颗粒化） 2.8.1 设置队列TTL spring-rabbitmq-producer.xml 123456&lt;!--2.重新配置一个队列，同时，对队列中的消息设置过期时间--&gt;&lt;rabbit:queue name=&quot;test_spring_queue_ttl&quot; auto-declare=&quot;true&quot;&gt; &lt;rabbit:queue-arguments&gt; &lt;entry key=&quot;x-message-ttl&quot; value-type=&quot;long&quot; value=&quot;5000&quot;&gt;&lt;/entry&gt; &lt;/rabbit:queue-arguments&gt;&lt;/rabbit:queue&gt; 5秒之后，消息自动删除 2.8.2 设置消息TTL 设置某条消息的ttl，只需要在创建发送消息时指定即可 12&lt;!--2.配置队列--&gt; &lt;rabbit:queue name=&quot;test_spring_queue_ttl_2&quot;&gt; 12345678910111213141516171819202122232425262728package test;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageProperties;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.HashMap;import java.util.Map;/** * @BelongsProject: spring-rabbitmq-producer * @Author: GuoAn.Sun * @Description: 生产者 */public class Sender2 &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/spring-rabbitmq-producer.xml&quot;); RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class); // 创建消息配置对象 MessageProperties messageProperties = new MessageProperties(); // 设置消息过期时间 messageProperties.setExpiration(&quot;6000&quot;); // 创建消息 Message message = new Message(&quot;6秒后自动删除&quot;.getBytes(), messageProperties); // 发送消息 rabbitTemplate.convertAndSend(&quot;msg.user&quot;, message); System.out.println(&quot;消息已发出...&quot;); context.close(); &#125;&#125; 如果同时设置了queue和message的TTL值，则二者中较小的才会起作用 2.9 死信队列 DLX（Dead Letter Exchanges）死信交换机&#x2F;死信邮箱，当消息在队列中由于某些原因没有被及时消费而变成死信（dead message）后，这些消息就会被分发到DLX交换机中，而绑定DLX交换机的队列，称之为：“死信队列” 消息没有被及时消费的原因： 消息被拒绝（basic.reject&#x2F; basic.nack）并且不再重新投递 requeue&#x3D;false 消息超时未消费 达到最大队列长度 spring-rabbitmq-producer-dlx.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--1.配置连接--&gt;&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;192.168.204.141&quot; port=&quot;5672&quot; username=&quot;laosun&quot; password=&quot;123123&quot; virtual-host=&quot;/lagou&quot;/&gt;&lt;!--3.配置rabbitAdmin:主要用于在java代码中对队列的管理，用来创建，绑定，删除队列与交 换机，发送消息等--&gt;&lt;rabbit:admin connection-factory=&quot;connectionFactory&quot;/&gt;&lt;!--6.配置rabbitmq的模版--&gt;&lt;rabbit:template id=&quot;rabbitTemplate&quot;connection-factory=&quot;connectionFactory&quot; exchange=&quot;my_exchange&quot;/&gt;&lt;!-- ##################################################################--&gt;&lt;!--死信队列--&gt;&lt;rabbit:queue name=&quot;dlx_queue&quot;/&gt;&lt;!--定向死信交换机--&gt;&lt;rabbit:direct-exchange name=&quot;dlx_exchange&quot; &gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding key=&quot;dlx_ttl&quot; queue=&quot;dlx_queue&quot;&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=&quot;dlx_max&quot; queue=&quot;dlx_queue&quot;&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt;&lt;/rabbit:direct-exchange&gt;&lt;!--测试超时的队列--&gt;&lt;rabbit:queue name=&quot;test_ttl_queue&quot;&gt; &lt;rabbit:queue-arguments&gt; &lt;!--队列ttl为6秒--&gt; &lt;entry key=&quot;x-message-ttl&quot; value-type=&quot;long&quot; value=&quot;6000&quot;/&gt; &lt;!--超时 消息 投递给 死信交换机--&gt; &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx_exchange&quot;/&gt; &lt;/rabbit:queue-arguments&gt;&lt;/rabbit:queue&gt;&lt;!--测试超长度的队列--&gt;&lt;rabbit:queue name=&quot;test_max_queue&quot;&gt; &lt;rabbit:queue-arguments&gt; &lt;!--队列ttl为6秒--&gt; &lt;entry key=&quot;x-max-length&quot; value-type=&quot;long&quot; value=&quot;2&quot;/&gt; &lt;!--超时 消息 投递给 死信交换机--&gt; &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx_exchange&quot;/&gt; &lt;/rabbit:queue-arguments&gt;&lt;/rabbit:queue&gt;&lt;!--定向测试交换机--&gt;&lt;rabbit:direct-exchange name=&quot;my_exchange&quot; &gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding key=&quot;dlx_ttl&quot; queue=&quot;test_ttl_queue&quot;&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=&quot;dlx_max&quot; queue=&quot;test_max_queue&quot;&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt;&lt;/rabbit:direct-exchange&gt; 发消息进行测试 123456789101112public class SenderDLX &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/spring-rabbitmq-producer-dlx.xml&quot;); RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class); // rabbitTemplate.convertAndSend(&quot;dlx_ttl&quot;, &quot;测试超时&quot;.getBytes()); rabbitTemplate.convertAndSend(&quot;dlx_max&quot;, &quot;测试长度1&quot;.getBytes()); rabbitTemplate.convertAndSend(&quot;dlx_max&quot;, &quot;测试长度2&quot;.getBytes()); rabbitTemplate.convertAndSend(&quot;dlx_max&quot;, &quot;测试长度3&quot;.getBytes()); System.out.println(&quot;消息已发出...&quot;); context.close(); &#125;&#125; 2.10 延迟队列 延迟队列：TTL + 死信队列的合体 死信队列只是一种特殊的队列，里面的消息仍然可以消费 在电商开发部分中，都会涉及到延时关闭订单，此时延迟队列正好可以解决这个问题 2.10.1 生产者沿用上面死信队列案例的超时测试，超时时间改为订单关闭时间即可 2.10.2 消费者 spring-rabbitmq-consumer.xml 1234&lt;!-- 监听死信队列 --&gt;&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; prefetch=&quot;3&quot; acknowledge=&quot;manual&quot;&gt; &lt;rabbit:listener ref=&quot;consumerListener&quot; queue-names=&quot;dlx_queue&quot; /&gt;&lt;/rabbit:listener-container&gt; 3. RabbitMQ集群rabbitmq有3种模式，但集群模式是2种。详细如下： 单一模式：即单机情况不做集群，就单独运行一个rabbitmq而已。之前我们一直在用 普通模式：默认模式，以两个节点（A、B）为例来进行说明 当消息进入A节点的Queue后，consumer从B节点消费时，RabbitMQ会在A和B之间创建临时通道进行消息传输，把A中的消息实体取出并经过通过交给B发送给consumer 当A故障后，B就无法取到A节点中未消费的消息实体 如果做了消息持久化，那么得等A节点恢复，然后才可被消费 如果没有持久化的话，就会产生消息丢失的现象 镜像模式：非常经典的 mirror 镜像模式，保证 100% 数据不丢失。 高可靠性解决方案，主要就是实现数据的同步，一般来讲是 2 - 3 个节点实现数据同步 对于 100% 数据可靠性解决方案，一般是采用 3 个节点。 在实际工作中也是用得最多的，并且实现非常的简单，一般互联网大厂都会构建这种镜像集群模式 还有主备模式，远程模式，多活模式等，本次课程不作为重点，可自行查阅资料了解 3.1 集群搭建前置条件：准备两台linux，并安装好rabbitmq 集群步骤如下： 修改 &#x2F;etc&#x2F;hosts 映射文件 A服务器： 1234567127.0.0.1 A localhost localhost.localdomain localhost4localhost4.localdomain4::1 A localhost localhost.localdomain localhost6localhost6.localdomain6192.168.204.141 A192.168.204.142 B B服务器： 1234567127.0.0.1 B localhost localhost.localdomain localhost4localhost4.localdomain4::1 B localhost localhost.localdomain localhost6localhost6.localdomain6192.168.204.141 A192.168.204.142 B 相互通信，cookie必须保持一致，同步 rabbitmq的cookie 文件：跨服务器拷贝 .erlang.cookie（隐藏文件，使用 ls -all 显示） 1[root@A opt]# scp /var/lib/rabbitmq/.erlang.cookie 192.168.204.142:/var/lib/rabbitmq 修改cookie文件，要重启服务器，reboot 停止防火墙，启动rabbitmq服务 12[root@A ~]# systemctl stop firewalld [root@A ~]# systemctl start rabbitmq-server 加入集群节点 123[root@B ~]# rabbitmqctl stop_app [root@B ~]# rabbitmqctl join_cluster rabbit@A [root@B ~]# rabbitmqctl start_app 查看节点状态 1[root@B ~]# rabbitmqctl cluster_status 查看管理端 搭建集群结构之后，之前创建的交换机、队列、用户都属于单一结构，在新的集群环境中是不能用的 所以在新的集群中重新手动添加用户即可（任意节点添加，所有节点共享） 123[root@A ~]# rabbitmqctl add_user laosun 123123 [root@A ~]# rabbitmqctl set_user_tags laosun administrator [root@A ~]# rabbitmqctl set_permissions -p &quot;/&quot; laosun &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 注意：当节点脱离集群还原成单一结构后，交换机，队列和用户等数据 都会重新回来 此时，集群搭建完毕，但是默认采用的模式**“普通模式”**，可靠性不高 3.2 镜像模式 将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态一致 语法：set_policy {name} {pattern} {definition} name：策略名，可自定义 pattern：队列的匹配模式（正则表达式） “^” 可以使用正则表达式，比如”^queue_” 表示对队列名称以“queue_”开头的所有队列进行镜像，而”^”表示匹配所有的队列 definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode ha-mode：（High Available，高可用）模式，指明镜像队列的模式，有效值为all&#x2F;exactly&#x2F;nodes，当前策略模式为 all，即复制到所有节点，包含新增节点 123all：表示在集群中所有的节点上进行镜像 exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定 nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定 ha-params：ha-mode模式需要用到的参数 ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual 1[root@A ~]# rabbitmqctl set_policy xall &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27; 通过管理端设置镜像策略 3.3 HAProxy实现镜像队列的负载均衡 虽然我们在程序中访问A服务器，可以实现消息的同步，虽然在同步，但都是A服务器在接收消息，A太累 是否可以想Nginx一样，做负载均衡，A和B轮流接收消息，再镜像同步 3.3.1 HAProxy简介 HA（High Available，高可用），Proxy（代理） HAProxy是一款提供高可用性，负载均衡，并且基于TCP和HTTP应用的代理软件 HAProxy完全免费 HAProxy可以支持数以万计的并发连接 HAProxy可以简单又安全的整合进架构中，同时还保护web服务器不被暴露到网络上 3.3.2 HAProxy与NginxOSI：（Open System Interconnection：开放式系统互联 是把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层） Nginx的优点： 工作在OSI第7层，可以针对http应用做一些分流的策略 Nginx对网络的依赖非常小，理论上能ping通就就能进行负载功能，屹立至今的绝对优势 Nginx安装和配置比较简单，测试起来比较方便； Nginx不仅仅是一款优秀的负载均衡器&#x2F;反向代理软件，它同时也是功能强大的Web应用服务器 HAProxy的优点： 工作在网络4层和7层，支持TCP与Http协议， 它仅仅就只是一款负载均衡软件；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的 支持8种负载均衡策略 ，支持心跳检测 性能上HA胜，功能性和便利性上Nginx胜 对于Http协议，Haproxy处理效率比Nginx高。所以，没有特殊要求的时候或者一般场景，建议使用Haproxy来做Http协议负载 但如果是Web应用，那么建议使用Nginx！ 总之，大家可以结合各自使用场景的特点来进行合理地选择 3.3.3 安装和配置HAProxy下载：http://www.haproxy.org/download/1.8/src/haproxy-1.8.12.tar.gz 解压 1[root@localhost opt]# tar -zxvf haproxy-1.8.12.tar.gz make时需要使用 TARGET 指定内核及版本 12[root@localhost opt]# uname -r 3.10.0-514.6.2.el7.x86_64 根据内核版本选择编译参数： 进入目录，编译和安装 123[root@localhost opt]# cd haproxy-1.8.12 [root@localhost haproxy-1.8.12]# make TARGET=linux2628 PREFIX=/usr/local/haproxy [root@localhost haproxy-1.8.12]# make install PREFIX=/usr/local/haproxy 安装成功后，查看版本 1[root@localhost haproxy-1.8.12]# /usr/local/haproxy/sbin/haproxy -v 配置启动文件，复制haproxy文件到&#x2F;usr&#x2F;sbin下 ，复制haproxy脚本，到&#x2F;etc&#x2F;init.d下 123[root@localhost haproxy-1.8.12]# cp /usr/local/haproxy/sbin/haproxy /usr/sbin/[root@localhost haproxy-1.8.12]# cp ./examples/haproxy.init /etc/init.d/haproxy[root@localhost haproxy-1.8.12]# chmod 755 /etc/init.d/haproxy 创建系统账号 1[root@localhost haproxy-1.8.12]# useradd -r haproxy haproxy.cfg 配置文件需要自行创建 12[root@localhost haproxy-1.8.12]# mkdir /etc/haproxy [root@localhost haproxy-1.8.12]# vim /etc/haproxy/haproxy.cfg 添加配置信息到haproxy.cfg 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#全局配置 global #设置日志 log 127.0.0.1 local0 info #当前工作目录 chroot /usr/local/haproxy #用户与用户组 user haproxy group haproxy #运行进程ID uid 99 gid 99 #守护进程启动 daemon #最大连接数 maxconn 4096 #默认配置 defaults #应用全局的日志配置 log global #默认的模式mode &#123;tcp|http|health&#125;，TCP是4层，HTTP是7层，health只返回OK mode tcp #日志类别tcplog option tcplog #不记录健康检查日志信息 option dontlognull #3次失败则认为服务不可用 retries 3 #每个进程可用的最大连接数 maxconn 2000 #连接超时 timeout connect 5s #客户端超时30秒，ha就会发起重新连接 timeout client 30s #服务端超时15秒，ha就会发起重新连接 timeout server 15s #绑定配置 listen rabbitmq_cluster bind 192.168.204.143:5672 #配置TCP模式 mode tcp #简单的轮询 balance roundrobin #RabbitMQ集群节点配置，每隔5秒对mq集群做检查，2次正确证明服务可用，3次失败证 明服务不可用 server A 192.168.204.141:5672 check inter 5000 rise 2 fall 3 server B 192.168.204.142:5672 check inter 5000 rise 2 fall 3 #haproxy监控页面地址 listen monitor bind 192.168.204.143:8100 mode http option httplog stats enable # 监控页面地址 http://192.168.204.143:8100/monitor stats uri /monitor stats refresh 5s 启动HAProxy 1[root@localhost haproxy]# service haproxy start 访问监控中心：http://192.168.204.143:8100/monitor 记得关闭防火墙： systemctl stop firewalld 项目发消息，只需要将服务器地址修改为143即可，其余不变 所有的请求都会交给HAProxy，其负载均衡给每个rabbitmq服务器 3.4 KeepAlived搭建高可用的HAProxy集群现在的最后一个问题暴露出来了，如果HAProxy服务器宕机，rabbitmq服务器就不可用了。所以我们需要对HAProxy也要做高可用的集群 3.4.1 概述 Keepalived是Linux下一个轻量级别的高可用热备解决方案 Keepalived的作用是检测服务器的状态，它根据TCP&#x2F;IP参考模型的第三、第四层、第五层交换机制检测每个服务节点的状态，如果有一台web服务器宕机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，同时使用其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。 keepalived基于vrrp（Virtual Router Redundancy Protocol，虚拟路由冗余协议）协议，vrrp它是一种主备（主机和备用机）模式的协议，通过VRRP可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信 两台主机之间生成一个虚拟的ip，我们称漂移ip，漂移ip由主服务器承担，一但主服务器宕机，备份服务器就会抢夺漂移ip，继续工作，有效的解决了群集中的单点故障 说白了，将多台路由器设备虚拟成一个设备，对外提供统一ip（VIP） 3.4.2 安装KeepAlived 修改hosts文件的地址映射 IP 用途 主机名 192.168.204.143 KeepAlived HAProxy C 192.168.204.144 KeepAlived HAProxy D 安装 keepalived 1[root@C ~]# yum install -y keepalived 修改配置文件（内容大改，不如删掉，重新创建） 12[root@C ~]# rm -rf /etc/keepalived/keepalived.conf [root@C ~]# vim /etc/keepalived/keepalived.conf 1234567891011121314151617181920212223242526272829303132333435363738! Configuration File for keepalivedglobal_defs &#123; router_id C ## 非常重要，标识本机的hostname&#125; vrrp_script chk_haproxy&#123; script &quot;/etc/keepalived/haproxy_check.sh&quot; ## 执行的脚本位置 interval 2 ## 检测时间间隔 weight -20 ## 如果条件成立则权重减20&#125;vrrp_instance VI_1 &#123; state MASTER ## 非常重要，标识主机，备用机143改为 BACKUP interface ens33 ## 非常重要，网卡名（ifconfig查看） virtual_router_id 66 ## 非常重要，自定义，虚拟路由ID号（主备节点要相同） priority 100 ## 优先级（0-254），一般主机的大于备机 advert_int 1 ## 主备信息发送间隔，两个节点必须一致，默认1秒 authentication &#123; ## 认证匹配，设置认证类型和密码，MASTER和BACKUP必须使 用相同的密码才能正常通信 auth_type PASS auth_pass 1111 &#125; track_script &#123; chk_haproxy ## 检查haproxy健康状况的脚本 &#125; virtual_ipaddress &#123; ## 简称“VIP” 192.168.204.66/24 ## 非常重要，虚拟ip，可以指定多个，以后连接mq就用这个虚拟ip &#125;&#125;virtual_server 192.168.204.66 5672 &#123; ## 虚拟ip的详细配置 delay_loop 6 # 健康检查间隔，单位为秒 lb_algo rr # lvs调度算法rr|wrr|lc|wlc|lblc|sh|dh lb_kind NAT # 负载均衡转发规则。一般包括DR,NAT,TUN 3种 protocol TCP # 转发协议，有TCP和UDP两种，一般用TCP real_server 192.168.204.143 5672 &#123; ## 本机的真实ip weight 1 # 默认为1,0为失效 &#125;&#125; 创建执行脚本 &#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh 123456789#!/bin/bashCOUNT=`ps -C haproxy --no-header |wc -l`if [ $COUNT -eq 0 ];then /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg sleep 2 if [ `ps -C haproxy --no-header |wc -l` -eq 0 ];then killall keepalived fifi Keepalived 组之间的心跳检查并不能察觉到 HAproxy 负载是否正常，所以需要使用此脚本。在 Keepalived 主机上，开启此脚本检测 HAproxy 是否正常工作，如正常工作，记录日志。如进程不存在，则尝试重启 HAproxy ，2秒后检测，如果还没有，则关掉主 Keepalived ，此时备Keepalived 检测到主 Keepalived 挂掉，接管VIP，继续服务 授权，否则不能执行 1[root@C etc]# chmod +x /etc/keepalived/haproxy_check.sh 启动keepalived（两台都启动） 12[root@C etc]# systemctl stop firewalld [root@C etc]# service keepalived start | stop | status | restart 查看状态 12[root@C etc]# ps -ef | grep haproxy[root@C etc]# ps -ef | grep keepalived 查看ip情况 ip addr 或 ip a 1[root@C etc]# ip a 此时，安装完毕，按照上面的步骤就可以安装第二台了（服务器hostname和ip注意要修改） 常见的网络错误：子网掩码、网关等信息要一致 3.4.3 测试ip漂移的规则 查看虚拟ip ip addr 或 ip a 目前，C节点是主机，所以虚拟ip在C节点 停止C的keepalived，虚拟ip漂移到D节点 重新启动C节点keepalived，虚拟ip依旧在D节点，并不会由于C的回归而回归 停止D的keepalived，虚拟ip再漂移回C节点 测试vip+端口是否提供服务（在141，A服务器上测试） 12[root@A ~]# curl 192.168.204.66:5672AMQP ## 正常提供AMQP服务，表示通过vip访问mq服务正常","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"FastDFS详解","slug":"FastDFS详解","date":"2021-06-15T03:44:21.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2021/06/15/FastDFS详解/","link":"","permalink":"http://yournotes.cn/2021/06/15/FastDFS%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1. 场景概述 天猫，淘宝等购物网站，大量的图片和视频，文件太多，如何存储？ 用户访问量大又如何保证下载速度？分布式文件系统就是解决这些问题的！ 1.1 什么是文件系统 文件数据是如何存储的？？ 1.2 分布式文件系统 一台电脑存储量有限，并且并发吞吐量也有限，如何提高性能？ 一吨货物，我要运送到吐鲁番： 1个人运，不敢想象 50个人运，太难了； 500个人运，每个人都很轻松； 这就是分布式吗？ 这里面有集群的概念，也有分布式的概念，二者不要混淆，面试常问的经典题目 分布式：不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署不同的服务器上。解决高并发的问题； 集群：同一个业务部署在多台服务器上，提高系统的高可用 1.3 主流的分布式文件系统1.3.1 HDFS (Hadoop Distributed File System)Hadoop 分布式文件系统； 高容错的系统，适合部署到廉价的机器上； 能提供高吞吐量的数据访问，非常适合大规模数据应用； HDFS采用主从结构，一个HDFS是由一个name节点和N个data节点组成； name节点储存元数据，一个文件分割成N份存储在不同的data节点上。 1.3.2 GFS Google File System 可扩展的分布式文件系统，用于大型的，分布式的，对大量数据进行访问的应用； 运行于廉价的普通硬件上，可以提供容错功能； 它可以给大量的用户提供总体性能较高的服务； GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver（分块服务器）组成； 一个文件被分割若干块，分散储存到多个分块server中 1.3.3.FastDFS 由淘宝资深架构师余庆编写并开源； 专为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务； HDFS，GFS等都是通用的文件系统，他们的优点是开发体验好，但是系统的复杂度较高，性能也一般； 相比之下，专用的分布式文件系统体验差，但是复杂度低，性能也高，尤其fastDFS特别适合图片，小视频等小文件，因为fastDFS对文件是不分割的，所以没有文件合并的开销； 网络通信用socket，速度快。 1.4 工作原理 fastDFS包含Tracker Server和Storage Server； 客户端请求Tracker Server进行文件的上传与下载； Tracker Server调度Storage Server最终完成上传与下载。 Tracker （译：追踪者） 作用是负载均衡和调度，它管理着存储服务（Storage Server），可以理解为：“大管家，追踪者，调度员”； Tracker Server可以集群，实现高可用，策略为“轮询”。 Storage （译：仓库; 贮存器） 作用是文件存储，客户端上传的文件最终存储到storage服务器上； storage集群采用分组的方式，同组内的每台服务器是平等关系，数据同步，目的是实现数据备份，从而高可用，而不同组的服务器之间是不通信的； 同组内的每台服务器的存储量不一致的情况下，会选取容量最小的那个，所以同组内的服务器之间软硬件最好保持一致。 Storage Server会连接集群中的所有Tracker Server，定时向他们汇报自己的状态，例如：剩余空间，文件同步情况，文件上传下载次数等信息。 1.5 上传&#x2F;下载 原理 客户端上传文件后，storage会将文件id返回给客户端 group1&#x2F;M00&#x2F;02&#x2F;11&#x2F;aJxAeF21O5wAAAAAAAAGaEIOA12345.sh 组名：文件上传后，在storage组的名称，文件上传成功后，由storage返回，需要客户端自行保存。 虚拟磁盘路径：storage配置的虚拟路径，在磁盘选项storage_path对应。storage_path0对应M00，storage_path1对应M01， 数据两级目录：storage在虚拟磁盘下自行创建的目录。 文件名：与上传时不同，是用storage根据特定信息生成的，里面包含：storage服务器的ip，创建时间戳，大小，后缀名等信息 2. FastDFS的上传与下载2.1 安装2.1.1 安装gcc（编译时需要）1yum install -y gcc gcc-c++ 2.1.2 安装libevent（运行时需求）1yum -y install libevent 2.1.3 安装 libfastcommonlibfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。 上传 libfastcommon-master.zip 到 &#x2F;opt 123安装解压zip包的命令: yum install -y unzip 解压包: unzip libfastcommon.zip 进入目录: cd libfastcommon-master 编译 123./make.sh # 如果：make.sh的权限不够，则需要授权（可执行的权利）# chmod 777 make.sh 安装 12./make.sh install# libfastcommon安装好后会在/usr/lib64 目录下生成 libfastcommon.so 库文件 拷贝库文件 12cd /usr/lib64cp libfastcommon.so /usr/lib 2.1.4 安装Tracker下载 FastDFS_v5.05.tar.gz，并上传到 &#x2F;opt 1234tar -zxvf FastDFS_v5.05.tar.gz cd FastDFS ./make.sh ./make.sh install 2.2 配置 Tracker配置 1vim /etc/fdfs/tracker.conf 12345#端口号 port=22122 #基础目录（Tracker运行时会向此目录存储storage的管理数据）（基础目录不存在的话，需要自行创建 mkdir /home/fastdfs） base_path=/home/fastdfs Storage配置 1vim /etc/fdfs/storage.conf 123456789101112131415161718192021#配置组名 group_name=group1 #端口 port=23000 #向tracker心跳间隔（秒） heart_beat_interval=30 #storage基础目录 #目录不存在，需要自行创建 base_path=/home/fastdfs #store存放文件的位置(store_path) #可以理解一个磁盘一个path，多个磁盘，多个store_path #fdfs_storage目录不存在，需要自行创建 #mkdir /home/fastdfs/fdfs_storage store_path0=/home/fastdfs/fdfs_storage #如果有多个挂载磁盘则定义多个store_path，如下 #store_path1=..... (M01) #store_path2=..... (M02) #配置tracker服务器:IPtracker_server=10.1.220.247:22122 #如果有多个则配置多个tracker #tracker_server=10.1.220.x:22122 2.3 启动服务 启动tracker 1/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 启动storage 1/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 查看所有运行的端口： 1netstat -ntlp 2.4 搭建Java工程使用IDEA创建maven工程 2.4.1 pom.xml1234567891011&lt;!--fastdfs的java客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 2.4.2 创建配置文件在resources下创建config目录，在config目录下创建 fastdfs-client.properties，内容如下： 12345678##fastdfs-client.properties fastdfs.connect_timeout_in_seconds = 5 fastdfs.network_timeout_in_seconds = 30 fastdfs.charset = UTF-8 fastdfs.http_anti_steal_token = false fastdfs.http_secret_key = FastDFS1234567890 fastdfs.http_tracker_http_port = 80 fastdfs.tracker_servers = 10.1.220.247:22122 2.4.3 文件上传12345678910111213141516171819202122232425262728293031323334353637383940package test;import org.csource.common.NameValuePair;import org.csource.fastdfs.*;/** * @BelongsProject: lagou-fastdfs * @Author: GuoAn.Sun * @CreateTime: 2020-07-28 17:33 * @Description: 文件上传 */public class TestUpload &#123; public static void main(String[] args) &#123; try &#123; // 加载配置文件 ClientGlobal.initByProperties(&quot;config/fastdfs-client.properties&quot;); // 创建tracker客户端 TrackerClient trackerClient = new TrackerClient(); // 通过tracker客户端获取tracker的连接服务并返回 TrackerServer trackerServer = trackerClient.getConnection(); // 声明storage服务 StorageServer storageServer = null; // 定义storage客户端 StorageClient1 client = new StorageClient1(trackerServer, storageServer); // 定义文件元信息 NameValuePair[] list = new NameValuePair[1]; list[0] = new NameValuePair(&quot;fileName&quot;,&quot;1.jpg&quot;); String fileID = client.upload_file1(&quot;F:\\img\\1.jpg&quot;, &quot;jpg&quot;, list); System.out.println(&quot;fileID = &quot; + fileID); // group1/M00/00/00/CgHc918f8l6AFYp0AAWICfQnHuk889.jpg /** * group1：一台服务器，就是一个组 * M00： store_path0 ----&gt; /home/fastdfs/fdfs_storage/data * 00/00：两级数据目录 */ trackerServer.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 2.4.4 文件查询12345678910111213141516171819202122232425package test;import org.csource.fastdfs.*;/** * @BelongsProject: lagou-fastdfs * @Author: GuoAn.Sun * @CreateTime: 2020-07-28 17:46 * @Description: 文件查询 */public class TestQuery &#123; public static void main(String[] args) throws Exception &#123; // 加载配置文件 ClientGlobal.initByProperties(&quot;config/fastdfs-client.properties&quot;); // 创建tracker客户端 TrackerClient trackerClient = new TrackerClient(); // 通过tracker客户端获取tracker的连接服务并返回 TrackerServer trackerServer = trackerClient.getConnection(); // 声明storage服务 StorageServer storageServer = null; // 定义storage客户端 StorageClient1 client = new StorageClient1(trackerServer, storageServer); FileInfo fileInfo = client.query_file_info1(&quot;group1/M00/00/00/CgHc918f8l6AFYp0AAWICfQnHuk889.jpg&quot;); if(fileInfo!=null) System.out.println(&quot;fileInfo = &quot; + fileInfo); elseSystem.out.println(&quot;查无此文件！&quot;); trackerServer.close(); &#125;&#125; 2.4.5 文件下载12345678910111213141516171819202122232425262728293031package test;import org.csource.fastdfs.*;import java.io.File;import java.io.FileOutputStream;/** * @BelongsProject: lagou-fastdfs * @Author: GuoAn.Sun * @CreateTime: 2020-07-28 17:49 * @Description: 文件下载 */public class TestDownload &#123; public static void main(String[] args) throws Exception&#123; // 加载配置文件 ClientGlobal.initByProperties(&quot;config/fastdfs-client.properties&quot;); // 创建tracker客户端 TrackerClient trackerClient = new TrackerClient(); // 通过tracker客户端获取tracker的连接服务并返回 TrackerServer trackerServer = trackerClient.getConnection(); // 声明storage服务 StorageServer storageServer = null; // 定义storage客户端 StorageClient1 client = new StorageClient1(trackerServer, storageServer); byte[] bytes = client.download_file1(&quot;group1/M00/00/00/CgHc918f8l6AFYp0AAWICfQnHuk889.jpg&quot;); // 通过io将字节数组，转换成一个文件 FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;F:/xxxxxx.jpg&quot;)); fileOutputStream.write(bytes); fileOutputStream.close(); trackerServer.close(); System.out.println(&quot;下载完毕！&quot;); &#125;&#125; 3. 项目实战 掌握fastDFS在真实项目中的使用方法； 掌握fastDFS实现图片服务器； 3.1 搭建图片服务器3.1.1 Nginx模块安装 （Storage） 上传 fastdfs-nginx-module_v1.16.tar.gz 到 &#x2F;opt 解压nginx模块 1tar -zxvf fastdfs-nginx-module_v1.16.tar.gz 修改 config 文件，将文件中的 &#x2F;usr&#x2F;local&#x2F; 路径改为 &#x2F;usr&#x2F; 12cd /opt/fastdfs-nginx-module/src vim config 将 fastdfs-nginx-module&#x2F;src下的 mod_fastdfs.conf 拷贝至 &#x2F;etc&#x2F;fdfs 下 1cp mod_fastdfs.conf /etc/fdfs/ 修改 &#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf 1vim /etc/fdfs/mod_fastdfs.conf 12345678base_path=/home/fastdfs tracker_server=10.1.220.247:22122 #(n个tracker配置n行) #tracker_server=10.1.220.x:22122 #url中包含group名称 url_have_group_name=true #指定文件存储路径（上面配置的store路径） store_path0=/home/fastdfs/fdfs_storage 将 libfdfsclient.so 拷贝至 &#x2F;usr&#x2F;lib 下 1cp /usr/lib64/libfdfsclient.so /usr/lib/ 创建nginx&#x2F;client目录 1mkdir -p /var/temp/nginx/client 3.1.2 Nginx安装 （Tracker） 将 nginx-1.14.0.tar.gz上传到&#x2F;opt（安装过nginx，此步省略） 解压：tar -zxvf nginx-1.14.0.tar.gz（安装过nginx，此步省略） 安装依赖库（安装过nginx，此步省略） 123456yum install pcre yum install pcre-devel yum install zlib yum install zlib-devel yum install openssl yum install openssl-devel 进入nginx解压的目录下 cd &#x2F;opt&#x2F;nginx-1.14.0 安装 1./configure \\ --prefix=/usr/local/nginx \\ --pid-path=/var/run/nginx/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi \\ --add-module=/opt/fastdfs-nginx-module/src **注意：**上边将临时文件目录指定为 &#x2F;var&#x2F;temp&#x2F;nginx，需要在 &#x2F;var 下创建 temp 及 nginx 目录：mkdir&#x2F;var&#x2F;temp&#x2F;nginx 编译：make 安装：make install 拷贝配置文件 123cd /opt/FastDFS/conf cp http.conf mime.types /etc/fdfs/ 是否覆盖：yes 修改nginx配置文件 12cd /usr/local/nginx/conf/ vim nginx.conf 123456789server &#123; listen 80; server_name 10.1.220.247; #charset koi8-r; #access_log logs/host.access.log main; location /group1/M00 &#123; root /home/fastdfs/fdfs_storage/data; ngx_fastdfs_module; &#125; 关闭nginx，并启动nginx 12pkill -9 nginx/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 访问nginx并查看图片 http://10.1.220.247 http://10.1.220.247/group1/M00/00/00/CgHc918f8l6AFYp0AAWICfQnHuk889.jpg 3.2 创建前端页面1234567&lt;!--上传文件，文件与文字相比较起来，属于内容较大，必须使用post方式提交--&gt; &lt;!--上传文件，和普通文件有区别，action接收参数也会区别对待，所以声明带文件提交的表单为“多部 件表单”--&gt; &lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;fname&quot;&gt; &lt;br&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; 3.3 搭建web服务3.3.1 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependencies&gt; &lt;!-- 因为有jsp页面，所以引用servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 页面提交过来的请求，使用springmvc来处理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java连接fastDFS的客户端工具--&gt; &lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 图片上传到FastDFS需要用的到IO工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 图片保存到web服务器需要用到的IO工具--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--用来转换java对象和json字符串，注意，2.7以上版本必须搭配spring5.0以上--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8001&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.3.2 web.xml123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet- class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.3.3 spring-mvc.xml123456789&lt;!--扫描注解的包--&gt;&lt;context:component-scan base-package=&quot;controller&quot;/&gt;&lt;!--扫描控制器中的注解：@Response--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--上传文件的解析器（规定上传文件的大小限制）--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件最大限制：2GB--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;2048000000&quot;/&gt;&lt;/bean&gt; 3.3.4 文件实体类12345public class FileSystem implements Serializable &#123; private String fileId; private String filePath; private String fileName;&#125; 3.3.5 控制层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package controller;import entity.FileSystem;import org.csource.common.NameValuePair;import org.csource.fastdfs.*;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import java.io.File;import java.util.UUID;/** * @BelongsProject: lagou-imageServer * @Author: GuoAn.Sun * @CreateTime: 2020-07-29 14:25 * @Description: 处理上传文件的控制器 */@Controller public class FileAction &#123; /** * @param request 多部件表单的请求对象 * @return 上传文件对象的json对象 * @throws Exception * * 上传文件的流程： * 1、先把文件保存到web服务器上 * 2、再从web服务器上将文件 上传 到 FastDFS上 */ @RequestMapping(&quot;upload&quot;) //MultipartHttpServletRequest：是httpservletRequest的强化版本，不仅可以装文本信 息，还可以装图片文件信息 public @ResponseBody FileSystem upload(MultipartHttpServletRequest request) throws Exception &#123; FileSystem fileSystem = new FileSystem(); /* 1、把文件保存到web服务器 */ // 从页面请求中，获取上传的文件对象 MultipartFile file = request.getFile(&quot;fname&quot;); // 从文件对象中获取 文件的原始名称 String oldFileName = file.getOriginalFilename(); // 通过字符串截取的方式，从文件原始名中获取文件的后缀 1.jpg String hou = oldFileName.substring(oldFileName.lastIndexOf(&quot;.&quot;) + 1); // 为了避免文件因为同名而覆盖，生成全新的文件名 String newFileName = UUID.randomUUID().toString() + &quot;.&quot; + hou; // 创建web服务器保存文件的目录(预先创建好D:/upload目录，否则系统找不到路径，会抛异 常) File toSaveFile = new File(&quot;D:/upload/&quot; + newFileName); // 将路径转换成文件 file.transferTo(toSaveFile); // 获取服务器的绝对路径 String newFilePath = toSaveFile.getAbsolutePath(); /* 2、把文件从web服务器上传到FastDFS*/ ClientGlobal.initByProperties(&quot;config/fastdfs-client.properties&quot;); TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer = trackerClient.getConnection(); StorageServer storageServer = null; StorageClient1 client = new StorageClient1(trackerServer, storageServer); NameValuePair[] list = new NameValuePair[1]; list[0] = new NameValuePair(&quot;fileName&quot;,oldFileName); String fileId = client.upload_file1(newFilePath, hou, list); trackerServer.close(); // 封装fileSystem数据对象 fileSystem.setFileId(fileId); fileSystem.setFileName(oldFileName); fileSystem.setFilePath(fileId); //已经上传到FastDFS上，通过fileId来访问图 片，所以fileId即为文件路径 return fileSystem; &#125;&#125; 3.3.6 添加fastDFS的配置文件在resources下创建config目录，在config目录下创建 fastdfs-client.properties 参考：2.4.2 3.3.7 启动fastDFS服务，测试开始1234567[root@localhost /]# /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart [root@localhost /]# /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart [root@localhost /]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf [root@localhost /]# netstat -ntlp [root@localhost /]# systemctl stop firewalld.service [root@localhost /]# cd /home/fastdfs/fdfs_storage/data/ [root@localhost /]# ls 3.6 典型错误 重启linux服务器，可能会到nginx启动失败： 12[root@localhost logs]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf[root@localhost /]# nginx: [emerg] open() &quot;/var/run/nginx/nginx.pid&quot; failed (2: No such file or directory) 导致本次错误的原因，是没有修改pid文件的路径，编辑nginx的配置文件： 1vim /usr/local/nginx/conf/nginx.conf 1pid /usr/local/nginx/logs/nginx.pid; 再次启动nginx，搞定！","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Redis详解","slug":"Redis详解","date":"2021-06-08T09:41:17.000Z","updated":"2025-04-17T08:34:52.016Z","comments":true,"path":"2021/06/08/Redis详解/","link":"","permalink":"http://yournotes.cn/2021/06/08/Redis%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、概述1.1 互联网架构的演变历程 第1阶段 数据访问量不大，简单的架构即可搞定！ 第2阶段 数据访问量大，使用缓存技术来缓解数据库的压力。 不同的业务访问不同的数据库 第3阶段 主从读写分离。 之前的缓存确实能够缓解数据库的压力，但是写和读都集中在一个数据库上，压力又来了。 一个数据库负责写，一个数据库负责读。分工合作。愉快！ 让master（主数据库）来响应事务性**（增删改）操作，让slave（从数据库）来响应非事务性（查询）**操作，然后再采用主从复制来把master上的事务性操作同步到slave数据库中 mysql的master&#x2F;slave就是网站的标配！ 第4阶段 mysql的主从复制，读写分离的基础上，mysql的主库开始出现瓶颈 由于MyISAM使用表锁，所以并发性能特别差 分库分表开始流行，mysql也提出了表分区，虽然不稳定，但我们看到了希望 开始吧，mysql集群 1.2 Redis入门介绍 互联网需求的3高 高并发，高可扩，高性能 Redis 是一种运行速度很快，并发性能很强，并且运行在内存上的NoSql（not only sql）数据库 NoSQL数据库 和 传统数据库 相比的优势 NoSQL数据库无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。 而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦 Redis的常用使用场景 缓存，毫无疑问这是Redis当今最为人熟知的使用场景。在提升服务器性能方面非常有效；一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问 排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定； 计算器&#x2F;限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力； 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能； 简单消息队列，除了Redis自身的发布&#x2F;订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦； Session****共享，以jsp为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。 1.3 Redis&#x2F;Memcache&#x2F;MongoDB对比都是nosql数据库的著名代表 1.3.1 Redis和Memcache Redis和Memcache都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。 memcache 数据结构单一kv，redis 更丰富一些，还提供 list，set， hash 等数据结构的存储，有效的减少网络 IO 的次数 虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value交换到磁盘 存储数据安全–memcache挂掉后，数据没了（没有持久化机制）；redis可以定期保存到磁盘（持久化） 灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过RBD或AOF恢复 1.3.2 Redis和MongoDB redis和mongodb并不是竞争关系，更多的是一种协作共存的关系。 mongodb本质上还是硬盘数据库，在复杂查询时仍然会有大量的资源消耗，而且在处理复杂逻辑时仍然要不可避免地进行多次查询。 这时就需要redis或Memcache这样的内存数据库来作为中间层进行缓存和加速。 比如在某些复杂页面的场景中，整个页面的内容如果都从mongodb中查询，可能要几十个查询语句，耗时很长。如果需求允许，则可以把整个页面的对象缓存至redis中，定期更新。这样mongodb和redis就能很好地协作起来 1.4 分布式数据库CAP原理1.4.1 CAP简介 传统的关系型数据库事务具备ACID： A：原子性 C：一致性 I：独立性 D：持久性 分布式数据库的CAP: C（Consistency）：强一致性 “all nodes see the same data at the same time”,即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。 A（Availability）：高可用性 可用性指“Reads and writes always succeed”，即服务一直可用，而且要是正常的响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。 P（Partition tolerance）：分区容错性 即分布式系统在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性或可用性的服务。 分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。 1.4.2 CAP理论 CAP理论提出就是针对分布式数据库环境的，所以，P这个属性必须容忍它的存在，而且是必须具备的。 因为P是必须的，那么我们需要选择的就是A和C。 大家知道，在分布式环境下，为了保证系统可用性，通常都采取了复制的方式，避免一个节点损坏，导致系统不可用。那么就出现了每个节点上的数据出现了很多个副本的情况，而数据从一个节点复制到另外的节点时需要时间和要求网络畅通的，所以，当P发生时，也就是无法向某个节点复制数据时，这时候你有两个选择： 选择可用性 A，此时，那个失去联系的节点依然可以向系统提供服务，不过它的数据就不能保证是同步的了（失去了C属性）。 选择一致性C，为了保证数据库的一致性，我们必须等待失去联系的节点恢复过来，在这个过程中，那个节点是不允许对外提供服务的，这时候系统处于不可用状态(失去了A属性)。 最常见的例子是读写分离，某个节点负责写入数据，然后将数据同步到其它节点，其它节点提供读取的服务，当两个节点出现通信问题时，你就面临着选择A（继续提供服务，但是数据不保证准确），C（用户处于等待状态，一直等到数据同步完成）。 1.4.3 CAP总结 分区是常态，不可避免，三者不可共存 可用性和一致性是一对冤家 一致性高，可用性低 一致性低，可用性高 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类： CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 二、下载与安装2.1 下载redis：http://www.redis.net.cn/ 图形工具：https://redisdesktop.com/download 2.2 安装虽然可以在安装在windows操作系统，但是官方不推荐，一如既往的安装在linux上环境是虚拟机 上传tar.gz包，并解压 1tar -zxvf redis-5.0.4.tar.gz 安装gcc（必须有网络） 1yum -y install gcc 进入redis目录，进行编译 1make 编译之后，开始安装 1make install 2.3 安装后的操作2.3.1 后台运行方式 redis默认不会使用后台运行，如果你需要，修改配置文件daemonize&#x3D;yes，当你后台服务启动的时候，会写成一个进程文件运行。 1vim /opt/redis-5.0.4/redis.conf 1daemonize yes 以配置文件的方式启动 1cd /usr/local/bin redis-server /opt/redis-5.0.4/redis.conf 2.3.2 关闭数据库 单实例关闭 1redis-cli shutdown 多实例关闭 1redis-cli -p 6379 shutdown 2.3.3 常用操作 检测6379端口是否在监听 1netstat -lntp | grep 6379 端口为什么是6379？ ​ 6379在是手机按键上MERZ对应的号码， ​ 而MERZ取自意大利歌女Alessia Merz的名字。 ​ MERZ长期以来被antirez（redis作者）及其朋友当作愚蠢的代名词。 检测后台进程是否存在 1ps -ef|grep redis 2.3.4 连接redis并测试12redis-cli ping 2.3.5 HelloWorld1234# 保存数据 set k1 china # 获取数据 get kl 2.3.6 测试性能 先 ctrl+c，退出redis客户端 1redis-benchmark 执行命令后，命令不会自动停止，需要我们手动ctrl+c停止测试\\ 123456789101112131415[root@localhost bin]# redis-benchmark====== PING_INLINE ======100000 requests completed in 1.80 seconds # 1.8秒处理了10万个请求，性能要看笔记 本的配置高低50 parallel clients3 bytes payloadkeep alive: 187.69% &lt;= 1 milliseconds99.15% &lt;= 2 milliseconds 99.65% &lt;= 3 milliseconds 99.86% &lt;= 4 milliseconds 99.92% &lt;= 5 milliseconds 99.94% &lt;= 6 milliseconds 99.97% &lt;= 7 milliseconds 100.00% &lt;= 7 milliseconds 55524.71 requests per second # 每秒处理的请求数量 2.3.7 默认16个数据库1vim /opt/redis-5.0.4/redis.conf 123456789101112127.0.0.1:6379&gt; get k1 # 查询k1&quot;china&quot;127.0.0.1:6379&gt; select 16 # 切换16号数据库(error) ERR DB index is out of range # 数据库的下标超出了范围127.0.0.1:6379&gt; select 15 # 切换15号数据库OK127.0.0.1:6379[15]&gt; get k1 # 查询k1(nil)127.0.0.1:6379[15]&gt; select 0 # 切换0号数据库OK127.0.0.1:6379&gt; get k1 # 查询k1&quot;china&quot; 2.3.8 数据库键的数量1dbsize redis在linux支持命令补全（tab） 2.3.9 清空数据库 清空当前库 1flushdb 清空所有（16个）库，慎用！！ 1flushall 2.3.10 模糊查询（key）模糊查询keys命令，有三个通配符： 通配任意多个字符 查询所有的键 1keys * 模糊查询k开头，后面随便多少个字符 1keys k* 模糊查询e为最后一位，前面随便多少个字符 1keys *e 双 * 模式，匹配任意多个字符：查询包含k的键 1keys *k* ?：通配单个字符 模糊查询k字头，并且匹配一个字符 1keys k? 你只记得第一个字母是k，他的长度是3 1keys k?? []：通配括号内的某一个字符 记得其他字母，就第二个字母可能是a或e 1keys r[ae]dis 2.3.11 键（key） exists key：判断某个key是否存在 1234127.0.0.1:6379&gt; exists k1(integer) 1 # 存在127.0.0.1:6379&gt; exists y1(integer) 0 # 不存在 move key db：移动（剪切，粘贴）键到几号库 12345678127.0.0.1:6379&gt; move x1 8 # 将x1移动到8号库(integer) 1 # 移动成功127.0.0.1:6379&gt; exists x1 # 查看当前库中是否存在x1(integer) 0 # 不存在（因为已经移走了）127.0.0.1:6379&gt; select 8 # 切换8号库OK127.0.0.1:6379[8]&gt; keys * # 查看当前库中的所有键1) &quot;x1&quot; ttl key：查看键还有多久过期（-1永不过期，-2已过期） 12127.0.0.1:6379[8]&gt; ttl x1(integer) -1 # 永不过期 time to live 还能活多久 expire key 秒：为键设置过期时间（生命倒计时） 1234567891011121314127.0.0.1:6379[8]&gt; set k1 v1 # 保存k1OK127.0.0.1:6379[8]&gt; ttl k1 # 查看k1的过期时间(integer) -1 # 永不过期127.0.0.1:6379[8]&gt; expire k1 10 # 设置k1的过期时间为10秒（10秒后自动销毁）(integer) 1 # 设置成功127.0.0.1:6379[8]&gt; get k1 # 获取k1&quot;v1&quot;127.0.0.1:6379[8]&gt; ttl k1 # 查看k1的过期时间&#x27;(integer) 2 # 还有2秒过期127.0.0.1:6379[8]&gt; get k1(nil)127.0.0.1:6379[8]&gt; keys * # 从内存中销毁了(empty list or set) type key：查看键的数据类型 12127.0.0.1:6379[8]&gt; type k1 string # k1的数据类型是会string字符串 三、使用Redis3.1 五大数据类型 操作文档：http://redisdoc.com/ 3.1.1 字符串String set&#x2F;get&#x2F;del&#x2F;append&#x2F;strlen 12345678910111213141516171819127.0.0.1:6379&gt; set k1 v1 # 保存数据OK127.0.0.1:6379&gt; set k2 v2 # 保存数据OK127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;127.0.0.1:6379&gt; del k2 # 删除数据k2(integer) 1127.0.0.1:6379&gt; keys *1) &quot;k1&quot;127.0.0.1:6379&gt; get k1 # 获取数据k1&quot;v1&quot;127.0.0.1:6379&gt; append k1 adc # 往k1的值追加数据abc(integer) 5127.0.0.1:6379&gt; get k1&quot;v1adc&quot;127.0.0.1:6379&gt; strlen k1 # 返回k1值的长度（字符数量）(integer) 5 incr&#x2F;decr&#x2F;incrby&#x2F;decrby：加减操作，操作的必须是数字类型 incr：意思是increment，增加 decr：意思是decrement，减少 12345678910111213141516171819202122127.0.0.1:6379&gt; set k1 1 # 初始化k1的值为1OK127.0.0.1:6379&gt; incr k1 # k1自增1（相当于++）(integer) 2127.0.0.1:6379&gt; incr k1(integer) 3127.0.0.1:6379&gt; get k1&quot;3&quot;127.0.0.1:6379&gt; decr k1 # k1自减1（相当于--）(integer) 2127.0.0.1:6379&gt; decr k1(integer) 1127.0.0.1:6379&gt; get k1&quot;1&quot;127.0.0.1:6379&gt; incrby k1 3 # k1自增3（相当于+=3）(integer) 4127.0.0.1:6379&gt; get k1&quot;4&quot;127.0.0.1:6379&gt; decrby k1 2 # k1自减2（相当于-=2）(integer) 2127.0.0.1:6379&gt; get k1&quot;2&quot; getrange&#x2F;setrange：类似between…and… range：范围 123456789101112127.0.0.1:6379&gt; set k1 abcdef # 初始化k1的值为abcdefOK127.0.0.1:6379&gt; get k1&quot;abcdef&quot;127.0.0.1:6379&gt; getrange k1 0 -1 # 查询k1全部的值&quot;abcdef&quot;127.0.0.1:6379&gt; getrange k1 0 3 # 查询k1的值，范围是下标0~下标3（包含0和3，共 返回4个字符）&quot;abcd&quot;127.0.0.1:6379&gt; setrange k1 1 xxx # 替换k1的值，从下标1开始提供为xxx(integer) 6127.0.0.1:6379&gt; get k1&quot;axxxef&quot; setex&#x2F;setnx set with expir：添加数据的同时设置生命周期 123456127.0.0.1:6379&gt; setex k1 5 v1 # 添加k1 v1数据的同时，设置5秒的声明周期OK127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; get k1 # 已过期，k1的值v1自动销毁(nil) set if not exist：添加数据的时候判断是否已经存在，防止已存在的数据被覆盖掉 123456127.0.0.1:6379&gt; setnx k1 xu (integer) 0 # 添加失败，因为k1已经存在127.0.0.1:6379&gt; get k1&quot;sun&quot;127.0.0.1:6379&gt; setnx k2 xu(integer) 1 # k2不存在，所以添加成功 mset&#x2F;mget&#x2F;msetnx m：more更多 123456789101112131415127.0.0.1:6379&gt; set k1 v1 k2 v2 # set不支持一次添加多条数据(error) ERR syntax error127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # mset可以一次添加多条数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;127.0.0.1:6379&gt; mget k2 k3 # 一次获取多条数据1) &quot;v2&quot;2) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k3 v3 k4 v4 # 一次添加多条数据时，如果添加的数据中有已经存在的，则失败(integer) 0127.0.0.1:6379&gt; msetnx k4 v4 k5 v5 # 一次添加多条数据时，如果添加的数据 中都不存在的，则成功(integer) 1 getset：先get后set 123456789101112131415127.0.0.1:6379&gt; getset k6 v6(nil) # 因为没有k6，所以get为null，然后将k6v6的值添加到数据库127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k5&quot;3) &quot;k4&quot;4) &quot;k6&quot;5) &quot;k3&quot;6) &quot;k1&quot;127.0.0.1:6379&gt; get k6&quot;v6&quot;127.0.0.1:6379&gt; getset k6 vv6 # 先获取k6的值，然后修改k6的值为vv6&quot;v6&quot;127.0.0.1:6379&gt; get k6&quot;vv6&quot; 3.1.2 列表Listpush和pop，类似机枪AK47：push，压子弹，pop，射击出子弹 lpush&#x2F;rpush&#x2F;lrange l：left 自左向右→添加 （从上往下添加） r：right 自右向左←添加（从下往上添加） 123456789101112131415161718127.0.0.1:6379&gt; lpush list01 1 2 3 4 5 # 从上往下添加(integer) 5127.0.0.1:6379&gt; keys *1) &quot;list01&quot;127.0.0.1:6379&gt; lrange list01 0 -1 # 查询list01中的全部数据0表示开 始，-1表示结尾1) &quot;5&quot;2) &quot;4&quot;3) &quot;3&quot;4) &quot;2&quot;5) &quot;1&quot;127.0.0.1:6379&gt; rpush list02 1 2 3 4 5 # 从下往上添加(integer) 5127.0.0.1:6379&gt; lrange list02 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;5) &quot;5&quot; lpop&#x2F;rpop：移除第一个元素（上左下右） 1234127.0.0.1:6379&gt; lpop list02 # 从左（上）边移除第一个元素&quot;1&quot;127.0.0.1:6379&gt; rpop list02 # 从右（下）边移除第一个元素&quot;5&quot; lindex：根据下标查询元素（从左向右，自上而下） 12345678910127.0.0.1:6379&gt; lrange list01 0 -11) &quot;5&quot; 2) &quot;4&quot; 3) &quot;3&quot; 4) &quot;2&quot; 5) &quot;1&quot;127.0.0.1:6379&gt; lindex list01 2 # 从上到下数，下标为2的值&quot;3&quot;127.0.0.1:6379&gt; lindex list01 1 # 从上到下数，下标为1的值&quot;4&quot; llen：返回集合长度 12127.0.0.1:6379&gt; llen list01(integer) 5 lrem：删除n个value 12345678910111213127.0.0.1:6379&gt; lpush list01 1 2 2 3 3 3 4 4 4 4 (integer) 10 127.0.0.1:6379&gt; lrem list01 2 3 # 从list01中移除2个3 (integer) 2 127.0.0.1:6379&gt; lrange list01 0 -1 1) &quot;4&quot; 2) &quot;4&quot; 3) &quot;4&quot; 4) &quot;4&quot; 5) &quot;3&quot; 6) &quot;2&quot; 7) &quot;2&quot; 8) &quot;1&quot; ltrim：截取指定范围的值，别的全扔掉 ltrim key begindex endindex 12345678910111213141516171819127.0.0.1:6379&gt; lpush list01 1 2 3 4 5 6 7 8 9(integer) 9127.0.0.1:6379&gt; lrange list01 0 -11) &quot;9&quot; # 下标0 2) &quot;8&quot; # 下标1 3) &quot;7&quot; # 下标2 4) &quot;6&quot; # 下标3 5) &quot;5&quot; # 下标4 6) &quot;4&quot; # 下标5 7) &quot;3&quot; # 下标6 8) &quot;2&quot; # 下标7 9) &quot;1&quot; # 下标8127.0.0.1:6379&gt; ltrim list01 3 6 # 截取下标3~6的值，别的全扔掉OK127.0.0.1:6379&gt; lrange list01 0 -11) &quot;6&quot; 2) &quot;5&quot; 3) &quot;4&quot; 4) &quot;3&quot; rpoplpush：从一个集合搞一个元素到另一个集合中（右出一个，左进一个） 123456789101112131415161718192021222324252627282930127.0.0.1:6379&gt; rpush list01 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; lrange list01 0 -11) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 5) &quot;5&quot;127.0.0.1:6379&gt; rpush list02 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; lrange list02 0 -11) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 5) &quot;5&quot;127.0.0.1:6379&gt; rpoplpush list01 list02 # list01右边出一个，从左进入到list02的第一个位置&quot;5&quot;127.0.0.1:6379&gt; lrange list01 0 -11) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot;127.0.0.1:6379&gt; lrange list02 0 -11) &quot;5&quot; 2) &quot;1&quot; 3) &quot;2&quot; 4) &quot;3&quot; 5) &quot;4&quot; 6) &quot;5&quot; lset：改变某个下标的某个值 lset key index value 12345678910111213141516127.0.0.1:6379&gt; lrange list02 0 -11) &quot;5&quot; 2) &quot;1&quot; 3) &quot;2&quot; 4) &quot;3&quot; 5) &quot;4&quot; 6) &quot;5&quot;127.0.0.1:6379&gt; lset list02 0 x # 将list02中下标为0的元素修改成xOK127.0.0.1:6379&gt; lrange list02 0 -11) &quot;x&quot;2) &quot;1&quot; 3) &quot;2&quot; 4) &quot;3&quot; 5) &quot;4&quot; 6) &quot;5&quot; linsert：插入元素（指定某个元素之前&#x2F;之后） linsert key before&#x2F;after oldvalue new value 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; lrange list02 0 -1 1) &quot;x&quot; 2) &quot;1&quot; 3) &quot;2&quot; 4) &quot;3&quot; 5) &quot;4&quot; 6) &quot;5&quot;127.0.0.1:6379&gt; linsert list02 before 2 java # 从左边进入，在list02中的2素之前插入java(integer) 7127.0.0.1:6379&gt; lrange list02 0 -11) &quot;x&quot; 2) &quot;1&quot; 3) &quot;java&quot; 4) &quot;2&quot; 5) &quot;3&quot; 6) &quot;4&quot; 7) &quot;5&quot;127.0.0.1:6379&gt; linsert list02 after 2 redis # 从左边进入，在list02中的元素之后插入redis(integer) 8127.0.0.1:6379&gt; lrange list02 0 -11) &quot;x&quot; 2) &quot;1&quot; 3) &quot;java&quot; 4) &quot;2&quot; 5) &quot;redis&quot; 6) &quot;3&quot; 7) &quot;4&quot; 8) &quot;5&quot; 性能总结：类似添加火车皮一样，头尾操作效率高，中间操作效率惨； 3.1.3 集合Set和java中的set特点类似，不允许重复 sadd&#x2F;smembers&#x2F;sismember：添加&#x2F;查看&#x2F;判断是否存在 12345678910127.0.0.1:6379&gt; sadd set01 1 2 2 3 3 3 # 添加元素（自动排除重复元素）(integer) 3127.0.0.1:6379&gt; smembers set01 # 查询set01集合1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot;127.0.0.1:6379&gt; sismember set01 2(integer) 1 # 存在127.0.0.1:6379&gt; sismember set01 5(integer) 0 # 不存在 注意：1和0可不是下标，而是布尔。1：true存在，2：false不存在 scard：获得集合中的元素个数 12127.0.0.1:6379&gt; scard set01 (integer) 3 # 集合中有3个元素 srem：删除集合中的元素 srem key value 12127.0.0.1:6379&gt; srem set01 2 # 移除set01中的元素2(integer) 1 # 1表示移除成功 srandmember：从集合中随机获取几个元素’ srandmember 整数（个数） 12345678910111213141516171819202122127.0.0.1:6379&gt; sadd set01 1 2 3 4 5 6 7 8 9 (integer) 9 127.0.0.1:6379&gt; smembers set01 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 5) &quot;5&quot; 6) &quot;6&quot; 7) &quot;7&quot; 8) &quot;8&quot; 9) &quot;9&quot;127.0.0.1:6379&gt; srandmember set01 3 # 从set01中随机获取3个元素1) &quot;8&quot; 2) &quot;2&quot; 3) &quot;3&quot;127.0.0.1:6379&gt; srandmember set01 5 # 从set01中随机获取5个元素1) &quot;5&quot; 2) &quot;8&quot; 3) &quot;7&quot; 4) &quot;4&quot; 5) &quot;6&quot; spop：随机出栈（移除） 1234567891011121314127.0.0.1:6379&gt; smembers set011) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 5) &quot;5&quot; 6) &quot;6&quot; 7) &quot;7&quot; 8) &quot;8&quot; 9) &quot;9&quot;127.0.0.1:6379&gt; spop set01 # 随机移除一个元素&quot;8&quot;127.0.0.1:6379&gt; spop set01 # 随机移除一个元素&quot;7&quot; smove：移动元素：将key1某个值赋值给key2 123456127.0.0.1:6379&gt; sadd set01 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; sadd set02 x y z(integer) 3127.0.0.1:6379&gt; smove set01 set02 3 # 将set01中的元素3移动到set02中(integer) 1 # 移动成功 数学集合类 交集：sinter 并集：sunion 差集：sdiff 123456789101112131415161718192021222324127.0.0.1:6379&gt; sadd set01 1 2 3 4 5 (integer) 5 127.0.0.1:6379&gt; sadd set02 2 a 1 b 3 (integer) 5 127.0.0.1:6379&gt; sinter set01 set02 # set01和set02共同存在的元素 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 127.0.0.1:6379&gt; sunion set01 set02 # 将set01和set02中所有元素合并起来（排除重复的） 1) &quot;5&quot; 2) &quot;4&quot; 3) &quot;3&quot; 4) &quot;2&quot; 5) &quot;b&quot; 6) &quot;a&quot; 7) &quot;1&quot; 127.0.0.1:6379&gt; sdiff setr01 set02 (empty list or set) 127.0.0.1:6379&gt; sdiff set01 set02 # 在set01中存在，在set02中不存在1) &quot;4&quot; 2) &quot;5&quot; 127.0.0.1:6379&gt; sdiff set02 set01 # 在set02中存在，在set01中不存在 1) &quot;b&quot; 2) &quot;a&quot; 3.1.4 哈希Hash类似java里面的Map&lt;String,Object&gt;KV模式不变，但V是一个键值对 hset&#x2F;hget&#x2F;hmset&#x2F;hmget&#x2F;hgetall&#x2F;hdel：添加&#x2F;得到&#x2F;多添加&#x2F;多得到&#x2F;得到全部&#x2F;删除属性 12345678910111213141516171819202122232425127.0.0.1:6379&gt; hset user id 1001 # 添加user，值为id=1001 (integer) 1 127.0.0.1:6379&gt; hget user (error) ERR wrong number of arguments for &#x27;hget&#x27; command 127.0.0.1:6379&gt; hget user id # 查询user，必须指明具体的字段 &quot;1001&quot; 127.0.0.1:6379&gt; hmset student id 101 name tom age 22 # 添加学生student，属性一堆 OK127.0.0.1:6379&gt; hget student name # 获取学生名字 &quot;tom&quot; 127.0.0.1:6379&gt; hmget student name age # 获取学生年龄 1) &quot;tom&quot; 2) &quot;22&quot; 127.0.0.1:6379&gt; hgetall student # 获取学生全部信息 1) &quot;id&quot; 2) &quot;101&quot; 3) &quot;name&quot; 4) &quot;tom&quot; 5) &quot;age&quot; 6) &quot;22&quot; 127.0.0.1:6379&gt; hdel student age # 删除学生年龄属性 (integer) 1 # 删除成功 127.0.0.1:6379&gt; hgetall student 1) &quot;id&quot; 2) &quot;101&quot; 3) &quot;name&quot; 4) &quot;tom&quot; hlen：返回元素的属性个数 1234567127.0.0.1:6379&gt; hgetall student 1) &quot;id&quot; 2) &quot;101&quot; 3) &quot;name&quot; 4) &quot;tom&quot; 127.0.0.1:6379&gt; hlen student (integer) 2 # student属性的数量，id和name，共两个属性 hexists：判断元素是否存在某个属性 1234127.0.0.1:6379&gt; hexists student name # student中是否存在name属性(integer) 1 # 存在127.0.0.1:6379&gt; hexists student age # student中是否存在age属性(integer) 0 # 不存在 hkeys&#x2F;hvals：获得属性的所有key&#x2F;获得属性的所有value 123456127.0.0.1:6379&gt; hkeys student # 获取student所有的属性名1) &quot;id&quot; 2) &quot;name&quot; 127.0.0.1:6379&gt; hvals student # 获取student所有属性的值（内容） 1) &quot;101&quot; 2) &quot;tom&quot; hincrby&#x2F;hincrbyfloat：自增（整数）&#x2F;自增（小数） 123456789101112127.0.0.1:6379&gt; hmset student id 101 name tom age 22OK127.0.0.1:6379&gt; hincrby student age 2 # 自增整数2(integer) 24127.0.0.1:6379&gt; hget student age&quot;24&quot;127.0.0.1:6379&gt; hmset user id 1001 money 1000OK127.0.0.1:6379&gt; hincrbyfloat user money 5.5 # 自增小数5.5&quot;1005.5&quot;127.0.0.1:6379&gt; hget user money&quot;1005.5&quot; hsetnx：添加的时候，先判断是否存在 12345678910111213127.0.0.1:6379&gt; hsetnx student age 18 # 添加时，判断age是否存在 (integer) 0 # 添加失败，因为age已存在 127.0.0.1:6379&gt; hsetnx student sex 男 # 添加时，判断sex是否存在 (integer) 1 # 添加成功，因为sex不存在 127.0.0.1:6379&gt; hgetall student 1) &quot;id&quot; 2) &quot;101&quot; 3) &quot;name&quot; 4) &quot;tom&quot; 5) &quot;age&quot; 6) &quot;24&quot; 7) &quot;sex&quot; 8) &quot;\\xe7\\x94\\xb7&quot; # 可以添加中文，但是显示为乱码（后期解决） 3.1.5 有序集合Zset真实需求：充10元可享vip1；充20元可享vip2；充30元可享vip3；以此类推… zadd&#x2F;zrange （withscores）：添加&#x2F;查询 12345678910111213141516171819127.0.0.1:6379&gt; zadd zset01 10 vip1 20 vip2 30 vip3 40 vip4 50 vip5 (integer) 5 127.0.0.1:6379&gt; zrange zset01 0 -1 # 查询数据 1) &quot;vip1&quot; 2) &quot;vip2&quot; 3) &quot;vip3&quot; 4) &quot;vip4&quot; 5) &quot;vip5&quot; 127.0.0.1:6379&gt; zrange zset01 0 -1 withscores # 带着分数查询数据 1) &quot;vip1&quot; 2) &quot;10&quot; 3) &quot;vip2&quot; 4) &quot;20&quot; 5) &quot;vip3&quot; 6) &quot;30&quot; 7) &quot;vip4&quot; 8) &quot;40&quot; 9) &quot;vip5&quot; 10) &quot;50&quot; zrangebyscore：模糊查询 ( ： 不包含 limit：跳过几个截取几个 1234567891011121314127.0.0.1:6379&gt; zrangebyscore zset01 20 40 # 20 &lt;= score &lt;= 40 1) &quot;vip2&quot; 2) &quot;vip3&quot; 3) &quot;vip4&quot; 127.0.0.1:6379&gt; zrangebyscore zset01 20 (40 # 20 &lt;= score &lt; 40 1) &quot;vip2&quot; 2) &quot;vip3&quot; 127.0.0.1:6379&gt; zrangebyscore zset01 (20 (40 # 20 &lt; score &lt; 40 1) &quot;vip3&quot; 127.0.0.1:6379&gt; zrangebyscore zset01 10 40 limit 2 2 # 10 &lt;= score &lt;= 40，共返回四个，跳过前2个，取2个 1) &quot;vip3&quot; 2) &quot;vip4&quot; 127.0.0.1:6379&gt; zrangebyscore zset01 10 40 limit 2 1 # 20 &lt;= score &lt;= 40，共返回四个，跳过前2个，取1个 1) &quot;vip3&quot; zrem：删除元素 12127.0.0.1:6379&gt; zrem zset01 vip5 # 移除vip5(integer) 1 zcard&#x2F;zcount&#x2F;zrank&#x2F;zscore：集合长度&#x2F;范围内元素个数&#x2F;得元素下标&#x2F;通过值得分数 12345678127.0.0.1:6379&gt; zcard zset01 # 集合中元素的个数 (integer) 4 127.0.0.1:6379&gt; zcount zset01 20 30 # 分数在20~40之间，共有几个元素 (integer) 2 127.0.0.1:6379&gt; zrank zset01 vip3 # vip3在集合中的下标（从上向下） (integer) 2 127.0.0.1:6379&gt; zscore zset01 vip2 # 通过元素获得对应的分数 &quot;20&quot; zrevrank：逆序找下标（从下向上） 12127.0.0.1:6379&gt; zrevrank zset01 vip3(integer) 1 zrevrange：逆序查询 12345678910127.0.0.1:6379&gt; zrange zset01 0 -1 # 顺序查询1) &quot;vip1&quot; 2) &quot;vip2&quot; 3) &quot;vip3&quot; 4) &quot;vip4&quot; 127.0.0.1:6379&gt; zrevrange zset01 0 -1 # 逆序查询 1) &quot;vip4&quot; 2) &quot;vip3&quot; 3) &quot;vip2&quot; 4) &quot;vip1&quot; zrevrangebyscore：逆序范围查找 1234127.0.0.1:6379&gt; zrevrangebyscore zset01 30 20 # 逆序查询分数在30~20之间的 （注意，先写大值，再写小值）1) &quot;vip3&quot; 2) &quot;vip2&quot;127.0.0.1:6379&gt; zrevrangebyscore zset01 20 30 # 如果小值在前，则结果为null (empty list or set) 3.3 持久化3.3.1 RDBRedis DataBase 在指定的时间间隔内，将内存中的数据集的快照写入磁盘； 默认保存在&#x2F;usr&#x2F;local&#x2F;bin中，文件名dump.rdb; 3.3.1.1 自动备份 redis是内存数据库，当我们每次用完redis，关闭linux时，按道理来说，内存释放，redis中的数据也会随之消失 为什么我们再次启动redis的时候，昨天的数据还在，并没有消失呢？ 正是因为，每次关机时，redis会自动将数据备份到一个文件中 ：&#x2F;usr&#x2F;local&#x2F;bin&#x2F;dump.rdb 接下来我们就来全方位的认识 自动备份机制 默认的自动备份策略不利于我们测试，所以修改redis.conf文件中的自动备份策略 123456vim redis.conf/SNAP # 搜索save 900 1 # 900秒内，至少变更1次，才会自动备份save 120 10 # 120秒内，至少变更10次，才会自动备份save 60 10000 # 60秒内，至少变更10000次，才会自动备份 当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save “” 使用shutdown模拟关机 ，关机之前和关机之后，对比dump.rdb文件的更新时间。注意：当我们使用shutdown命令，redis会自动将数据库备份，所以，dump.rdb文件创建时间更新了 开机启动redis，我们要在120秒内保存10条数据，再查看dump.rdb文件的更新时间（开两个终端窗口，方便查看） 120秒内保存10条数据这一动作触发了备份指令，目前，dump.rdb文件中保存了10条数据，将dump.rdb拷贝一份dump10.rdb，此时两个文件中都保存10条数据 既然有数据已经备份了，那我们就肆无忌惮的将数据全部删除flushall，再次shutdown关机 再次启动redis，发现数据真的消失了，并没有按照我们所想的 将dump.rdb文件中的内容恢复到redis中。为什么？ 因为，当我们保存10条以上的数据时，数据备份起来了； 然后删除数据库，备份文件中的数据，也没问题； 但是，问题出在shutdown上，这个命令一旦执行，就会立刻备份，将删除之后的空数据库生成备份文件，将之前装10条数据的备份文件覆盖掉了。所以，就出现了上图的结果。自动恢复失败。 怎么解决这个问题呢？要将备份文件再备份 将dump.rdb文件删除，将dump10.rdb重命名为dump.rdb 启动redis服务，登录redis，数据10条，全部恢复！ 3.3.1.2 手动备份 之前自动备份，必须更改好多数据，例如上边，我们改变了十多条数据，才会自动备份； 现在，我只保存一条数据，就想立刻备份，应该怎么做？ 每次操作完成，执行命令 save 就会立刻备份 3.3.1.3 与RDB相关的配置 stop-writes-on-bgsave-error：进水口和出水口，出水口发生故障与否 yes：当后台备份时候反生错误，前台停止写入 no：不管死活，就是往里怼 rdbcompression：对于存储到磁盘中的快照，是否启动LZF压缩算法，一般都会启动，因为这点性能，多买一台电脑，完全搞定N个来回了。 yes：启动 no：不启动（不想消耗CPU资源，可关闭） dbfilename：快照备份文件名字 dir：快照备份文件保存的目录，默认为当前目录 优势and劣势 优：适合大规模数据恢复，对数据完整性和一致行要求不高； 劣：一定间隔备份一次，意外down掉，就失去最后一次快照的所有修改 3.3.2 AOFAppend Only File 以日志的形式记录每个写操作； 将redis执行过的写指令全部记录下来（读操作不记录）； 只许追加文件，不可以改写文件； redis在启动之初会读取该文件从头到尾执行一遍，这样来重新构建数据； 3.3.2.1 开启AOF 为了避免失误，最好将redis.conf总配置文件备份一下，然后再修改内容如下： 12appendonly yesappendfilename appendonly.aof 重新启动redis，以新配置文件启动 1redis-server /usr/local/redis5.0.4/redis.conf 连接redis，加数据，删库，退出 查看当前文件夹多一个aof文件，看看文件中的内容,保存的都是 写 操作 文件中最后一句要删除，否则数据恢复不了 编辑这个文件，最后要 :wq**!** 强制执行 只需要重新连接，数据恢复成功 3.3.2.2 共存？谁优先？我们查看redis.conf文件，AOF和RDB两种备份策略可以同时开启，那系统会怎样选择？ 动手试试，编辑appendonly.aof，胡搞乱码，保存退出 启动redis 失败，所以是AOF优先载入来恢复原始数据！因为AOF比RDB数据保存的完整性更高！ 修复AOF文件，杀光不符合redis语法规范的代码 1reids-check-aof --fix appendonly.aof 3.3.2.3 与AOF相关的配置 appendonly：开启aof模式 appendfilename：aof的文件名字，最好别改！ appendfsync：追写策略 always：每次数据变更，就会立即记录到磁盘，性能较差，但数据完整性好 everysec：默认设置，异步操作，每秒记录，如果一秒内宕机，会有数据丢失 no：不追写 no-appendfsync-on-rewrite：重写时是否运用Appendfsync追写策略；用默认no即可，保证数据安全性。 AOF采用文件追加的方式，文件会越来越大，为了解决这个问题，增加了重写机制，redis会自动记录上一次AOF文件的大小，当AOF文件大小达到预先设定的大小时，redis就会启动AOF文件进行内容压缩，只保留可以恢复数据的最小指令集合 auto-aof-rewrite-percentage：如果AOF文件大小已经超过原来的100%，也就是一倍，才重写压缩 auto-aof-rewrite-min-size：如果AOF文件已经超过了64mb，才重写压缩 3.3.3 总结（如何选择？） RDB：只用作后备用途，建议15分钟备份一次就好 AOF： 在最恶劣的情况下，也只丢失不超过2秒的数据，数据完整性比较高，但代价太大，会带来持续的IO 对硬盘的大小要求也高，默认64mb太小了，企业级最少都是5G以上； 后面要学习的master&#x2F;slave才是新浪微博的选择！！ 3.4 事务 可以一次执行多个命令，是一个命令组，一个事务中，所有命令都会序列化（排队），不会被插队； 一个队列中，一次性，顺序性，排他性的执行一系列命令 三特性 隔离性：所有命令都会按照顺序执行，事务在执行的过程中，不会被其他客户端送来的命令打断 没有隔离级别：队列中的命令没有提交之前都不会被实际的执行，不存在“事务中查询要看到事务里的更新，事务外查询不能看到”这个头疼的问题 不保证原子性：冤有头债有主，如果一个命令失败，但是别的命令可能会执行成功，没有回滚 三步走 开启multi 入队queued 执行exec 与关系型数据库事务相比， multi：可以理解成关系型事务中的 begin exec ：可以理解成关系型事务中的 commit discard ：可以理解成关系型事务中的 rollback 3.4.1 一起生开启事务，加入队列，一起执行，并成功 123456789101112131415127.0.0.1:6379&gt; multi # 开启事务 OK127.0.0.1:6379&gt; set k1 v1 QUEUED # 加入队列 127.0.0.1:6379&gt; set k2 v2QUEUED # 加入队列 127.0.0.1:6379&gt; get k2 QUEUED # 加入队列 127.0.0.1:6379&gt; set k3 v3 QUEUED # 加入队列 127.0.0.1:6379&gt; exec # 执行，一起成功！ 1) OK 2) OK 3) &quot;v2&quot; 4) OK 3.4.2 一起死放弃之前的操作，恢复到原来的值 123456789127.0.0.1:6379&gt; multi # 开启事务 OK127.0.0.1:6379&gt; set k1 v1111 QUEUED 127.0.0.1:6379&gt; set k2 v2222 QUEUED 127.0.0.1:6379&gt; discard # 放弃操作 OK127.0.0.1:6379&gt; get k1 &quot;v1&quot; # 还是原来的值 3.4.3 一粒老鼠屎坏一锅汤一句报错，全部取消，恢复到原来的值 1234567891011121314127.0.0.1:6379&gt; multi OK127.0.0.1:6379&gt; set k4 v4 QUEUED 127.0.0.1:6379&gt; setlalala # 一句报错 (error) ERR unknown command `setlalala`, with args beginning with: 127.0.0.1:6379&gt; set k5 v5 QUEUED 127.0.0.1:6379&gt; exec # 队列中命令全部取消 (error) EXECABORT Transaction discarded because of previous errors. 127.0.0.1:6379&gt; keys * # 还是原来的值 1) &quot;k2&quot; 2) &quot;k3&quot; 3) &quot;k1&quot; 3.4.4 冤有头债有主追究责任，谁的错，找谁去 1234567891011121314151617127.0.0.1:6379&gt; multi OK127.0.0.1:6379&gt; incr k1 # 虽然v1不能++，但是加入队列并没有报错，类似java中的通过编 译QUEUED 127.0.0.1:6379&gt; set k4 v4 QUEUED 127.0.0.1:6379&gt; set k5 v5 QUEUED 127.0.0.1:6379&gt; exec 1) (error) ERR value is not an integer or out of range # 真正执行的时候，报错 2) OK # 成功 3) OK # 成功 127.0.0.1:6379&gt; keys * 1) &quot;k5&quot; 2) &quot;k1&quot; 3) &quot;k3&quot; 4) &quot;k2&quot; 5) &quot;k4&quot; 3.4.5 watch监控测试：模拟收入与支出 正常情况下： 12345678910111213127.0.0.1:6379&gt; set in 100 # 收入100元 OK127.0.0.1:6379&gt; set out 0 # 支出0元 OK127.0.0.1:6379&gt; multi OK127.0.0.1:6379&gt; decrby in 20 # 收入-20 QUEUED 127.0.0.1:6379&gt; incrby out 20 # 支出+20 QUEUED 127.0.0.1:6379&gt; exec 1) (integer) 80 2) (integer) 20 # 结果，没问题！ 特殊情况下： 12345678910127.0.0.1:6379&gt; watch in # 监控收入in OK127.0.0.1:6379&gt; multi OK127.0.0.1:6379&gt; decrby in 20 QUEUED 127.0.0.1:6379&gt; incrby out 20 QUEUED 127.0.0.1:6379&gt; exec (nil) # 在exec之前，我开启了另一个窗口（线程），对监控的in做了修改，所以本次的事务将 被打断（失效），类似于“乐观锁” unwatch：取消watch命令对所有key的操作 一旦执行了exec命令，那么之前加的所有监控自动失效！ 3.5 Redis的发布订阅 进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。例如：微信订阅号 订阅一个或多个频道 1234567891011121314127.0.0.1:6379&gt; subscribe cctv1 cctv5 cctv6 # 1.订阅三个频道 Reading messages... (press Ctrl-C to quit) 1) &quot;subscribe&quot; 2) &quot;cctv1&quot; 3) (integer) 1 1) &quot;subscribe&quot; 2) &quot;cctv5&quot;3) (integer) 2 1) &quot;subscribe&quot; 2) &quot;cctv6&quot; 3) (integer) 3 1) &quot;message&quot; # 3.cctv5接收到推送过来的信息 2) &quot;cctv5&quot; 3) &quot;NBA&quot; 发送消息 12127.0.0.1:6379&gt; publish cctv5 NBA # 2.发送消息给cctv5 (integer) 1 3.5 主从复制 就是 redis集群的策略 配从（库）不配主（库）：小弟可以选择谁是大哥，但大哥没有权利去选择小弟 读写分离：主机写，从机读 3.5.1 一主二仆 准备三台服务器，并修改redis.conf 1bind 0.0.0.0 启动三台redis，并查看每台机器的角色，都是master 1info replication 测试开始 首先，将三个机器全都清空，第一台添加值 1mset k1 v1 k2 v2 其余两台机器，复制（找大哥） 1slaveof 192.168.204.141 6379 第一台再添加值 1set k3 v3 **思考1：**slave之前的k1和k2是否能拿到？ **思考2：**slave之后的k3是否能拿到？ **思考3：**同时添加k4，结果如何？ **思考4：**主机shutdown，从机如何？ **思考5：**主机重启，从机又如何？ **思考6：**从机死了，主机如何？从机归来身份是否变化？ 3.5.2 血脉相传 一个主机理论上可以多个从机，但是这样的话，这个主机会很累 我们可以使用java面向对象继承中的传递性来解决这个问题，减轻主机的负担 形成祖孙三代： 1234127.0.0.1:6379&gt; slaveof 192.168.204.141 6379 # 142跟随141OK127.0.0.1:6379&gt; slaveof 192.168.204.142 6379 # 143跟随142 &#x27;OK 3.5.3 谋权篡位 1个主机，2个从机，当1个主机挂掉了，只能从2个从机中再次选1个主机 国不可一日无君，军不可一日无帅 手动选老大 模拟测试：1为master，2和3为slave，当1挂掉后，2篡权为master，3跟2 1slaveof no one # 2上执行，没有人能让我臣服，那我就是老大 1slaveof 192.168.204.142 6379 # 3跟随2号 **思考：**当1再次回归，会怎样？ 2和3已经形成新的集群，和1没有任何的关系了。所以1成为了光杆司令 3.5.4 复制原理 完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求 全量复制：Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份slave接收到数据文件后，存盘，并加载到内存中；（步骤1234） 增量复制：Slave初始化后，开始正常工作时主服务器发生的写操作同步到从服务器的过程；（步骤56）但，只要是重新连接master，一次性（全量复制）同步将自动执行； Redis主从同步策略：主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。 当然，如果有需要，slave 在任何时候都可以发起全量同步。 redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。 3.5.5 哨兵模式 自动版的谋权篡位！ 有个哨兵一直在巡逻，突然发现！！！！！老大挂了，小弟们会自动投票，从众小弟中选出新的老大 Sentinel是Redis的高可用性解决方案： 由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求 模拟测试 1主，2和3从 每一台服务器中创建一个配置文件sentinel.conf，名字绝不能错，并编辑sentinel.conf 12# sentinel monitor 被监控主机名（自定义） ip port 票数 sentinel monitor redis141 192.168.204.141 6379 1 启动服务的顺序：主Redis –&gt; 从Redis –&gt; Sentinel1&#x2F;2&#x2F;3 1redis-sentinel sentinel.conf 将1号老大挂掉，后台自动发起激烈的投票，选出新的老大 12127.0.0.1:6379&gt; shutdownnot connected&gt; exit 查看最后权利的分配 3成为了新的老大，2还是小弟 如果之前的老大再次归来呢？ 1号再次归来，自己成为了master，和3平起平坐 过了几秒之后，被哨兵检测到了1号机的归来，1号你别自己玩了，进入集体吧，但是新的老大已经产生了，你只能作为小弟再次进入集体！ 3.5.6 缺点 由于所有的写操作都是在master上完成的； 然后再同步到slave上，所以两台机器之间通信会有延迟； 当系统很繁忙的时候，延迟问题会加重； slave机器数量增加，问题也会加重 3.6 总配置redis.conf 详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478# Redis 配置文件示例# 注意单位: 当需要配置内存大小时, 可能需要指定像1k,5GB,4M等常见格式 ## 1k =&gt; 1000 bytes # 1kb =&gt; 1024 bytes # 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes # 1g =&gt; 1000000000 bytes # 1gb =&gt; 1024*1024*1024 bytes ## 单位是对大小写不敏感的 1GB 1Gb 1gB 是相同的。 ################################## INCLUDES 包含文件相关 ################################### # 可以在这里包含一个或多个其他的配置文件。如果你有一个适用于所有Redis服务器的标准配置模板 # 但也需要一些每个服务器自定义的设置，这个功能将很有用。被包含的配置文件也可以包含其他配置文 件，# 所以需要谨慎的使用这个功能。 ## 注意“inclue”选项不能被admin或Redis哨兵的&quot;CONFIG REWRITE&quot;命令重写。 # 因为Redis总是使用最后解析的配置行最为配置指令的值, 你最好在这个文件的开头配置includes来 # 避免它在运行时重写配置。 # 如果相反你想用includes的配置覆盖原来的配置，你最好在该文件的最后使用include ## include /path/to/local.conf # include /path/to/other.conf ################################ GENERAL 综合配置 ##################################### # 默认Rdis不会作为守护进程运行。如果需要的话配置成&#x27;yes&#x27; # 注意配置成守护进程后Redis会将进程号写入文件/var/run/redis.pid daemonize no # 当以守护进程方式运行时，默认Redis会把进程ID写到 /var/run/redis.pid。你可以在这里修改路 径。pidfile /var/run/redis.pid # 接受连接的特定端口，默认是6379 # 如果端口设置为0，Redis就不会监听TCP套接字。 port 6379 # TCP listen() backlog. # server在与客户端建立tcp连接的过程中，SYN队列的大小 # 在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核默默地将这个值减小 # 到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog # 两个值来达到想要的效果。tcp-backlog 511# 默认Redis监听服务器上所有可用网络接口的连接。可以用&quot;bind&quot;配置指令跟一个或多个ip地址来实现 # 监听一个或多个网络接口 ## 示例: ## bind 192.168.1.100 10.0.0.1 # bind 127.0.0.1 # 指定用来监听Unix套套接字的路径。没有默认值， 所以在没有指定的情况下Redis不会监听Unix套接 字## unixsocket /tmp/redis.sock # unixsocketperm 755 # 一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭) timeout 0 # TCP keepalive. ## 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，由于以下两个原因这是很有用 的：## 1）能够检测无响应的对端 # 2）让该连接中间的网络设备知道这个连接还存活 ## 在Linux上，这个指定的值(单位：秒)就是发送ACK的时间间隔。 # 注意：要关闭这个连接需要两倍的这个时间值。 # 在其他内核上这个时间间隔由内核配置决定 ## 这个选项的一个合理值是60秒 tcp-keepalive 0 # 指定服务器调试等级 # 可能值： # debug （大量信息，对开发/测试有用） # verbose （很多精简的有用信息，但是不像debug等级那么多） # notice （适量的信息，基本上是你生产环境中需要的） # warning （只有很重要/严重的信息会记录下来） loglevel notice # 指明日志文件名。也可以使用&quot;stdout&quot;来强制让Redis把日志信息写到标准输出上。 # 注意:如果Redis以守护进程方式运行，而设置日志显示到标准输出的话，日志会发送到/dev/null logfile &quot;&quot; # 要使用系统日志记录器，只要设置 &quot;syslog-enabled&quot; 为 &quot;yes&quot; 就可以了。 # 然后根据需要设置其他一些syslog参数就可以了。 # syslog-enabled no # 指明syslog身份 # syslog-ident redis # 指明syslog的设备。必须是user或LOCAL0 ~ LOCAL7之一。 # syslog-facility local0 # 设置数据库个数。默认数据库是 DB 0，# 可以通过select &lt;dbid&gt; (0 &lt;= dbid &lt;= &#x27;databases&#x27; - 1 ）来为每个连接使用不同的数据 库。databases 16 ################################ SNAPSHOTTING 快照，持久化操作配置 ################################ ## 把数据库存到磁盘上: ## save &lt;seconds&gt; &lt;changes&gt; ## 会在指定秒数和数据变化次数之后把数据库写到磁盘上。 ## 下面的例子将会进行把数据写入磁盘的操作: # 900秒（15分钟）之后，且至少1次变更 # 300秒（5分钟）之后，且至少10次变更 # 60秒之后，且至少10000次变更 ## 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。 ## 通过添加一条带空字符串参数的save指令也能移除之前所有配置的save指令 # 像下面的例子： # save &quot;&quot; save 900 1 save 300 10 save 60 10000 # 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作 # 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难。 ## 如果后台保存进程能重新开始工作，Redis将自动允许写操作 ## 然而如果你已经部署了适当的Redis服务器和持久化的监控，你可能想关掉这个功能以便于即使是 # 硬盘，权限等出问题了Redis也能够像平时一样正常工作， stop-writes-on-bgsave-error yes # 当导出到 .rdb 数据库时是否用LZF压缩字符串对象？ # 默认设置为 &quot;yes&quot;，因为几乎在任何情况下它都是不错的。 # 如果你想节省CPU的话你可以把这个设置为 &quot;no&quot;，但是如果你有可压缩的key和value的话， # 那数据文件就会更大了。 rdbcompression yes # 因为版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠但在 # 生产和加载RDB文件时，这有一个性能消耗(大约10%)，所以你可以关掉它来获取最好的性能。 ## 生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查 rdbchecksum yes # 持久化数据库的文件名 dbfilename dump.rdb # 工作目录 ## 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。 ## 累加文件也放这里。 ## 注意你这里指定的必须是目录，不是文件名。 dir ./ ################################# REPLICATION 主从复制的配置 ################################# # 主从同步。通过 slaveof 指令来实现Redis实例的备份。 # 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听 # 不同的端口。 ## slaveof &lt;masterip&gt; &lt;masterport&gt; # 如果master设置了密码保护（通过 &quot;requirepass&quot; 选项来配置），那么slave在开始同步之前必须 # 进行身份验证，否则它的同步请求会被拒绝。 ## masterauth &lt;master-password&gt; # 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能： ## 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求， # 可能是正常数据，也可能是还没获得值的空数据。 # 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步 # （SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。 #slave-serve-stale-data yes # 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入 salve # 的数据在同master同步之后将很容被删除)，但是如果客户端由于配置错误在写入时也可能产生一些问 题。## 从Redis2.6默认所有的slave为只读 ## 注意:只读的slave不是为了暴露给互联网上不可信的客户端而设计的。它只是一个防止实例误用的保护 层。# 一个只读的slave支持所有的管理命令比如config,debug等。为了限制你可以用&#x27;rename- command&#x27;来 # 隐藏所有的管理和危险命令来增强只读slave的安全性 slave-read-only yes # slave根据指定的时间间隔向master发送ping请求。 # 时间间隔可以通过 repl_ping_slave_period 来设置。 # 默认10秒。 ## repl-ping-slave-period 10 # 以下选项设置同步的超时时间 ## 1）slave在与master SYNC期间有大量数据传输，造成超时 # 2）在slave角度，master超时，包括数据、ping等 # 3）在master角度，slave超时，当master发送REPLCONF ACK pings ## 确保这个值大于指定的repl-ping-slave-period，否则在主从间流量不高时每次都会检测到超时 ## repl-timeout 60 # 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY ？ ## 如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到 slave # 上有延迟，Linux内核的默认配置会达到40毫秒 ## 如果你选择了 &quot;no&quot; 数据传输到salve的延迟将会减少但要使用更多的带宽 ## 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，把这个选项设置为“yes” # 是个不错的选择。 repl-disable-tcp-nodelay no # 设置数据备份的backlog大小。backlog是一个slave在一段时间内断开连接时记录salve数据的缓 冲，# 所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，将在断开连接的这段 # 时间内slave丢失的部分数据传送给它。 ## 同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。 ## backlog只分配一次并且至少需要一个slave连接 ## repl-backlog-size 1mb # 当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个 # slave断开开始计时多少秒后，backlog缓冲将会释放。 ## 0表示永不释放backlog ## repl-backlog-ttl 3600 # slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，哨兵将用它来 # 选择一个slave提升=升为master。 ## 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25， # 哨兵将挑选优先级最小数字为10的slave。 ## 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被 # 哨兵挑选提升为master ## 默认优先级为100 slave-priority 100 # 如果master少于N个延时小于等于M秒的已连接slave，就可以停止接收写操作。 ## N个slave需要是“oneline”状态 ## 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送） # 开始计数。 ## This option does not GUARANTEES that N replicas will accept the write, but # will limit the window of exposure for lost writes in case not enough slaves # are available, to the specified number of seconds. ## 例如至少需要3个延时小于等于10秒的slave用下面的指令： ## min-slaves-to-write 3 # min-slaves-max-lag 10 ## 两者之一设置为0将禁用这个功能。 ## 默认 min-slaves-to-write 值是0（该功能禁用）并且 min-slaves-max-lag 值是10。 ################################## SECURITY 安全相关配置 ################################### # 要求客户端在处理任何命令时都要验证身份和密码。 # 这个功能在有你不信任的其它客户端能够访问redis服务器的环境里非常有用。 ## 为了向后兼容的话这段应该注释掉。而且大多数人不需要身份验证(例如:它们运行在自己的服务器上) \\## 警告：因为Redis太快了，所以外面的人可以尝试每秒150k的密码来试图破解密码。这意味着你需要 # 一个高强度的密码，否则破解太容易了。 ## requirepass foobared # 命令重命名 ## 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字， # 这样内部的工具仍然可以使用，而普通的客户端将不行。 ## 例如： ## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 ## 也可以通过改名为空字符串来完全禁用一个命令 ## rename-command CONFIG &quot;&quot; ## 请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。 ################################### LIMITS 范围配置 #################################### # 设置最多同时连接的客户端数量。默认这个限制是10000个客户端，然而如果Redis服务器不能配置 # 处理文件的限制数来满足指定的值，那么最大的客户端连接数就被设置成当前文件限制数减32（因 # 为Redis服务器保留了一些文件描述符作为内部使用） ## 一旦达到这个限制，Redis会关闭所有新连接并发送错误&#x27;max number of clients reached&#x27; ## maxclients 10000 # 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见： # maxmemmory-policy）删除key ## 如果因为删除策略Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更 # 多内存的错误信息给命令。例如，SET,LPUSH等等，但是会继续响应像Get这样的只读命令。 ## 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略） # 的时候，这个选项通常事很有用的。 ## 警告：当有多个slave连上达到内存上限的实例时，master为同步slave的输出缓冲区所需 # 内存不计算在使用内存中。这样当驱逐key时，就不会因网络问题 / 重新同步事件触发驱逐key # 的循环，反过来slaves的输出缓冲区充满了key被驱逐的DEL命令，这将触发删除更多的key， # 直到这个数据库完全被清空为止 ## 总之...如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲 # 的内存作为slave的输出缓存区(但是如果最大内存策略设置为&quot;noeviction&quot;的话就没必要了)## maxmemory &lt;bytes&gt; # 最大内存策略：如果达到内存限制了，Redis如何选择删除key。你可以在下面五个行为里选： ## volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。 # allkeys-lru -&gt; 根据LRU算法删除任何key。 # volatile-random -&gt; 根据过期设置来随机删除key。 # allkeys-&gt;random -&gt; 无差别随机删。 # volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL） # noeviction -&gt; 谁也不删，直接在写操作时返回错误。 ## 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。 ## 目前为止涉及的命令：set setnx setex append # incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby # zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby # getset mset msetnx exec sort ## 默认值如下： ## maxmemory-policy volatile-lru # LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样本量做检测。 # 例如：默认Redis会检查3个key然后取最旧的那个，你可以通过下面的配置指令来设置样本的个数。 ## maxmemory-samples 3 ############################## APPEND ONLY MODE AOF模式配置 ############################### # 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程 # 出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。 ## AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置） # 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis # 能只丢失1秒的写操作。 ## AOF和RDB持久化能同时启动并且不会有问题。 # 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。 ## 请查看 http://redis.io/topics/persistence 来获取更多信息. appendonly no # 纯累加文件名字（默认：&quot;appendonly.aof&quot;） appendfilename &quot;appendonly.aof&quot; # fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。 # 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。 ## Redis支持三种不同的模式： ## no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。# always：每次写操作都立刻写入到aof文件。慢，但是最安全。 # everysec：每秒写一次。折中方案。 ## 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。根据你的理解来 # 决定，如果你能放宽该配置为&quot;no&quot; 来获取更好的性能(但如果你能忍受一些数据丢失，可以考虑使用 # 默认的快照持久化模式)，或者相反，用“always”会比较慢但比everysec要更安全。 ## 请查看下面的文章来获取更多的细节 # http://antirez.com/post/redis-persistence-demystified.html ## 如果不能确定，就用 &quot;everysec&quot; # appendfsync always appendfsync everysec # appendfsync no # 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，并且后台的存储进程（后台存储或写入AOF # 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。 # 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。 ## 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。 ## 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。 # 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定） ## 如果把这个设置成&quot;yes&quot;带来了延迟问题，就保持&quot;no&quot;，这是保存持久数据的最安全的方式。 no-appendfsync-on-rewrite no # 自动重写AOF文件 # 如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。 ## 工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大 小）## 这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写 # 日志的最小尺寸，这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。 ## 指定百分比为0会禁用AOF自动重写特性。 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb ################################ LUA SCRIPTING ############################### # 设置lua脚本的最大运行时间，单位为毫秒，redis会记个log，然后返回error。当一个脚本超过了最 大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已 经调用了write，只能用第二个命令杀。 lua-time-limit 5000 ################################## SLOW LOG ################################### # 是redis用于记录慢查询执行时间的日志系统。由于slowlog只保存在内存中，因此slowlog的效率很 高，完全不用担心会影响到redis的性能。 # 只有query执行时间大于slowlog-log-slower-than的才会定义成慢查询，才会被slowlog进行记 录。# 单位是微妙 slowlog-log-slower-than 10000# slowlog-max-len表示慢查询最大的条数 slowlog-max-len 128 ############################ EVENT NOTIFICATION ############################## # 这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执 行情况，所以在默认配置下，该功能处于关闭状态。 # notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通 知：# K 键空间通知，所有通知以 __keyspace@__ 为前缀 # E 键事件通知，所有通知以 __keyevent@__ 为前缀 # g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知 # $ 字符串命令的通知 # l 列表命令的通知 # s 集合命令的通知 # h 哈希命令的通知 # z 有序集合命令的通知 # x 过期事件：每当有过期键被删除时发送 # e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送 # A 参数 g$lshzxe 的别名 # 输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分 发。详细使用可以参考http://redis.io/topics/notifications notify-keyspace-events &quot;&quot; ############################### ADVANCED CONFIG ############################### # 单位字节:数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist- entries用hash hash-max-ziplist-entries 512 # value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用 hash。 hash-max-ziplist-value 64 # 数据量小于等于list-max-ziplist-entries用ziplist(压缩列表)，大于list-max-ziplist- entries用list。 list-max-ziplist-entries 512 # value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用 list。 list-max-ziplist-value 64 # 数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set。 set-max-intset-entries 512 # 数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用 zset。 zset-max-ziplist-entries 128 # value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用 zset。 zset-max-ziplist-value 64 # 基数统计的算法 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数# 设置HyeperLogLog的字节数限制，这个值通常在0~15000之间，默认为3000，基本不超过16000。 value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max- bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为 3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。 hll-sparse-max-bytes 3000# 重置hash。 Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降 低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒 的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释 放内存。 activerehashing yes # 对于Redis服务器的输出（也就是命令的返回值）来说，其大小通常是不可控制的。有可能一个简单的命 令，能够产生体积庞大的返回数据。另外也有可能因为执行了太多命令，导致产生返回数据的速率超过了往 客户端发送的速率，这是也会导致服务器堆积大量消息，从而导致输出缓冲区越来越大，占用过多内存，甚 至导致系统崩溃。 # 用于强制断开出于某些原因而无法以足够快的速度从服务器读取数据的客户端的连接。 #对于normal client，包括monitor。第一个0表示取消hard limit，第二个0和第三个0表示取消 soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。 client-output-buffer-limit normal 0 0 0 #对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过 64mb持续60秒，那么服务器就会立即断开客户端连接。 client-output-buffer-limit slave 256mb 64mb 60 #对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么 服务器就会立即断开客户端连接。 client-output-buffer-limit pubsub 32mb 8mb 60 # redis执行任务的频率 hz 10# aof rewrite过程中,是否采取增量&quot;文件同步&quot;策略,默认为&quot;yes&quot;,而且必须为yes. # rewrite过程中,每32M数据进行一次文件同步,这样可以减少&quot;aof大文件&quot;写入对磁盘的操作次数. aof-rewrite-incremental-fsync yes 通常情况下，默认的配置足够你解决问题！ 没有极特殊的要求，不要乱改配置！ 3.7 Jedisjava和redis打交道的API客户端 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; 3.7.1 连接redis123456789public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.204.141&quot;,6379); String pong = jedis.ping(); System.out.println(&quot;pong = &quot; + pong); &#125;// 运行前：// 1.关闭防火墙 systemctl stop firewalld.service// 2.修改redis.conf [ bind 0.0.0.0 ] 允许任何ip访问，以这个redis.conf启动redis服务 （重启redis）// redis-server /opt/redis5.0.4/redis.conf 3.7.2 常用API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private void testString()&#123; Jedis jedis = new Jedis(&quot;192.168.204.141&quot;,6379); // string jedis.set(&quot;k1&quot;,&quot;v1&quot;); jedis.set(&quot;k2&quot;,&quot;v2&quot;); jedis.set(&quot;k3&quot;,&quot;v3&quot;); Set&lt;String&gt; set = jedis.keys(&quot;*&quot;); Iterator&lt;String&gt; iterator = set.iterator(); for (set.iterator();iterator.hasNext();)&#123; String k = iterator.next(); System.out.println(k+&quot;-&gt;&quot;+jedis.get(k)); &#125; Boolean k2Exists = jedis.exists(&quot;k2&quot;); // 查看k2是否存在 System.out.println(&quot;k2Exists = &quot; + k2Exists); System.out.println( jedis.ttl(&quot;k1&quot;) ); // 查看k1的过期时间 jedis.mset(&quot;k4&quot;,&quot;v4&quot;,&quot;k5&quot;,&quot;v5&quot;); System.out.println( jedis.mget(&quot;k1&quot;,&quot;k2&quot;,&quot;k3&quot;,&quot;k4&quot;,&quot;k5&quot;) ); System.out.println(&quot;-------------------------------------------------------- &quot;);&#125;private void testList()&#123; Jedis jedis = new Jedis(&quot;192.168.204.141&quot;,6379); // list jedis.lpush(&quot;list01&quot;, &quot;l1&quot;,&quot;l2&quot;,&quot;l3&quot;,&quot;l4&quot;,&quot;l5&quot;); List&lt;String&gt; list01 = jedis.lrange(&quot;list01&quot;, 0, -1); for (String s : list01)&#123; System.out.println(s); &#125; System.out.println(&quot;-------------------------------------------------------- &quot;);&#125;private void testSet()&#123; Jedis jedis = new Jedis(&quot;192.168.204.141&quot;,6379); // set jedis.sadd(&quot;order&quot;,&quot;jd001&quot;); jedis.sadd(&quot;order&quot;,&quot;jd002&quot;); jedis.sadd(&quot;order&quot;,&quot;jd003&quot;); Set&lt;String&gt; order = jedis.smembers(&quot;order&quot;); Iterator&lt;String&gt; order_iterator = order.iterator(); while(order_iterator.hasNext())&#123; String s = order_iterator.next(); System.out.println(s); &#125; jedis.srem(&quot;order&quot;, &quot;jd002&quot;); System.out.println( jedis.smembers(&quot;order&quot;).size() );&#125;private void testHash()&#123; Jedis jedis = new Jedis(&quot;192.168.204.141&quot;,6379); jedis.hset(&quot;user1&quot;, &quot;username&quot;,&quot;james&quot;); System.out.println( jedis.hget(&quot;user1&quot;, &quot;username&quot;) ); HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;username&quot;, &quot;tom&quot;); map.put(&quot;gender&quot;, &quot;boy&quot;); map.put(&quot;address&quot;, &quot;beijing&quot;); map.put(&quot;phone&quot;, &quot;13590875543&quot;); jedis.hmset(&quot;user2&quot;, map); List&lt;String&gt; list = jedis.hmget(&quot;user2&quot;, &quot;username&quot;, &quot;phone&quot;); for (String s: list)&#123; System.out.println(s); &#125;&#125;private void testZset()&#123; Jedis jedis = new Jedis(&quot;192.168.204.141&quot;,6379); jedis.zadd(&quot;zset01&quot;, 60d, &quot;zs1&quot;); jedis.zadd(&quot;zset01&quot;, 70d, &quot;zs2&quot;); jedis.zadd(&quot;zset01&quot;, 80d, &quot;zs3&quot;); jedis.zadd(&quot;zset01&quot;, 90d, &quot;zs4&quot;); Set&lt;String&gt; zset01 = jedis.zrange(&quot;zset01&quot;, 0, -1); Iterator&lt;String&gt; iterator = zset01.iterator(); while (iterator.hasNext())&#123; String s = iterator.next(); System.out.println(s); &#125;&#125;public static void main(String[] args) &#123; new Test2_API().testZset();&#125; 3.7.3 事务 初始化余额和支出 12set yue 100 set zhichu 0 123456789101112131415161718192021222324public static void main(String[] args) throws Exception&#123; Jedis jedis = new Jedis(&quot;192.168.204.141&quot;,6379); int yue = Integer.parseint( jedis.get(&quot;yue&quot;) ); int zhichu = 10; jedis.watch(&quot;yue&quot;); // 监控余额 Thread.sleep(5000); // 模拟网络延迟 if(yue &lt; zhichu)&#123; jedis.unwatch(); //解除监控 System.out.println(&quot;余额不足！&quot;); &#125; else&#123; Transaction transaction = jedis.multi(); // 开启事务 transaction.decrBy(&quot;yue&quot;, zhichu); // 余额减少 transaction.incrBy(&quot;zhichu&quot;, zhichu); // 累计消费增加 transaction.exec(); System.out.println(&quot;余额：&quot; + jedis.get(&quot;yue&quot;)); System.out.println(&quot;累计支出：&quot; + jedis.get(&quot;zhichu&quot;)); &#125;&#125; 模拟网络延迟：，10秒内，进入linux修改余额为5，这样，余额&lt;支出，就会进入if 3.7.4 JedisPool redis的连接池技术 详情：https://help.aliyun.com/document_detail/98726.html 12345&lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt;&lt;/dependency&gt; 使用单例模式进行优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import jdk.nashorn.internal.scripts.JD;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @BelongsProject: lagou-jedis * @Author: GuoAn.Sun * @CreateTime: 2020-08-05 17:46 * @Description: 单例模式优化jedis连接池 */public class JedisPoolUtil &#123; private JedisPoolUtil()&#123; &#125; private volatile static JedisPool jedisPool = null; private volatile static Jedis jedis = null; // 返回一个连接池 private static JedisPool getInstance()&#123; // 双层检测锁（企业中用的非常频繁） if(jedisPool == null)&#123; // 第一层：检测体温 synchronized (JedisPoolUtil.class)&#123; // 排队进站 if(jedisPool == null) &#123; //第二层：查看健康码 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(1000); // 资源池中的最大连接数 config.setMaxIdle(30); // 资源池允许的最大空闲连接数 config.setMaxWaitMillis(60*1000); // 当资源池连接用尽后，调用者 的最大等待时间（单位为毫秒） config.setTestOnBorrow(true); //向资源池借用连接时是否做连接有效 性检测(业务量很大时候建议设置为false，减少一次ping的开销) jedisPool = new JedisPool( config, &quot;192.168.204.141&quot;,6379 ); &#125; &#125; &#125; return jedisPool; &#125; // 返回jedis对象 public static Jedis getJedis()&#123; if(jedis == null)&#123; jedis = getInstance().getResource(); &#125; return jedis; &#125;&#125; 测试类 12345678910111213/** * @BelongsProject: lagou-jedis * @Author: GuoAn.Sun * @CreateTime: 2020-08-05 17:54 * @Description: 测试jedis连接池 */public class Test_JedisPool &#123; public static void main(String[] args) &#123; Jedis jedis1 = JedisPoolUtil.getJedis(); Jedis jedis2 = JedisPoolUtil.getJedis(); System.out.println(jedis1==jedis2); &#125;&#125; 3.8 高并发下的分布式锁 经典案例：秒杀，抢购优惠券等 3.8.1 搭建工程并测试单线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8001&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet- class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;bean id=&quot;stringRedisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt; &lt;property name=&quot;hostName&quot; value=&quot;192.168.204.141&quot;&gt;&lt;/property&gt; &lt;property name=&quot;port&quot; value=&quot;6379&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617181920212223242526package controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller public class TestKill &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @RequestMapping(&quot;kill&quot;) // 只能解决一个tomcat的并发问题：synchronized锁的一个进程下的线程并发，如果分布式环 境，多个进程并发，这种方案就失效了！ public @ResponseBody synchronized String kill() &#123; // 1.从redis中获取 手机的库存数量 int phoneCount = Integer.parseint(stringRedisTemplate.opsForValue().get(&quot;phone&quot;)); // 2.判断手机的数量是否够秒杀的 if(phoneCount &gt; 0)&#123; phoneCount--; // 库存减少后，再将库存的值保存回redis stringRedisTemplate.opsForValue().set(&quot;phone&quot;, phoneCount+&quot;&quot;); System.out.println(&quot;库存-1，剩余：&quot;+ phoneCount); &#125; else&#123; System.out.println(&quot;库存不足！&quot;); &#125; return &quot;over!&quot;; &#125;&#125; 3.8.2 高并发测试 启动两次工程，端口号分别8001和8002 使用nginx做负载均衡 12345678910111213upstream sga&#123; server 192.168.204.1:8001; server 192.168.204.1:8002; &#125;server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://sga; root html; index index.html index.htm; &#125;&#125; 1/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 使用 JMeter 模拟1秒内发出100个http请求，会发现同一个商品会被两台服务器同时抢购！ 3.8.3 实现分布式锁的思路 因为redis****是单线程的，所以命令也就具备原子性，使用setnx命令实现锁，保存k-v 如果k不存在，保存（当前线程加锁），执行完成后，删除k表示释放锁 如果k已存在，阻塞线程执行，表示有锁 如果加锁成功，在执行业务代码的过程中出现异常，导致没有删除k（释放锁失败），那么就会造成死锁（后面的所有线程都无法执行） 设置过期时间，例如10秒后，redis自动删除 高并发下，由于时间段等因素导致服务器压力过大或过小，每个线程执行的时间不同 第一个线程，执行需要13秒，执行到第10秒时，redis自动过期了k（释放锁） 第二个线程，执行需要7秒，加锁，执行第3秒（锁 被释放了，为什么，是被第一个线程的finally主动deleteKey释放掉了） 。。。连锁反应，当前线程刚加的锁，就被其他线程释放掉了，周而复始，导致锁会永久失效 给每个线程加上唯一的标识UUID随机生成，释放的时候判断是否是当前的标识即可 问题又来了，过期时间如果设定？ 如果10秒太短不够用怎么办？ 设置60秒，太长又浪费时间 可以开启一个定时器线程，当过期时间小于总过期时间的1&#x2F;3时，增长总过期时间（吃仙丹续命！） 自己实现分布式锁，太难了！ 3.8.4 Redisson Redis 是最流行的 NoSQL 数据库解决方案之一，而 Java 是世界上最流行（注意，我没有说“最 好”）的编程语言之一。 虽然两者看起来很自然地在一起“工作”，但是要知道，Redis 其实并没有对 Java 提供原生支持 相反，作为 Java 开发人员，我们若想在程序中集成 Redis，必须使用 Redis 的第三方库。 而 Redisson 就是用于在 Java 程序中操作 Redis 的库，它使得我们可以在程序中轻松地使用Redis。 Redisson 在 java.util 中常用接口的基础上，为我们提供了一系列具有分布式特性的工具类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package controller;import org.redisson.Redisson;import org.redisson.api.RLock;import org.redisson.config.Config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.concurrent.TimeUnit;@Controller public class TestKill &#123; @Autowired private Redisson redisson; @Autowired private StringRedisTemplate stringRedisTemplate; @RequestMapping(&quot;kill&quot;) // 只能解决一个tomcat的并发问题：synchronized锁的一个进程下的线程并发，如果分布式环 境，多个进程并发，这种方案就失效了！ public @ResponseBody synchronized String kill() &#123; // 定义商品id String productKey = &quot;HUAWEI-P40&quot;; // 通过redisson获取锁 RLock rLock = redisson.getLock(productKey); // 底层源码就是集成了setnx，过 期时间等操作// 上锁（过期时间为30秒） rLock.lock(30, TimeUnit.SECONDS); try&#123; // 1.从redis中获取 手机的库存数量 int phoneCount = Integer.parseint(stringRedisTemplate.opsForValue().get(&quot;phone&quot;)); // 2.判断手机的数量是否够秒杀的 if (phoneCount &gt; 0) &#123; phoneCount--; // 库存减少后，再将库存的值保存回redis stringRedisTemplate.opsForValue().set(&quot;phone&quot;, phoneCount + &quot;&quot;); System.out.println(&quot;库存-1，剩余：&quot; + phoneCount); &#125; else &#123; System.out.println(&quot;库存不足！&quot;); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; // 释放锁 rLock.unlock(); &#125; return &quot;over!&quot;; &#125; @Bean public Redisson redisson()&#123; Config config = new Config(); // 使用单个redis服务器 config.useSingleServer().setAddress(&quot;redis://192.168.204.141:6379&quot;).setDatabase (0); // 使用集群redis // config.useClusterServers().setScanInterval(2000).addNodeAddress(&quot;redis://192.168 .204.141:6379&quot;,&quot;redis://192.168.204.142:6379&quot;,&quot;redis://192.168.204.143:6379&quot;); return (Redisson)Redisson.create(config); &#125;&#125; 实现分布式锁的方案其实有很多，我们之前用过的zookeeper的特点就是高可靠性，现在我们用的redis特点就是高性能。 目前分布式锁，应用最多的仍然是“Redis”","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"zookeeper详解","slug":"zookeeper详解","date":"2021-06-01T12:39:00.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/06/01/zookeeper详解/","link":"","permalink":"http://yournotes.cn/2021/06/01/zookeeper%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、Zookeeper概述1.1 概述 美团，饿了么，淘宝，58同城等等应用都是zookeeper的现实生活版 老孙我开了个饭店，如何才能让大家都能吃到我们的饭菜？需要入驻美团，这样大家就可以在美团 app中看到我的饭店，下订单，从而完成一次交易 Zookeeper是一个开源的分布式（多台服务器干一件事）的，为分布式应用提供协调服务的Apache项目。 在大数据技术生态圈中，zookeeper（动物管理员），Hadoop（大象），Hive（蜜蜂），Pig（猪）等技术 1.2 工作机制 Zookeeper从设计模式角度来理解：是一个基于观察者模式（一个人干活，有人盯着他）设计的分布式服务管理框架 它负责 存储 和 管理 大家都关心的数据 然后接受观察者的注册，一旦这些数据的发生变化 Zookeeper就将负责通知已经注册的那些观察者做出相应的反应 从而实现集群中类似Master&#x2F;Slave管理模式 Zookeeper &#x3D; 文件系统 + 通知机制 商家营业并入驻 获取到当前营业的饭店列表 服务器节点下线 服务器节点上下线事件通知 重新再去获取服务器列表，并注册监听 1.3 特点分布式和集群的区别？ 无论分布式和集群，都是很多人在做事情。具体区别如下： 例如：我有一个饭店，越来越火爆，我得多招聘一些工作人员 分布式：招聘1个厨师，1个服务员，1个前台，三个人负责的工作不一样，但是最终目的都是为饭店工作 集群：招聘3个服务员，3个人的工作一样 1.4 数据结构 ZooKeeper数据模型的结构与linux文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode（ZookeeperNode）。 每一个ZNode默认能够存储1MB的数据（元数据），每个ZNode的路径都是唯一的 元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能 1.5 应用场景 提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等 1.5.1 统一命名服务 在分布式环境下，通常需要对应用或服务进行统一的命名，便于识别 例如：服务器的IP地址不容易记，但域名相比之下却是很容易记住 1.5.2 统一配置管理 分布式环境下，配置文件做同步是必经之路 1000台服务器，如果配置文件作出修改，那一台一台的修改，运维人员肯定会疯，如何做到修改一处就快速同步到每台服务器上 将配置管理交给Zookeeper 将配置信息写入到Zookeeper的某个节点上 每个客户端都监听这个节点 一旦节点中的数据文件被修改，Zookeeper这个话匣子就会通知每台客户端服务器 1.5.3 服务器节点动态上下线 客户端能实时获取服务器上下线的变化 在美团APP上实时可以看到商家是否正在营业或打样 1.5.4 软负载均衡 Zookeeper会记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户请求（雨露均沾） 都是自己的孩子，得一碗水端平 1.6 下载地址镜像库地址：http://archive.apache.org/dist/zookeeper/ apache-zookeeper-3.6.0.tar.gz需要安装maven，然后再运行mvn clean install 和mvnjavadoc:aggregate，前一个命令会下载安装好多jar包，不知道要花多长时间 apache-zookeeper-3.6.0-bin.tar.gz已经自带所需要的各种jar包 二、Zookeeper本地模式安装2.1 本地模式安装2.1.1 安装前准备 安装jdk 拷贝apache-zookeeper-3.6.0-bin.tar.gz到opt目录 解压安装包 1[root@localhost opt]# tar -zxvf apache-zookeeper-3.6.0-bin.tar.gz 重命名 1[root@localhost opt]# mv apache-zookeeper-3.6.0-bin zookeeper 2.1.2 配置修改1、在&#x2F;opt&#x2F;zookeeper&#x2F;这个目录上创建zkData和zkLog目录 12[root@localhost zookeeper]# mkdir zkData [root@localhost zookeeper]# mkdir zkLog 2、进入&#x2F;opt&#x2F;zookeeper&#x2F;conf这个路径，复制一份 zoo_sample.cfg 文件并命名为 zoo.cfg 1[root@localhost conf]# cp zoo_sample.cfg zoo.cfg 3、编辑zoo.cfg文件，修改dataDir路径： 12dataDir=/opt/zookeeper/zkDatadataLogDir=/opt/zookeeper/zkLog 2.1.3 操作Zookeeper1、启动Zookeeper 1[root@localhost bin]# ./zkServer.sh start 2、查看进程是否启动 1[root@localhost bin]# jps QuorumPeerMain：是zookeeper集群的启动入口类，是用来加载配置启动QuorumPeer线程的 3、查看状态： 1[root@localhost bin]# ./zkServer.sh status 4、启动客户端 1[root@localhost bin]# ./zkCli.sh 5、退出客户端 1[zk: localhost:2181(CONNECTED) 0] quit 2.2 配置参数解读Zookeeper中的配置文件zoo.cfg中参数含义解读如下： tickTime &#x3D;2000：通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒 Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。 initLimit &#x3D;10：LF初始通信时限 集群中的Follower跟随者服务器与Leader领导者服务器之间，启动时能容忍的最多心跳数 10*2000（10个心跳时间）如果领导和跟随者没有发出心跳通信，就视为失效的连接，领导和跟随者彻底断开 syncLimit &#x3D;5：LF同步通信时限 集群启动后，Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime-&gt;10秒，Leader就认为Follwer已经死掉，会将Follwer从服务器列表中删除 dataDir：数据文件目录+数据持久化路径 主要用于保存Zookeeper中的数据。 dataLogDir：日志文件目录 clientPort &#x3D;2181：客户端连接端口 监听客户端连接的端口 三、Zookeeper内部原理3.1 选举机制（面试重点） 半数机制：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器 虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的 Server1先投票，投给自己，自己为1票，没有超过半数，根本无法成为leader，顺水推舟将票数投给了id比自己大的Server2 Server2也把自己的票数投给了自己，再加上Server1给的票数，总票数为2票，没有超过半数，也无法成为leader，也学习Server1，顺水推舟，将自己所有的票数给了id比自己大的Server3 Server3得到了Server1和Server2的两票，再加上自己投给自己的一票。3票超过半数，顺利成为leader Server4和Server5都投给自己，但是无法改变Server3的票数，只好听天由命，承认Server3是leader 3.2 节点类型 持久型（persistent）： 持久化目录节点（persistent）客户端与zookeeper断开连接后，该节点依旧存在 持久化顺序编号目录节点（persistent_sequential）客户端与zookeeper断开连接后，该节点依旧存在，创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护，例如：Znode001，Znode002… 短暂型（ephemeral）： 临时目录节点（ephemeral）客户端和服务器端断开连接后，创建的节点自动删除 临时顺序编号目录节点（ephemeral_sequential）客户端与zookeeper断开连接后，该节点被删除，创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护，例如：Znode001，Znode002… 注意：序号是相当于i++，和数据库中的自增长类似 3.3 监听器原理（面试重点） 在main方法中创建Zookeeper客户端的同时就会创建两个线程，一个负责网络连接通信，一个负责监听 监听事件就会通过网络通信发送给zookeeper zookeeper获得注册的监听事件后，立刻将监听事件添加到监听列表里 zookeeper监听到 数据变化 或 路径变化，就会将这个消息发送给监听线程 监听节点数据的变化：get path [watch] 监听子节点增减的变化：ls path [watch] 监听线程就会在内部调用process方法（需要我们实现process方法内容） 3.4 写数据流程 Client 想向 ZooKeeper 的 Server1 上写数据，必须的先发送一个写的请求 如果Server1不是Leader，那么Server1 会把接收到的请求进一步转发给Leader。 这个Leader 会将写请求广播给各个Server，各个Server写成功后就会通知Leader。 当Leader收到半数以上的 Server 数据写成功了，那么就说明数据写成功了。 随后，Leader会告诉Server1数据写成功了。 Server1会反馈通知 Client 数据写成功了，整个流程结束 四、Zookeeper实战（开发重点）这里是用虚拟机做的演示 4.1 分布式安装部署集群思路：先搞定一台服务器，再克隆出两台，形成集群！ 4.1.1 安装zookeeper请参考本文 2.1 4.1.2 配置服务器编号 在&#x2F;opt&#x2F;zookeeper&#x2F;zkData创建myid文件 1[root@localhost zkData]# vim myid 在文件中添加与server对应的编号：1 其余两台服务器分别对应2和3 4.1.3 配置zoo.cfg文件 打开zoo.cfg文件，增加如下配置 1234#######################cluster########################## server.1=192.168.204.141:2888:3888 server.2=192.168.204.142:2888:3888 server.3=192.168.204.143:2888:3888 配置参数解读 server.A&#x3D;B:C:D A：一个数字，表示第几号服务器 集群模式下配置的&#x2F;opt&#x2F;zookeeper&#x2F;zkData&#x2F;myid文件里面的数据就是A的值 B：服务器的ip地址 C：与集群中Leader服务器交换信息的端口 D：选举时专用端口，万一集群中的Leader服务器挂了，需要一个端口来重新进行选举选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。 4.1.4 配置其余两台服务器 在虚拟机数据目录vms下，创建zk02 将本台服务器数据目录下的.vmx文件和所有的.vmdk文件分别拷贝zk02下 虚拟机-&gt;文件-&gt;打开 （选择zk02下的.vmx文件） 开启此虚拟机，弹出对话框，选择“我已复制该虚拟机” 进入系统后，修改linux中的ip，修改&#x2F;opt&#x2F;zookeeper&#x2F;zkData&#x2F;myid中的数值为2 第三台服务器zk03,重复上面的步骤 4.1.5 集群操作 每台服务器的防火墙必须关闭 1[root@localhost bin]# systemctl stop firewalld.service 启动第1台 1[root@localhost bin]# ./zkServer.sh start 查看状态 1[root@localhost bin]# ./zkServer.sh status 1234ZooKeeper JMX enabled by default Using config: /opt/zookeeper/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Error contacting service. It is probably not running. 注意：因为没有超过半数以上的服务器，所以集群失败 （防火墙没有关闭也会导致失败） 当启动第2台服务器时 查看第1台的状态：Mode: follower 查看第2台的状态：Mode: leader 4.2 客户端命令行操作 启动客户端 1[root@localhost bin]# ./zkCli.sh 显示所有操作命令 1help 查看当前znode中所包含的内容 1ls / 查看当前节点详细信息 zookeeper老版本使用 ls2 &#x2F; ，现在已经被新命令替代 1ls -s / 信息字段 意思 cZxid 创建节点的事务:每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。 ctime 被创建的毫秒数(从1970年开始) mZxid 最后更新的事务zxid mtime 最后修改的毫秒数(从1970年开始) pZxid 最后更新的子节点zxid cversion 创建版本号，子节点修改次数 dataVersion 数据变化版本号 aclVersion 权限版本号 ephemeralOwner 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。 dataLength 数据长度 numChildren 子节点数 分别创建2个普通节点 在根目录下，创建中国和美国两个节点 12create /china create /usa 在根目录下，创建俄罗斯节点，并保存“普京”数据到节点上 1create /ru &quot;pujing&quot; 多级创建节点 在中国节点下，创建武汉”下雨” china必须提前创建好，否则会报错“节点不存在” 1create /china/wuhan &quot;下雨&quot; 获得节点的值 1get /china/wuhan 创建短暂节点：创建成功之后，quit退出客户端，重新连接，短暂的节点消失 1234create -e /uk ls / quit ls / 创建带序号的节点 创建带序号的节点 123create -s /ru/city # 执行三次ls /ru[city0000000000, city0000000001, city0000000002] 如果原来没有序号节点，序号从0开始递增。 如果原节点下已有2个节点，则再排序时从2开始，以此类推 修改节点数据值 1set /china/wuhan &quot;太阳&quot; 监听 节点的值变化 或 子节点变化（路径变化） 在server3主机上注册监听&#x2F;usa节点的数据变化 1addWatch /usa 在Server1主机上修改&#x2F;usa的数据 1set /usa &quot;telangpu&quot; Server3会立刻响应 WatchedEvent state:SyncConnected type:NodeDataChanged path:&#x2F;usa 如果在Server1的&#x2F;usa下面创建子节点NewYork 1create /usa/NewYork Server3会立刻响应 WatchedEvent state:SyncConnected type:NodeCreatedpath:&#x2F;usa&#x2F;NewYork 删除节点 1delete /usa/NewYork 递归删除节点 （非空节点，节点下有子节点） 1deleteall /ru 不仅删除&#x2F;ru，而且&#x2F;ru下的所有子节点也随之删除 4.3 API应用4.3.1 IDEA环境搭建1) 创建一个Maven工程 2) 添加pom文件 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3) 在resources下创建log4j.properties 12345678log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.FileAppender log4j.appender.logfile.File=target/zk.log log4j.appender.logfile.layout=org.apache.log4j.PatternLayout log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n 4.3.2 创建ZooKeeper客户端12345678910111213141516171819public class TestZK &#123; // 集群ip private String connStr =&quot;192.168.249.81:2181,192.168.249.82:2181,192.168.249.83:2181&quot;; /* * session超时 60秒：一定不能太少，因为连接zookeeper和加载集群环境会因为性能原因延迟略高 * 如果时间太少，还没有创建好客户端，就开始操作节点，会报错的 */ private int sessionTimeout = 60000; @Test public void init() throws IOException &#123; // 创建监听器 Watcher watcher = new Watcher() &#123; public void process(WatchedEvent watchedEvent) &#123; &#125; &#125;; // 创建zookeeper客户端 ZooKeeper zk = new ZooKeeper(connStr, sessionTimeout, watcher); &#125;&#125; 4.3.3 创建节点一个ACL对象就是一个Id和permission对 表示哪个&#x2F;哪些范围的Id（Who）在通过了怎样的鉴权（How）之后，就允许进行那些操作（What）：Who How What； permission（What）就是一个int表示的位码，每一位代表一个对应操作的允许状态。 类似linux的文件权限，不同的是共有5种操作：CREATE、READ、WRITE、DELETE、ADMIN(对应更改ACL的权限) OPEN_ACL_UNSAFE：创建开放节点，允许任意操作 （用的最少，其余的权限用的很少） READ_ACL_UNSAFE：创建只读节点 CREATOR_ALL_ACL：创建者才有全部权限 1234567891011121314@Before public void init() throws IOException&#123; // 省略...&#125;@Test public void createNode() throws Exception &#123; String nodeCreated = zKcli.create(&quot;/lagou&quot;, &quot;laosun&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // 参数1：要创建的节点的路径 // 参数2：节点数据 // 参数3：节点权限 // 参数4：节点的类型 System.out.println(&quot;nodeCreated = &quot; + nodeCreated);&#125; 4.3.4 查询节点的值1234567@Test public void find() throws Exception&#123; byte[] bs = zKcli.getData(&quot;/lagou&quot;, false, new Stat()); // 路径不存在时会报错 String data = new String(bs); System.out.println(&quot;查询到数据：&quot;+data);&#125; 4.3.5 修改节点的值123456@Test public void update()throws Exception&#123; Stat stat = zKcli.setData(&quot;/lagou&quot;, &quot;laosunA&quot;.getBytes(), 0); //先查看节点详 情，获得dataVersion = 0 System.out.println(stat);&#125; 4.3.6 删除节点123456@Test public void delete() throws Exception &#123; zKcli.delete(&quot;/lagou&quot;, 1); // 先查看节点详情，获得dataVersion = 1 System.out.println(&quot;删除成功！&quot;);&#125; 4.3.7 获取子节点12345678@Test public void getChildren() throws Exception &#123; List&lt;String&gt; children = zKcli.getChildren(&quot;/&quot;,false); // false:不监听 for (String child : children) &#123; System.out.println(child); &#125;&#125; 4.3.8 监听子节点的变化12345678910@Test public void getChildren() throws Exception &#123; List&lt;String&gt; children = zKcli.getChildren(&quot;/&quot;, true); // true：注册监听 for (String child : children) &#123; System.out.println(child); &#125; // 让线程不停止，等待监听的响应 System.in.read();&#125; 程序在运行的过程中，我们在linux下创建一个节点 IDEA的控制台就会做出响应：NodeChildrenChanged–&#x2F; 4.3.9 判断Znode是否存在12345@Test public void exist() throws Exception &#123; Stat stat = zKcli.exists(&quot;/lagou&quot;, false); System.out.println(stat == null ? &quot;不存在&quot; : &quot;存在&quot;);&#125; 4.4 案例1：模拟美团商家上下线4.4.1 需求 模拟美团服务平台，商家营业通知，商家打烊通知 提前在根节点下，创建好 &#x2F;meituan 节点 4.4.2 商家服务类123456789101112131415161718192021222324252627282930313233public class ShopServer &#123; private static String connectString = &quot;192.168.204.141:2181,192.168.204.142:2181,192.168.204.143:2181&quot;; private static int sessionTimeout = 60000; private ZooKeeper zk = null; // 创建到zk的客户端连接 public void getConnect() throws IOException &#123; zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; public void process(WatchedEvent event) &#123; &#125; &#125; ); &#125; // 注册到集群 public void register(String ShopName) throws Exception &#123; // 一定是&quot;EPHEMERAL_SEQUENTIAL短暂有序型&quot;的节点，才能给shop编号，shop1， shop2...” String create = zk.create(&quot;/meituan/Shop&quot;, ShopName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(&quot;【&quot;+ShopName+&quot;】 开始营业！ &quot; + create); &#125; // 业务功能 public void business(String ShopName) throws Exception &#123; System.out.println(&quot;【&quot;+ShopName+&quot;】 正在营业中 ...&quot;); System.in.read(); &#125; public static void main(String[] args) throws Exception &#123; ShopServer shop = new ShopServer(); // 1.连接zookeeper集群（和美团取得联系） shop.getConnect(); // 2.将服务器节点注册（入住美团） shop.register(args[0]); // 3.业务逻辑处理（做生意） shop.business(args[0]); &#125;&#125; 4.4.3 客户类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Customers &#123; private static String connectString = &quot;192.168.204.141:2181,192.168.204.142:2181,192.168.204.143:2181&quot;; private static int sessionTimeout = 60000; private ZooKeeper zk = null; // 创建到zk的客户端连接 public void getConnect() throws IOException &#123; zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; public void process(WatchedEvent event) &#123; // 再次获取所有商家 try &#123; getShopList(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; ); &#125; // 获取服务器列表信息 public void getShopList() throws Exception &#123; // 1获取服务器子节点信息，并且对父节点进行监听 List&lt;String&gt; shops = zk.getChildren(&quot;/meituan&quot;, true); // 2存储服务器信息列表 ArrayList&lt;String&gt; shoplist = new ArrayList(); // 3遍历所有节点，获取节点中的主机名称信息 for (String shop : shops) &#123; byte[] data = zk.getData(&quot;/meituan/&quot; + shop, false, new Stat()); shoplist.add(new String(data)); &#125; // 4打印服务器列表信息 System.out.println(shoplist); &#125; // 业务功能 public void business() throws Exception &#123; System.out.println(&quot;客户正在浏览商家 ...&quot;); System.in.read(); &#125; public static void main(String[] args) throws Exception &#123; // 1.获取zk连接 （客户打开美团） Customers client = new Customers(); client.getConnect(); // 2.获取/meituan的子节点信息，从中获取服务器信息列表（从美团中获取商家列表） client.getShopList(); // 3.业务进程启动 （对比商家，点餐） client.business(); &#125;&#125; 1）运行客户类，就会得到商家列表 2）首先在linux中添加一个商家，然后观察客户端的控制台输出（商家列表会立刻更新出最新商家），多添加几个，也会实时输出商家列表 123create /meituan/KFC &quot;KFC&quot; create /meituan/BKC &quot;BurgerKing&quot; create /meituan/baozi &quot;baozi&quot; 3）在linux中删除商家，在客户端的控制台也会实时看到商家移除后的最新商家列表 1delete /meituan/baozi 4）运行商家服务类（以main方法带参数的形式运行） 4.5 案例2：分布式锁-商品秒杀 锁：我们在多线程中接触过，作用就是让当前的资源不会被其他线程访问！ 我的日记本，不可以被别人看到。所以要锁在保险柜中 当我打开锁，将日记本拿走了，别人才能使用这个保险柜 在zookeeper中使用传统的锁引发的 “羊群效应” ：1000个人创建节点，只有一个人能成功，999人需要等待！ 羊群是一种很散乱的组织，平时在一起也是盲目地左冲右撞，但一旦有一只头羊动起来，其他的羊也会不假思索地一哄而上，全然不顾旁边可能有的狼和不远处更好的草。羊群效应就是比喻人都有一种从众心理，从众心理很容易导致盲从，而盲从往往会陷入骗局或遭到失败。 避免“羊群效应”，zookeeper采用分布式锁 所有请求进来，在&#x2F;lock下创建 临时顺序节点 ，放心，zookeeper会帮你编号排序 判断自己是不是&#x2F;lock下最小的节点 是，获得锁（创建节点） 否，对前面小我一级的节点进行监听 获得锁请求，处理完业务逻辑，释放锁（删除节点），后一个节点得到通知（比你年轻的死了，你成为最嫩的了） 重复步骤2 实现步骤 1）初始化数据库创建数据库zkproduct，使用默认的字符集utf8 12345678-- 商品表 create table product( id int primary key auto_increment, -- 商品编号 product_name varchar(20) not null, -- 商品名称 stock int not null, -- 库存 version int not null -- 版本 )insert into product (product_name,stock,version) values(&#x27;锦鲤-清空购物车-大奖&#x27;,5,0) 123456-- 订单表 create table `order`( id varchar(100) primary key, -- 订单编号 pid int not null, -- 商品编号 userid int not null -- 用户编号 ) 2）搭建工程搭建ssm框架，对库存表-1，对订单表+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;packaging&gt;war&lt;/packaging&gt;&lt;properties&gt; &lt;spring.version&gt;5.2.7.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- maven内嵌的tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;!-- 目前apache只提供了tomcat6和tomcat7两个插件 --&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8001&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 打包完成后,运行服务 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 后台的日志输出：针对开发者--&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 1.扫描包下的注解 --&gt; &lt;context:component-scan base-package=&quot;controller,service,mapper&quot;/&gt; &lt;!-- 2.创建数据连接池对象 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.204.131:3306/zkproduct? serverTimezone=GMT&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123123&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- 3.创建SqlSessionFactory，并引入数据源对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/mybatis- config.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.告诉spring容器，数据库语句代码在哪个文件中--&gt; &lt;!-- mapper.xDao接口对应resources/mapper/xDao.xml--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;mapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 5.将数据源关联到事务 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 6.开启事务 --&gt; &lt;tx:annotation-driven/&gt;&lt;/beans&gt; 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet- class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 1234567@Mapper @Component public interface OrderMapper &#123; // 生成订单 @Insert(&quot;insert into `order` (id,pid,userid) values (#&#123;id&#125;,#&#123;pid&#125;,# &#123;userid&#125;)&quot;) int insert(Order order); &#125; 12345678910@Mapper @Component public interface ProductMapper &#123; // 查询商品（目的查库存） @Select(&quot;select * from product where id = #&#123;id&#125;&quot;) Product getProduct(@Param(&quot;id&quot;) int id); // 减库存 @Update(&quot;update product set stock = stock-1 where id = #&#123;id&#125;&quot;) int reduceStock(@Param(&quot;id&quot;) int id); &#125; 1234567891011121314151617181920212223@Service public class OrderServiceImpl implements OrderService &#123; @Autowired ProductMapper productMapper; @Autowired OrderMapper orderMapper; @Override public void reduceStock(int id) throws Exception &#123; // 1.获取库存 Product product = productMapper.getProduct(id); // 模拟网络延迟 Thread.sleep(1000); if(product.getStock() &lt;= 0) throw new RuntimeException(&quot;已抢光！&quot;); // 2.减库存 int i = productMapper.reduceStock(id); if(i == 1)&#123; Order order = new Order(); order.setId(UUID.randomUUID().toString()); order.setPid(id); order.setUserid(101); orderMapper.insert(order); &#125; elsethrow new RuntimeException(&quot;减库存失败，请重试！&quot;); &#125;&#125; 12345678910@Controller public class ProductAction &#123; @Autowired private OrderService orderService; @GetMapping(&quot;/product/reduce&quot;) @ResponseBody public Object reduceStock(int id) throws Exception&#123; orderService.reduceStock(id); return &quot;ok&quot;; &#125; &#125; 3）启动测试 启动两次工程，端口号分别8001和8002 使用nginx做负载均衡 12345678910111213upstream sga&#123; server 192.168.204.1:8001; server 192.168.204.1:8002; &#125;server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://sga; root html; index index.html index.htm; &#125;&#125; 使用 JMeter 模拟1秒内发出10个http请求 下载地址：http://jmeter.apache.org/download_jmeter.cgi 查看测试结果，10次请求全部成功 查看数据库，stock库存变成 -5 （并发导致的数据结果错误） 4）apahce提供的zookeeper客户端基于zookeeper原生态的客户端类实现分布式是非常麻烦的，我们使用apahce提供了一个zookeeper客户端来实现 Curator：http://curator.apache.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt; &lt;!-- 网友投票最牛逼版本 --&gt; &lt;/dependency&gt; recipes是curator族谱大全，里面包含zookeeper和framework 5）在控制层中加入分布式锁的逻辑代码1234567891011121314151617181920212223242526272829303132@Controller public class ProductAction &#123; @Autowired private ProductService productService; private static String connectString = &quot;192.168.204.141:2181,192.168.204.142:2181,192.168.204.143:2181&quot;; @GetMapping(&quot;/product/reduce&quot;) @ResponseBody public Object reduce( int id) throws Exception &#123; // 重试策略 （1000毫秒试1次，最多试3次） RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3); //1.创建curator工具对象 CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retryPolicy); client.start(); //2.根据工具对象创建“内部互斥锁” InterProcessMutex lock = new InterProcessMutex(client, &quot;/product_&quot;+id); try &#123; //3.加锁 lock.acquire(); productService.reduceStock(id); &#125; catch(Exception e)&#123; if(e instanceof RuntimeException)&#123; throw e; &#125; &#125; finally&#123; //4.释放锁 lock.release(); &#125; return &quot;ok&quot;; &#125;&#125; 6）再次测试，并发问题解决！","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Dubbo详解","slug":"Dubbo详解","date":"2021-05-23T07:58:17.000Z","updated":"2025-04-17T08:34:51.958Z","comments":true,"path":"2021/05/23/Dubbo详解/","link":"","permalink":"http://yournotes.cn/2021/05/23/Dubbo%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、Dubbo概述1.1 什么是分布式系统？ 《分布式系统原理与范型》定义： “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统” 分布式系统（distributed system）是建立在网络之上的软件系统。 简单来说：多个（不同职责）人共同来完成一件事！ 任何一台服务器都无法满足淘宝的双十一的数据吞吐量，一定是很多台服务器公共来完成的。 歇后语：“三个臭皮匠赛过诸葛亮”，就是分布式系统的真实写照 1.1.1 单一应用架构 当网站流量很小时，只需要一个应用，将所有的功能部署到一起（所有业务都放在一个tomcat里），从而减少部署节点和成本； 此时，用于简化 增删改查 工作量的数据访问框架 （ORM）是关键； 例如：某个超市的收银系统，某个公司的员工管理系统 ORM：对象关系映射（Object Relational Mapping） 优点 小项目开发快 成本低 架构简单 易于测试 易于部署 缺点 大项目模块耦合严重 不易开发 维护 沟通成本高 新增业务困难 核心业务与边缘业务混合在一块，出现问题互相影响 1.1.2 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成几个互不相干的几个应用,以提高效率； 大模块按照mvc分层模式，进行拆分成多个互不相关的小模块，并且每个小模块都有独立的服务器 此时，用于加速前端页面开发的web框架（MVC）是关键；因为每个小应用都有独立的页面 MVC：模型视图控制器 （Model View Controller） 缺点： 模块之间不可能完全没有交集，公用模块无法重复利用，开发性的浪费 1.1.3 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的业务，逐渐形成稳健的服务中心，使前端应用能更快速的响应多变的市场需求； 此时，用户提高业务复用及整合的分布式服务框架（RPC）远程调用是关键； RPC：独立的应用服务器之间，要依靠RPC（Romote Procedure Call）才能调用 物流服务不忙，有100台服务器； 商品服务特别忙，也是100台服务器； 如何做到资源优化调配？↓ 1.1.4 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐呈现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率； 此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键； SOA：面向服务架构（Service-Oriented Architecture），简单理解就是“服务治理”，例如：公交车站的“调度员” 1.2 Dubbo简介 Dubbo是分布式服务框架，是阿里巴巴的开源项目，现交给apache进行维护 Dubbo致力于提高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案 简单来说，dubbo是个服务框架，如果没有分布式的需求，是不需要用的 1.2.1 RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式 RPC基本的通信原理 在客户端将对象进行序列化 底层通信框架使用netty（基于tcp协议的socket），将序列化的对象发给服务方提供方 服务提供方通过socket得到数据文件之后，进行反序列化，获得要操作的对象 对象数据操作完毕，将新的对象序列化，再通过服务提供方的socket返回给客户端 客户端获得序列化数据，再反序列化，得到最新的数据对象，至此，完成一次请求 RPC两个核心模块：通讯（socket），序列化。 1.2.2 节点角色 节点 角色说明 Provider 服务的提供方（洗浴中心） Consumer 服务的消费方（客人） Registry 服务注册与发现的注册中心（便民服务中心，所有的饭店娱乐场所都在已在本中心注册） Monitor 监控服务的统计中心（统计服务被调用的次数） Container 服务运行容器（烧烤一条街，洗浴一条街） 1.2.3 调用关系 服务容器负责启动，加载，运行服务提供者； 服务提供者在启动时，向注册中心注册自己提供的服务； 服务消费者在启动时，向注册中心订阅自己所需的服务； 在注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者； 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用； 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心； 二、快速入门http://dubbo.apache.org/ 2.1 注册中心2.1.1 Zookeeper 官方推荐使用zookeeper注册中心； 注册中心负责服务地址的注册与查找，相当于目录服务； 服务提供者和消费者只在启动时与注册中心交互，注册中不转发请求，压力较小； Zookeeper是apache hadoop的子项目，是一个树形的目录服务，支持变更推送，适合作为dubbo的服务注册中心，工业强度较高，可用于生产环境； dubbo即是求职的人，也是招聘单位，而zookeeper就是人才市场招聘网站； 2.1.2 安装点下试试 2.2 服务提供方 一个空的maven项目 提供一个服务接口即可 2.2.1 服务方的pom.xml各种依赖请严格按照下面的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;packaging&gt;war&lt;/packaging&gt;&lt;properties&gt; &lt;spring.version&gt;5.0.6.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.11.0.GA&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven &lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8001&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 打包完成后,运行服务 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.2.2 服务方接口123public interface HelloService &#123; String sayHello(String name); &#125; 2.2.3 服务方实现1234567@com.alibaba.dubbo.config.annotation.Service public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;Hello,&quot; + name + &quot;!!!&quot;; &#125; &#125; 2.2.4 服务方的配置文件spring.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--1.服务提供方在zookeeper中的“别名”--&gt; &lt;dubbo:application name=&quot;dubbo-server&quot;/&gt; &lt;!--2.注册中心的地址--&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.204.141:2181&quot;/&gt; &lt;!--3.扫描类（将什么包下的类作为服务提供类）--&gt; &lt;dubbo:annotation package=&quot;service.impl&quot;/&gt;&lt;/beans&gt; 2.2.5 服务方的web.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;listener&gt; &lt;listener- class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 2.3 服务消费方2.3.1 消费方的pom.xml与服务方一致，只需要修改tomcat的端口为8002 2.3.2 消费方的Controller12345678910@RestController public class HelloAction &#123; @com.alibaba.dubbo.config.annotation.Reference private HelloService hs; @RequestMapping(&quot;hello&quot;) @ResponseBody public String hello( String name)&#123; return hs.sayHello(name); &#125;&#125; 2.3.3 消费方的接口注意：controller中要依赖HelloService，所以我们创建一个接口；这里是消费方，不需要实现，因为实现会让服务方搞定！ 123public interface HelloService &#123; String sayHello(String name); &#125; 2.3.4 消费方的web.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet- class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2.3.5 消费方的springmvc.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--Dubbo的应用名称，通常使用项目名 --&gt; &lt;dubbo:application name=&quot;dubbo-consumer&quot; /&gt; &lt;!--配置Dubbo的注册中心地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.204.141:2181&quot; /&gt; &lt;!--配置Dubbo扫描类，将这个类作为服务进行发布 --&gt; &lt;dubbo:annotation package=&quot;controller&quot; /&gt;&lt;/beans&gt; 2.4 启动服务测试首先启动服务方，再启动消费方。 访问：http://localhost:8002/hello?name=james 三、监控中心我们在开发时，需要知道注册中心都注册了哪些服务，以便我们开发和测试。图形化显示注册中心的中 服务列表我们可以通过部署一个web应用版的管理中心来实现。 3.1 服务管理端3.1.1 安装管理端 解压 dubbo-admin-master.zip 修改配置文件 返回到项目根目录，使用maven打包：mvn clean package 在dos下运行target目录中的jar文件：java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 此时打开浏览器输入：http://localhost:7001/ ； 第一次访问时，需要登录，帐号密码都是root 3.1.2 管理端使用 启动服务方，将服务注册到zookeeper 启动dubbo-server服务方后，刷新管理端，服务注册成功，只是没有消费者 点击服务名，进入服务提供者页面 把消费者也运行起来，刷新服务，显示正常 查看消费者 3.2 监控统计中心Monitor：统计中心 ，记录服务被调用多少次等 解压dubbo-monitor-simple-2.5.3.zip 修改dubbo-monitor-simple-2.5.3\\conf\\dubbo.properties 双击运行dubbo-monitor-simple-2.5.3\\bin\\start.bat 分别修改dubbo-server和dubbo-consumer的spring.xml，加入下面标签 12&lt;!-- 让监控 去注册中心 自动找服务 --&gt; &lt;dubbo:monitor protocol=&quot;registry&quot;/&gt; 四、综合实战4.1 配置说明4.1.1 启动时检查 启动时会在注册中心检查依赖的服务是否可用，不可用时会抛出异常 在消费方编写初始化容器的main方法启动（tomcat启动方式，必须访问一次action才能初始化spring） 123456public class Test &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring/spring.xml&quot;); System.in.read(); &#125;&#125; 12&lt;!--默认是true:抛异常；false:不抛异常--&gt; &lt;dubbo:consumer check=&quot;false&quot; /&gt; 系统级别日志，需要配合log4j才输出，在resources下添加log4j.properties，内容如下： 1234567891011log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%nlog4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=dubbo.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n log4j.rootLogger=error, stdout,file 4.1.2 超时时间 由于网络或服务端不可靠，会导致调用过程中出现不确定的阻塞状态（超时） 为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间 在服务提供者添加如下配置： 12&lt;!--设置超时时间为2秒，默认为1秒--&gt; &lt;dubbo:provider timeout=&quot;2000&quot;/&gt; 可以将服务实现HelloServiceImpl.java中加入模拟的网络延迟进行测试： 123456789101112@Service public class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return &quot;Hello,&quot;+name+&quot;!!!!!&quot;; &#125;&#125; 超时设置2秒，而模拟的网络延迟有3秒，超出时限，报错！ 配置原则： dubbo推荐在Provider上尽量多配置Consumer端属性： 作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等 在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作消费者的缺省值。 4.1.3 重试次数 当出现失败，自动切换并重试其它服务器，dubbo重试的缺省值是2次，我们可以自行设置 在provider提供方配置： 12&lt;!-- 消费方连接第1次不算，再来重试3次，总共重试4次 --&gt; &lt;dubbo:provider timeout=&quot;2000&quot; retries=&quot;3&quot;/&gt; 12345678910111213@Service public class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; System.out.println(&quot;=============被调用 1 次===============&quot;); try &#123; Thread.sleep(3000); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return &quot;Hello,&quot;+name+&quot;!!!!!&quot;; &#125;&#125; 并不是所有的方法都适合设置重试次数 幂等方法：适合（当参数一样，无论执行多少次，结果是一样的，例如：查询，修改） 非幂等方法：不适合（当参数一样，执行结果不一样，例如：删除，添加） 单独设置某个方法 提供方接口添加sayNo()方法并实现 1234public interface HelloService &#123; String sayHello( String name ); String sayNo(); &#125; 1234567891011121314151617@Service public class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; System.out.println(&quot;=============hello被调用一次 ===============&quot;); try &#123; Thread.sleep(3000); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return &quot;Hello,&quot;+name+&quot;!!!!!&quot;; &#125; public String sayNo() &#123; System.out.println(&quot;-------no被调用一次-------&quot;); return &quot;no!&quot;; &#125;&#125; 消费方接口添加sayNo()方法声明 1234public interface HelloService &#123; String sayHello( String name ); String sayNo(); &#125; 消费方controller 1234567891011121314@Controller public class HelloAction &#123; //@Reference 此注解已经在xml文件中被&lt;dubbo:reference&gt;顶替，所以自动注入 即可 @Autowired private HelloService helloService; @GetMapping(&quot;hello&quot;) @ResponseBody public String sayHi(String name)&#123; return helloService.sayHello(name); &#125; @GetMapping(&quot;no&quot;) @ResponseBody public String no()&#123; return helloService.sayNo(); &#125;&#125; 消费方配置方法重试次数 12345&lt;dubbo:reference interface=&quot;service.HelloService&quot; id=&quot;helloService&quot;&gt; &lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;3&quot;/&gt; &lt;dubbo:method name=&quot;sayNo&quot; retries=&quot;0&quot;/&gt; &lt;!-- 不重试 --&gt;&lt;/dubbo:reference&gt; 4.1.4 多版本 一个接口，多个（版本的）实现类，可以使用定义版本的方式引入 为HelloService接口定义两个实现类，提供者修改配置： 12&lt;dubbo:service interface=&quot;service.HelloService&quot; class=&quot;service.impl.HelloServiceImpl01&quot; version=&quot;1.0.0&quot;/&gt;&lt;dubbo:service interface=&quot;service.HelloService&quot; class=&quot;service.impl.HelloServiceImpl02&quot; version=&quot;2.0.0&quot;/&gt; 注意：消费者的控制层要改为自动注入，因为@Reference注解和 &lt;dubbo:reference&gt;在这里冲突 12345@Controller public class HelloAction &#123; @Autowired private HelloService helloService; &#125; 当消费者的版本修改为 version&#x3D;”*“，那么就会随机调用服务提供者的版本 123456-------1.0被调用一次------- -------2.0被调用一次------- -------1.0被调用一次------- -------1.0被调用一次------- -------1.0被调用一次------- -------2.0被调用一次------- 4.1.5 本地存根 目前我们的分布式架构搭建起来有一个严重的问题，就是所有的操作全都是 消费者发起，由服务提供者执行 消费者动动嘴皮子却什么活都不干，这样会让提供者很累，例如简单的参数验证，消费者完全能够胜任，把合法的参数再发送给提供者执行，效率高了，提供者也没那么累了 例如：去房产局办理房屋过户，请带好自己的证件和资料，如果什么都不带，那么办理过户手续会很麻烦，得先调查你有什么贷款，有没有抵押，不动产证是不是你本人，复印资料等操作。一天肯定办不完。明天还要来。如果你能提前将这些东西准备好，办理过户，1个小时足矣，这就是“房产中介办事效率高的原因” 话不多说，先在消费者处理一些业务逻辑，再调用提供者的过程，就是“本地存根” 代码实现肯定在 消费者，创建一个HelloServiceStub类并且实现HelloService接口 注意：必须使用构造方法的方式注入 1234567891011121314151617public class HelloServiceStub implements HelloService &#123; private HelloService helloService; // 注入HelloService public HelloServiceStub(HelloService helloService) &#123; this.helloService = helloService; &#125; public String sayHello(String name) &#123; System.out.println(&quot;本地存根数据验证。。。&quot;); if(!StringUtils.isEmpty(name))&#123; return helloService.sayHello(name); &#125; return &quot;i am sorry!&quot;; &#125; public String sayNo() &#123; return helloService.sayNo(); &#125;&#125; 修改消费者配置： 1234&lt;dubbo:reference interface=&quot;service.HelloService&quot; id=&quot;helloService&quot; version=&quot;1.0.0&quot; stub=&quot;service.impl.HelloServiceStub&quot;&gt; &lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;3&quot;/&gt; &lt;dubbo:method name=&quot;sayNo&quot; retries=&quot;0&quot;/&gt;&lt;/dubbo:reference&gt; 4.2 负载均衡策略 负载均衡（Load Balance）, 其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。 简单的说，好多台服务器，不能总是让一台服务器干活，应该“雨露均沾” dubbo一共提供4种策略，缺省为 random 随机分配调用 修改提供者配置并启动3个提供者，让消费者对其进行访问 tomcat端口8001，8002，8003 provider端口20881，20882，20883 1&lt;dubbo:provider timeout=&quot;2000&quot; retries=&quot;3&quot; port=&quot;20881&quot;/&gt; HelloServiceImpl01类，服务器1，服务器2，服务器3 1234public String sayNo() &#123; System.out.println(&quot;----服务器1---1.0被调用一次-------&quot;); return &quot;no!&quot;;&#125; 启动consumer进行测试 消费方修改权重 1234&lt;dubbo:reference loadbalance=&quot;roundrobin&quot; interface=&quot;service.HelloService&quot; id=&quot;helloService&quot; version=&quot;2.0.0&quot; stub=&quot;stub.HelloServiceStub&quot;&gt; &lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;3&quot;/&gt; &lt;dubbo:method name=&quot;sayNo&quot; retries=&quot;0&quot;/&gt;&lt;/dubbo:reference&gt; 最好使用管理端修改权重 4.3 高可用4.3.1 zookeeper宕机 zookeeper注册中心宕机，还可以消费dubbo暴露的服务 监控中心宕掉不影响使用，只是丢失部分采样数据’] 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 测试： 正常发出请求’ 关闭zookeeper：.&#x2F;zkServer.sh stop 消费者仍然可以正常消费 4.4 服务降级 壁虎遇到危险会自动脱落尾巴，目的是损失不重要的东西，保住重要的 服务降级，就是根据实际的情况和流量，对一些服务有策略的停止或换种简单的方式处理，从而释放服务器的资源来保证核心业务的正常运行 4.4.1 为什么要服务降级 而为什么要使用服务降级，这是防止分布式服务发生雪崩效应 什么是雪崩？就是蝴蝶效应，当一个请求发生超时，一直等待着服务响应，那么在高并发情况下，很多请求都是因为这样一直等着响应，直到服务资源耗尽产生宕机，而宕机之后会导致分布式其他服务调用该宕机的服务也会出现资源耗尽宕机，这样下去将导致整个分布式服务都瘫痪，这就是雪崩。 4.4.2 服务降级实现方式 在 管理控制台配置服务降级：屏蔽和容错 屏蔽：mock&#x3D;force:return+null 表示消费方对该服务的方法调用都 直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 容错：mock&#x3D;fail:return+null 表示消费方对该服务的方法调用在 失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 4.5 整合MyBatis实现用户注册4.5.1 初始化数据库123456789CREATE DATABASE smd USE smd CREATE TABLE users( uid INT(11) AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50) NOT NULL, PASSWORD VARCHAR(50) NOT NULL, phone VARCHAR(50) NOT NULL, createtime VARCHAR(50) NOT NULL ) 4.5.2 创建聚合项目-项目模块化 lagou-dubbo（项目目录） lagou-dubbo-parent（父工程，聚合项目：定义所有模块用的依赖版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.sunguoan&lt;/groupId&gt;&lt;artifactId&gt;sun-parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;properties&gt; &lt;spring.version&gt;5.0.6.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- JSP相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!--dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.11.0.GA&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; lagou-dubbo-entity（实体工程，jar项目） lagou-dubbo-dao（数据访问层工程，jar项目） lagou-dubbo-interface（服务接口定义工程，jar项目） lagou-dubbo-service（privoder服务提供者工程，jar项目） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;parent&gt; &lt;groupId&gt;com.sunguoan&lt;/groupId&gt; &lt;artifactId&gt;sun-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;artifactId&gt;sun-service&lt;/artifactId&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.sunguoan&lt;/groupId&gt; &lt;artifactId&gt;sun-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sunguoan&lt;/groupId&gt; &lt;artifactId&gt;sun-dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8001&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 打包完成后,运行服务 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; lagou-dubbo-web（consumer服务消费者工程，war项目） 12345678910111213141516171819202122232425262728293031&lt;!-- 解决post乱码 --&gt;&lt;filter&gt; &lt;filter-name&gt;charset&lt;/filter-name&gt; &lt;filter- class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;charset&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet- class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.5.3 启动测试 先选择父项目（聚合工程）进行全员安装成jar 启动服务service 启动调用者web","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"LeetCode初级算法之数学问题：412.Fizz Buzz","slug":"Fizz-Buzz","date":"2021-05-22T03:18:18.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2021/05/22/Fizz-Buzz/","link":"","permalink":"http://yournotes.cn/2021/05/22/Fizz-Buzz/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/fizz-buzz/ 写一个程序，输出从 1 到 n 数字的字符串表示。 如果 n 是3的倍数，输出“Fizz”； 如果 n 是5的倍数，输出“Buzz”； 如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例： 1234567891011121314151617181920n = 15,返回:[ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot;] 题解一这个题解的话直接按照意思来就可以了 123456789101112131415public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; res = new ArrayList(); for (int i = 1; i &lt;= n; i++)&#123; if(i%3==0 &amp;&amp; i%5==0)&#123; res.add(&quot;FizzBuzz&quot;); &#125; else if(i%3==0)&#123; res.add(&quot;Fizz&quot;); &#125; else if(i%5==0)&#123; res.add(&quot;Buzz&quot;); &#125; else&#123; res.add(String.valueOf(i)); &#125; &#125; return res;&#125; 题解二这题解题确实是简单，但题可能是希望考虑到代码的黏性减少代码重复降低耦合，所以官方解题也举了例子（假设题目条件不仅仅两个）。这边也写一下吧，就是说有几种情况就我们就自己手动组合后列举，代码量就会大全都是if示例 123456789101112131415161718192021222324/* * 假设有三个条件了 * i = 3 Three * i = 5 Five * i = 7 Seven * 那么会组合出8种分支 */if(i%3==0 &amp;&amp; i%5==0 &amp;&amp; i%7==0)&#123; res.add(&quot;ThreeFiveSeven&quot;);&#125; else if(i%3==0 &amp;&amp; i%5==0)&#123; res.add(&quot;ThreeFive&quot;);&#125; else if(i%3==0 &amp;&amp; i%7==0)&#123; res.add(&quot;ThreeSeven&quot;);&#125; else if(i%5==0 &amp;&amp; i%7==0)&#123; res.add(&quot;FiveSeven&quot;);&#125; else if(i%3==0)&#123; res.add(&quot;Three&quot;);&#125; else if(i%5==0)&#123; res.add(&quot;Five&quot;);&#125; else if(i%7==0)&#123; res.add(Seven);&#125; else &#123; res.add(String.valueOf(i));&#125; 如果更多一点，那这个if分支就太大量了。其实很简单我们平时写代码即使我们不太注重这个随意的去写，也不会像上面这样写。举个例子：示例 1234567891011/* * str开头若是&#x27;a&#x27; 执行a方法 * str结尾若是&#x27;b&#x27; 执行b方法 * 和题目一样两个都满足当然是都要执行的 */if(str.charAt(0) == &#x27;a&#x27;)&#123; a();&#125;if(str.charAt(length-1) == &#x27;b&#x27;)&#123; b();&#125; 一般会像上面这样两个单if，而不是如下： 12345678if(str.charAt(0) == &#x27;a&#x27; &amp;&amp; str.charAt(length-1) == &#x27;b&#x27;)&#123; a(); b();&#125; else if(str.charAt(0) == &#x27;a&#x27;)&#123; a();&#125; else if(str.charAt(length-1) == &#x27;b&#x27;)&#123; b();&#125; 所以这题也是一样 1234567891011121314151617public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; res = new ArrayList(); for (int i = 1; i &lt;= n; i++)&#123; String str = &quot;&quot;; if (i%3 == 0) &#123; str += &quot;Fizz&quot;; &#125; if (i%5 == 0) &#123; str += &quot;Buzz&quot;; &#125; if (str.equals(&quot;&quot;)) &#123; str += String.valueOf(i); &#125; res.add(str); &#125; return res;&#125; 题解三像题解二我们使用单if之后，不去手动组合。分支数量会下降，并且结构更清晰（避免嵌套或者多分支），虽然倍率下降但还是会随着条件的增多而增多if。所以若是有很多条件的情况下不妨去存在容器里把很多if变成循环+if 123Map&lt;Integer,String&gt; map = new HashMap();map.put(3,&quot;Fizz&quot;);map.put(5,&quot;Buzz&quot;); 12345for (Integer key : map.keySet()) &#123; if (num % key == 0) &#123; str += map.get(key); &#125;&#125; 所以代码如下： 12345678910111213141516171819public List&lt;String&gt; fizzBuzz(int n) &#123; Map&lt;Integer,String&gt; map = new HashMap(); map.put(3,&quot;Fizz&quot;); map.put(5,&quot;Buzz&quot;); List&lt;String&gt; res = new ArrayList(); for (int i = 1; i &lt;= n; i++)&#123; String str = &quot;&quot;; for (Integer key : map.keySet()) &#123; if (i % key == 0) &#123; str += map.get(key); &#125; &#125; if (str.equals(&quot;&quot;)) &#123; str += String.valueOf(i); &#125; res.add(str); &#125; return res;&#125; 总结这题本身是简单的，但主要是怎么去处理变得通用，就像在过去我们学习javaEE去改写通用servlet一样，把n个方法名的判断通过泛型给免去了，这里也是一样n个if不可能都写出来换成循环遍历n个if，其实还有改进的点，就比如像在题解二举得例子如果说这两个条件都满足所以两个方法都执行，但是它们需要有先后顺序么？如果实际的逻辑是需要的那么解法二可以手动调整单if顺序，但解法三不行因为hashmap的keySet()方法取是乱序的，但可以使用TreeMap或LinkMap.TreeMap是按key升序，而LinkMap是按put的顺序","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"SSM整合","slug":"SSM整合","date":"2021-05-16T08:09:22.000Z","updated":"2025-04-17T08:34:52.016Z","comments":true,"path":"2021/05/16/SSM整合/","link":"","permalink":"http://yournotes.cn/2021/05/16/SSM%E6%95%B4%E5%90%88/","excerpt":"","text":"1. 需求和步骤分析需求 ​ 使用ssm框架完成对 account 表的增删改查操作。 步骤分析 准备数据库和表记录 创建web项目 编写mybatis在ssm环境中可以单独使用 编写spring在ssm环境中可以单独使用 spring整合mybatis 编写springMVC在ssm环境中可以单独使用 spring整合springMVC 2. 环境搭建2.1 准备数据库和表记录123456789CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `money` double DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; insert into `account`(`id`,`name`,`money`) values (1,&#x27;tom&#x27;,1000), (2,&#x27;jerry&#x27;,1000); 2.2 创建web项目3. 编写mybatis在ssm环境中可以单独使用需求：基于mybatis先来实现对account表的查询 3.1 相关坐标123456789101112131415161718192021&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 3.2 Accoun实体12345public class Account &#123; private Integer id; private String name; private Double money; &#125; 3.3 AccountDao接口123public interface AccountDao &#123; public List&lt;Account&gt; findAll(); &#125; 3.4 AccountDao.xml映射12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lagou.dao.AccountDao&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;Account&quot;&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; 3.5 mybatis核心配置文件jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db jdbc.username=root jdbc.password=root SqlMapConfig.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--加载properties--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!--类型别名配置--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.lagou.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;!--环境配置--&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!--使用MySQL环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射--&gt; &lt;mappers&gt; &lt;package name=&quot;com.lagou.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.6 测试代码1234567891011121314151617181920public class MyBatisTest &#123; @Test public void testMybatis() throws Exception &#123; // 加载核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); // 获得sqlsession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获得sqlsession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 获得mapper代理对象 AccountDao accountDao = sqlSession.getMapper(AccountDao.class); // 执行 List&lt;Account&gt; list = accountDao.findAll(); for (Account account : list) &#123; System.out.println(account); &#125; // 释放资源 sqlSession.close(); &#125;&#125; 4. 编写spring在ssm环境中可以单独使用4.1 相关坐标1234567891011121314151617181920212223242526&lt;!--spring坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4.2 AccountService接口123public interface AccountService &#123; public List&lt;Account&gt; findAll(); &#125; 4.3 AccountServiceImpl实现12345678@Service public class AccountServiceImpl implements AccountService &#123; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(&quot;findAll执行了....&quot;); return null; &#125;&#125; 4.4 spring核心配置文件applicationContext.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注解组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou.service&quot;/&gt; &lt;/beans&gt; 4.5 测试代码1234567891011@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class SpringTest &#123; @Autowired private AccountService accountService; @Test public void testSpring() throws Exception &#123; List&lt;Account&gt; list = accountService.findAll(); System.out.println(list); &#125;&#125; 5. spring整合mybatis5.1 整合思想​ 将mybatis接口代理对象的创建权交给spring管理，我们就可以把dao的代理对象注入到service中此时也就完成了spring与mybatis的整合了。 5.2 导入整合包123456&lt;!--mybatis整合spring坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 5.3 spring配置文件管理mybatis注意：此时可以将mybatis主配置文件删除。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注解组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou.service&quot;/&gt; &lt;!--spring整合mybatis--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--SqlSessionFactory创建交给spring的IOC容器--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--数据库环境配置--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--类型别名配置--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lagou.domain&quot;/&gt; &lt;!--如果要引入mybatis主配置文件，可以通过如下配置--&gt; &lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot;/&gt;--&gt; &lt;/bean&gt; &lt;!--映射接口扫描配置，由spring创建代理对象，交给IOC容器--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.lagou.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 5.4 修改AccountServiceImpl123456789@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() &#123; return accountDao.findAll(); &#125;&#125; 6. 编写springMVC在ssm环境中可以单独使用需求：访问到controller里面的方法查询所有账户，并跳转到list.jsp页面进行列表展示 6.1 相关坐标1234567891011121314151617181920212223&lt;!--springMVC坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 6.2 导入页面资源 6.3 前端控制器DispathcerServlet12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet- class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--post中文处理--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter- class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 6.4 AccountController和 list.jsp123456789101112@Controller @RequestMapping(&quot;/account&quot;) public class AccountController &#123; @RequestMapping(&quot;/findAll&quot;) public String findAll(Model model) &#123; List&lt;Account&gt; list = new ArrayList&lt;&gt;(); list.add(new Account(1,&quot;张三&quot;,1000d)); list.add(new Account(2,&quot;李四&quot;,1000d)); model.addAttribute(&quot;list&quot;, list); return &quot;list&quot;; &#125;&#125; 1234567891011&lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;account&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;account.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.money&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;update.jsp&quot;&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 6.5 springMVC核心配置文件123456789101112131415161718192021222324&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou.controller&quot;/&gt; &lt;!--mvc注解增强--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--实现静态资源映射--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; 7. spring整合springMVC7.1 整合思想​ spring和springMVC其实根本就不用整合，本来就是一家。 ​ 但是我们需要做到spring和web容器整合，让web容器启动的时候自动加载spring配置文件，web容器销毁的时候spring的ioc容器也销毁。 7.2 spring和web容器整合ContextLoaderListener加载【掌握】 ​ 可以使用spring-web包中的ContextLoaderListener监听器，可以监听servletContext容器的创建和销毁，来同时创建或销毁IOC容器。 12345678&lt;!--spring 与 web容器整合--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 7.3 修改AccountController123456789101112@Controller@RequestMapping(&quot;/account&quot;) public class AccountController &#123; @Autowired private AccountService accountService; @RequestMapping(&quot;/findAll&quot;) public String findAll(Model model) &#123; List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(&quot;list&quot;, list); return &quot;list&quot;; &#125;&#125; 8. spring配置声明式事务8.1 spring配置文件加入声明式事务123456&lt;!--事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--开启事务注解支持--&gt;&lt;tx:annotation-driven/&gt; 1234@Service @Transactional public class AccountServiceImpl implements AccountService &#123;&#125; 8.2 add.jsp12345678910111213141516&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/account/save&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;余额：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;age&quot; name=&quot;age&quot; placeholder=&quot;请输入余额&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;button&quot; onclick=&quot;history.go(-1)&quot; value=&quot;返回&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 8.3 AccountController12345@RequestMapping(&quot;/save&quot;) public String save(Account account)&#123; accountService.save(account); return &quot;redirect:/account/findAll&quot;; &#125; 8.4 AccountService接口和实现类1public void save(Account account); 12345678@Service @Transactional public class AccountServiceImpl implements AccountService &#123; @Override public void save(Account account) &#123; accountDao.save(account); &#125;&#125; 8.5 AccountDao1void save(Account account); AccountDao.xml123&lt;insert id=&quot;save&quot; parameterType=&quot;Account&quot;&gt; insert into account (name, money) values (#&#123;name&#125;, #&#123;money&#125;) &lt;/insert&gt; 9. 修改操作9.1 数据回显① AccountController 12345@RequestMapping(&quot;/findById&quot;) public String findById(Integer id, Model model) &#123; Account account = accountService.findById(id); model.addAttribute(&quot;account&quot;, account); return &quot;update&quot;; &#125; ② AccountService接口和实现类 1Account findById(Integer id); 1234@Override public Account findById(Integer id) &#123; return accountDao.findById(id); &#125; ③ AccountDao接口和映射文件 1Account findById(Integer id); 123&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;Account&quot;&gt; select * from account where id = #&#123;id&#125; &lt;/select&gt; ④ update.jsp 12345678910111213141516171819&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/account/update&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;account.id&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; name=&quot;name&quot; value=&quot;$&#123;account.name&#125;&quot; placeholder=&quot;请输入姓名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;money&quot;&gt;余额：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;money&quot; name=&quot;money&quot; value=&quot;$&#123;account.money&#125;&quot; placeholder=&quot;请输入余额&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;button&quot; onclick=&quot;history.go(-1)&quot; value=&quot;返回&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 9.2 账户更新① AccountController 12345@RequestMapping(&quot;/update&quot;) public String update(Account account)&#123; accountService.update(account); return &quot;redirect:/account/findAll&quot;; &#125; ② AccountService接口和实现类 1void update(Account account); 1234@Override public void update(Account account) &#123; accountDao.update(account); &#125; ③ AccountDao接口和映射文件 1void update(Account account); 123&lt;update id=&quot;update&quot; parameterType=&quot;Account&quot;&gt; update account set name = #&#123;name&#125;,money = #&#123;money&#125; where id = #&#123;id&#125; &lt;/update&gt; 10. 批量删除10.1 list.jsp12345678910111213&lt;script&gt; $(&#x27;#checkAll&#x27;).click(function() &#123; $(&#x27;input[name=&quot;ids&quot;]&#x27;).prop(&#x27;checked&#x27;, $(this).prop(&#x27;checked&#x27;)); &#125;) $(&#x27;#deleteBatchBtn&#x27;).click(function() &#123; if (confirm(&#x27;您确定要删除吗?&#x27;)) &#123; if ($(&#x27;input[name=&quot;ids&quot;]:checked&#x27;).length &gt; 0) &#123; $(&#x27;#deleteBatchForm&#x27;).submit(); &#125; else &#123; alert(&#x27;想啥呢？&#x27;) &#125; &#125; &#125;)&lt;/script&gt; 10.2 AccountController12345@RequestMapping(&quot;/deleteBatch&quot;) public String deleteBatch(Integer[] ids) &#123; accountService.deleteBatch(ids); return &quot;redirect:/account/findAll&quot;; &#125; 10.3 AccountService接口和实现类1void deleteBatch(Integer[] ids); 1234@Override public void deleteBatch(Integer[] ids) &#123; accountDao.deleteBatch(ids); &#125; 10.4 AccountDao接口和映射文件1void deleteBatch(Integer[] ids); 12345&lt;delete id=&quot;deleteBatch&quot; parameterType=&quot;int&quot;&gt; delete from account &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;id&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/delete&gt;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"SpringMVC 进阶","slug":"springmvc-进阶","date":"2021-05-09T07:22:02.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/05/09/springmvc-进阶/","link":"","permalink":"http://yournotes.cn/2021/05/09/springmvc-%E8%BF%9B%E9%98%B6/","excerpt":"","text":"1. ajax异步交互Springmvc默认用MappingJackson2HttpMessageConverter对json数据进行转换，需要加入jackson的包；同时使用 &lt;mvc:annotation-driven /&gt; 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 1.1 @RequestBody该注解用于Controller的方法的形参声明，当使用ajax提交并指定contentType为json形式时，通过HttpMessageConverter接口转换为对应的POJO对象。 123456789101112131415161718&lt;button id=&quot;btn1&quot;&gt; ajax异步提交&lt;/button&gt;&lt;script&gt; $(&quot;#btn1&quot;).click(function() &#123; let url = &#x27;$&#123;pageContext.request.contextPath&#125;/ajaxRequest&#x27;; let data = &#x27;[&#123;&quot;id&quot;:1,&quot;username&quot;:&quot;张三&quot;&#125;,&#123;&quot;id&quot;:2,&quot;username&quot;:&quot;李四&quot;&#125;]&#x27;; $.ajax(&#123; type: &#x27;POST&#x27;, url: url, data: data, contentType: &#x27;application/json;charset=utf-8&#x27;, success: function(resp) &#123; alert(JSON.stringify(resp)) &#125; &#125;) &#125;)&lt;/script&gt; 1234@RequestMapping(value = &quot;/ajaxRequest&quot;) public void ajaxRequest(@RequestBody List&lt;User&gt;list) &#123; System.out.println(list); &#125; 1.2 @ResponseBody该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端。 12345678910/* * @RequestMapping produces = &quot;application/json; * charset=utf-8&quot; 响应返回数据的mime类型和编码，默认为 json */@RequestMapping(value = &quot;/ajaxRequest&quot;) @ResponseBody public List&lt;User&gt; ajaxRequest(@RequestBody List&lt;User&gt; list) &#123; System.out.println(list); return list;&#125; 2. RESTful2.1 什么是RESTfulRestful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：读取（Read） POST：新建（Create） PUT：更新（Update） DELETE：删除（Delete） 客户端请求 原来风格URL地址 RESTful风格URL地址 查询所有 /user/findAll GET /user 根据ID查询 /user/findById?id=1 GET /user/{1} 新增 /user/save POST /user 修改 /user/update PUT /user 删除 /user/delete?id=1 DELETE /user/{1} 2.2 代码实现@PathVariable 用来接收RESTful风格请求地址中占位符的值 @RestController RESTful风格多用于前后端分离项目开发，前端通过ajax与服务器进行异步交互，我们处理器通常返回的是json数据所以使用@RestController来替代@Controller和@ResponseBody两个注解。 1234567891011121314151617181920212223// @Controller @RestController public class RestFulController &#123; @GetMapping(value = &quot;/user/&#123;id&#125;&quot;) // 相当于 @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;,method = RequestMethod.GET) // @ResponseBody public String get(@PathVariable Integer id) &#123; return &quot;get：&quot; + id; &#125; @PostMapping(value = &quot;/user&quot;) // @ResponseBody public String post() &#123; return &quot;post&quot;; &#125; @PutMapping(value = &quot;/user&quot;) // @ResponseBody public String put() &#123; return &quot;put&quot;; &#125; @DeleteMapping(value = &quot;/user/&#123;id&#125;&quot;) // @ResponseBody public String delete(@PathVariable Integer id) &#123; return &quot;delete：&quot;+ id; &#125;&#125; 3. 文件上传3.1 文件上传三要素 表单项 type&#x3D;”file” 表单的提交方式 method&#x3D;”POST” 表单的enctype属性是多部分表单形式 enctype&#x3D;“multipart&#x2F;form-data” 3.2 文件上传原理 当form表单修改为多部分表单时，request.getParameter()将失效。 当form表单的enctype取值为 application&#x2F;x-www-form-urlencoded 时，form表单的正文内容格式是： name&#x3D;value&amp;name&#x3D;value 当form表单的enctype取值为 mutilpart&#x2F;form-data 时，请求正文内容就变成多部分形式： 3.3 单文件上传步骤分析 导入fileupload和io坐标 配置文件上传解析器 编写文件上传代码 1）导入fileupload和io坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 2）配置文件上传解析器 1234567&lt;!--文件上传解析器--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设定文件上传的最大值为5MB，5*1024*1024 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt; &lt;!-- 设定文件上传时写入内存的最大值，如果小于这个参数不会生成临时文件，默认为10240 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3）编写文件上传代码 12345&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/fileUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 文件：&lt;input type=&quot;file&quot; name=&quot;filePic&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;单文件上传&quot;&gt;&lt;/form&gt; 123456789@RequestMapping(&quot;/fileUpload&quot;) public String fileUpload(String username, MultipartFile filePic) throws IOException &#123; System.out.println(username); // 获取文件名 String originalFilename = filePic.getOriginalFilename(); //保存文件 filePic.transferTo(new File(&quot;d:/upload/&quot;+originalFilename)); return &quot;success&quot;;&#125; 3.4 多文件上传123456&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/filesUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 文件1：&lt;input type=&quot;file&quot; name=&quot;filePic&quot;&gt;&lt;br&gt; 文件2：&lt;input type=&quot;file&quot; name=&quot;filePic&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;多文件上传&quot;&gt;&lt;/form&gt; 1234567891011@RequestMapping(&quot;/filesUpload&quot;) public String filesUpload(String username, MultipartFile[] filePic) throws IOException &#123; System.out.println(username); for (MultipartFile multipartFile : filePic) &#123; // 获取文件名 String originalFilename = multipartFile.getOriginalFilename(); // 保存到服务器 multipartFile.transferTo(new File(&quot;d:/upload/&quot; + originalFilename)); &#125; return &quot;success&quot;;&#125; 4. 异常处理4.1 异常处理的思路在Java中，对于异常的处理一般有两种方式： 一种是当前方法捕获处理（try-catch），这种处理方式会造成业务代码和异常处理代码的耦合。 另一种是自己不处理，而是抛给调用者处理（throws），调用者再抛给它的调用者，也就是一直向上抛。在这种方法的基础上，衍生出了SpringMVC的异常处理机制。 系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图： 4.2 自定义异常处理器步骤分析 创建异常处理器类实现HandlerExceptionResolver 配置异常处理器 编写异常页面 测试异常跳转 1）创建异常处理器类实现HandlerExceptionResolver 123456789public class GlobalExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;error&quot;, ex.getMessage()); modelAndView.setViewName(&quot;error&quot;); return modelAndView; &#125;&#125; 2）配置异常处理器 12@Component public class GlobalExecptionResovler implements HandlerExceptionResolver &#123;&#125; 3）编写异常页面 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;error&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;这是一个最终异常的显示页面&lt;/h3&gt; &lt;p&gt;$&#123;error&#125;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 4）测试异常跳转 12345@RequestMapping(&quot;/testException&quot;) public String testException() &#123; int i = 1 / 0; return &quot;success&quot;;&#125; 4.3 web的处理异常机制12345678910&lt;!--处理500异常--&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;!--处理404异常--&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt;&lt;/error-page&gt; 5. 拦截器5.1 拦截器（interceptor）的作用Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 5.2 拦截器和过滤器区别关于interceptor和filter的区别，如图所示： 5.3 快速入门步骤分析 创建拦截器类实现HandlerInterceptor接口 配置拦截器 测试拦截器的拦截效果 1）创建拦截器类实现HandlerInterceptor接口 123456789101112131415161718public class MyInterceptor1 implements HandlerInterceptor &#123; // 在目标方法执行之前 拦截 @Override public Boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; System.out.println(&quot;preHendle1&quot;); return true; &#125; // 在目标方法执行之后,视图对象返回之前 执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; System.out.println(&quot;postHandle1&quot;); &#125; // 在流程都执行完毕后 执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(&quot;afterCompletion1&quot;); &#125;&#125; 2）配置拦截器 12345678&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.lagou.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 3）测试拦截器的拦截效果 编写Controller,发请求到controller,跳转页面 12345678@Controller public class TargetController &#123; @RequestMapping(&quot;/target&quot;) public String targetMethod() &#123; System.out.println(&quot;目标方法执行了...&quot;); return &quot;success&quot;; &#125;&#125; 编写jsp页面 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;success&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;success...&lt;/h3&gt; &lt;% System.out.println( &quot;视图执行了....&quot;);%&gt; &lt;/body&gt;&lt;/html&gt; 5.4 拦截器链开发中拦截器可以单独使用，也可以同时使用多个拦截器形成一条拦截器链。开发步骤和单个拦截器是一样的，只不过注册的时候注册多个，注意这里注册的顺序就代表拦截器执行的顺序。 同上，再编写一个MyHandlerInterceptor2操作，测试执行顺序： 123456789101112131415&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--拦截器路径配置--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--自定义拦截器类--&gt; &lt;bean class=&quot;com.lagou.interceptor.MyInterceptor1&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--拦截器路径配置--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--自定义拦截器类--&gt; &lt;bean class=&quot;com.lagou.interceptor.MyInterceptor2&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 5.5 知识小结拦截器中的方法说明如下：","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"SpringMVC 入门","slug":"SpringMVC-入门","date":"2021-05-02T10:19:43.000Z","updated":"2025-04-17T08:34:52.018Z","comments":true,"path":"2021/05/02/SpringMVC-入门/","link":"","permalink":"http://yournotes.cn/2021/05/02/SpringMVC-%E5%85%A5%E9%97%A8/","excerpt":"","text":"1. SpringMVC简介1.1 MVC模式MVC是软件工程中的一种软件架构模式，它是一种分离业务逻辑与显示界面的开发思想。 M（model）模型：处理业务逻辑，封装实体 V（view） 视图：展示内容 C（controller）控制器：负责调度分发（1.接收请求、2.调用模型、3.转发到视图） 1.2 SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模式的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 总结 SpringMVC的框架就是封装了原来Servlet中的共有行为；例如：参数封装，视图转发等。 1.3 SpringMVC快速入门需求客户端发起请求，服务器接收请求，执行逻辑并进行视图跳转。 步骤分析 创建web项目，导入SpringMVC相关坐标 配置SpringMVC前端控制器 DispathcerServlet 编写Controller类和视图页面 使用注解配置Controller类中业务方法的映射地址 配置SpringMVC核心文件 spring-mvc.xml 1）创建web项目，导入SpringMVC相关坐标 123456789101112131415161718192021222324&lt;!-- 设置为web工程 --&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependencies&gt; &lt;!--springMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jsp坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）配置SpringMVC前端控制器DispathcerServlet 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet- class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3）编写Controller类和视图页面 UserController.java 123456public class UserController &#123; public String quick() &#123; System.out.println(&quot;quick running.....&quot;); return &quot;/WEB-INF/pages/success.jsp&quot;; &#125;&#125; &#x2F;WEB-INF&#x2F;pages&#x2F; success.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;success&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;请求成功！&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 4）使用注解配置Controller类中业务方法的映射地址 12345678@Controller public class UserController &#123; @RequestMapping(&quot;/quick&quot;) public String quick() &#123; System.out.println(&quot;quick running.....&quot;); return &quot;/WEB-INF/pages/success.jsp&quot;; &#125;&#125; 5）配置SpringMVC核心文件spring-mvc.xml 123456789101112131415&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou.controller&quot;/&gt;&lt;/beans&gt; 1.4 web工程执行流程 1.5 知识小结 SpringMVC是对MVC设计模式的一种实现，属于轻量级的WEB框架。 SpringMVC的开发步骤： 创建web项目，导入SpringMVC相关坐标 配置SpringMVC前端控制器 DispathcerServlet 编写Controller类和视图页面 使用注解配置Controller类中业务方法的映射地址 配置SpringMVC核心文件 spring-mvc.xml 2.SpringMVC组件概述2.1 SpringMVC的执行流程 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如 果有则生成)一并返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter处理器适配器。 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 Controller执行完成返回ModelAndView。 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ViewReslover解析后返回具体View。 DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet将渲染后的视图响应响应用户。 2.2 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的 中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器 实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型 的处理器进行执行。 处理器：Handler【开发者编写】 ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 视图解析器：ViewResolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物 理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View 【开发者编写】 ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展 示给用户，需要由程序员根据业务需求开发具体的页面。 1234567891011121314151617181920&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou.controller&quot; /&gt; &lt;!--处理器映射器和处理器适配器功能增强--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.3 SpringMVC注解解析@Controller ​ SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用： 12&lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou.controller&quot;/&gt; @RequestMapping 作用： ​ 用于建立请求 URL 和处理请求方法之间的对应关系 位置： 类上：请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以&#x2F;开头。 方法上：请求URL的第二级访问目录，和一级目录组成一个完整的 URL 路径。 属性： value：用于指定请求的URL。它和path属性的作用是一样的 method：用来限定请求的方式 params：用来限定请求参数的条件 例如：params&#x3D;{“accountName”} 表示请求参数中必须有accountName ​ prams&#x3D;{“money!100”} 表示请求参数中money不能是100 2.4 知识小结 SpringMVC的三大组件 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 视图解析器：View Resolver 开发者编写 处理器：Handler 视图：View 3. SpringMVC的请求3.1 请求参数类型介绍客户端请求参数的格式是：name=value&amp;name=value…… 服务器要获取请求的参数的时候要进行类型转换，有时还需要进行数据的封装 SpringMVC可以接收如下类型的参数： 基本类型参数 对象类型参数 数组类型参数 集合类型参数 3.2 获取基本类型参数Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换；自动的类型转换是指从String向其他类型的转换。 123&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/simpleParam?id=1&amp;username=杰克&quot;&gt; 基本类型 &lt;/a&gt; 123456@RequestMapping(&quot;/simpleParam&quot;) public String simpleParam(Integer id,String username) &#123; System.out.println(id); System.out.println(username); return &quot;success&quot;; &#125; 3.3 获取对象类型参数Controller中的业务方法参数的POJO属性名与请求参数的name一致，参数值会自动映射匹配。 123456789&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/pojoParam&quot; method=&quot;post&quot;&gt; 编号： &lt;input type=&quot;text&quot; name=&quot;id&quot;&gt; &lt;br&gt; 用户名： &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;对象类型&quot;&gt;&lt;/form&gt; 12345public class User &#123; Integer id; String username; // setter getter... &#125; 12345@RequestMapping(&quot;/pojoParam&quot;) public String pojoParam(User user) &#123; System.out.println(user); return &quot;success&quot;; &#125; 3.4 中文乱码过滤器当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 1234567891011121314&lt;!--配置全局过滤的filter--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter- class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3.5 获取数组类型参数Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 12345678910&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/arrayParam&quot;&gt; 编号： &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;1&quot;&gt;1&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;2&quot;&gt;2&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;3&quot;&gt;3&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;4&quot;&gt;4&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;5&quot;&gt;5&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;数组类型&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/arrayParam&quot;) public String arrayParam(Integer[] ids) &#123; System.out.println(Arrays.toString(ids)); return &quot;success&quot;;&#125; 3.6 获取集合（复杂）类型参数获得集合参数时，要将集合参数包装到一个POJO中才可以。 123456789101112131415161718192021222324252627282930&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/queryParam&quot; method=&quot;post&quot;&gt; 搜索关键字： &lt;input type=&quot;text&quot; name=&quot;keyword&quot;&gt; &lt;br&gt; user对象： &lt;input type=&quot;text&quot; name=&quot;user.id&quot; placeholder=&quot;编号&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user.username&quot; placeholder=&quot;姓名&quot;&gt; &lt;br&gt; list集合 &lt;br&gt; 第一个元素： &lt;input type=&quot;text&quot; name=&quot;userList[0].id&quot; placeholder=&quot;编号&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].username&quot; placeholder=&quot;姓名&quot;&gt; &lt;br&gt; 第二个元素： &lt;input type=&quot;text&quot; name=&quot;userList[1].id&quot; placeholder=&quot;编号&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].username&quot; placeholder=&quot;姓名&quot;&gt; &lt;br&gt; map集合 &lt;br&gt; 第一个元素： &lt;input type=&quot;text&quot; name=&quot;userMap[&#x27;u1&#x27;].id&quot; placeholder=&quot;编号&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userMap[&#x27;u1&#x27;].username&quot; placeholder=&quot;姓名&quot;&gt; &lt;br&gt; 第二个元素： &lt;input type=&quot;text&quot; name=&quot;userMap[&#x27;u2&#x27;].id&quot; placeholder=&quot;编号&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userMap[&#x27;u2&#x27;].username&quot; placeholder=&quot;姓名&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;复杂类型&quot;&gt;&lt;/form&gt; 123456public class QueryVo &#123; private String keyword; private User user; private List&lt;User&gt; userList; private Map&lt;String, User&gt; userMap;&#125; 12345@RequestMapping(&quot;/queryParam&quot;) public String queryParam(QueryVo queryVo) &#123; System.out.println(queryVo); return &quot;success&quot;;&#125; 3.7 自定义类型转换器SpringMVC 默认已经提供了一些常用的类型转换器；例如：客户端提交的字符串转换成int型进行参数设置，日期格式类型要求为：yyyy&#x2F;MM&#x2F;dd 不然的话会报错，对于特有的行为，SpringMVC提供了自定义类型转换器方便开发者自定义处理。 12345&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/converterParam&quot;&gt; 生日： &lt;input type=&quot;text&quot; name=&quot;birthday&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;自定义类型转换器&quot;&gt;&lt;/form&gt; 1234567891011121314public class DateConverter implements Converter&lt;String, Date&gt; &#123; public Date convert(String dateStr) &#123; //将日期字符串转换成日期对象 返回 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try &#123; date = format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 1234567891011&lt;!--处理器映射器和适配器增强--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation- driven&gt;&lt;!--自定义转换器配置--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;com.lagou.converter.DateConverter&quot;&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 12345@RequestMapping(&quot;/converterParam&quot;) public String converterParam(Date birthday) &#123; System.out.println(birthday); return &quot;success&quot;;&#125; 3.8 相关注解@RequestParam 当请求的参数name名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 123&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/findByPage?pageNo=2&quot;&gt; 分页查询 &lt;/a&gt; 1234567891011121314/* * @RequestParam() * 注解 defaultValue * 设置参数默认值 name * 匹配页面传递参数的名称 required * 设置是否必须传递参数，默认值为true； * 如果设置了默认值，值自动改为false */@RequestMapping(&quot;/findByPage&quot;) public String findByPage(@RequestParam(name = &quot;pageNo&quot;, defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(defaultValue = &quot;5&quot;) Integer pageSize) &#123; System.out.println(pageNum); System.out.println(pageSize); return &quot;success&quot;;&#125; @RequestHeader 获取请求头的数据。 12345@RequestMapping(&quot;/requestHead&quot;) public String requestHead(@RequestHeader(&quot;cookie&quot;) String cookie) &#123; System.out.println(cookie); return &quot;success&quot;;&#125; @CookieValue 获取cookie中的数据。 12345@RequestMapping(&quot;/cookieValue&quot;) public String cookieValue(@CookieValue(&quot;JSESSIONID&quot;) String jesessionId) &#123; System.out.println(jesessionId); return &quot;success&quot;;&#125; 3.9 获取Servlet相关APISpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： 1234567@RequestMapping(&quot;/servletAPI&quot;) public String servletAPI(HttpServletRequest request, HttpServletResponse response, HttpSession session) &#123; System.out.println(request); System.out.println(response); System.out.println(session); return &quot;success&quot;;&#125; 4. SpringMVC的响应4.1 SpringMVC响应方式介绍页面跳转 返回字符串逻辑视图 void原始ServletAPI ModelAndView 返回数据 直接返回字符串数据 将对象或集合转为json返回（任务二演示） 4.2 返回字符串逻辑视图直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转到指定页面 1234@RequestMapping(&quot;/returnString&quot;) public String returnString() &#123; return &quot;success&quot;;&#125; 4.3 void原始ServletAPI我们可以通过request、response对象实现响应 1234567891011@RequestMapping(&quot;/returnVoid&quot;) public void returnVoid(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // 1.通过response直接响应数据 response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;拉勾网&quot;); request.setAttribute(&quot;username&quot;, &quot;拉勾教育&quot;); // 2.通过request实现转发 request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request, response); // 3.通过response实现重定向 response.sendRedirect(request.getContextPath() + &quot;/index.jsp&quot;);&#125; 4.4 转发和重定向企业开发我们一般使用返回字符串逻辑视图实现页面的跳转，这种方式其实就是请求转发。 我们也可以写成：forward转发 如果用了forward：则路径必须写成实际视图url，不能写逻辑视图。它相当于： 1request.getRequestDispatcher(&quot;url&quot;).forward(request,response) 使用请求转发，既可以转发到jsp，也可以转发到其他的控制器方法。 12345@RequestMapping(&quot;/forward&quot;) public String forward(Model model) &#123; model.addAttribute(&quot;username&quot;, &quot;拉勾招聘&quot;); return &quot;forward:/WEB-INF/pages/success.jsp&quot;;&#125; Redirect重定向 我们可以不写虚拟目录，springMVC框架会自动拼接，并且将Model中的数据拼接到url地址上 12345@RequestMapping(&quot;/redirect&quot;) public String redirect(Model model) &#123; model.addAttribute(&quot;username&quot;, &quot;拉勾教育&quot;); return &quot;redirect:/index.jsp&quot;; &#125; 4.5 ModelAndView4.4.1 方式一在Controller中方法创建并返回ModelAndView对象，并且设置视图名称 12345678910@RequestMapping(&quot;/returnModelAndView1&quot;) public ModelAndView returnModelAndView1() &#123; /* Model:模型 作用封装数据 View：视图 作用展示数据 */ ModelAndView modelAndView = new ModelAndView(); //设置模型数据 modelAndView.addObject(&quot;username&quot;, &quot; lagou&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView;&#125; 4.4.2 方式二在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 12345678910@RequestMapping(&quot;/returnModelAndView1&quot;) public ModelAndView returnModelAndView1() &#123; /* Model:模型 作用封装数据 View：视图 作用展示数据 */ ModelAndView modelAndView = new ModelAndView(); //设置模型数据 modelAndView.addObject(&quot;username&quot;, &quot; lagou&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView;&#125; 4.6 @SessionAttributes如果在多个请求之间共用数据，则可以在控制器类上标注一个 @SessionAttributes,配置需要在session中存放的数据范围，Spring MVC将存放在model中对应的数据暂存到 HttpSession中。 注意：@SessionAttributes只能定义在类上 1234567891011121314@Controller @SessionAttributes(&quot;username&quot;) //向request域存入的key为username时，同步到session域中 public class UserController &#123; @RequestMapping(&quot;/forward&quot;) public String forward(Model model) &#123; model.addAttribute(&quot;username&quot;, &quot;子慕&quot;); return &quot;forward:/WEB-INF/pages/success.jsp&quot;; &#125; @RequestMapping(&quot;/returnString&quot;) public String returnString() &#123; return &quot;success&quot;; &#125;&#125; 4.7 知识小结 页面跳转采用返回字符串逻辑视图 forward转发: 可以通过Model向request域中设置数据 redirect重定向: 直接写资源路径即可，虚拟目录springMVC框架自动完成拼接 数据存储到request域中 : model.addAttribute(&quot;username&quot;, &quot;木瓜煲鸡脚&quot;); 5. 静态资源访问的开启当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是 &#x2F;（缺省）,代表对所有的静态资源都进行处理操作，这样就不会执行Tomcat内置的DefaultServlet处理，我们可以通过以下两种方式指定放行静态资源： 方式一 1234&lt;!--在springmvc配置文件中指定放行资源--&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt; &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt; 方式二 12&lt;!--在springmvc配置文件中开启DefaultServlet处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Spring JDBCtemplate&声明式事务","slug":"Spring-JDBCtemplate-声明式事务","date":"2021-04-25T02:35:46.000Z","updated":"2025-04-17T08:34:52.017Z","comments":true,"path":"2021/04/25/Spring-JDBCtemplate-声明式事务/","link":"","permalink":"http://yournotes.cn/2021/04/25/Spring-JDBCtemplate-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"1. Spring的JdbcTemplate主要是学习声明是事务，顺便用下Spring的JdbcTemplate来做演示 1.1 JdbcTemplate是什么？JdbcTemplate是spring框架中提供的一个模板对象，是对原始繁琐的Jdbc API对象的简单封装。 核心对象 1JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSource dataSource); 核心方法 12345int update(); //执行增、删、改语句 List&lt;T&gt; query(); //查询多个 T queryForObject(); //查询一个 new BeanPropertyRowMapper&lt;&gt;(); //实现ORM映射封装 举个栗子 查询数据库所有账户信息到Account实体中 1234567891011public class JdbcTemplateTest &#123; @Test public void testFindAll() throws Exception &#123; // 创建核心对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JdbcUtils.getDataSource()); // 编写sql String sql = &quot;select * from account&quot;; // 执行sql List&lt;Account&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt; (Account.class)); &#125;&#125; 1.2 Spring整合JdbcTemplate需求 基于Spring的xml配置实现账户的CRUD案例 步骤分析 创建java项目，导入坐标 编写Account实体类 编写AccountDao接口和实现类 编写AccountService接口和实现类 编写spring核心配置文件 编写测试代码 1）创建java项目，导入坐标 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）编写Account实体类 12345public class Account &#123; private Integer id; private String name; private double money;&#125; 3）编写AccountDao接口和实现类 1234567public interface AccountDao &#123; public List&lt;Account&gt; findAll(); public Account findById(Integer id); public void save(Account account); public void update(Account account); public void delete(Integer id);&#125; 1234567891011121314151617181920212223242526272829303132333435363738@Repository public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public List&lt;Account&gt; findAll() &#123; // 编写sql String sql = &quot;select * from account&quot;; // 执行sql return jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt; (Account.class)); &#125; @Override public Account findById(Integer id) &#123; // 编写sql String sql = &quot;select * from account where id = ?&quot;; // 执行sql return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt; (Account.class),id); &#125; @Override public void save(Account account) &#123; // 编写sql String sql = &quot;insert into account values(null,?,?)&quot;; // 执行sql jdbcTemplate.update(sql, account.getName(), account.getMoney()); &#125; @Override public void update(Account account) &#123; // 编写sql String sql = &quot;update account set name = ?,money = ? where id = ?&quot;; // 执行sql jdbcTemplate.update(sql, account.getName(), account.getMoney(),account.getId()); &#125; @Override public void delete(Integer id) &#123; // 编写sql String sql = &quot;delete from account where id = ?&quot;; // 执行sql jdbcTemplate.update(sql, id); &#125;&#125; 4）编写AccountService接口和实现类 1234567public interface AccountService &#123; public List&lt;Account&gt; findAll(); public Account findById(Integer id); public void save(Account account); public void update(Account account); public void delete(Integer id);&#125; 12345678910111213141516171819202122232425@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() &#123; return accountDao.findAll(); &#125; @Override public Account findById(Integer id) &#123; return accountDao.findById(id); &#125; @Override public void save(Account account) &#123; accountDao.save(account); &#125; @Override public void update(Account account) &#123; accountDao.update(account); &#125; @Override public void delete(Integer id) &#123; accountDao.delete(id); &#125;&#125; 5）编写spring核心配置文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.lagou&quot;/&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 6）编写测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AccountServiceTest &#123; @Autowired private AccountService accountService; //测试保存 @Test public void testSave() &#123; Account account = new Account(); account.setName(&quot;lucy&quot;); account.setMoney(100d); accountService.save(account); &#125; //测试查询 @Test public void testFindById() &#123; Account account = accountService.findById(3); System.out.println(account); &#125; //测试查询所有 、 @Test public void testFindAll() &#123; List&lt;Account&gt; accountList = accountService.findAll(); for (Account account : accountList) &#123; System.out.println(account); &#125; &#125; //测试修改 @Test public void testUpdate() &#123; Account account = new Account(); account.setId(3); account.setName(&quot;rose&quot;); account.setMoney(2000d); accountService.update(account); &#125; //测试删除 @Test public void testDelete() &#123; accountService.delete(3); &#125;&#125; 1.4 实现转账案例步骤分析 创建java项目，导入坐标 编写Account实体类 编写AccountDao接口和实现类 编写AccountService接口和实现类 编写spring核心配置文件 编写测试代码 1）创建java项目，导入坐标 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）编写Account实体类 123456public class Account &#123; private Integer id; private String name; private double money; // setter getter....&#125; 3）编写AccountDao接口和实现类 1234public interface AccountDao &#123; public void out(String outUser, double money); public void in(String inUser, double money);&#125; 12345678910111213@Repository public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public void out(String outUser, double money) &#123; jdbcTemplate.update(&quot;update account set money = money - ? where name = ?&quot;, money, outUser); &#125; @Override public void in(String inUser, double money) &#123; jdbcTemplate.update(&quot;update account set money = money + ? where name = ?&quot;, money, inUser); &#125;&#125; 4）编写AccountService接口和实现类 123public interface AccountService &#123; public void transfer(String outUser, String inUser, double money);&#125; 12345678910@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public void transfer(String outUser, String inUser, double money) &#123; accountDao.out(outUser, money); accountDao.in(inUser, money); &#125;&#125; 5）编写spring核心配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--IOC注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou&quot;/&gt; &lt;!--加载jdbc配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--把数据库连接池交给IOC容器--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--把JdbcTemplate交给IOC容器--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 6）编写测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws Exception &#123; accountService.transfer(&quot;tom&quot;, &quot;jerry&quot;, 100d); &#125;&#125; 2. Spring的事务2.1 Spring中的事务控制方式Spring的事务控制可以分为编程式事务控制和声明式事务控制。 编程式开发者直接把事务的代码和业务代码耦合到一起，在实际开发中不用。 声明式开发者采用配置的方式来实现的事务控制，业务代码与事务代码实现解耦合，使用的AOP思想。 2.2 编程式事务控制相关对象【了解】2.2.1 PlatformTransactionManagerPlatformTransactionManager接口，是spring的事务管理器，里面提供了我们常用的操作事务的方法。 方法 说明 TransactionStatus getTransaction(TransactionDefinition definition) 获取事务的状态信息 void commit(TransactionStatus status)； 提交事务 void rollback(TransactionStatus status)； 回滚事务 注意 PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类。 Dao层技术是jdbcTemplate或mybatis时： DataSourceTransactionManager Dao层技术是hibernate时： HibernateTransactionManager Dao层技术是JPA时： JpaTransactionManager 2.2.2 TransactionDefinitionTransactionDefinition接口提供事务的定义信息（事务隔离级别、事务传播行为等等） 方法 说明 int getIsolationLevel() 获得事务的隔离级别 int getPropogationBehavior() 获得事务的传播行为 int getTimeout() 获得超时时间 boolean isReadOnly() 是否只读 1）事务隔离级别 设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读（幻读）。 ISOLATION_DEFAULT 使用数据库默认级别 ISOLATION_READ_UNCOMMITTED 读未提交 ISOLATION_READ_COMMITTED 读已提交 ISOLATION_REPEATABLE_READ 可重复读 ISOLATION_SERIALIZABLE 串行化 2）事务传播行为 事务传播行为指的就是当一个业务方法【被】另一个业务方法调用时，应该如何进行事务控制。 参数 说明 REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW 新建事务，如果当前在事务中，把当前事务挂起 NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER 以非事务方式运行，如果当前存在事务，抛出异常 NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED 类似的操作 read-only（是否只读）：建议查询时设置为只读 timeout（超时时间）：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 2.2.3 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态。 方法 说明 boolean isNewTransaction() 是否是新事务 boolean hasSavepoint() 是否是回滚点 boolean isRollbackOnly() 事务是否回滚 boolean isCompleted() 事务是否完成 可以简单的理解三者的关系：事务管理器通过读取事务定义参数进行事务管理，然后会产生一系列的事务状态。 2.2.4 实现代码1）配置文件 1234&lt;!--事务管理器交给IOC--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 2）业务层代码 1234567891011121314151617181920212223242526272829303132333435363738394041@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Autowired private PlatformTransactionManager transactionManager; @Override public void transfer(String outUser, String inUser, double money) &#123; // 创建事务定义对象 DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // 设置是否只读，false支持事务 def.setReadOnly(false); // 设置事务隔离级别，可重复读mysql默认级别 def.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ); // 设置事务传播行为，必须有事务 def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); // 配置事务管理器 TransactionStatus status = transactionManager.getTransaction(def); try &#123; // 转账 accountDao.out(outUser, money); accountDao.in(inUser, money); // 提交事务 transactionManager.commit(status); &#125; catch (Exception e) &#123; e.printStackTrace(); // 回滚事务 figuration(&quot;classpath:applicationContext.xml&quot;) public class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws Exception &#123; accountService.transfer(&quot;tom&quot;, &quot;jerry&quot;, 100d); &#125; &#125; transactionManager.rollback(status); &#125; &#125;&#125; 2.2.5 知识小结Spring中的事务控制主要就是通过这三个API实现的 PlatformTransactionManager 负责事务的管理，它是个接口，其子类负责具体工作 TransactionDefinition 定义了事务的一些相关参数 TransactionStatus 代表事务运行的一个实时状态 理解三者的关系：事务管理器通过读取事务定义参数进行事务管理，然后会产生一系列的事务状态。 2.3 基于XML的声明式事务控制【重点】在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。底层采用AOP思想来实现的。 声明式事务控制明确事项： 核心业务代码(目标对象) （切入点是谁？） 事务增强代码(Spring已提供事务管理器)）（通知是谁？） 切面配置（切面如何配置？） 2.3.1 快速入门 需求使用spring声明式事务控制转账业务。 步骤分析 引入tx命名空间 事务管理器通知配置 事务管理器AOP配置 测试事务控制转账业务代码 1）引入tx命名空间 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w2.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;/beans&gt; 2）事务管理器通知配置 1234567891011&lt;!--事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--通知增强--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!--定义事务的属性--&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 3）事务管理器AOP配置 12345&lt;!--aop配置--&gt;&lt;aop:config&gt; &lt;!--切面配置--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.lagou.serivce..*.*(..))&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 4）测试事务控制转账业务代码 1234567@Override public void transfer(String outUser, String inUser, double money) &#123; accountDao.out(outUser, money); // 制造异常 int i = 1 / 0; accountDao.in(inUser, money);&#125; 2.3.2 事务参数的配置详解 name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 1234567&lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot; /&gt; CRUD常用配置 1234567&lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot;/&gt;&lt;/tx:attributes&gt; 2.3.3 知识小结 平台事务管理器配置 事务通知的配置 事务aop织入的配置 2.4 基于注解的声明式事务控制【重点】2.4.1 常用注解步骤分析 修改service层，增加事务注解 修改spring核心配置文件，开启事务注解支持 1）修改service层，增加事务注解 123456789101112@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.REPEATABLE_READ, timeout = -1, readOnly = false) @Override public void transfer(String outUser, String inUser, double money) &#123; accountDao.out(outUser, money); int i = 1 / 0; accountDao.in(inUser, money); &#125;&#125; 2）修改spring核心配置文件，开启事务注解支持 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w2.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--省略之前datsSource、jdbcTemplate、组件扫描配置--&gt; &lt;!--事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--事务的注解支持--&gt; &lt;tx:annotation-driven/&gt;&lt;/beans&gt; 2.4.2 纯注解核心配置类 12345678910111213141516@Configuration // 声明为spring配置类 @ComponentScan(&quot;com.lagou&quot;) // 扫描包 @Import(DataSourceConfig.class) // 导入其他配置类 @EnableTransactionManagement // 事务的注解驱动 public class SpringConfig &#123; @Bean public JdbcTemplate getJdbcTemplate(@Autowired DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(&quot;transactionManager&quot;) public PlatformTransactionManager getPlatformTransactionManager(@Autowired DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 数据源配置类 1234567891011121314151617181920@PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 2.4.3 知识小结 平台事务管理器配置（xml、注解方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven/、@EnableTransactionManagement 3. Spring集成web环境3.1 ApplicationContext应用上下文获取方式应用上下文对象是通过 new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写 new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 解决思路分析： 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 3.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： 在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） 使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 3.3 实现1）导入Spring集成web的坐标 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）配置ContextLoaderListener监听器 123456789&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;• &lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 3）通过工具获得应用上下文对象 12ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);Object obj = applicationContext.getBean(&quot;id&quot;);","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"AOP面向切面","slug":"AOP面向切面","date":"2021-04-18T09:12:04.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2021/04/18/AOP面向切面/","link":"","permalink":"http://yournotes.cn/2021/04/18/AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2/","excerpt":"","text":"1. 转账案例 先通过一个转账案例在没有AOP的情况下，体验是如何通过基本的代理去实现这样的场景，最后在了解AOP，通过AOP再次实现一次 需求 使用spring框架整合DBUtils技术，实现用户转账功能 1.1 基础功能步骤分析 创建java项目，导入坐标 编写Account实体类 编写AccountDao接口和实现类 编写AccountService接口和实现类 编写spring核心配置文件 编写测试代码 1）创建java项目，导入坐标 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2） 编写Account实体类 123456public class Account &#123; private Integer id; private String name; private double money; // setter getter.... &#125; 3）编写AccountDao接口和实现类 123456public interface AccountDao &#123; // 转出操作 public void out(String outUser, double money); // 转入操作 public void in(String inUser, double money);&#125; 1234567891011121314151617181920212223@Repository public class AccountDaoImpl implements AccountDao &#123; @Autowired private QueryRunner queryRunner; @Override public void out(String outUser, double money) &#123; try &#123; queryRunner.update(&quot;update account set money=money-? where name=?&quot;, money, outUser); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void in(String inUser, double money) &#123; try &#123; queryRunner.update(&quot;update account set money=money+? where name=?&quot;, money, inUser); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4）编写AccountService接口和实现类 123public interface AccountService &#123; public void transfer(String outUser, String inUser, double money);&#125; 12345678910@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public void transfer(String outUser, String inUser, double money) &#123; accountDao.out(outUser, money); accountDao.in(inUser, money); &#125;&#125; 5）编写spring核心配置文件 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou&quot;/&gt; &lt;!--加载jdbc配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--把数据库连接池交给IOC容器--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--把QueryRunner交给IOC容器--&gt; &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 6）编写测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws Exception &#123; accountService.transfer(&quot;tom&quot;, &quot;jerry&quot;, 100d); &#125;&#125; 7）问题分析 上面的代码事务在dao层，转出转入操作都是一个独立的事务，但实际开发，应该把业务逻辑控制在一个事务中，所以应该将事务挪到service层。 3.2 传统事务步骤分析 编写线程绑定工具类 编写事务管理器 修改service层代码 修改dao层代码 1）编写线程绑定工具类 12345678910111213141516171819202122232425262728293031323334353637/** * 连接工具类，从数据源中获取一个连接，并将实现和线程的绑定 */@Component public class ConnectionUtils &#123; private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;(); @Autowired private DataSource dataSource; /** * 获取当前线程上的连接 * * @return Connection */ public Connection getThreadConnection() &#123; // 1.先从ThreadLocal上获取 Connection connection = threadLocal.get(); // 2.判断当前线程是否有连接 if (connection == null) &#123; try &#123; // 3.从数据源中获取一个连接，并存入到ThreadLocal中 connection = dataSource.getConnection(); threadLocal.set(connection); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return connection; &#125; /*** 解除当前线程的连接绑定 */ public void removeThreadConnection() &#123; threadLocal.remove(); &#125;&#125; 2）编写事务管理器 12345678910111213141516171819202122232425262728293031323334353637383940/** * 事务管理器工具类，包含：开启事务、提交事务、回滚事务、释放资源 */@Component public class TransactionManager &#123; @Autowired private ConnectionUtils connectionUtils; public void beginTransaction() &#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void commit() &#123; try &#123; connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void rollback() &#123; try &#123; connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void release() &#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(true);// 改回自 动提交事务 connectionUtils.getThreadConnection().close();// 归还到连接池 connectionUtils.removeThreadConnection();// 解除线程绑定 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3）修改service层代码 1234567891011121314151617181920212223242526272829@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Autowired private TransactionManager transactionManager; @Override public void transfer(String outUser, String inUser, double money) &#123; try &#123; // 1.开启事务 transactionManager.beginTransaction(); // 2.业务操作 accountDao.out(outUser, money); int i = 1 / 0; accountDao.in(inUser, money); // 3.提交事务 transactionManager.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 4.回滚事务 transactionManager.rollback(); &#125; finally &#123; // 5.释放资源 transactionManager.release(); &#125; &#125;&#125; 4）修改dao层代码 12345678910111213141516171819202122232425@Repositorypublic class AccountDaoImpl implements AccountDao &#123; @Autowired private QueryRunner queryRunner; @Autowired private ConnectionUtils connectionUtils; @Override public void out(String outUser, double money) &#123; try &#123; queryRunner.update(connectionUtils.getThreadConnection(), &quot;update account set money=money-? where name=?&quot;, money, outUser); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void in(String inUser, double money) &#123; try &#123; queryRunner.update(connectionUtils.getThreadConnection(), &quot;update account set money=money+? where name=?&quot;, money, inUser); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5）问题分析 上面代码，通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了一个新的问题： 业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了，违背了面向对象的开发思想。 2. Proxy优化转账案例我们可以将业务代码和事务代码进行拆分，通过动态代理的方式，对业务方法进行事务的增强。这样就不会对业务层产生影响，解决了耦合性的问题啦！ 常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术·：利用拦截器（必须实现invocationHandler）加上反射机制生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理，从而实现方法增强 CGLIB代理：基于父类的动态代理技术：动态生成一个要代理的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截技术拦截所有的父类方法的调用，顺势织入横切逻辑，对方法进行增强 2.1 JDK动态代理方式Jdk工厂类 123456789101112131415161718192021222324252627282930313233343536@Component public class JdkProxyFactory &#123; @Autowired private AccountService accountService; @Autowired private TransactionManager transactionManager; public AccountService createAccountServiceJdkProxy() &#123; AccountService accountServiceProxy = null; accountServiceProxy = (AccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; try &#123; // 1.开启事务 transactionManager.beginTransaction(); // 2.业务操作 result = method.invoke(accountService, args); // 3.提交事务 transactionManager.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 4.回滚事务 transactionManager.rollback()； &#125; finally &#123; // 5.释放资源 transactionManager.release(); &#125; return result; &#125; &#125; ); return accountServiceProxy; &#125;&#125; 测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AccountTest &#123; @Autowired private JdkProxyFactory jdkProxyFactory; @Test public void testTransfer() throws Exception &#123; AccountService accountServiceJdkProxy = jdkProxyFactory.createAccountServiceJdkProxy(); accountServiceJdkProxy.transfer(&quot;tom&quot;, &quot;jerry&quot;, 100d); &#125;&#125; 2.2 CGLIB动态代理方式Cglib工厂类 1234567891011121314151617181920212223242526272829303132333435363738394041@Component public class CglibProxyFactory &#123; @Autowired private AccountService accountService; @Autowired private TransactionManager transactionManager; public AccountService createAccountServiceCglibProxy() &#123; AccountService accountServiceProxy = null; /* * 参数一：目标对象的字节码对象 * 参数二：动作类，实现增强功能 * */ accountServiceProxy = (AccountService) Enhancer.create(accountService.getClass(), new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; Object result = null; try &#123; // 1.开启事务 transactionManager.beginTransaction(); // 2.业务操作 result = method.invoke(accountService, objects); // 3.提交事务 transactionManager.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 4.回滚事务 transactionManager.rollback(); &#125; finally &#123; // 5.释放资源 transactionManager.release(); &#125; return result; &#125; &#125; ); return accountServiceProxy; &#125;&#125; 测试代码 1234567891011@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AccountServiceTest &#123; @Autowired private CglibProxyFactory cglibProxyFactory; @Test public void testTransfer() throws Exception &#123; AccountService accountServiceCglibProxy = cglibProxyFactory.createAccountServiceCglibProxy(); accountServiceCglibProxy.transfer(&quot;tom&quot;, &quot;jerry&quot;, 100d); &#125;&#125; 3. 初识AOP3.1 什么是AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程 AOP 是 OOP（面向对象编程） 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 这样做的好处是： 在程序运行期间，在不修改源码的情况下对方法进行功能增强 逻辑清晰，开发核心业务的时候，不必关注增强业务的代码 减少重复代码，提高开发效率，便于后期维护 3.2 AOP底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 3.3 AOP相关术语Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些可以被拦截到的点。在spring中,这些点指的是方法，因为 spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 Advice（通知&#x2F; 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 分类：前置通知、后置通知、异常通知、最终通知、环绕通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织 入，而AspectJ采用编译期织入和类装载期织入 3.4 AOP开发明确事项3.4.1 开发阶段（自己做的） 编写核心业务代码（目标类的目标方法） 切入点 把公用代码抽取出来，制作成通知（增强功能方法） 通知 在配置文件中，声明切入点与通知间的关系，即切面 3.4.2 运行阶段（Spring框架完成的）Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 3.4.3 底层代理实现在 Spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 当bean实现接口时，会用JDK代理模式 当bean没有实现接口，用cglib实现（ 可以强制使用cglib（在spring配置中加入&lt;aop:aspectj\u0002autoproxy proxyt-target-class&#x3D;”true”&#x2F;&gt;） 3.5 知识小结 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念： Pointcut（切入点）：真正被增强的方法 Advice（通知&#x2F; 增强）：封装增强业务逻辑的方法 Aspect（切面）：切点+通知 Weaving（织入）：将切点与通知结合，产生代理对象的过程 4. 基于XML的AOP开发4.1 快速入门步骤分析 创建java项目，导入AOP相关坐标 创建目标接口和目标实现类（定义切入点） 创建通知类及方法（定义通知） 将目标类和通知类对象创建权交给spring 在核心配置文件中配置织入关系，及切面 编写测试代码 4.1.1 创建java项目，导入AOP相关坐标12345678910111213141516171819202122232425dependencies&gt; &lt;!--导入spring的context坐标，context依赖aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj的织入（切点表达式需要用到该jar包） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring整合junit--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.1.2 创建目标接口和目标实现类123public interface AccountService &#123; public void transfer();&#125; 123456public class AccountServiceImpl implements AccountService &#123; @Override public void transfer() &#123; System.out.println(&quot;转账业务...&quot;); &#125;&#125; 4.1.3 创建通知类12345public class MyAdvice &#123; public void before() &#123; System.out.println(&quot;前置通知...&quot;); &#125;&#125; 4.1.4 将目标类和通知类对象创建权交给spring1234&lt;!--目标类交给IOC容器--&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.lagou.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;&lt;!--通知类交给IOC容器--&gt;&lt;bean id=&quot;myAdvice&quot; class=&quot;com.lagou.advice.MyAdvice&quot;&gt;&lt;/bean&gt; 4.1.5 在核心配置文件中配置织入关系，及切面1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--目标类交给IOC容器--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.lagou.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!--通知类交给IOC容器--&gt; &lt;bean id=&quot;myAdvice&quot; class=&quot;com.lagou.advice.MyAdvice&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!--引入通知类--&gt; &lt;aop:aspect ref=&quot;myAdvice&quot;&gt; &lt;!--配置目标类的transfer方法执行时，使用通知类的before方法进行前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.lagou.service.impl.AccountServiceImpl.transfer())&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.1.6 编写测试代码123456789@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws Exception &#123; accountService.transfer(); &#125;&#125; 4.2 XML配置AOP详解4.2.1 切点表达式表达式语法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 1234567execution(public void com.lagou.service.impl.AccountServiceImpl.transfer()) execution(void com.lagou.service.impl.AccountServiceImpl.*(..)) execution(* com.lagou.service.impl.*.*(..)) execution(* com.lagou.service..*.*(..)) 切点表达式抽取 当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替pointcut 属性来引用抽取后的切点表达式。 1234567&lt;aop:config&gt; &lt;!--抽取的切点表达式--&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lagou.service..*.* (..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;aop:aspect ref=&quot;myAdvice&quot;&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 4.2.2 通知类型通知的配置语法： 1&lt;aop:通知类型 method=“通知类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 aop:before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 aop:afterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 异常通知 aop:afterThrowing 用于配置异常通知。指定增强的方法出现异常后执行 最终通知 aop:after 用于配置最终通知。无论切入点方法执行时是否有异常，都会执行 环绕通知 aop:around 用于配置环绕通知。开发者可以手动控制增强代码在什么时候执行 注意：通常情况下，环绕通知都是独立使用的 4.3 知识小结 aop织入的配置 12345&lt;aop:config&gt; &lt;aop:aspect ref=“通知类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型 前置通知、后置通知、异常通知、最终通知 环绕通知 切点表达式 execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 5. 基于注解的AOP开发5.1 快速入门步骤分析 创建java项目，导入AOP相关坐标 创建目标接口和目标实现类（定义切入点） 创建通知类（定义通知） 将目标类和通知类对象创建权交给spring 在通知类中使用注解配置织入关系，升级为切面类 在配置文件中开启组件扫描和 AOP 的自动代理 编写测试代码 5.1.1 创建java项目，导入AOP相关坐标12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;!--导入spring的context坐标，context依赖aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj的织入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring整合junit--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5.1.2 创建目标接口和目标实现类123public interface AccountService &#123; public void transfer();&#125; 123456public class AccountServiceImpl implements AccountService &#123; @Override public void transfer() &#123; System.out.println(&quot;转账业务...&quot;); &#125;&#125; 5.1.3 创建通知类12345public class MyAdvice &#123; public void before() &#123; System.out.println(&quot;前置通知...&quot;); &#125;&#125; 5.1.4 将目标类和通知类对象创建权交给spring1234567@Service public class AccountServiceImpl implements AccountService &#123;&#125;@Component public class MyAdvice &#123;&#125; 5.1.5 在通知类中使用注解配置织入关系，升级为切面类12345678@Component @Aspect public class MyAdvice &#123; @Before(&quot;execution(* com.lagou..*.*(..))&quot;) public void before() &#123; System.out.println(&quot;前置通知...&quot;); &#125;&#125; 5.1.6 在配置文件中开启组件扫描和 AOP 的自动代理1234&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.lagou&quot;/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 5.1.7 编写测试代码12345678910@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws Exception &#123; accountService.transfer(); &#125;&#125; 5.2 注解配置AOP详解5.2.1 切点表达式切点表达式的抽取 1234567891011@Component @Aspect public class MyAdvice &#123; @Pointcut(&quot;execution(* com.lagou..*.*(..))&quot;) public void myPoint()&#123; &#125; @Before(&quot;MyAdvice.myPoint()&quot;) public void before() &#123; System.out.println(&quot;前置通知...&quot;); &#125;&#125; 5.2.2 通知类型通知的配置语法：@通知注解(“切点表达式”) 名称 标签 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 异常通知 @AfterThrowing 用于配置异常通知。指定增强的方法出现异常后执行 最终通知 @After 用于配置最终通知。无论切入点方法执行时是否有异常，都会执行 环绕通知 @Around 用于配置环绕通知。开发者可以手动控制增强代码在什么时候执行 注意 当前四个通知组合在一起时，执行顺序如下： @Before -&gt; @After -&gt; @AfterReturning（如果有异常：@AfterThrowing） 5.2.3 纯注解配置12345@Configuration @ComponentScan(&quot;com.lagou&quot;) @EnableAspectJAutoProxy //替代 &lt;aop:aspectj-autoproxy /&gt; public class SpringConfig &#123;&#125; 5.3 知识小结 使用@Aspect注解，标注切面类 使用@Before等注解，标注通知方法 使用@Pointcut注解，抽取切点表达式 配置aop自动代理 &lt;aop:aspectj-autoproxy/&gt; 或 @EnableAspectJAutoProxy 6. AOP优化转账案例依然使用前面的转账案例，将两个代理工厂对象直接删除！改为spring的aop思想来实现 6.1 xml配置实现1）配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou&quot;/&gt; &lt;!--加载jdbc配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--把数据库连接池交给IOC容器--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--把QueryRunner交给IOC容器--&gt; &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--AOP配置--&gt; &lt;aop:config&gt; &lt;!--切点表达式--&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lagou.service..*.*(..))&quot;/&gt; &lt;!-- 切面配置 --&gt; &lt;aop:aspect ref=&quot;transactionManager&quot;&gt; &lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2）事务管理器（通知） 12345678910111213141516171819202122232425262728293031323334353637383940// 事务管理器工具类，包括：开启事务、提交事务、回滚事务、释放资源 、@Component public class TransactionManager &#123; @Autowired ConnectionUtils connectionUtils; public void begin()&#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void commit()&#123; try &#123; connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void rollback()&#123; try &#123; connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void release()&#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(true); connectionUtils.getThreadConnection().close(); connectionUtils.removeThreadConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 6.2 注解配置实现1）配置文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou&quot;/&gt; &lt;!--开启AOP注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--加载jdbc配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--把数据库连接池交给IOC容器--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--把QueryRunner交给IOC容器--&gt; &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 2）事务管理器（通知） 123456789101112131415161718192021222324252627282930313233343536373839@Component @Aspectpublic class TransactionManager &#123; @Autowired ConnectionUtils connectionUtils; @Around(&quot;execution(* com.lagou.serivce..*.*(..))&quot;) public Object around(ProceedingJoinPoint pjp) &#123; Object object = null; try &#123; // 开启事务 connectionUtils.getThreadConnection().setAutoCommit(false); // 业务逻辑 pjp.proceed(); // 提交事务 connectionUtils.getThreadConnection().commit(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); // 回滚事务 try &#123; connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(true); connectionUtils.getThreadConnection().close(); connectionUtils.removeThreadConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return object; &#125;&#125;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"LeetCode初级算法之设计问题：155.最小栈","slug":"最小栈","date":"2021-04-12T03:08:45.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2021/04/12/最小栈/","link":"","permalink":"http://yournotes.cn/2021/04/12/%E6%9C%80%E5%B0%8F%E6%A0%88/","excerpt":"","text":"题目信息 题目地址:https://leetcode-cn.com/problems/min-stack/ 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解法一：添加辅助栈首先是具备栈的基本操作,除此之外添加了个获取最小元素的方法,也就是我们需要记录最小元素,但栈的元素变动有两种一种是入栈一种是出栈,这两种情况都会影响最小元素.所以我们没办法只用一个变量来记录最小值因为会回退,必须是容器存每个阶段最小值且变化逻辑与数据栈同步,这样一想的话就是再用一个栈呗. 如图: 这样的话，我们就是用另外一个栈记录最小值，并且可以跟随数据栈的变化回退或者添加，最终另外栈的顶部就是当前的最小值 下面我先手动实现个简单的栈再操作（因为是有两个栈都有基本操作，所以直接写在解题类里就会有重复，因此把栈的操作提出来），也可以就用java包的栈 12345678910111213141516171819202122232425262728class MyStack &#123; private int[] data; private int size = -1; public MyStack() &#123; //data = new int[10000]; data = new int[50]; &#125; public void push(int x) &#123; // 是否需要扩容 size++; if (size&gt;data.length-1) &#123; data=Arrays.copyOf(data, data.length*2); &#125; data[size] = x; &#125; public void pop() &#123; size--; &#125; public int peek() &#123; if(!isEmpty())&#123; // 抛异常 &#125; return data[size]; &#125; public Boolean isEmpty()&#123; return size &lt; 0; &#125;&#125; 再用这个栈去是实现我们的最小栈：在入栈时判断当前元素是否比最小栈的栈顶要小，出栈时判断当前元素是否是最小栈的栈顶。 1234567891011121314151617181920212223242526class MinStack &#123; MyStack data; MyStack min; public MinStack() &#123; data = new MyStack(); min = new MyStack(); &#125; public void push(int x) &#123; data.push(x); if(min.isEmpty() || x &lt;= min.peek())&#123; min.push(x); &#125; &#125; public void pop() &#123; if(data.peek() == min.peek())&#123; min.pop(); &#125; data.pop(); &#125; public int top() &#123; return data.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125; 时间复杂度：只有栈的操作，无论是弹出还是压栈都是O(1)的操作空间复杂度：定义了两个栈需要去存储数据，最差情况是2n，因此空间复杂度为O(n) 解法二：封装元素数据与解法一一个逻辑，既然两个栈是同步的关系，把辅助栈的数据放到到通一个栈也可以。每个元素是一个对象其中不仅包含当前数值也包含当前最小栈里最小值 12345678910111213141516class StackNode&#123; private int value; private int min; public void setValue(int value)&#123; this.value = value; &#125; public void setMin(int min)&#123; this.min = min; &#125; public int getValue()&#123; return value; &#125; public int getMin()&#123; return min; &#125;&#125; 代码如下： 12345678910111213141516171819202122232425class MinStack &#123; MyStack&lt;StackNode&gt; data; public MinStack() &#123; data = new MyStack&lt;StackNode&gt;(); &#125; public void push(int x) &#123; StackNode node = new StackNode(); node.setValue(x); if(data.isEmpty() || x &lt;= data.peek().getMin())&#123; node.setMin(x); &#125; else&#123; node.setMin(data.peek().getMin()); &#125; data.push(node); &#125; public void pop() &#123; data.pop(); &#125; public int top() &#123; return data.peek().getValue(); &#125; public int getMin() &#123; return data.peek().getMin(); &#125;&#125; 判定点与解法一一样，只是放到了同一元素的第二属性。上面我们写的栈MyStack是写死的数据类型int数组，这里要全部换成StackNode不如就写个泛型的上面的解也是用的这个栈，如下： 12345678910111213141516171819202122232425262728class MyStack&lt;T&gt; &#123; private T[] data; private int size = -1; public MyStack() &#123; //data = new int[10000]; data = (T[])new Object[50]; &#125; public void push(T x) &#123; // 是否需要扩容 size++; if (size&gt;data.length-1) &#123; data=Arrays.copyOf(data, data.length*2); &#125; data[size] = x; &#125; public void pop() &#123; size--; &#125; public T peek() &#123; if(!isEmpty())&#123; // 抛异常 &#125; return data[size]; &#125; public Boolean isEmpty()&#123; return size &lt; 0; &#125;&#125; 时间复杂度和空间复杂度与解一一样分别是O(1)与O(n) 总结总体上是比较简单可以快的找到思路的，同时也多熟悉熟悉栈的数据结构。这次动图是用adobe的an画的以后大概都会用这个做。设计问题的两题就完结了下篇开始初级的合集的数学问题","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"Spring IOC控制反转","slug":"Spring-IOC控制反转","date":"2021-04-11T03:32:47.000Z","updated":"2025-04-17T08:34:52.017Z","comments":true,"path":"2021/04/11/Spring-IOC控制反转/","link":"","permalink":"http://yournotes.cn/2021/04/11/Spring-IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"1. Spring概述1.1 Spring是什么Spring是分层的 Java SE&#x2F;EE应用 full-stack(全栈式) 轻量级开源框架。 提供了表现层 SpringMVC和持久层 Spring JDBC Template以及 业务层 事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 两大核心: 以 IOC（Inverse Of Control：控制反转）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 1.2 Spring发展历程EJB 1997 年，IBM提出了EJB 的思想 1998 年，SUN制定开发标准规范 EJB1.0 1999 年，EJB1.1 发布 2001 年，EJB2.0 发布 2003 年，EJB2.1 发布 2006 年，EJB3.0 发布 Spring Rod Johnson（ Spring 之父） 改变Java世界的大师级人物 2002年编著《Expert one on one J2EE design and development》 指出了JavaEE和EJB组件框架中的存在的一些主要缺陷；提出普通java类依赖注入更为简单的解 决方案。 2004年编著《Expert one-on-one J2EE Development without EJB》 阐述了JavaEE开发时不使用EJB的解决方式（Spring 雏形） 同年4月spring1.0诞生 2006年10月，发布 Spring2.0 2009年12月，发布 Spring3.0 2013年12月，发布 Spring4.0 2017年9月， 发布最新 Spring5.0 通用版（GA） 1.3 Spring优势1）方便解耦，简化开发 Spring就是一个容器，可以将所有对象创建和关系维护交给Spring管理 什么是耦合度？对象之间的关系，通常说当一个模块(对象)更改时也需要更改其他模块(对象)，这就是 耦合，耦合度过高会使代码的维护成本增加。要尽量解耦 2）AOP编程的支持 Spring提供面向切面编程，方便实现程序进行权限拦截，运行监控等功能。 3）声明式事务的支持 通过配置完成事务的管理，无需手动编程 4）方便测试，降低JavaEE API的使用 Spring对Junit4支持，可以使用注解测试 5）方便集成各种优秀框架 不排除各种优秀的开源框架，内部提供了对各种优秀框架的直接支持 Spring体系结构 2. 初识IOC2.1 概述**控制反转（Inverse Of Control）**不是什么技术，而是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。 控制：在java中指的是对象的控制权限（创建、销毁反转：指的是对象控制权由原来 由开发者在类中手动控制 反转到 由Spring容器控制 举个栗子 传统方式 之前我们需要一个userDao实例，需要开发者自己手动创建 new UserDao(); IOC方式 现在我们需要一个userDao实例，直接从spring的IOC容器获得，对象的创建权交给了spring控制 2.2 自定义IOC容器2.2.1 介绍需求 实现service层与dao层代码解耦合 步骤分析 创建java项目，导入自定义IOC相关坐标 编写Dao接口和实现类 编写Service接口和实现类 编写测试代码 2.2.2 实现1）创建java项目，导入自定义IOC相关坐标 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）编写Dao接口和实现类 123public interface UserDao &#123; public void save();&#125; 12345public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;保存成功了...&quot;); &#125;&#125; 3）编写Service接口和实现类 123public interface UserService &#123; public void save();&#125; 1234567public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void save()&#123; userDao = new UserDaoImpl(); userDao.save(); &#125;&#125; 4）编写测试代码 1234567public class UserTest &#123; @Test public void testSave() throws Exception &#123; UserService userService = new UserServiceImpl(); userService.save(); &#125;&#125; 5）问题 当前service对象和dao对象耦合度太高，而且每次new的都是一个新的对象，导致服务器压力过大。 解耦合的原则是编译期不依赖，而运行期依赖就行了。 6）编写beans.xml 把所有需要创建对象的信息定义在配置文件中 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 7）编写BeanFactory工具类 12345678910111213141516171819202122232425262728293031public class BeanFactory &#123; private static Map&lt;String, Object&gt; ioc = new HashMap&lt;&gt;(); // 程序启动时，初始化对象实例 static &#123; try &#123; // 1.读取配置文件 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;beans.xml&quot;); // 2.解析xml SAXReader saxReader = new SAXReader(); Document document = saxReader.read(in); // 3.编写xpath表达式 String xpath = &quot;//bean&quot;; // 4.获取所有的bean标签 List&lt;Element&gt; list = document.selectNodes(xpath); // 5.遍历并创建对象实例，设置到map集合中 for (Element element : list) &#123; String id = element.attributeValue(&quot;id&quot;); String className = element.attributeValue(&quot;class&quot;); Object object = Class.forName(className).newInstance(); ioc.put(id, object); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 获取指定id的对象实例 public static Object getBean(String beandId) &#123; return ioc.get(beandId); &#125;&#125; 8）修改UserServiceImpl实现类 1234567public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void save() throws Exception &#123; userDao = (UserDao) BeanFactory.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; 2.2.3 知识小结 其实升级后的BeanFactory就是一个简单的Spring的IOC容器所具备的功能。 之前我们需要一个userDao实例，需要开发者自己手动创建 new UserDao(); 现在我们需要一个userdao实例，直接从spring的IOC容器获得，对象的创建权交给了spring控制 最终目标：代码解耦合 3. Spring快速入门3.1 介绍**需求：**借助spring的IOC实现service层与dao层代码解耦合 步骤分析 创建java项目，导入spring开发基本坐标 编写Dao接口和实现类 创建spring核心配置文件 在spring配置文件中配置 UserDaoImpl 使用spring相关API获得Bean实例 3.2 实现1）创建java项目，导入spring开发基本坐标 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2）编写Dao接口和实现类 123public interface UserDao &#123; public void save();&#125; 12345public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;保存成功了...&quot;); &#125;&#125; 3）创建spring核心配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 4）在spring配置文件中配置 UserDaoImpl 123&lt;beans ...&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 5）使用spring相关API获得Bean实例 12345678public class UserTest &#123; @Test public void testSave() throws Exception &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; 3.3 知识小结Spring的开发步骤 导入坐标 创建Bean 创建applicationContext.xml 在配置文件中进行Bean配置 创建ApplicationContext对象，执行getBean 4. Spring相关API4.1 API继承体系介绍Spring的API体系异常庞大，我们现在只关注两个BeanFactory和ApplicationContext 4.2 BeanFactoryBeanFactory是 IOC 容器的核心接口，它定义了IOC的基本功能。 特点：在第一次调用getBean()方法时，创建指定对象的实例 1BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;)); 4.3 ApplicationContext代表应用上下文对象，可以获得spring中IOC容器的Bean对象。 特点：在spring容器启动时，加载并创建所有对象的实例 常用实现类 ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种。 FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 1ApplicationContext app =new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 常用方法 Object getBean(String name); 根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 &lt;T&gt; T getBean(Class&lt;T&gt; requiredType); 根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错 &lt;T&gt; T getBean(String name,Class&lt;T&gt; requiredType); 根据Bean的id和类型获得Bean实例，解决容器中相同类型Bean有多个情况。 4.4 知识小结123ApplicationContext app = new ClasspathXmlApplicationContext(&quot;xml文件&quot;); app.getBean(&quot;id&quot;); app.getBean(Class); 5. Spring配置文件5.1 Bean标签基本配置&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt; 用于配置对象交由Spring来创建。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名 默认情况下它调用的是类中的 无参构造函数，如果没有无参构造函数则不能创建成功。 5.2 Bean标签范围配置1&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt;&lt;/bean&gt; scope属性指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中 session WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中 global sessio WEB项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession 相当于session 1）当scope的取值为singleton时 Bean的实例化个数：1个 Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 Bean的实例化个数：多个 Bean的实例化时机：当调用getBean()方法时实例化Bean Bean的生命周期： 对象创建：对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 5.3 Bean生命周期配置&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;&lt;/bean&gt; init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 5.4 Bean实例化三种方式 无参构造方法实例化 工厂静态方法实例化 工厂普通方法实例化 5.4.1 无参构造方法实例化它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败 1&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;/&gt; 5.4.2 工厂静态方法实例化应用场景 依赖的jar包中有个A类，A类中有个静态方法m1，m1方法的返回值是一个B对象。如果我们频繁使用B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类中的m1方法，直接从IOC容器获得。 12345public class StaticFactoryBean &#123; public static UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 1&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 5.4.3 工厂普通方法实例化应用场景 依赖的jar包中有个A类，A类中有个普通方法m1，m1方法的返回值是一个B对象。如果我们频繁使用B对象， 此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类中的m1方法，直接从IOC容器获得。 12345public class DynamicFactoryBean &#123; public UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 12&lt;bean id=&quot;dynamicFactoryBean&quot; class=&quot;com.lagou.factory.DynamicFactoryBean&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;dynamicFactoryBean&quot; factory- method=&quot;createUserDao&quot;/&gt; 5.5 Bean依赖注入概述**依赖注入 DI（Dependency Injection）：**它是 Spring 框架核心 IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。简单的说，就是通过框架把持久层对象传入业务层，而不用我们自己去获取。 5.6 Bean依赖注入方式5.6.1 构造方法在UserServiceImpl中创建有参构造 12345678910public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 配置Spring容器调用有参构造时进行注入 12345&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.lagou.service.impl.UserServiceImpl&quot;&gt; &lt;!--&lt;constructor-arg index=&quot;0&quot; type=&quot;com.lagou.dao.UserDao&quot; ref=&quot;userDao&quot;/&gt;--&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; 5.6.2 set方法在UserServiceImpl中创建set方法 12345678910public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 配置Spring容器调用set方法进行注入 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.lagou.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; 5.6.3 P命名空间注入P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： 首先，需要引入P命名空间： 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式： 12&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.lagou.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 5.7 Bean依赖注入的数据类型上面操作，都是注入Bean对象，除了对象的引用可以注入，普通数据类型和集合都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的。下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 5.7.1 注入普通数据类型12345678910public class User &#123; private String username; private String age; public void setUsername(String username) &#123; this.username = username; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 1234&lt;bean id=&quot;user&quot; class=&quot;com.lagou.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;jack&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 5.7.2 注入集合数据类型1）List集合注入 1234567public class UserDaoImpl implements UserDao &#123; private List&lt;Object&gt; list; public void save() &#123; System.out.println(list); System.out.println(&quot;保存成功了...&quot;); &#125;&#125; 123456789101112&lt;bean id=&quot;user&quot; class=&quot;com.lagou.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;jack&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;ref bean=&quot;user&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 2）Set集合注入 12345678910public class UserDaoImpl implements UserDao &#123; private Set&lt;Object&gt; set; public void setSet(Set&lt;Object&gt; set) &#123; this.set = set; &#125; public void save() &#123; System.out.println(set); System.out.println(&quot;保存成功了...&quot;); &#125;&#125; 123456789101112&lt;bean id=&quot;user&quot; class=&quot;com.lagou.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;jack&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;set&quot;&gt; &lt;list&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;ref bean=&quot;user&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 3）Array数组注入 12345678910public class UserDaoImpl implements UserDao &#123; private Object[] array; public void setArray(Object[] array) &#123; this.array = array; &#125; public void save() &#123; System.out.println(Arrays.toString(array)); System.out.println(&quot;保存成功了...&quot;); &#125;&#125; 123456789101112&lt;bean id=&quot;user&quot; class=&quot;com.lagou.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;jack&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;array&quot;&gt; &lt;array&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;ref bean=&quot;user&quot;&gt;&lt;/ref&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4）Map集合注入 12345678910public class UserDaoImpl implements UserDao &#123; private Map&lt;String, Object&gt; map; public void setMap(Map&lt;String, Object&gt; map) &#123; this.map = map; &#125; public void save() &#123; System.out.println(map); System.out.println(&quot;保存成功了...&quot;); &#125;&#125; 123456789101112&lt;bean id=&quot;user&quot; class=&quot;com.lagou.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;jack&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;k1&quot; value=&quot;ddd&quot;/&gt; &lt;entry key=&quot;k2&quot; value-ref=&quot;user&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 5）Properties配置注入 12345678910public class UserDaoImpl implements UserDao &#123; private Properties properties; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void save() &#123; System.out.println(properties); System.out.println(&quot;保存成功了...&quot;); &#125;&#125; 123456789&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt; &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt; &lt;prop key=&quot;k3&quot;&gt;v3&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 5.8 配置文件模块化实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，也就是所谓的配置文件模块化。 1）并列的多个配置文件 1ApplicationContext act = new ClassPathXmlApplicationContext(&quot;beans1.xml&quot;,&quot;beans2.xml&quot;,&quot;...&quot;); 2）主从配置文件 1&lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; 注意： 同一个xml中不能出现相同名称的bean,如果出现会报错 多个xml如果出现相同名称的bean，不会报错，但是后加载的会覆盖前加载的bean 5.9 知识小结Spring的重点配置 &lt;bean&gt;标签：创建对象并放到spring的IOC容器 id属性:在容器中Bean实例的唯一标识，不允许重复 class属性:要实例化的Bean的全限定名 scope属性:Bean的作用范围，常用是Singleton(默认)和prototype &lt;constructor-arg&gt;标签：属性注入 name属性：属性名称 value属性：注入的普通属性值 ref属性：注入的对象引用值 &lt;property&gt;标签：属性注入 name属性：属性名称 value属性：注入的普通属性值 ref属性：注入的对象引用值 &lt;list&gt; &lt;set&gt; &lt;array&gt; &lt;map&gt; &lt;props&gt; &lt;import&gt;标签:导入其他的Spring的分文件 6. DbUtils（IOC实战）6.1 DbUtils是什么？DbUtils是Apache的一款用于简化Dao代码的工具类，它底层封装了JDBC技术。 核心对象 1QueryRunner queryRunner = new QueryRunner(DataSource dataSource); 核心方法 int update(); 执行增、删、改语句 T query(); 执行查询语句 ResultSetHandler 这是一个接口，主要作用是将数据库返回的记录封装到实体对象 举个例子 查询数据库所有账户信息到Account实体中 123456789101112131415public class DbUtilsTest &#123; @Test public void findAllTest() throws Exception &#123; // 创建DBUtils工具类，传入连接池 QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); // 编写sql String sql = &quot;select * from account&quot;; // 执行sql List&lt;Account&gt; list = queryRunner.query(sql, new BeanListHandler&lt;Account&gt; (Account.class)); // 打印结果 for (Account account : list) &#123; System.out.println(account); &#125; &#125;&#125; 6.2 Spring的xml整合DbUtils6.2.1 介绍需求 基于Spring的xml配置实现账户的CRUD案例 步骤分析 准备数据库环境 创建java项目，导入坐标 编写Account实体类 编写AccountDao接口和实现类 编写AccountService接口和实现类 编写spring核心配置文件 编写测试代码 6.2.2 实现1）准备数据库环境 123456789101112131415CREATE DATABASE `spring_db`; USE `spring_db`; CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `money` double DEFAULT NULL, PRIMARY KEY (`id`)); insert into `account`(`id`, `name`, `money`) values (1, &#x27;tom&#x27;, 1000), (2, &#x27;jerry&#x27;, 1000); 2）创建java项目，导入坐标 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3）编写Account实体类 12345public class Account &#123; private Integer id; private String name; private double money;&#125; 4）编写AccountDao接口和实现类 1234567public interface AccountDao &#123; public List&lt;Account&gt; findAll(); public Account findById(Integer id); public void save(Account account); public void update(Account account); public void delete(Integer id);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class AccountDaoImpl implements AccountDao &#123; private QueryRunner queryRunner; public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; @Override public List&lt;Account&gt; findAll() &#123; List&lt;Account&gt; list = null; // 编写 sql String sql = &quot;select * from account&quot;; try &#123; // 执行sql list = queryRunner.query(sql, new BeanListHandler&lt;Account&gt; (Account.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; @Override public Account findById(Integer id) &#123; Account account = null; // 编写sql String sql = &quot;select * from account where id = ?&quot;; try &#123; // 执行sql account = queryRunner.query(sql, new BeanHandler&lt;Account&gt; (Account.class), id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return account; &#125; @Override public void save(Account account) &#123; // 编写sql String sql = &quot;insert into account values(null,?,?)&quot;; // 执行sql try &#123; queryRunner.update(sql, account.getName(), account.getMoney()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void update(Account account) &#123; // 编写sql String sql = &quot;update account set name = ?,money = ? where id = ?&quot;; // 执行sql try &#123; queryRunner.update(sql, account.getName(), account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void delete(Integer id) &#123; // 编写sql String sql = &quot;delete from account where id = ?&quot;; // 执行sql try &#123; queryRunner.update(sql, id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5）编写AccountService接口和实现类 1234567public interface AccountService &#123; public List&lt;Account&gt; findAll(); public Account findById(Integer id); public void save(Account account); public void update(Account account); public void delete(Integer id);&#125; 1234567891011121314151617181920212223242526public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public List&lt;Account&gt; findAll() &#123; return accountDao.findAll(); &#125; @Override public Account findById(Integer id) &#123; return accountDao.findById(id); &#125; @Override public void save(Account account) &#123; accountDao.save(account); &#125; @Override public void update(Account account) &#123; accountDao.update(account); &#125; @Override public void delete(Integer id) &#123; accountDao.delete(id); &#125;&#125; 6）编写spring核心配置文件 applicationContext.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--把数据库连接池交给IOC容器--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_db&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--把QueryRunner交给IOC容器--&gt; &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--把AccountDao交给IOC容器--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.lagou.dao.impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;queryRunner&quot; ref=&quot;queryRunner&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--把AccountService交给IOC容器--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.lagou.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 7）编写测试代码 12345678910111213141516171819202122232425262728293031323334353637383940public class AccountServiceTest &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); AccountService accountService = applicationContext.getBean(AccountService.class); //测试保存 @Test public void testSave() &#123; Account account = new Account(); account.setName(&quot;lucy&quot;); account.setMoney(100d); accountService.save(account); &#125; //测试查询 @Test public void testFindById() &#123; Account account = accountService.findById(3); System.out.println(account); &#125; //测试查询所有 @Testpublic void testFindAll() &#123; List&lt;Account&gt; accountList = accountService.findAll(); for (Account account : accountList) &#123; System.out.println(account); &#125; &#125; //测试修改 @Test public void testUpdate() &#123; Account account = new Account(); account.setId(3); account.setName(&quot;jack&quot;); account.setMoney(2000d); accountService.update(account); &#125; //测试删除 @Test public void testDelete() &#123; accountService.delete(3); &#125;&#125; 8）抽取jdbc配置文件 applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间： xmlns:context&#x3D;”http://www.springframework.org/schema/context“ 约束路径： http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 1234567&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 6.3 知识小结 DataSource的创建权交由Spring容器去完成 QueryRunner的创建权交由Spring容器去完成，使用构造方法传递DataSource Spring容器加载properties文件 &lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt; &lt;property name=&quot;&quot; value=&quot;${key}&quot;/&gt; 7. Spring注解开发Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 7.1 Spring常用注解7.1.1 介绍Spring常用注解主要是替代&lt;bean&gt;的配置 注释 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用,根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 说明： JDK11以后完全移除了javax扩展导致不能使用@resource注解 123456&lt;!--需要引入--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 7.1.2 实现1）Bean实例化（IOC） 1&lt;bean id=&quot;userDao&quot; class=&quot;com.lagou.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 12345// @Component(value = &quot;userDao&quot;) @Repository // 如果没有写value属性值，Bean的id为：类名首字母小写 public class UserDaoImpl implements UserDao &#123;&#125; 2）属性依赖注入（DI） 123&lt;bean id=&quot;userService&quot; class=&quot;com.lagou.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;/&gt;&lt;/bean&gt; 使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 123456789101112@Service public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; // &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;/&gt; // @Autowired // @Qualifier(&quot;userDaoImpl&quot;) // @Resource(name = &quot;userDaoImpl&quot;) public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 3）@Value 使用@Value进行字符串的注入，结合SPEL表达式获得配置参数 12345678@Service public class UserServiceImpl implements UserService &#123; @Value(&quot;注入普通数据&quot;) private String str; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver;&#125; 4）@Scope 1&lt;bean scope=&quot;&quot;/&gt; 使用@Scope标注Bean的范围 12345@Service @Scope(&quot;singleton&quot;) public class UserServiceImpl implements UserService &#123;&#125; 5）Bean生命周期 1&lt;bean init-method=&quot;init&quot; destroy-method=&quot;destory&quot; /&gt; 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 12345678@PostConstruct public void init()&#123; System.out.println(&quot;初始化方法....&quot;);&#125;@PreDestroy public void destroy()&#123; System.out.println(&quot;销毁方法.....&quot;);&#125; 7.2 Spring常用注解整合DbUtils步骤分析 拷贝xml配置项目，改为注解配置项目 修改AccountDaoImpl实现类 修改AccountServiceImpl实现类 修改spring核心配置文件 编写测试代码 1）拷贝xml配置项目，改为常用注解配置项目 过程略…. 2）修改AccountDaoImpl实现类 123456@Repository public class AccountDaoImpl implements AccountDao &#123; @Autowired private QueryRunner queryRunner; ....&#125; 3）修改AccountServiceImpl实现类 123456@Service public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; ....&#125; 4）修改spring核心配置文件 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w1.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--注解的组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lagou&quot;&gt;&lt;/context:component-scan&gt; &lt;!--加载jdbc配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--把数据库连接池交给IOC容器--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--把QueryRunner交给IOC容器--&gt; &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 5）编写测试代码 12345678910public class AccountServiceTest &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); AccountService accountService = applicationContext.getBean(AccountService.class); //测试查询 @Test public void findByIdTest() &#123; Account account = accountService.findById(3); System.out.println(account); &#125;&#125; 7.3 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置：&lt;bean&gt; 加载properties文件的配置：&lt;context:property-placeholder&gt; 组件扫描的配置：&lt;context:component-scan&gt; 引入其他文件：&lt;import&gt; 注解 说明 @Configuration 用于指定当前类是一个Spring 配置类，当创建容器时会从该类上加载注解 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载 properties 文件中的配置 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包 @Import 用于导入其他配置类 7.4 Spring纯注解整合DbUtils步骤分析 编写Spring核心配置类 编写数据库配置信息类 编写测试代码 1）编写Spring核心配置类 123456789@Configuration @ComponentScan(&quot;com.lagou&quot;) @Import(DataSourceConfig.class) public class SpringConfig &#123; @Bean(&quot;queryRunner&quot;) public QueryRunner getQueryRunner(@Autowired DataSource dataSource) &#123; return new QueryRunner(dataSource); &#125;&#125; 2）编写数据库配置信息类 123456789101112131415161718192021222324@PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 3）编写测试代码 12345678910public class AccountServiceTest &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = applicationContext.getBean(AccountService.class); //测试查询 @Test public void testFindById() &#123; Account account = accountService.findById(3); System.out.println(account); &#125;&#125; 8. Spring整合Junit8.1普通Junit测试问题在普通的测试类中，需要开发者手动加载配置文件并创建Spring容器，然后通过Spring相关API获得Bean实例；如果不这么做，那么无法从容器中获得对象。 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); AccountService accountService = applicationContext.getBean(AccountService.class); 8.2 Spring整合Junit步骤分析 导入spring集成Junit的坐标 使用@Runwith注解替换原来的运行器 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试 1）导入spring集成Junit的坐标 123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2）使用@Runwith注解替换原来的运行器 1234@RunWith(SpringJUnit4ClassRunner.class) public class SpringJunitTest &#123; &#125; 3）使用@ContextConfiguration指定配置文件或配置类 123456@RunWith(SpringJUnit4ClassRunner.class) //@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;) 加载spring 核心配置文件 @ContextConfiguration(classes = &#123;SpringConfig.class&#125;) // 加载spring核心配置类 public class SpringJunitTest &#123; &#125; 4）使用@Autowired注入需要测试的对象 123456@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = &#123;SpringConfig.class&#125;) public class SpringJunitTest &#123; @Autowired private AccountService accountService; &#125; 5）创建测试方法进行测试 123456789101112@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = &#123;SpringConfig.class&#125;) public class SpringJunitTest &#123; @Autowired private AccountService accountService; //测试查询 @Test public void testFindById() &#123; Account account = accountService.findById(3); System.out.println(account); &#125;&#125;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Mybatis加载策略&注解开发","slug":"Mybatis加载策略-注解开发","date":"2021-04-04T06:51:54.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2021/04/04/Mybatis加载策略-注解开发/","link":"","permalink":"http://yournotes.cn/2021/04/04/Mybatis%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"1. Mybatis加载策略1.1 什么是延迟加载？问题 通过前面的学习，我们已经掌握了Mybatis中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的订单信息。此时就是我们所说的延迟加载。 举个栗子 在一对多中，当我们有一个用户，它有个100个订单 在查询用户的时候，要不要把关联的订单查出来？ 在查询订单的时候，要不要把关联的用户查出来？ 回答 在查询用户时，用户下的订单应该是，什么时候用，什么时候查询。 在查询订单时，订单所属的用户信息应该是随着订单一起查询出来。 延迟加载 就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。 优点 先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表 速度要快。 缺点 因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时 间，所以可能造成用户等待时间变长，造成用户体验下降。 在多表中： 一对多，多对多：通常情况下采用延迟加载 一对一（多对一）：通常情况下采用立即加载 注意： 延迟加载是基于嵌套查询来实现的 1.2 实现1.2.1 局部延迟加载在association和collection标签中都有一个fetchType属性，通过修改它的值，可以修改局部的加载策略。 1234567891011121314&lt;!-- 开启一对多 延迟加载 --&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!--fetchType=&quot;lazy&quot; 懒加载策略 fetchType=&quot;eager&quot; 立即加载策略 --&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;order&quot; column=&quot;id&quot; select=&quot;com.lagou.dao.OrderMapper.findByUid&quot; fetchType=&quot;lazy&quot;&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; SELECT * FROM `user` &lt;/select&gt; 1.2.2 设置触发延迟加载的方法大家在配置了延迟加载策略后，发现即使没有调用关联对象的任何方法，但是在你调用当前对象的equals、clone、hashCode、toString方法时也会触发关联对象的查询。 我们可以在配置文件中使用lazyLoadTriggerMethods配置项覆盖掉上面四个方法。 1234&lt;settings&gt; &lt;!--所有方法都会延迟加载--&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;toString()&quot;/&gt; &lt;/settings&gt; 1.2.3 全局延迟加载在Mybatis的核心配置文件中可以使用setting标签修改全局的加载策略。 1234&lt;settings&gt; &lt;!--开启全局延迟加载功能--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 注意 局部的加载策略优先级高于全局的加载策略。 12345678910111213&lt;!-- 关闭一对一 延迟加载 --&gt;&lt;resultMap id=&quot;orderMap&quot; type=&quot;order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot;&gt;&lt;/result&gt; &lt;!--fetchType=&quot;lazy&quot; 懒加载策略fetchType=&quot;eager&quot; 立即加载策略 --&gt; &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; select=&quot;com.lagou.dao.UserMapper.findById&quot; fetchType=&quot;eager&quot;&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt; SELECT * from orders &lt;/select&gt; 2. MyBatis缓存2.1 为什么使用缓存？当用户频繁查询某些固定的数据时,第一次将这些数据从数据库中查询出来,保存在缓存中。当用户再次查询这些数据时,不用再通过数据库查询,而是去缓存里面查询。减少网络连接和数据库查询带来的损耗,从而提高我们的查询效率,减少高并发访问带来的系统性能问题。 一句话概括： 经常查询一些不经常发生变化的数据，使用缓存来提高查询效率 像大多数的持久化框架一样，Mybatis也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。 Mybatis中缓存分为一级缓存，二级缓存。 2.2 一级缓存2.2.1 介绍一级缓存是SqlSession级别的缓存，是默认开启的 所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。 2.2.2 验证12345678910@Test public void testOneCache() throws Exception &#123; SqlSession sqlSession = MyBatisUtils.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findById(1); System.out.println(&quot;第一次查询的用户：&quot; + user1); User user2 = userMapper.findById(1); System.out.println(&quot;第二次查询的用户：&quot; + user2); sqlSession.close();&#125; 我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是Mybatis提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询id为1的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 2.2.3 分析一级缓存是SqlSession范围的缓存，执行SqlSession的C（增加）U（更新）D（删除）操作，或者调用clearCache()、commit()、close()方法，都会清空缓存。 第一次发起查询用户id为41的用户信息，先去找缓存中是否有id为41的用户信息，如果没有，从数据库 查询用户信息。 得到用户信息，将用户信息存储到一级缓存中。 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这 样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户id为41的用户信息，先去找缓存中是否有id为41的用户信息，缓存中有，直接从缓 存中获取用户信息。 2.2.4 清除1234567891011@Test public void testClearOneCache() throws Exception &#123; SqlSession sqlSession = MybatisUtils.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findById(41); System.out.println(&quot;第一次查询的用户：&quot; + user1); //调用sqlSession清除缓存的方法 sqlSession.clearCache(); User user2 = userMapper.findById(41); System.out.println(&quot;第二次查询的用户：&quot; + user2);&#125; 12&lt;!-- 每次查询时，都会清除缓存 --&gt; &lt; select flushCache=&quot;true&quot;&gt;&lt;/select&gt; 2.3 二级缓存2.3.1 介绍二级缓存是namspace级别（跨sqlSession）的缓存，是默认不开启的 二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置 &lt;cache/&gt; 就可以开启二级缓存了。 2.3.2 验证1）核心配置文件 1234567&lt;settings&gt; &lt;!-- 因为cacheEnabled的取值默认就为true，所以这一步可以省略不配置。 为true代表开启二级缓存；为false代表不开启二级缓存。 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 2）配置UserMapper.xml映射 12345678910111213&lt;mapper namespace=&quot;com.lagou.dao.UserMapper&quot;&gt; &lt;!--当前映射文件开启二级缓存--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!-- &lt;select&gt;标签中设置useCache=”true”代表当前这个statement要使用二级缓存。 如果不使用二级缓存可以设置为false 注意： 针对每次查询都需要最新的数据sql，要设置成useCache=&quot;false&quot;，禁用二级缓存。 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; useCache=&quot;true&quot; &gt; SELECT * FROM `user` where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 3）修改User实体 123456789public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Role&gt; roleList; private List&lt;Order&gt; orderList;&#125; 3）测试结果 12345678910111213@Test public void testTwoCache() throws Exception &#123; SqlSession sqlSession = MyBatisUtils.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(41); System.out.println(&quot;第一次查询的用户：&quot; + user); sqlSession.close(); SqlSession sqlSession1 = MyBatisUtils.openSession(); UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class); User user1 = userMapper1.findById(41); System.out.println(&quot;第二次查询的用户：&quot;+user1); sqlSession1.close();&#125; 2.3.3 分析二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 映射语句文件中的所有select语句将会被缓存。 映射语句文件中的所有insert、update和delete语句会刷新缓存。 2.3.4 注意问题（脏读）mybatis的二级缓存因为是namespace级别，所以在进行多表查询时会产生脏读问题 2.4 小结 mybatis的缓存，都不需要我们手动存储和获取数据。mybatis自动维护的。 mybatis开启了二级缓存后，那么查询顺序：二级缓存–》一级缓存–》数据库 注意：mybatis的二级缓存会存在脏读问题，需要使用第三方的缓存技术解决问题。 3. MyBatis注解3.1 MyBatis常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增，代替了&lt;insert&gt;&lt;/insert&gt; @Delete：实现删除，代替了&lt;delete&gt;&lt;/delete&gt; @Update：实现更新，代替了&lt;update&gt;&lt;/update&gt; @Select：实现查询，代替了&lt;select&gt;&lt;/select&gt; @Result：实现结果集封装，代替了&lt;result&gt;&lt;/result&gt; @Results：可以与@Result 一起使用，封装多个结果集，代替了&lt;resultMap&gt;&lt;/resultMap&gt; @One：实现一对一结果集封装，代替了&lt;association&gt;&lt;/association&gt; @Many：实现一对多结果集封装，代替了&lt;collection&gt;&lt;/collection&gt; 3.2 MyBatis注解的增删改查【重点】3.2.1 创建UserMapper接口12345678910public interface UserMapper &#123; @Select(&quot;SELECT * FROM `user`&quot;) public List&lt;User&gt; findAll(); @Insert(&quot;INSERT INTO `user`(username,birthday,sex,address) VALUES(# &#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&quot;) public void save(User user); @Update(&quot;UPDATE `user` SET username = #&#123;username&#125;,birthday = #&#123;birthday&#125;,sex = #&#123;sex&#125;,address = #&#123;address&#125; WHERE id = #&#123;id&#125;&quot;) public void update(User user); @Delete(&quot;DELETE FROM `user` where id = #&#123;id&#125;&quot;) public void delete(Integer id);&#125; 3.2.2 编写核心配置文件1234&lt;!--我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可--&gt; &lt;mappers&gt; &lt;!--扫描使用注解的Mapper类--&gt; &lt;mapper class=&quot;com.lagou.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt; 12345&lt;!--或者指定扫描包含映射关系的接口所在的包也可以--&gt; &lt;mappers&gt; &lt;!--扫描使用注解的Mapper类所在的包--&gt; &lt;package name=&quot;com.lagou.mapper&quot;&gt;&lt;/package&gt; &lt;/mappers&gt; 3.2.3 测试代码12345678910111213141516171819202122232425262728293031323334353637383940public class TestUser extends TestBaseMapper &#123; // 查询 @Test public void testFindAll() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAll(); for (User user : list) &#123; System.out.println(user); &#125; &#125; // 添加 @Test public void testSave() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername(&quot;于谦&quot;); user.setBirthday(new Date()); user.setSex(&quot;男&quot;); user.setAddress(&quot;北京德云社&quot;); userMapper.save(user); &#125; // 更新 @Test public void testUpdate() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setId(49); user.setUsername(&quot;郭德纲&quot;); user.setBirthday(new Date()); user.setSex(&quot;男&quot;); user.setAddress(&quot;北京德云社&quot;); userMapper.update(user); &#125; // 删除 @Test public void testDelete() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.delete(49); &#125;&#125; 3.3 使用注解实现复杂映射开发之前我们在映射文件中通过配置 &lt;resultMap&gt;、&lt;association&gt;、&lt;collection&gt; 来实现复杂关系映射。 使用注解开发后，我们可以使用 @Results、@Result，@One、@Many 注解组合完成复杂关系的配置。 3.4 一对一查询3.4.1 介绍需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询语句 12SELECT * FROM orders; SELECT * FROM `user` WHERE id = #&#123;订单的uid&#125;; 3.4.2 代码实现1）OrderMapper接口 1234567891011public interface OrderMapper &#123; @Select(&quot;SELECT * FROM orders&quot;) @Results(&#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;ordertime&quot;, property = &quot;ordertime&quot;), @Result(column = &quot;money&quot;, property = &quot;money&quot;), @Result(property = &quot;user&quot;, javaType = User.class, column = &quot;uid&quot;, one = @One(select = &quot;com.lagou.mapper.UserMapper.findById&quot;, fetchType = FetchType.EAGER)) &#125;) public List&lt;Order&gt; findAllWithUser();&#125; 2）UserMapper接口 1234public interface UserMapper &#123; @Select(&quot;SELECT * FROM `user` WHERE id = #&#123;id&#125;&quot;) public User findById(Integer id); &#125; 3）测试代码 12345678@Test public void testOrderWithUser() throws Exception &#123; OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); List&lt;Order&gt; list = orderMapper.findAllWithUser(); for (Order order : list) &#123; System.out.println(order); &#125;&#125; 3.5 一对多查询3.5.1 介绍需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询语句 12SELECT * FROM `user`; SELECT * FROM orders where uid = #&#123;用户id&#125;; 3.5.2 代码实现1）UserMapper接口 123456789101112public interface UserMapper &#123; @Select(&quot;SELECT * FROM `user`&quot;) @Results(&#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;brithday&quot;, property = &quot;brithday&quot;), @Result(column = &quot;sex&quot;, property = &quot;sex&quot;), @Result(column = &quot;address&quot;, property = &quot;address&quot;), @Result(property = &quot;orderList&quot;, javaType = List.class, column = &quot;id&quot; , many = @Many(select = &quot;com.lagou.mapper.OrderMapper.findByUid&quot;)) &#125;) public List&lt;User&gt; findAllWithOrder(); &#125; 2）OrderMapper接口 1234public interface OrderMapper &#123; @Select(&quot;SELECT * FROM orders WHERE uid = #&#123;uid&#125;&quot;) public List&lt;Order&gt; findByUid(Integer uid); &#125; 3）测试代码 12345678@Test public void testUserWithOrder() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllWithOrder(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 3.6 多对多查询3.6.1 介绍需求：查询所有用户，同时查询出该用户的所有角色 多对多查询语句 12SELECT * FROM `user`; SELECT * FROM role r INNER JOIN user_role ur ON r.`id` = ur.`rid` WHERE ur.`uid` = #&#123;用户id&#125;; 3.6.2 代码实现1）UserMapper接口 12345678910111213public interface UserMapper &#123; @Select(&quot;SELECT * FROM `user`&quot;) @Results(&#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;brithday&quot;, property = &quot;brithday&quot;), @Result(column = &quot;sex&quot;, property = &quot;sex&quot;), @Result(column = &quot;address&quot;, property = &quot;address&quot;), @Result(property = &quot;roleList&quot;, javaType = List.class, column = &quot;id&quot; , many = @Many(select = &quot;com.lagou.mapper.RoleMapper.findByUid&quot;)) &#125;) public List&lt;User&gt; findAllWithRole(); &#125; 2）RoleMapper接口 1234public interface RoleMapper &#123; @Select(&quot;SELECT * FROM role r INNER JOIN user_role ur ON r.`id` = ur.`rid` WHERE ur.`uid` = #&#123;uid&#125;&quot;) public List&lt;Role&gt; findByUid(Integer uid); &#125; 3）测试代码 12345678@Test public void testUserWithRole() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllWithRole(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 3.7 基于注解的二级缓存3.7.1 配置SqlMapConfig.xml文件开启二级缓存的支持1234567&lt;settings&gt; &lt;!-- 因为cacheEnabled的取值默认就为true，所以这一步可以省略不配置。 为true代表开启二级缓存；为false代表不开启二级缓存。 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 3.7.2 在Mapper接口中使用注解配置二级缓存12@CacheNamespace public interface UserMapper &#123;...&#125; 3.8 注解延迟加载不管是一对一还是一对多 ，在注解配置中都有fetchType的属性 fetchType &#x3D; FetchType.LAZY 表示懒加载 fetchType &#x3D; FetchType.EAGER 表示立即加载 fetchType &#x3D; FetchType.DEFAULT 表示使用全局配置 3.9 小结 注解开发和xml配置优劣分析 注解开发和xml配置相比，从开发效率来说，注解编写更简单，效率更高。 从可维护性来说，注解如果要修改，必须修改源码，会导致维护成本增加。xml维护性更强。","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"右键打开cmd","slug":"右键打开cmd","date":"2021-03-27T05:47:59.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2021/03/27/右键打开cmd/","link":"","permalink":"http://yournotes.cn/2021/03/27/%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80cmd/","excerpt":"前言 前面再注册表修改了cmd默认地址，后来发现这样并不好，影响了其他地方的使用。还不如配置可以让windows右键在当前位置打开终端.","text":"前言 前面再注册表修改了cmd默认地址，后来发现这样并不好，影响了其他地方的使用。还不如配置可以让windows右键在当前位置打开终端. 编辑配置按shift右键只有Powershell，所以需要自己配置cmd的 新建文件cmd.txt键入下列内容，@&#x3D;为右键显示文字 1234567891011121314151617181920212223242526272829Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere]@=&quot;在此处打开命令窗口&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere]@=&quot;在此处打开命令窗口&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere]@=&quot;在此处打开命令窗口&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere]@=&quot;在此处打开命令窗口&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot; 之后修改后缀为.reg 双击确定 ，注意文本编码是ANSI ，否则提示语乱码。 更正乱码当然提示乱不乱码都可以使用，已经注册完了是乱码需要改的话也可以。win+r打开注册表 打开这个地址：HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere 右键修改即可","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"折腾","slug":"日常/折腾","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Mybatis配置深入","slug":"Mybatis配置深入","date":"2021-03-27T03:09:54.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2021/03/27/Mybatis配置深入/","link":"","permalink":"http://yournotes.cn/2021/03/27/Mybatis%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%85%A5/","excerpt":"","text":"1. Mybatis高级查询1.1 ResutlMap属性建立对象关系映射 resultType 如果实体的属性名与表中字段名一致，将查询结果自动封装到实 ResutlMap 如果实体的属性名与表中字段名不一致，可以使用ResutlMap实现手动封装到实体类中 1）编写UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findAllResultMap();&#125; 2）编写UserMapper.xml 123456789101112131415161718192021&lt;!-- 实现手动映射封装 resultMap id=&quot;userResultMap&quot; 此标签唯一标识 type=&quot;user&quot; 封装后的实体类型 &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; 表中主键字段封装 column=&quot;uid&quot; 表中的字段名 property=&quot;id&quot; user实体的属性名 &lt;result column=&quot;NAME&quot; property=&quot;username&quot;&gt;&lt;/result&gt; 表中普通字段封装 column=&quot;NAME&quot; 表中的字段名 property=&quot;username&quot; user实体的属性名 补充：如果有查询结果有 字段与属性是对应的，可以省略手动封装 【了解】 --&gt;&lt;resultMap id=&quot;userResultMap&quot; type=&quot;user&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;NAME&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;PASSWORD&quot; property=&quot;username&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllResultMap&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT id AS uid,username AS NAME,password AS PASSWORD FROM USER &lt;/select&gt; 3）代码测试 12345678@Test public void testFindAllResultMap() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllResultMap(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 1.2 多条件查询（三种）需求根据id和username查询user表 1）方式一 使用#&#123;arg0&#125;-#&#123;argn&#125;或者 #&#123;param1&#125;-#&#123;paramn&#125;获取参数 UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findByIdAndUsername1(Integer id, String username);&#125; UserMapper.xml 123456&lt;mapper namespace=&quot;com.lagou.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findByIdAndUsername1&quot; resultType=&quot;user&quot;&gt; &lt;!-- select * from user where id = #&#123;arg0&#125; and username = #&#123;arg1&#125; --&gt; select * from user where id = #&#123;param1&#125; and username = #&#123;param2&#125; &lt;/select&gt;&lt;/mapper&gt; 测试 123456@Test public void testFindByIdAndUsername() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findByIdAndUsername1(1 , &quot;木瓜&quot;); System.out.println(list);&#125; 2）方式二 使用注解，引入 @Param() 注解获取参数 UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findByIdAndUsername2(@Param(&quot;id&quot;) Integer id,@Param(&quot;username&quot;) String username);&#125; UserMapper.xml 12345&lt;mapper namespace=&quot;com.lagou.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findByIdAndUsername2&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; and username = #&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; 测试 123456@Test public void testFindByIdAndUsername() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findByIdAndUsername2(1, &quot;子慕&quot;); System.out.println(list);&#125; 3）方式三（推荐） 使用pojo对象传递参数 UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findByIdAndUsername3(User user);&#125; UserMapper.xml 12345&lt;mapper namespace=&quot;com.lagou.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findByIdAndUsername3&quot; parameterType=&quot;com.lagou.domain.User&quot; resultType=&quot;com.lagou.domain.User&quot;&gt; select * from user where id = #&#123;id&#125; and username = #&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; 测试 123456789@Test public void testFindByIdAndUsername() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User param = new User(); param.setId(1); param.setUsername(&quot;木瓜煲鸡脚&quot;); List&lt;User&gt; list = userMapper.findByIdAndUsername3(param); System.out.println(list);&#125; 1.3 模糊查询需求 根据username模糊查询user表 1）方式一 UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findByUsername1(String username);&#125; UserMapper.xml 12345&lt;mapper namespace=&quot;com.lagou.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findByUsername1&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&gt; select * from user where username like #&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; 测试 12345678@Test public void testFindByUsername() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findByUsername1(&quot;%王%&quot;); for (User user : list) &#123; System.out.println(user); &#125;&#125; 2）方式二 UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findByUsername2(String username);&#125; UserMapper.xml 123456&lt;mapper namespace=&quot;com.lagou.mapper.UserMapper&quot;&gt; &lt;!--不推荐使用，因为会出现sql注入问题--&gt; &lt;select id=&quot;findByUsername2&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&gt; select * from user where username like &#x27;$&#123;value&#125;&#x27; &lt;/select&gt;&lt;/mapper&gt; 测试 12345678@Test public void testFindByUsername() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findByUsername2(&quot;%王%&quot;); for (User user : list) &#123; System.out.println(user); &#125;&#125; 3） ${} 与 #{} 区别【笔试题】 #&#123;&#125;：表示一个占位符号 通过 #{} 可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{} 可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值， #{} 括号中名称随便写。 $&#123;&#125;：表示一个占位符号 通过 ${} 可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换，会出现sql注入问题。 ${} 可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值， ${} 括号中只能是value 补充：TextSqlNode.java 源码可以证明 2. Mybatis映射文件深入2.1 返回主键应用场景 我们很多时候有这种需求，向数据库插入一条记录后，希望能立即拿到这条记录在数据库中的主键值。 2.1.1 useGeneratedKeysmapper接口 1234public interface UserMapper &#123; // 返回主键 public void save(User user);&#125; mapper.xml 1234567&lt;!-- useGeneratedKeys=&quot;true&quot; 声明返回主键 keyProperty=&quot;id&quot; 把返回主键的值，封装到实体的id属性中 注意：只适用于主键自增的数据库，mysql和sqlserver支持，oracle不支持 --&gt;&lt;insert id=&quot;save&quot; parameterType=&quot;user&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO `user`(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; 注意：只适用于主键自增的数据库，mysql和sqlserver支持，oracle不行。 2.1.2 selectKeymapper接口 1234public interface UserMapper &#123; // 返回主键 public void save(User user);&#125; mapper.xml 12345678910111213&lt;!-- selectKey 适用范围广，支持所有类型数据库 keyColumn=&quot;id&quot; 指定主键列名 keyProperty=&quot;id&quot; 指定主键封装到实体的id属性中 resultType=&quot;int&quot; 指定主键类型 order=&quot;AFTER&quot; 设置在sql语句执行前（后），执行此语句 --&gt;&lt;insert id=&quot;save&quot; parameterType=&quot;user&quot;&gt; &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID(); &lt;/selectKey&gt; INSERT INTO `user`(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; 2.1.3 测试代码1234567891011@Testpublic void testSave() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername(&quot;子慕&quot;); user.setAddress(&quot;北京&quot;); user.setBirthday(new Date()); user.setSex(&quot;男&quot;); userMapper.save(user); System.out.println(&quot;返回主键:&quot; + user.getId());&#125; 2.2 动态SQL应用场景 当我们要根据不同的条件，来执行不同的sql语句的时候，需要用到动态sql。 2.2.1 动态 SQL 之&lt;if&gt;需求根据id和username查询，但是不确定两个都有值。 1）UserMapper接口 1public List&lt;User&gt; findByIdAndUsernameIf(User user); 2）UserMapper.xml 123456789101112&lt;!-- where标签相当于 where 1=1，但是如果没有条件，就不会拼接where关键字 --&gt;&lt;select id=&quot;findByIdAndUsernameIf&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; SELECT * FROM `user` &lt;where&gt; &lt;if test=&quot;id != null&quot;&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username != null&quot;&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3）测试代码 12345678910// if标签 where标签 @Test public void testFindByIdAndUsernameIf() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User param = new User(); // param.setId(42); // param.setUsername(&quot;王小二&quot;); List&lt;User&gt; list = userMapper.findByIdAndUsernameIf(param); System.out.println(list);&#125; 2.2.2 动态 SQL 之&lt;set&gt;需求动态更新user表数据，如果该属性有值就更新，没有值不做处理。 1）UserMapper接口 1public void updateIf(User user); 2）UserMapper.xml 123456789&lt;!-- set标签在更新的时候，自动加上set关键字，然后去掉最后一个条件的逗号 --&gt;&lt;update id=&quot;updateIf&quot; parameterType=&quot;user&quot;&gt; UPDATE `user` &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;birthday != null&quot;&gt; birthday = #&#123;birthday&#125;, &lt;/if&gt; &lt;if test=&quot;sex !=null&quot;&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test=&quot;address !=null&quot;&gt; address = #&#123;address&#125;, &lt;/if&gt; &lt;/set&gt; WHERE id = #&#123;id&#125; &lt;/update&gt; 3）测试代码 123456789// set标签 @Test public void testUpdateIf()throws Exception&#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setId(1); user.setUsername(&quot;小二王&quot;); user.setSex(&quot;女&quot;); userMapper.updateIf(user);&#125; 2.2.3 动态 SQL 之&lt;foreach&gt;foreach主要是用来做数据的循环遍历 例如： select * from user where id in (1,2,3) 在这样的语句中，传入的参数部分必须依靠foreach遍历才能实现。 &lt;foreach&gt;标签用于遍历集合，它的属性： collection：代表要遍历的集合元素 open：代表语句的开始部分 close：代表结束部分 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 集合 1）UserMapper接口 1public List&lt;User&gt; findByList(List&lt;Integer&gt; ids); 2）UserMapper.xml 123456789&lt;!-- 如果查询条件为普通类型 List集合，collection属性值为：collection 或者 list --&gt;&lt;select id=&quot;findByList&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot; &gt; SELECT * FROM `user` &lt;where&gt; &lt;foreach collection=&quot;collection&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 3）测试代码 1234567891011// foreach标签 list @Test public void testFindByList() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(46); ids.add(48); ids.add(51); List&lt;User&gt; list = userMapper.findByList(ids); System.out.println(list);&#125; 数组 1）UserMapper接口 1public List&lt;User&gt; findByArray(Integer[] ids); 2）UserMapper.xml 123456789&lt;!-- 如果查询条件为普通类型 Array数组，collection属性值为：array --&gt;&lt;select id=&quot;findByArray&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM `user` &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 3）测试代码 12345678// foreach标签 array @Test public void testFindByArray() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); Integer[] ids = &#123;46, 48, 51&#125;; List&lt;User&gt; list = userMapper.findByArray(ids); System.out.println(list);&#125; 2.3 SQL片段应用场景 映射文件中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 1234567891011121314151617181920&lt;!--抽取的sql片段--&gt;&lt;sql id=&quot;selectUser&quot;&gt; SELECT * FROM `user` &lt;/sql&gt;&lt;select id=&quot;findByList&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot; &gt; &lt;!--引入sql片段--&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;collection&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;&lt;select id=&quot;findByArray&quot; parameterType=&quot;integer[]&quot; resultType=&quot;user&quot;&gt; &lt;!--引入sql片段--&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 2.4 知识小结MyBatis映射文件配置 12345678910&lt;select&gt;：查询 &lt;insert&gt;：插入 &lt;update&gt;：修改 &lt;delete&gt;：删除 &lt;selectKey&gt;：返回主键 &lt;where&gt;：where条件 &lt;if&gt;：if判断 &lt;foreach&gt;：for循环 &lt;set&gt;：set设置 &lt;sql&gt;：sql片段抽取 Mybatis核心配置文件深入3.1 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标 ②在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 ①导入通用PageHelper坐标 1234567891011&lt;!-- 分页助手 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件 12345&lt;!-- 分页助手的插件 --&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 指定方言 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;&lt;/plugin&gt; ③测试分页代码实现 123456789@Test public void testPageHelper()&#123; //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for (User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678//其他分页的数据 PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select); System.out.println(&quot;总条数：&quot;+pageInfo.getTotal()); System.out.println(&quot;总页数：&quot;+pageInfo.getPages()); System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum()); System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize()); System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage()); System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage()); 3.2 知识小结MyBatis核心配置文件常用标签： properties标签：该标签可以加载外部的properties文件 typeAliases标签：设置类型别名 environments标签：数据源环境配置标签 plugins标签：配置MyBatis的插件 4. Mybatis多表查询4.1 数据库表关系介绍关系型数据库表关系分为: 一对一 一对多 多对多 案例环境准备 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455DROP TABLE IF EXISTS `orders`; CREATE TABLE `orders` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `ordertime` VARCHAR(255) DEFAULT NULL, `total` DOUBLE DEFAULT NULL, `uid` INT(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `uid` (`uid`), CONSTRAINT `orders_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user` (`id`)) ENGINE = INNODB AUTO_INCREMENT = 4 DEFAULT CHARSET = utf8; -- ---------------------------- -- Records of orders -- ---------------------------- INSERT INTO `orders` VALUES (&#x27;1&#x27;, &#x27;2020-12-12&#x27;, &#x27;3000&#x27;, &#x27;1&#x27;); INSERT INTO `orders` VALUES (&#x27;2&#x27;, &#x27;2020-12-12&#x27;, &#x27;4000&#x27;, &#x27;1&#x27;); INSERT INTO `orders` VALUES (&#x27;3&#x27;, &#x27;2020-12-12&#x27;, &#x27;5000&#x27;, &#x27;2&#x27;); -- ---------------------------- -- Table structure for sys_role -- ---------------------------- DROP TABLE IF EXISTS `sys_role`; CREATE TABLE `sys_role` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `rolename` VARCHAR(255) DEFAULT NULL, `roleDesc` VARCHAR(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE = INNODB AUTO_INCREMENT = 3 DEFAULT CHARSET = utf8; -- ---------------------------- -- Records of sys_role -- ---------------------------- INSERT INTO `sys_role` VALUES (&#x27;1&#x27;, &#x27;CTO&#x27;, &#x27;CTO&#x27;); INSERT INTO `sys_role` VALUES (&#x27;2&#x27;, &#x27;CEO&#x27;, &#x27;CEO&#x27;); -- ------------------------------ Table structure for sys_user_role -- ---------------------------- DROP TABLE IF EXISTS `sys_user_role`; CREATE TABLE `sys_user_role` ( `userid` INT(11) NOT NULL, `roleid` INT(11) NOT NULL, PRIMARY KEY (`userid`, `roleid`), KEY `roleid` (`roleid`), CONSTRAINT `sys_user_role_ibfk_1` FOREIGN KEY (`userid`) REFERENCES `sys_role` (`id`), CONSTRAINT `sys_user_role_ibfk_2` FOREIGN KEY (`roleid`) REFERENCES `user` (`id`)) ENGINE = INNODB DEFAULT CHARSET = utf8; -- ---------------------------- -- Records of sys_user_role -- ---------------------------- INSERT INTO `sys_user_role` VALUES (&#x27;1&#x27;, &#x27;1&#x27;); INSERT INTO `sys_user_role` VALUES (&#x27;2&#x27;, &#x27;1&#x27;); INSERT INTO `sys_user_role` VALUES (&#x27;1&#x27;, &#x27;2&#x27;); INSERT INTO `sys_user_role` VALUES (&#x27;2&#x27;, &#x27;2&#x27;); 4.2 一对一（多对一）4.2.1 介绍一对一查询模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询所有订单，与此同时查询出每个订单所属的用户 一对一查询语句 1SELECT * FROM orders o LEFT JOIN USER u ON o.`uid`=u.`id`; 4.2.2 代码实现1）Order实体 1234567public class Order &#123; private Integer id; private Date ordertime; private double money; // 表示当前订单属于哪个用户 private User user;&#125; 2）OrderMapper接口 123public interface OrderMapper &#123; public List&lt;Order&gt; findAllWithUser(); &#125; 3）OrderMapper.xml 12345678910111213&lt;resultMap id=&quot;orderMap&quot; type=&quot;com.lagou.domain.Order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt; &lt;!--一对一（多对一）使用association标签关联 property=&quot;user&quot; 封装实体的属性名 javaType=&quot;user&quot; 封装实体的属性类型 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;com.lagou.domain.User&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 4）测试代码 12345678@Test public void testOrderWithUser() throws Exception &#123; OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); List&lt;Order&gt; list = orderMapper.findAllWithUser(); for (Order order : list) &#123; System.out.println(order); &#125;&#125; 4.3 一对多4.3.1 介绍一对多查询模型 用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询所有订单，与此同时查询出每个订单所属的用户 一对多查询语句 1SELECT *,o.id oid FROM USER u LEFT JOIN orders o ON u.`id` = o.`uid`; 4.3.2 代码实现1）User实体 123456789public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; // 代表当前用户具备的订单列表 private List&lt;Order&gt; orderList;&#125; 2）UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findAllWithOrder(); &#125; 3）UserMapper.xml 1234567891011121314&lt;resultMap id=&quot;userMap&quot; type=&quot;com.lagou.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;!--一对多使用collection标签关联 property=&quot;orderList&quot; 封装到集合的属性名 ofType=&quot;order&quot; 封装集合的泛型类型 --&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;com.lagou.domain.Order&quot;&gt; &lt;id column=&quot;oid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllWithOrder&quot; resultMap=&quot;userMap&quot;&gt; SELECT *,o.id oid FROM USER u LEFT JOIN orders o ON u.`id`=o.`uid`; &lt;/select&gt; 4）测试代码 12345678@Test public void testUserWithOrder() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllWithOrder(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 4.4 多对多4.4.1 介绍多对多查询的模型 多对多查询语句 12345SELECT * FROMUSER u -- 用户表 LEFT JOIN user_role ur -- 左外连接中间表 ON u.`id` = ur.`uid` LEFT JOIN role r -- 左外连接中间表 ON ur.`rid` = r.`id` ; 4.4.2 代码实现1）User和Role 实体 123456789101112131415public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; // 代表当前用户关联的角色列表 private List&lt;Role&gt; roleList;&#125;public class Role &#123; private Integer id; private String roleName; private String roleDesc;&#125; 2）UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findAllWithRole(); &#125; 3）UserMapper.xml映射 123456789101112131415&lt;resultMap id=&quot;userAndRoleMap&quot; type=&quot;com.lagou.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;com.lagou.domain.Role&quot;&gt; &lt;id column=&quot;rid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllWithRole&quot; resultMap=&quot;userAndRoleMap&quot;&gt; SELECT * FROM USER u LEFT JOIN user_role ur ON u.`id`=ur.`uid` INNER JOIN role r ON ur.`rid` = r.`id`; &lt;/select&gt; 4）测试代码 12345678@Test public void testUserWithRole() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllWithRole(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 4.5 小结MyBatis多表配置方式 多对一（一对一）配置：使用&lt;resultMap&gt;+&lt;association&gt;做配置 一对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置 多对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置 多对多的配置跟一对多很相似，难度在于SQL语句的编写。 5. MyBatis嵌套查询5.1 什么是嵌套查询嵌套查询就是将原来多表查询中的联合查询语句拆成单个表的查询，再使用mybatis的语法嵌套在一起。 举个栗子 需求：查询一个订单，与此同时查询出该订单所属的用户 联合查询SELECT * FROM orders o LEFT JOIN USER u ON o.uid&#x3D;u.id; 嵌套查询 先查询订单 SELECT * FROM orders 再根据订单uid外键，查询用户 SELECT * FROM user WHERE id &#x3D; #{根据订单查询的uid} 最后使用mybatis，将以上二步嵌套起来 5.2 一对一嵌套查询5.2.1 介绍需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询语句 12345-- 先查询订单SELECT * FROM orders;-- 再根据订单uid外键，查询用户SELECT * FROM `user` WHERE id = #&#123;订单的uid&#125;; 5.2.2 代码实现1）OrderMapper接口 123public interface OrderMapper &#123; public List&lt;Order&gt; findAllWithUser();&#125; 2）OrderMapper.xml映射 1234567891011121314&lt;!--一对一嵌套查询--&gt;&lt;resultMap id=&quot;orderMap&quot; type=&quot;order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt; &lt;!--根据订单中uid外键，查询用户表--&gt; &lt;association property=&quot;user&quot; javaType=&quot;user&quot; column=&quot;uid&quot; select=&quot;com.lagou.mapper.UserMapper.findById&quot;&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllWithUser&quot; resultMap=&quot;orderMap&quot; &gt; SELECT * FROM orders &lt;/select&gt; 3）UserMapper接口 123public interface UserMapper &#123; public User findById(Integer id);&#125; 4）UserMapper.xml映射 123&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM `user` where id = #&#123;uid&#125; &lt;/select&gt; 5）测试代码 12345678@Test public void testOrderWithUser() throws Exception &#123; OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); List&lt;Order&gt; list = orderMapper.findAllWithUser(); for (Order order : list) &#123; System.out.println(order); &#125;&#125; 5.3 一对多嵌套查询5.3.1 介绍需求：查询所有用户，与此同时查询出该用户具有的订单 一对多查询语句 12345-- 先查询用户SELECT * FROM `user`;-- 再根据用户id主键，查询订单列表SELECT * FROM orders where uid = #&#123;用户id&#125;; 5.3.2 代码实现1）UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findAllWithOrder();&#125; 2）UserMapper.xml映射 12345678910111213141516&lt;!--一对多嵌套查询--&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;!--根据用户id，查询订单表--&gt; &lt;collection property=&quot;orderList&quot; column=&quot;id&quot; ofType=&quot;order&quot; select=&quot;com.lagou.mapper.OrderMapper.findByUid&quot;&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllWithOrder&quot; resultMap=&quot;userMap&quot;&gt; SELECT * FROM `user` &lt;/select&gt; 3）OrderMapper.xml接口 123public interface OrderMapper &#123; public List&lt;Order&gt; findByUid(Integer uid);&#125; 4）OderMapper.xml映射 123&lt;select id=&quot;findByUid&quot; parameterType=&quot;int&quot; resultType=&quot;order&quot;&gt; SELECT * FROM orders where uid = #&#123;uid&#125; &lt;/select&gt; 5）测试代码 12345678@Test public void testUserWithOrder() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllWithOrder(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 5.4 多对多嵌套查询5.4.1 介绍需求：查询所有用户，与此同时查询出该用户具有的订单 一对多查询语句 12345678-- 先查询用户SELECT * FROM `user`;-- 再根据用户id主键，查询角色列表SELECT * FROM role r INNER JOIN user_role ur ON r.`id` = ur.`rid` WHERE ur.`uid` = #&#123;用户id&#125;; 5.4.2 代码实现1）UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findAllWithRole(); &#125; 2）UserMapper.xml映射 123456789101112131415&lt;!--多对多嵌套查询--&gt;&lt;resultMap id=&quot;userAndRoleMap&quot; type=&quot;user&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;adress&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;!--根据用户id，查询角色列表--&gt; &lt;collection property=&quot;roleList&quot; column=&quot;id&quot; ofType=&quot;role&quot; select=&quot;com.lagou.mapper.RoleMapper.findByUid&quot;&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAllWithRole&quot; resultMap=&quot;userAndRoleMap&quot;&gt; SELECT * FROM `user` &lt;/select&gt; 3）RoleMapper接口 123public interface RoleMapper &#123; public List&lt;Role&gt; findByUid(Integer uid); &#125; 4）RoleMapper.xml映射 12345&lt;select id=&quot;findByUid&quot; parameterType=&quot;int&quot; resultType=&quot;role&quot;&gt; SELECT r.id,r.`role_name` roleName,r.`role_desc` roleDesc FROM role r INNER JOIN user_role ur ON r.`id` = ur.`rid` WHERE ur.`uid` = #&#123;uid&#125; &lt;/select&gt; 5）测试代码 12345678@Test public void testUserWithRole() throws Exception &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllWithRole(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 5.5 小结12345678一对一配置：使用&lt;resultMap&gt;+&lt;association&gt;做配置，通过column条件，执行select查询 一对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置，通过column条件，执行select查询 多对多配置：使用&lt;resultMap&gt;+&lt;collection&gt;做配置，通过column条件，执行select查询 优点：简化多表查询操作 缺点：执行多次sql语句，浪费数据库性能","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"更新hexo版本","slug":"更新hexo版本","date":"2021-03-27T02:58:44.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2021/03/27/更新hexo版本/","link":"","permalink":"http://yournotes.cn/2021/03/27/%E6%9B%B4%E6%96%B0hexo%E7%89%88%E6%9C%AC/","excerpt":"前言 昨天使用vue 3发现node版本太老，但这个版本是hexo需要的版本。只更新node的话，hexo生成的public会全部为空，所以更新下新版本hexo。这次是直接手动更新，重新初始化hexo，因此做手动备份","text":"前言 昨天使用vue 3发现node版本太老，但这个版本是hexo需要的版本。只更新node的话，hexo生成的public会全部为空，所以更新下新版本hexo。这次是直接手动更新，重新初始化hexo，因此做手动备份 备份关键文件之前源文件是推送在github，这边先本地把环境重构之后再推送，我们这边就是把个人的配置的部分都备份一下其他都不要。 .git 可以先复制一份到时候就可以直接提交 source 不用说文章什么都在里面 themes 我们配置的主题样式 .gitignore 其实不用之后新版本的hexo初始化也有 _config.yml 页面的各种通用属性配置（头像等等） README.md 仓库的说明，不是关键的我这边留着 准备新hexo安装14版本node 配置依赖库镜像 1npm config set registry https://registry.npm.taobao.org 安装hexo 1npm install -g hexo-cli 查看版本信息 1hexo -v 初始化博客 12hexo init myblogcd myblog 安装依赖后测试一下 123npm ihexo ghexo s 填充原博客没有问题，那现在就相当于把我们的备份全都复制过来就可以了 再次使用出错这时候就出了问题，也是我当时使用命令更新后的问题，因此才采用了重新下载新版hexo初始化这样的方法，既然还是躲不掉这个问题就去解决这个问题呗 一开始发现只要不放_config.yml进去，其他的没问题 也就是问题在配置文件上，再看错误信息，我们找到js的那一行看看，看这个config.url是什么于是我把它拼接在错误信息后面 再次启动看错误信息，这不就是在_config.yml中配置的url么 尝试去在地址前加上 http: 就好了，奇了怪了以前的hexo配置不用加http所以使用正常，更新新的版本后url就不能这么配置了，要写全 完美， .git 文件夹也复制过去了所以直接push到我们的源文件备份分支。 最后最后还没完，初始的hexo-cli是不会自带git部署插件的，还有其他。可以对比原博客的package.json看自己以前用了哪些要装上的 我这边要给新的hexo装上，以下三个也是以前的hexo有用到 git部署 npm install hexo-deployer-git --save 百度站点 npm install hexo-generator-sitemap --save yilia主题目录 npm i hexo-generator-json-content --save","categories":[{"name":"博客系统","slug":"博客系统","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"name":"Hexo","slug":"博客系统/Hexo","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yournotes.cn/tags/Hexo/"}]},{"title":"hexo多端同步","slug":"hexo多端同步","date":"2021-03-27T02:43:51.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2021/03/27/hexo多端同步/","link":"","permalink":"http://yournotes.cn/2021/03/27/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5/","excerpt":"前言 使用Hexo在github搭建的博客，博客作为一个单独的GitHub仓库存在，但是这个仓库只有生成的静态网页文件，并没有Hexo的源文件，如果要换电脑或者在另外的电脑使用，就需要备份hexo环境文件。","text":"前言 使用Hexo在github搭建的博客，博客作为一个单独的GitHub仓库存在，但是这个仓库只有生成的静态网页文件，并没有Hexo的源文件，如果要换电脑或者在另外的电脑使用，就需要备份hexo环境文件。 本地环境上传这里就直接使用你静态文件部署的仓库，在这个仓库下用另外一个分支hexo来存，因为我们需要进行拉取和推送的只是我们的源文件，生成的静态文件只是单方向的部署。所以我们把hexo分支设置为默认分支更方便。 刚创建是一个空分支，我们在本地clone下来把.git文件夹放到项目后即可去push我们的源文件到hexo分支，之后我们在另一台电脑要用clone下来即可 hexo项目里是有一个.gitignore的文件的，里面就是过滤git推送的文件，一些是环境文件生成的不用提交的会过滤掉 新电脑环境准备 安装git 安装node 拉取博客环境，拉下来是没有node_modules的被过滤了 执行 npm i 进行安装依赖2.5配置node环境变量到博客目录下的node_modulesF:\\WorkSpace\\blog\\Jasper-zh.github.io\\node_modules\\.bin 测试上面都完成之后，就可使用hexo命令进行测试了 12hexo ghexo s 注意事项新电脑node版本尽量和最初上传的hexo环境的电脑差不多 新环境或者更改了node环境，hexo命令找不到就重新全局装一下hexo-cli 1npm install -g hexo-cli","categories":[{"name":"博客系统","slug":"博客系统","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"name":"hexo","slug":"博客系统/hexo","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yournotes.cn/tags/Hexo/"}]},{"title":"Linux安装mysql8问题","slug":"Linux安装mysql8问题","date":"2021-03-24T04:33:16.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2021/03/24/Linux安装mysql8问题/","link":"","permalink":"http://yournotes.cn/2021/03/24/Linux%E5%AE%89%E8%A3%85mysql8%E9%97%AE%E9%A2%98/","excerpt":"昨天还心想11点准时睡觉结果就遇到了问题搞到凌晨2点差点不用睡了😢，有必要记录一下","text":"昨天还心想11点准时睡觉结果就遇到了问题搞到凌晨2点差点不用睡了😢，有必要记录一下 这次是在一台CentOS安装Mysql数据库，大家可能都直接用rpm或者如果是Debian系统就是apt的方式来去安装mysql。这个确实会比较省心但安装的基本上是老版本5.7这种最后一个开源版本 这里是在官网下载8版本的linux通用包进行安装，其实关于这个的安装步骤我在另一篇文章有写。按照这篇文章的步骤会减少很多问题， 但昨天遇到了新问题 图上是已经解决得时候（主要问题不是图上的端口前面先解决了后面才会有），开启mysql.server时问题提示就是这个 12Starting MySQL..The server quit without updating PID file (/usr/local/mysql/var/MyServer.pid). ... failed! 或 12Starting MySQL.Logging to &#x27;/etc/mysql/localhost.localdomain.err&#x27;..... ERROR! The server quit without updating PID file (/etc/mysql/localhost.localdomain.pid). 按照网上解决方案都逃不了下面这七种对我来说是没用的。但像端口占用这种还是比较常见的，然后就是安装步骤有问题漏了权限或者默认路径映射。其中像my.cnf这种配置的解决方案对mysql8是没用的因为mysql8没有这些东西都是内置默认，第二是权限的问题总之按照之前那篇文章安装其实都不会出现这些问题 1.可能是&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;rekfan.pid文件没有写的权限解决方法 ：给予权限，执行 “chown -R mysql:mysql &#x2F;var&#x2F;data” “chmod -R 755 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data” 然后重新启动mysqld！ 2.可能进程里已经存在mysql进程解决方法：用命令“ps -ef|grep mysqld”查看是否有mysqld进程，如果有使用“kill -9 进程号”杀死，然后重新启动mysqld！ 3.可能是第二次在机器上安装mysql，有残余数据影响了服务的启动。解决方法：去mysql的数据目录&#x2F;data看看，如果存在mysql-bin.index，就赶快把它删除掉吧，它就是罪魁祸首了。 4.mysql在启动时没有指定配置文件时会使用&#x2F;etc&#x2F;my.cnf配置文件，请打开这个文件查看在[mysqld]节下有没有指定数据目录(datadir)。解决方法：请在[mysqld]下设置这一行：datadir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data 5.skip-federated字段问题解决方法：检查一下&#x2F;etc&#x2F;my.cnf文件中有没有没被注释掉的skip-federated字段，如果有就立即注释掉吧。 6.错误日志目录不存在解决方法：使用“chown” “chmod”命令赋予mysql所有者及权限 7.selinux惹的祸，如果是centos系统，默认会开启selinux解决方法：关闭它，打开&#x2F;etc&#x2F;selinux&#x2F;config，把SELINUX&#x3D;enforcing改为SELINUX&#x3D;disabled后存盘退出重启机器试试。 花了两三个小时主要是google都翻了几页然后都尝试了不够也就上面这七种。最后才想起来去看localhost.localdmain.err文件 我这边问题的根源就是temp下的mysql.sock、mysql.sock.lock、mysqlx.sock、mysql.sock.lock，删除完事成功启动服务重新生成。应该是之前服务残留。开始初始化安装mysql初始化密码没记录但又不能像以前版本可通过配置文件查那个随机密码。只能重新初始化这就是问题的根源，之前初始化的已经启动过了生成了这些。 如果不是我上面这个，是端口占用的话就更简单了 lsof -i:3306 kill -9 5398 1234[root@localhost hao]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 5398 mysql 36u IPv6 77510 0t0 TCP *:mysql (LISTEN)[root@localhost hao]# kill -9 5398 整完睡觉🐱‍👤","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"修改cmd初始地址","slug":"修改cmd初始地址","date":"2021-03-24T04:32:30.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/03/24/修改cmd初始地址/","link":"","permalink":"http://yournotes.cn/2021/03/24/%E4%BF%AE%E6%94%B9cmd%E5%88%9D%E5%A7%8B%E5%9C%B0%E5%9D%80/","excerpt":"由于自己平时hexo使用的还是比较频繁总是切换麻烦，所以更改一下cmd的默认地址为hexo地址就随便记录下","text":"由于自己平时hexo使用的还是比较频繁总是切换麻烦，所以更改一下cmd的默认地址为hexo地址就随便记录下 这是我们cmd的默认地址，换地址有几种方式。这里不用快捷方式的。改开始命令栏cmd进的窗口的地址，而不是某个cmd快捷方式的地址。 打开注册表win+r 输入 regedit 地址栏键入：HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor 这里我已经创建了AutoRun的配置，开始是没有的。空白处右键新建字符串，名称AutoRun数值数据cd /d 你的地址 保存后关掉cmd，重新打开就已经更改了地址了","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"折腾","slug":"日常/折腾","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Mybatis基本应用","slug":"Mybatis基本应用","date":"2021-03-20T11:56:53.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2021/03/20/Mybatis基本应用/","link":"","permalink":"http://yournotes.cn/2021/03/20/Mybatis%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/","excerpt":"","text":"1. 框架简介1.1 三层架构软件开发常用的架构是三层架构，之所以流行是因为有着清晰的任务划分。一般包括以下三层： 持久层：主要完成与数据库相关的操作，即对数据库的增删改查。因为数据库访问的对象一般称为Data Access Object（简称DAO），所以有人把持久层叫做DAO层。 业务层：主要根据功能需求完成业务逻辑的定义和实现。因为它主要是为上层提供服务的，所以有人把业务层叫做Service层或Business层。 表现层：主要完成与最终软件使用用户的交互，需要有交互界面（UI）。因此，有人把表现层称之为web层或View层。 三层架构之间调用关系为:表现层调用业务层，业务层调用持久层。各层之间必然要进行数据交互，我们一般使用java实体对象来传递数据 1.2 框架1.2.1 什么是框架？框架就是一套规范，既然是规范，你使用这个框架就要遵守这个框架所规定的约束。框架可以理解为半成品软件，框架做好以后，接下来在它基础上进行开发。 1.2.2 为什么使用框架？框架为我们封装好了一些冗余，且重用率低的代码。并且使用反射与动态代理机制，将代码实现了通用性，让 开发人员把精力专注在核心的业务代码实现上。 比如在使用servlet进行开发时，需要在servlet获取表单的参数，每次都要获取很麻烦，而框架底层就使用反射机制和拦截器机制帮助我们获取表单的值，使用jdbc每次做专一些简单的crud的时候都必须写sql，但使用框架就不需要这么麻烦了，直接调用方法就可以。当然，既然是使用框架，那么还是要遵循其一些规范进行配置 1.2.3 常见的框架Java世界中的框架非常的多，每一个框架都是为了解决某一部分或某些问题而存在的。下面列出在目前企业中 流行的几种框架（一定要注意他们是用来解决哪一层问题的）： 持久层框架：专注于解决数据持久化的框架。常用的有mybatis、hibernate、spring jdbc等等。 表现层框架：专注于解决与用户交互的框架。常见的有struts2、spring mvc等等。 全栈框架: 能在各层都给出解决方案的框架。比较著名的就是spring。 这么多框架，我们怎么选择呢?我们以企业中最常用的组合为准来学习Spring + Spring MVC + mybatis（SSM） 2. Mybatis简介2.1 原始jdbc操作（查询数据） 2.2 原始jdbc操作的分析原始jdbc开发存在的问题如下：① 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能② sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。③ 查询操作时，需要手动将结果集中的数据手动封装到实体中。 应对上述问题给出的解决方案：① 使用数据库连接池初始化连接资源② 将sql语句抽取到xml配置文件中③ 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 2.3 Mybatis简介MyBatis是一个优秀的基于ORM的半自动轻量级持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码 mybatis 历史 MyBatis 本是apache的一个开源项目iBatis, 2010年6月这个项目由apache software foundation 迁移到了google code，随着开发团队转投到Google Code旗下，iBatis正式改名为MyBatis ，代码于2013年11月迁移到Github Github地址：https://github.com/mybatis/mybatis-3/ 2.4 ORM思想ORM（Object Relational Mapping）对象关系映射 O（对象模型）： 实体对象，即我们在程序中根据数据库表结构建立的一个个实体javaBean R（关系型数据库的数据结构）： 关系数据库领域的Relational（建立的数据库表） M（映射）： 从R（数据库）到O（对象模型）的映射，可通过XML文件映射 实现： 让实体类和数据库表进行一一对应关系 先让实体类和数据库表对应 再让实体类属性和表里面字段对应 不需要直接操作数据库表，直接操作表对应的实体类对象 ORM作为是一种思想帮助我们跟踪实体的变化,并将实体的变化翻译成sql脚本,执行到数据库中去,也就是将实体的变化映射到了表的变化。mybatis采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作 3. Mybatis快速入门3.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ 案例需求：通过mybatis查询数据库user表的所有记录，封装到User对象中，打印到控制台上步骤分析： 1234567891011121314① 创建数据库及user表 ② 创建maven工程，导入依赖（MySQL驱动、mybatis、junit）③ 编写User实体类 ④ 编写UserMapper.xml映射配置文件（ORM思想）⑤ 编写SqlMapConfig.xml核心配置文件 数据库环境配置 映射关系配置的引入(引入映射配置文件的路径) ⑥ 编写测试代码 // 1.加载核心配置文件 // 2.获取sqlSessionFactory工厂对象 // 3.获取sqlSession会话对象 // 4.执行sql // 5.打印结果 // 6.释放资源 3.2 代码实现1） 创建user数据表 1234567891011121314CREATE DATABASE `mybatis_db`; USE `mybatis_db`; CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT &#x27;用户名称&#x27;, `birthday` datetime default NULL COMMENT &#x27;生日&#x27;, `sex` char(1) default NULL COMMENT &#x27;性别&#x27;, `address` varchar(256) default NULL COMMENT &#x27;地址&#x27;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- insert.... insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,&#x27;子 慕&#x27;,&#x27;2020-11-11 00:00:00&#x27;,&#x27;男&#x27;,&#x27;北京海淀&#x27;),(2,&#x27;应颠&#x27;,&#x27;2020-12-12 00:00:00&#x27;,&#x27;男&#x27;,&#x27;北 京海淀&#x27;); 2） 导入MyBatis的坐标和其他相关坐标 12345678910111213141516171819202122232425262728&lt;!--指定编码和版本--&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;java.version&gt;1.11&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.11&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 3） 编写User实体 12345678public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; // getter/setter 略 &#125; 4） 编写UserMapper映射文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;UserMapper&quot;&gt; &lt;!--查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.lagou.domain.User&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 5） 编写MyBatis核心文件 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--环境配置--&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!--使用MySQL环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!--使用JDBC类型事务管理器--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--使用连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis_db&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射配置--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/lagou/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 6） 编写测试类 12345678910111213141516@Test public void testFindAll() throws Exception &#123; // 加载核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); // 获取SqlSessionFactory工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获取SqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行sql List&lt;User&gt; list = sqlSession.selectList(&quot;UserMapper.findAll&quot;); for (User user : list) &#123; System.out.println(user); &#125; // 释放资源 sqlSession.close(); &#125; 3.3 知识小结1234561.创建mybatis_db数据库和user表 2.创建项目，导入依赖 3.创建User实体类 4.编写映射文件UserMapper.xml5.编写核心文件SqlMapConfig.xml6.编写测试类 4. Mybatis映射文件概述 5. Mybatis增删改查5.1 新增1） 编写映射文件UserMapper.xml 12345&lt;!--新增--&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.lagou.domain.User&quot;&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; 2）编写测试类 1234567891011121314151617181920@Test public void testSave() throws Exception &#123; // 加载核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); // 获取SqlSessionFactory工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获取SqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行sql User user = new User(); user.setUsername(&quot;jack&quot;); user.setBirthday(new Date()); user.setSex(&quot;男&quot;); user.setAddress(&quot;北京海淀&quot;); sqlSession.insert(&quot;UserMapper.save&quot;, user); // DML语句，手动提交事务 sqlSession.commit(); // 释放资源 sqlSession.close();&#125; 3）新增注意事项 123456789- 插入语句使用insert标签 - 在映射文件中使用parameterType属性指定要插入的数据类型 - Sql语句中使用#&#123;实体属性名&#125;方式引用实体中的属性值 - 插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); - 插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即 sqlSession.commit() 5.2 修改1） 编写映射文件UserMapper.xml 1234&lt;!--修改--&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.lagou.domain.User&quot;&gt; update user set username = #&#123;username&#125;,birthday = #&#123;birthday&#125;, sex = #&#123;sex&#125;,address = #&#123;address&#125; where id = #&#123;id&#125; &lt;/update&gt; 2）编写测试类 123456789101112131415161718192021@Test public void testUpdate() throws Exception &#123; // 加载核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); // 获取SqlSessionFactory工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获取SqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行sql User user = new User(); user.setId(4); user.setUsername(&quot;lucy&quot;); user.setBirthday(new Date()); user.setSex(&quot;女&quot;); user.setAddress(&quot;北京朝阳&quot;); sqlSession.update(&quot;UserMapper.update&quot;, user); // DML语句，手动提交事务 sqlSession.commit(); // 释放资源 sqlSession.close();&#125; 3）修改注意事项 123- 修改语句使用update标签 - 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 5.3 删除1） 编写映射文件UserMapper.xml 1234&lt;!--删除--&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt; 2）编写测试类 123456789101112131415@Test public void testDelete() throws Exception &#123; // 加载核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); // 获取SqlSessionFactory工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获取SqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行 sqlsqlSession.delete(&quot;UserMapper.delete&quot;, 50); // DML语句，手动提交事务 sqlSession.commit(); // 释放资源 sqlSession.close();&#125; 3）删除注意事项 12345- 删除语句使用delete标签 - Sql语句中使用#&#123;任意字符串&#125;方式引用传递的单个参数 - 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 5.4 知识小结 6. Mybatis核心文件概述6.1 MyBatis核心配置文件层级关系MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。配置文档的顶层结构如下： 6.2 MyBatis常用配置解析1）environments标签数据库环境的配置，支持多环境配置 123456781.其中，事务管理器（transactionManager）类型有两种： - JDBC： 这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 - MANAGED： 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。 例如：mybatis与spring整合后，事务交给spring容器管理。 2.其中，数据源（dataSource）常用类型有三种： - UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 - POOLED： 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 - JNDI : 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据 源，然后放置一个 JNDI 上下文的数据源引用 2）properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的 properties： 1234jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///mybatis_db jdbc.username=root jdbc.password=root 3）typeAliases标签 类型别名是为 Java 类型设置一个短的名字。 为了简化映射文件 Java 类型设置，mybatis框架为我们设置好的一些常用的类型的别名： 原来的类型名称配置如下： 配置typeAliases，为com.lagou.domain.User定义别名为user： 4）mappers标签 该标签的作用是加载映射的，加载方式有如下几种： 12345678910111.使用相对于类路径的资源引用，例如： &lt;mapper resource=&quot;org/mybatis/builder/userMapper.xml&quot;/&gt; 2.使用完全限定资源定位符（URL），例如： &lt;mapper url=&quot;file:///var/mappers/userMapper.xml&quot;/&gt; 3. 使用映射器接口实现类的完全限定类名，例如： &lt;mapper class=&quot;org.mybatis.builder.userMapper&quot;/&gt; 4. 将包内的映射器接口实现全部注册为映射器，例如： &lt;package name=&quot;org.mybatis.builder&quot;/&gt; 知识小结核心配置文件常用配置：properties标签：该标签可以加载外部的properties文件 1&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; typeAliases标签：设置类型别名 1&lt;typeAlias type=&quot;com.lagou.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; mappers标签：加载映射配置 1&lt;mapper resource=&quot;com/lagou/mapper/UserMapping.xml&quot;&gt;&lt;/mapper&gt; environments标签：数据源环境配置 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 7. Mybatis的API概述7.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream)通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 7.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： 7.3 SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 123456789&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit() void rollback() 7.4 基本流程 8. Mybatis的dao层开发使用8.1 传统开发方式1）编写UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findAll() throws Exception;&#125; 2）编写UserMapper实现 12345678910111213141516public class UserMapperImpl implements UserMapper &#123; @Override public List&lt;User&gt; findAll() throws Exception &#123; // 加载配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); // 获取SqlSessionFactory工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获取SqlSe会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行sql List&lt;User&gt; list = sqlSession.selectList(&quot;UserMapper.findAll&quot;); // 释放资源 sqlSession.close(); return list; &#125;&#125; 3）编写UserMapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;UserMapper&quot;&gt; &lt;!--查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 4）测试 12345678910@Test public void testFindAll() throws Exception &#123; // 创建UserMapper 实现类 UserMapper userMapper = new UserMapperImpl(); // 执行查询 List&lt;User&gt; list = userMapper.findAll(); for (User user : list) &#123; System.out.println(user); &#125;&#125; 5）知识小结传统开发方式 1231.编写UserMapper接口2.编写UserMapper实现3.编写UserMapper.xml 传统方式问题思考： 实现类中，存在mybatis模板代码重复 实现类调用方法时，xml中的sql statement 硬编码到java代码中 思考：能否只写接口，不写实现类。只编写接口和Mapper.xml即可？因为在dao（mapper）的实现类中对sqlsession的使用方式很类似。因此mybatis提供了接口的动态代理。 8.2 代理开发方式1）介绍采用 Mybatis 的基于接口代理方式实现 持久层 的开发，这种方式是我们后面进入企业的主流。基于接口代理方式的开发只需要程序员编写 Mapper 接口，Mybatis 框架会为我们动态生成实现类的对象。这种开发方式要求我们遵循一定的规范： Mapper.xml映射文件中的namespace与mapper接口的全限定名相同 Mapper接口方法名和Mapper.xml映射文件中定义的每个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml映射文件中定义的每个sql的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml映射文件中定义的每个sql的resultType的类型相同 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 2）编写UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; findAll() throws Exception;&#125; 3）编写UserMapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lagou.mapper.UserMapper&quot;&gt; &lt;!--查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 4）测试 123456789101112131415161718@Test public void testFindAll() throws Exception &#123; // 加载核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); // 获得SqlSessionFactory工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获得SqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 获得Mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 执行查询 List&lt;User&gt; list = userMapper.findAll(); for (User user : list) &#123; System.out.println(user); &#125; // 释放资源 sqlSession.close();&#125; 5）Mybatis基于接口代理方式的内部执行原理我们的持久层现在只有一个接口，而接口是不实际干活的，那么是谁在做查询的实际工作呢？ 下面通过追踪源码看一下： 1、通过追踪源码我们会发现，我们使用的mapper实际上是一个代理对象,是由MapperProxy代理产生的。 2、追踪MapperProxy的invoke方法会发现，其最终调用了mapperMethod.execute(sqlSession, args) 3、进入execute方法会发现，最终工作的还是sqlSession","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"不能说的秘密","slug":"不能说的秘密（吉他谱）","date":"2021-03-07T02:54:25.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/03/07/不能说的秘密（吉他谱）/","link":"","permalink":"http://yournotes.cn/2021/03/07/%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%88%E5%90%89%E4%BB%96%E8%B0%B1%EF%BC%89/","excerpt":"《不能说的秘密》谱子收藏、全文查看","text":"《不能说的秘密》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"Vue-cli&ElementUI","slug":"Vue-cli-ElementUI","date":"2021-03-06T12:17:44.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2021/03/06/Vue-cli-ElementUI/","link":"","permalink":"http://yournotes.cn/2021/03/06/Vue-cli-ElementUI/","excerpt":"","text":"1. 什么是Vue-cli Vue cli是基于Vue的应用开发提供的一个标准的脚手架工具.为应用搭建基础的框架结构,提供插件、开发服务、Preset、构建打包功能 Vue cli 背后集成了现代化开发的诸多功能,通过简单的命令就可以完成 “零配置”的项目环境搭建 2. 安装Vue-cli步骤在安装vue-cli前，要确认自己的电脑是否安装了nodejs和npm. 2.1 安装Node.js安装了node.js才有使用npm ，才能安装vue-cli 2.1.1 什么是node.js为什么会有node.js？ 传统意义上的 JavaScript 运行在浏览器上，Chrome 使用的 JavaScript 引擎是 V8，Node.js 是一个运行在服务端 的框架，它的底层就使用了 V8 引擎，这样就可以使用javascript去编写一些服务端的程序，这样也就实现了用 javaScript去开发 Apache + PHP 以及 Java Servlet所开发的服务端功能，这样做的好处就是前端和后端都采用 javascript，即开发一份js程序即可以运行在前端也可以运行的服务端，这样比一个应用使用多种语言在开发效率上 要高，不过node.js属于新兴产品，一些公司也在尝试使用node.js完成一些业务领域，node.js基于V8引擎，基于 事件驱动机制，在特定领域性能出色，比如用node.js实现消息推送、状态监控等的业务功能非常合适。 2.1.2 安装node.js 下载对应你系统的Node.js版本: https://nodejs.org/en/download/ 选安装目录进行安装, 我选择安装在了E盘: E:\\Program Files\\nodejs 测试: 在命令提示符下输入命令 1node -v //会显示当前node的版本 2.2 安装NPMnpm全称Node Package Manager，他是node包管理和分发的工具，使用NPM可以对应用的依赖进行管理，NPM 的功能和服务端项目构建工具maven的依赖管理功能差不多，我们通过npm 可以很方便地下载js库，打包js文件。 2.2.1 自动安装NPMnode.js已经集成了npm工具在命令提示符输入 npm -v 可查看当前npm版本 1npm -v 2.2.2 查看包管理路径包路径就是npm从远程下载的js包所存放的路径。 使用 npm config ls 查询NPM管理包路径（NPM下载的依赖包所存放的路径） 1npm config ls 我们发现NPM默认的管理包路径在: 1C:\\Users\\hao\\AppData\\Roaming\\npm 2.2.3 设置包管理路径依赖包放在C盘不太合适,为了方便对依赖包管理, 我们将管理包的路径设置在单独的地方: 我们选择一个路径,专门存放这些依赖包.我选择创建一个目录: H:\\software\\nodejs_package 在 H:\\software\\nodejs_package 下再创建 npm_modules 文件夹 和 npm_cache 文件夹: 执行下边的命令,设置为自定义的包管理路径： 12npm config set prefix &quot;H:\\software\\nodejs_package\\npm_modules&quot; npm config set cache &quot;H:\\software\\nodejs_package\\npm_cache&quot; 此时再使用 npm config ls 查询NPM管理包路径发现路径已更改 2.2.4 NPM环境变量配置 查看npm的全局路径是什么 1npm config get prefix 配置PATH环境变量 2.2.5 安装cnpmnpm默认会去国外的镜像去下载js包，在开发中通常我们使用国内镜像，这里我们使用淘宝镜像下边我们来安装cnpm： 有时我们使用npm下载资源会很慢，所以我们可以安装一个cnmp(淘宝镜像)来加快下载速度。 联网情况下, 输入命令，进行全局安装淘宝镜像: 1234//安装 npm install -g cnpm --registry=https://registry.npm.taobao.org //查看cnpm的版本 cnpm -v 2.3 安装vue-cli目前主流版本是 2.x 和 3.x 版本,安装3.x 以上的版本是因为该版本既可以创建2.x项目与3.x 项目注意: 以管理员身份打开命令行 安装命令 1npm install -g @vue/cli 输入 vue命令 输入 vue -V 查看版本 1vue -v 3. 快速构建Vue项目3.1 步骤说明我们使用vue-cli 快速构建项目,步骤如下: 桌面创建一个空的文件夹 以管理员身份运行cmd , 进入到vueTest文件夹 执行下面的命令 123//1.基于交互式命令方式,创建项目 //文件名 不支持驼峰（含大写字母）使用短横线方式 vue create my-project 选择自定义安装,点击回车 在这列表中,选择我们要安装的组件,使用空格键选择,选好后回车 按回车之后,提示选择什么模式的路由,我们输入 n (表示选择hash模式) 选择项目配置文件单独存放 是否保存模板,选择n 不创建 安装完成,提示输入执行下面这两个命令 首先进入项目目录 1cd my-project 启动项目 1npm run serve 访问项目: http://localhost:8080/ 停止项目 ctr+c或者关闭命令行窗口就可以 3.2 导入Vue项目到VSCode VSCode中右键选择打开文件夹 选择桌面上的项目 打开项目,可以看到如下项目结构 3.3 项目结构介绍1234567891011121314|--- my-project 项目名称 |--- node_modules 存放依赖包的目录 |--- public 静态资源管理目录 |--- src 组件源码目录(我们写的代码) |--- assets 存放静态图片资源(CSS也可以放在这里) |--- components 存放各种组件(一个页面可以看做一个组件)，各个组件联系在一起组成一个 完整的项目 |--- router 存放了项目路由文件 |--- views 放置的为公共组件(主要还是各个主要页面) |--- App.vue app.vue可以当做是网站首页，是一个vue项目的主组件，页面入口文件 |--- main.js 打包运行的入口文件，引入了vue模块和app.vue组件以及路由route |--- babel.config.js babel配置文件, 对源代码进行转码(把es6=&gt;es5) |--- package.json 项目及工具的依赖配置文件 |--- paxkage-lock.json 依赖配置文件 |--- README.md 项目说明 3.4 Vue脚手架自定义配置3.4.1 package.js 介绍每个项目的根目录下面，一般都有一个 package.json 文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。 npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 123456789101112131415161718192021222324252627&#123; //1.项目基本信息 &quot;name&quot;: &quot;project3&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, //2.指定运行脚本命令 &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot; &#125;, //4.生产环境所依赖模块的版本 &quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;vue&quot;: &quot;^2.6.11&quot;, &quot;vue-router&quot;: &quot;^3.2.0&quot; &#125;, //5.本地环境开发所依赖的版本 &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;~4.4.0&quot;, &quot;@vue/cli-plugin-router&quot;: &quot;~4.4.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.4.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; &#125; &#125; 3.4.2 通过package.json 配置项目配置内容采用JSON格式,所有的内容都用双引号包裹打开package.json,再最末端添加如下配置: 123456&quot;vue&quot;:&#123; &quot;devServer&quot;:&#123; &quot;port&quot;:&quot;8888&quot;, &quot;open&quot;:true &#125; &#125; 配置说明: 该配置设置打包时服务器相关的信息 port : 访问端口 open true: 打包完成自动打开浏览器 启动项目 在VSCode中选择项目,右键在终端打开 输入命令 1npm run serve 运行后发现端口号改为 8888,并且在打包完成后自动打开浏览器 注意: 不推荐这种方式,因为package.json 主要是用来管理包的配置信息.为了方便维护,我们将Vue脚手架相关的配置单独定义到 vue.confifig.js 配置文件中 3.4.3 单独的配置文件配置项目 在项目的根目录创建文件 vue.config.js 删除掉package中新添加的配置项. 在vue.config.js 文件中进行相关配置 12345module.exports = &#123; devServer:&#123; open:true port:8889 &#125; &#125; 3.5 Vue 组件化开发3.5.1 组件化开发组件化是Vue的精髓，Vue项目就是由一个一个的组件构成的。 我们主要的工作就是开发的组件. 3.5.2 组件介绍1）我们用 vue-cli 脚手架搭建的项目，里面有很多，如 index.vue 或者 App.vue 这一类的文件.每一个**.vue 文件都是一个组件 ，是一个自定义的文件类型**, 比如 App.vue 就是整个项目的根组件。 2）常见的组件： 页面级别的组件 页面级别的组件，通常是 views 目录下的.vue组件，是组成整个项目的各个主要页面 业务上可复用的基础组件 这一类组件通常是在业务中被各个页面复用的组件，这一类组件通常都写到 components 目录下，然后通过import在各个页面中使用 3）组件的组成部分 template : 组件的HTML部分 script: 组件的JS脚本 (使用ES6语法编写) style: 组件的CSS样式 1234567891011121314151617181920212223&lt;!-- 1.template 代表html结构, template中的内容必须有且只有一个根元素 编写页面静态部分 就是 view部分 --&gt; &lt;template&gt; &lt;div&gt;测试页面... &lt;/div&gt; &lt;/template&gt; &lt;!-- 2.编写vue.js代码 --&gt; &lt;script&gt; //可以导入其组件 // import Header from &#x27;../components/header.vue&#x27; //默认写法, 输出该组件 export default &#123; name:&quot;Home&quot;, // 组件名称，用于以后路由跳转 data() &#123;// 当前组件中需要使用的数据 return &#123;&#125; &#125;, methods: &#123;&#125; &#125; &lt;/script&gt; &lt;!-- 3.编写当前组件的样式代码 --&gt; &lt;style scoped&gt; /* 页面样式 加上scoped 表示样式就只在当前组件有效*/ &lt;/style&gt; 4. 项目运行流程4.1 main.js项目运行 会加载入口文件 main.js 1234567891011121314151617/* html文件中，通过script src = &#x27;xxx&#x27;标签引入js文件。 而vue中，通过 import 变量名 from 文件路径 的方式导入文件，不光可以导入js文件。 1.变量名: 指的是为导入的文件起一个名称，不是指导入的文件的名称，相当于变量名。 2.文件路径: 指的是文件的相对路径 */import Vue from &#x27;vue&#x27; import App from &#x27;./App.vue&#x27; import router from &#x27;./router&#x27; //关闭启动提示 Vue.config.productionTip = false //创建Vue实例 new Vue(&#123; router, //为整个项目添加路由 render: h =&gt; h(App) //这是一个函数ES6语法,作用是生成模板: App = App.vue &#125;).$mount(&#x27;#app&#x27;) //挂载的是App.vue组件中的id为app的区域 4.2 App.vueApp.vue 是vue项目的主组件，是页面入口文件 ，所有页面都是在App.vue下进行切换的 123456789101112&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--挂载的是这个div--&gt; &lt;div id=&quot;nav&quot;&gt; &lt;!--这里是两个路由导航链接--&gt; &lt;!--1. to=&quot;/&quot; 项目根路径 跳转的是首页--&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;!--2. to=&quot;/about&quot; 点击About按钮,跳转到about组件--&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;!--router-view 的作用是 根据访问的路径,渲染路径匹配到的视图组件--&gt; &lt;router-view/&gt; &lt;/div&gt; &lt;/template&gt; 4.3 router 路由找到路由文件,来看一下具体的路由配置 1234567891011121314151617181920212223242526272829// 引入所需文件 import Vue from &#x27;vue&#x27;//vue库 import VueRouter from &#x27;vue-router&#x27;//vue-router库 import Home from &#x27;../views/Home.vue&#x27; //首页 //使用路由功能 Vue.use(VueRouter)//创建路由规则 const routes = [&#123; path: &#x27;/&#x27;, //路径 name: &#x27;Home&#x27;, //名称 component: Home //组件 Home.vue &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import ( /* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;) &#125;] //创建路由管理器,管理routes const router = new VueRouter(&#123; routes &#125;)//export 用来导出模块 router就代表了整个路由文件 export default router 4.4 Home.vue组件 默认访问的是Home.vue 首页 1234567891011121314151617&lt; template&gt; &lt;div class = &quot;home&quot;&gt; 首页的logo &lt; img alt = &quot;Vue logo&quot; src = &quot;../assets/logo.png&quot; &gt; &lt; HelloWorld msg = &quot;Welcome to Your Vue.js App&quot; / &gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt; //导入了一个组件 HelloWorld.vue @符号表示 src这个目录 import HelloWorld from &#x27;@/components/HelloWorld.vue&#x27; export default &#123; name: &#x27;Home&#x27;, components: &#123; HelloWorld &#125; &#125;&lt;/script&gt; HelloWorld.vue 组件页面 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;p&gt; For a guide and recipes on how to configure / customize this project, &lt;br&gt; check out the &lt;a href=&quot;https://cli.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; vue-cli documentation &lt;/a&gt; &lt;/p&gt; &lt;h3&gt; Installed CLI Plugins &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;HelloWorld&#x27;, props: &#123; msg: String &#125; &#125;&lt;/script&gt; 5. 组件的使用案例5.1 创建Header.vue组件 在components 目录下创建 Header.vue 编写Header.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;header&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //JS 部分 export default &#123; name: &quot;Header&quot;, //组件的名称 data() &#123; //data函数 return &#123; msg: &quot;这是一个Header组件&quot; &#125; &#125;, &#125;&lt;/script&gt;//scoped 表示当前的样式,只作用与当前组件中的 template 视图.&lt;style scoped&gt; .header &#123; height: 100px; line-height: 100px; background-color: #eee;text-align: center; color: blue; &#125;&lt;/style&gt; 5.2 引入 Header组件修改Home.vue 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot;&gt; &lt;!-- &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; --&gt; &lt;Header/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // @ is an alias to /src //import HelloWorld from &#x27;@/components/HelloWorld.vue&#x27; import Header from &#x27;@/components/Header.vue&#x27;; export default &#123; name: &#x27;Home&#x27;, components: &#123; //HelloWorld Header &#125; &#125;&lt;/script&gt; 5.3 组件的传参props : 是组件中的属性, 表示组件可以接受参数, 12345678910111213141516&lt;template&gt; &lt;div id=&quot;Header&quot; class=&quot;header&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Header&quot;, //组件名称,用于路由的跳转 props:[&#x27;msg&#x27;] &#125;; &lt;/script&gt;// scoped 表示当前style的样式只作用于当前组件的template代码中，其他地方不会被影响&lt;style scoped&gt; .header &#123; height: 100px; line-height: 100px; background-color: #eee;text-align: center; color: blue; &#125;&lt;/style&gt; 6. Element-UI介绍element-ui 是饿了么前端出品的基于 Vue.js的 后台组件库，方便程序员进行页面快速布局和构建Element-UI官方站点：https://element.eleme.cn/#/zh-CN 7. Element-UI使用7.1 命令行方式安装 创建 一个新的项目 当前项目下打开终端, 安装依赖包 ,执行下面的命令 1npm i element-ui -S 打开 main.js , 导入Element-UI 相关资源. main.js是工程的入口文件，在此文件中加载了很多第三方组件，如：Element-UI、Base64、 VueRouter等。 12345678//导入组件库 import ElementUI from &#x27;element-ui&#x27; //导入组件相关样式 import &#x27;element-ui/lib/theme-chalk/index.css&#x27; //配置Vue插件 将El安装到Vue上 Vue.use(ElementUI); 复制Element 按钮样式 到app.vue文件的 template下 12345678910111213141516171819&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 测试elementUI --&gt; &lt;el-row&gt; &lt;el-button&gt;默认按钮&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt; &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;| &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt; 启动项目 npm run serve, 查看页面 7.2 Vue-CLI工程改造 删除components 目录下的 HelloWord.vue组件 删除App.vue中的部分内容,只保留如下部分 123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;style&gt; &lt;/style&gt; 删除router文件下的路由文件 index.js部分内容,只保留如下部分 12345678910import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter) const routes = [] const router = new VueRouter(&#123; routes&#125;) export default router 删除views目录下的 About.vue 与 Home.vue 7.3 安装axios npm安装：使用npm下载axios包 1npm i axios 在main.js文件中导入axios 相关资源 12345//引入axios import axios from &#x27;axios&#x27; //Vue对象使用axios Vue.prototype.axios = axios; 8. 用户登录界面制作8.1 Dialog对话框组件我们可以用Dialog制作一个登陆弹窗,选择自定义内容 123456789101112131415161718192021222324&lt;el-dialog title=&quot;收货地址&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;活动名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.name&quot; autocomplete=&quot;off&quot;&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;活动区域&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt; &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt; &lt;/el-option&gt; &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt; 取 消 &lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = false&quot;&gt; 确 定 &lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt; 8.2 创建login.vue 组件 在components 下创建login.vue 将Diglog组件的内容,拷贝到login.vue,进行修改: 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;el-dialog title=&quot;登录&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt; &lt;el-form&gt; &lt;el-form-item label=&quot;用户名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input autocomplete=&quot;off&quot;&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;用户密码&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input autocomplete=&quot;off&quot;&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = false&quot;&gt; 登录 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; formLabelWidth: &quot;120px&quot;, //宽度 dialogFormVisible: true &#125;; &#125; &#125;; &lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 8.3 配置路由123456789101112131415161718192021import Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import Login from &quot;@/components/Login.vue&quot;Vue.use(VueRouter);const routes = [//访问 /,也跳转到login &#123; path: &#x27;/&#x27;, redirect: &#x27;login&#x27; //重定向都login &#125;,//登录 &#123; path: &#x27;/login&#x27;, name: &#x27;login&#x27;, component: Login&#125;];const router = new VueRouter(&#123; routes,&#125;);export default router; 8.4 修改App.vue12345678&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- router-view 的作用是根据访问的路径,渲染路径匹配到的视图组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; &lt;/style&gt; 8.5 编写登录功能 去掉关闭按钮, 添加一个属性 :show-close&#x3D;”false” 1&lt;el-dialog title=&quot;登录&quot; :show-close=&quot;false&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt; 修改登陆触发事件 1&lt;el-button type=&quot;primary&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt; 双向数据绑定 data 中定义数据 1234567data() &#123; return &#123; formLabelWidth: &quot;120px&quot;, //宽度 dialogFormVisible: true, //是否关闭对话框 user: &#123; username: &quot;&quot;, password: &quot;&quot; &#125;, //登录数据 &#125;; &#125;, 使用 v-model, 将视图与模型进行绑定 12345678&lt;el-form&gt; &lt;el-form-item label=&quot;用户名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;user.username&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;用户密码&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;user.password&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 编写login方法 123456789101112131415161718192021222324methods: &#123; login() &#123; //定义常量保存 url const url = &quot;http&quot;; //发送请求 this.axios.get(url, &#123; //携带参数 params: &#123; username: this.user.username, password: this.user.password, &#125;, &#125;).then((res) = &gt;&#123; console.log(); //成功就将对话框关闭 this.dialogFormVisible = false; &#125;). catch((error) = &gt;&#123; //出现错误使用ElementUI提供的消息提示 this.$message.error(&quot;对不起! 登录错误!&quot;); &#125;); &#125;,&#125;, 8.6 Postman搭建mock server Mock server就是模拟一个服务器，我们使用Mock server可以模拟后台接口,对请求进行响应. 在前后端分离的开发中 前端利用mockeserver模拟出对应接口，拿到返回数据来调试，无需等后端开发人员完成工作。 postman模拟出一个server 步骤: 使用postman模拟出一个server 打开如下窗体，创建一个伪服务 第一步 第二步 第三步 1const url = &quot;复制上面的地址/login&quot;; 8.7 登录成功后跳转 在js中设置跳转，常用的一种方法是 this.$router.push 1234567891011121314151617181920212223242526methods: &#123; login() &#123; //定义常量保存 url const url = &quot;https://33284b33-e976-4124-a3a0-17044addc1e1.mock.pstmn.io/login&quot;; //发送请求 this.axios.get(url, &#123; //携带参数 params: &#123; username: this.user.username, password: this.user.password, &#125;, &#125;).then((res) = &gt;&#123; console.log(res.data); alert(&quot;登录成功!&quot;); //成功就将对话框关闭 this.dialogFormVisible = false; //跳转页面,前端跳转页面必须使用路由,使用$router对象中的push方法 this.$router.push(&#x27;/index&#x27;); &#125;). catch((error) = &gt;&#123; //出现错误使用ElementUI提供的消息提示 this.$message.error(&quot;对不起! 登录错误!&quot;); &#125;); &#125;,&#125;, 9. 跨域问题9.1 出现跨域问题当我们在前端项目中,向后端发送请求的获取课程数据的时候,出现了跨域问题: 已被CORS策略阻止：请求的资源上没有’ Access-Control-Allow-Origin’标头（跨域请求失败） 1Access to XMLHttpRequest at &#x27;http://localhost:8080/lagou_edu_home/course? methodName=findCourseList&#x27; from origin &#x27;http://localhost:8088&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. 9.2 什么是跨域跨域是指通过JS在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，只要协议、域名、端口有任何一个不同，都被当作是不同的域,浏览器就不允许跨域请求。 跨域的几种常见情 9.3 解决跨域问题跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置 Access-Control-Allow- Origin 及相关一系列参数，提供跨域访问的允许策略 设置响应头中的参数来允许跨域域请求: Access-Control-Allow-Credentials Access-Control-Allow-Origin 标识允许跨域的请求有哪些 1）在POM文件中引入依赖 123456&lt;!-- 解决跨域问题所需依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt; &lt;artifactId&gt;cors-filter&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; 1）在web.xml中 配置跨域 filter 123456789&lt;!--配置跨域过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"车站","slug":"车站（吉他谱）","date":"2021-03-01T02:54:09.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/03/01/车站（吉他谱）/","link":"","permalink":"http://yournotes.cn/2021/03/01/%E8%BD%A6%E7%AB%99%EF%BC%88%E5%90%89%E4%BB%96%E8%B0%B1%EF%BC%89/","excerpt":"《车站》谱子收藏、全文查看","text":"《车站》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"LeetCode初级算法之设计问题：384.打乱数组","slug":"打乱数组","date":"2021-02-28T17:41:38.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2021/03/01/打乱数组/","link":"","permalink":"http://yournotes.cn/2021/03/01/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/shuffle-an-array/ 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/shuffle-an-array/ 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。 实现 Solution class:Solution(int[] nums) 使用整数数组 nums 初始化对象int[] reset() 重设数组到它的初始状态并返回int[] shuffle() 返回数组随机打乱后的结果 示例： 12345输入[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;][[[1, 2, 3]], [], [], []]输出[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] 解释 1234Solution solution = new Solution([1, 2, 3]);solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2] 提示： 1 &lt;&#x3D; nums.length &lt;&#x3D; 200-106 &lt;&#x3D; nums[i] &lt;&#x3D; 106nums 中的所有元素都是 唯一的最多可以调用 5 * 104 次 reset 和 shuffle 解法一：暴力题目意思是让我们实现一个类，它测试就会创建对象并且调用打乱方法与重置方法。既然有重置的话打乱的修改不是在原数组上进行。第一是新数组第二是随机位置。那我们就可以使用ArrayList与Random来实现 代码如下 12345678910111213141516171819202122232425262728293031323334class Solution &#123; // 原数组、打乱返回数组、随机数 private int[] nums; private int[] result; private Random rand = new Random(); // 构造器初始化原数组与打乱数组的空间 public Solution(int[] nums) &#123; this.nums = nums; result = new int[nums.length]; &#125; // 重置方法：即返回原数组 public int[] reset() &#123; return nums; &#125; // 打乱方法：arrayList随机取[0,size) public int[] shuffle() &#123; //获取原数组的arrayList List&lt;Integer&gt; arrayList = getArrayList(); for (int i = 0; i &lt; nums.length; i++) &#123; int index = rand.nextInt(arrayList.size()); result[i] = arrayList.get(index); arrayList.remove(index); &#125; return result; &#125; // 获取List方法 private List&lt;Integer&gt; getArrayList() &#123; List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; arrayList.add(nums[i]); &#125; return arrayList; &#125;&#125; 时间复杂度：最差有(51024)(n&#x2F;2)*n，总体来说O(n^2)的时间复杂度空间复杂度：由于要用额外数组无法避免的O(n) 解法二：优化上面的解法效率确实是不够的，其实之前做了那么一系列数组的算法题，虽然都是初级合集的但明显我们能明白一个关于数组原地变换的一个点，就是通过交换减少规模但这一题并不能让我们通过交换来减少一半的规模，因为随机取再与后面的交换虽然能达到一半的复杂度并全员随机打乱，但并不是完全随机。所以我们还是要遍历完整每个进行random，这样做还是有个好处就是不需要arrayList了这样可以将n^2的复杂度降为n 代码如下： 1234567891011121314151617181920212223242526class Solution &#123; private int[] nums; private int[] result; Random random = new Random(); public Solution(int[] nums) &#123; this.nums = nums; result = nums.clone(); &#125; public int[] reset() &#123; result = nums; nums = nums.clone(); return result; &#125; public int[] shuffle() &#123; for (int i = 0; i &lt; result.length; i++) &#123; int index = random.nextInt(result.length - i) + i; int temp = result[index]; result[index] = result[i]; result[i] = temp; &#125; return result; &#125;&#125; 空间复杂度：O(n)时间复杂度：O(n) 总结这一题主要需要考虑打乱是一个什么状态，操作逻辑有没有影响到“随机”，关于解法一与二采用了两种方式记录原数组与打乱的过程数组，由于解法一的打乱赋值过程分了两个容器list和result所以才可以简略的这样写一个空数组，每次都是完全的按照阶乘的一个选取情况。解法二为了减少生成list所带来n倍的复杂度，采用交换，这样就需要在打乱数组本身原地进行，如果是在原数组取一对赋值到打乱数组那么就会出现重复。还有一个点是重置方法的，我在解法一直接是返回原数组只能说在当前逻辑上是满足，但最好还是像解法二一样真正的对打乱数组进行还原而不是把原数组返回出去。并且这里有个需要注意的点，我们在数组赋值实际上指向同一个对象，整个时候我们重置了result数组但result数组改变会影响原数组nums也就是我们要把nums指向另一个，也就是nums &#x3D; nums.clone();","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"Vue.js","slug":"Vue-js","date":"2021-02-27T04:07:10.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2021/02/27/Vue-js/","link":"","permalink":"http://yournotes.cn/2021/02/27/Vue-js/","excerpt":"","text":"超长警告！！！善用目录 1. Vue.js介绍1.1 Vue.js是什么? Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是， Vue 被设计 为可以自底向上逐层应用. Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一 方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 自底向上逐层应用：作为渐进式框架要实现的目标就是方便项目增量开发(即插即用)。 官方网站: https://cn.vuejs.org/v2/guide/ 作者 尤雨溪是中国人 1.2 为甚么使用Vue? 声明式渲染: 前后端分离是未来趋势 渐进式框架: 适用于各种业务需求 简单易学: 国人开发,中文文档,不存在语言障碍,易于理解和学习 2. Vue.js 基础2.1 Vue.js的使用 在html页面使用script引入vue.js的库即可使用。 1234远程CDN &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt; 本地&lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; Vue-CLI脚手架:使用vue.js官方提供的CLI脚本架很方便去创建vue.js工程雏形 2.2 入门程序创建一个vuetest目录, 并且在目录下创建 01_vue入门程序.html 文件 代码编写步骤： 定义html，引入vue.js 定义app div，此区域作为vue的接管区域 定义Vue实例，接管app区域。 定义model（数据对象） 在app中展示数据 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt; Vue入门 &lt;/title&gt; &lt;!-- 1.创建HTML文件， 引入vue.js 有两种方式--&gt; &lt;!-- 第一种 引入 vue.js的CDN地址 --&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt; &lt;/script&gt; --&gt; &lt;!-- 第二种 本地导入 --&gt; &lt;script src=&quot;vue.min.js&quot;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 2. 定义app div，此区域作为vue的接管区域 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &#123;&#123;&#125;&#125; 双括号是VUE中的差值表达式,将表达式的值输出到HTML页面 --&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; //3. 创建vue实例 var VM = new Vue(&#123; //定义 Vue实例挂载的元素节点,表示vue接管该div el:&#x27;#app&#x27;, //4.定义model模型数据对象 data:&#123;name:&quot;哈拉少&quot; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 双大括号：插值表达式 通常用来获取Vue实例中定义的数据(data) 属性节点中 不能够使用插值表达式 el：挂载点 定义 Vue实例挂载的元素节点,表示vue接管该区域 Vue会管理el选项命中的元素,及其内部元素 el选择挂载点时,是否可以使用其他选择器 ? 可以,但是建议使用 ID选择器 是否可以设置其他的DOM元素进行关联 ?可以但是建议选择DIV, 不能使用HTML和Body标签 data：数据对象 Vue中用到的数据定义在data中 data中可以写复杂类型 渲染复杂类型数据的时候,遵守js语法 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;!-- 此区域作为vue的接管区域 --&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;name&#125;&#125; &lt;br&gt; &#123;&#123;school.name&#125;&#125; &#123;&#123;school.mobile&#125;&#125; &lt;br&gt; &lt;ul&gt; &lt;li&gt; &#123;&#123;names[0]&#125;&#125; &lt;/li&gt; &lt;li&gt; &#123;&#123;names[1]&#125;&#125; &lt;/li&gt; &lt;li&gt; &#123;&#123;names[2]&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; //创建vue实例 var VM = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &quot;雷霆八嘎&quot;, //对象类型数据 author: &#123; name: &quot;木瓜煲鸡脚&quot;, mobile: &quot;1001001&quot; &#125;, //数组类型 names: [&quot;小斌&quot;, &quot;张百万&quot;, &quot;刘能&quot;] &#125; &#125;);&lt;/script&gt; 2.3 声明式渲染的好处Vue中的声明式渲染,简单理解就是我们声明数据,Vue帮我们将数据渲染到HTML. 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt; Document &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125; &lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- jQuery中，如果 DOM 发生变化, js代码也需要做相应的改变，高耦合 . &lt;script src=&quot;./js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function () &#123; $(&quot;#app&quot;).append(&quot;&lt;h2&gt;Hello Word! !&lt;/h2&gt;&quot;); &#125;); &lt;/script&gt; --&gt; &lt;!-- 在用 Vue中，只需要定义好展示数据，并把它放在 DOM 合适的位置就可以. --&gt; &lt;script src=&quot;js/vue.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, //挂载点 data: &#123; name: &quot;Hello Word! !&quot;, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 2.4 Vue常用指令根据官网的介绍，指令 是带有 v- 前缀的特殊属性。通过指令来操作DOM元素 2.4.1 v-text 指令作用: 获取data数据, 设置标签的内容.注意: 默认写法会替换全部内容,使用插值表达式 双括号 可以替换指定内容. 代码示例 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-text 获取data数据,设置标签内容,会覆盖之前的内容体--&gt; &lt;h2 v-text=&quot;message&quot;&gt; 百度 &lt;/h2&gt; &lt;!-- 使用插值表达式,不会覆盖 --&gt; &lt;h2&gt; &#123;&#123;message&#125;&#125;百度 &lt;/h2&gt; &lt;!-- 拼接字符串 --&gt; &lt;h2 v-text=&quot;message+1&quot;&gt; &lt;/h2&gt; &lt;h2 v-text=&quot;message+&#x27;abc&#x27;&quot;&gt; &lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;Java程序员&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.4.2 v-html 指令作用: 设置元素的 innerHTML (可以向元素中写入新的标签) 代码示例 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 获取普通文本 --&gt; &#123;&#123;message&#125;&#125; &lt;h2 v-text=&quot;message&quot;&gt; &lt;/h2&gt; &lt;h2 v-html=&quot;message&quot;&gt; &lt;/h2&gt; &lt;!-- 设置元素的innerHTML --&gt; &lt;h2 v-html=&quot;url&quot;&gt; &lt;/h2&gt; &lt;h2 v-text=&quot;url&quot;&gt; &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;Java程序员&quot;, url: &quot;&lt;a href=&#x27;https://www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot;, &#125;, &#125;);&lt;/script&gt; 2.4.3 v-on 指令作用: 为元素绑定事件, 比如: v-on:click,可以简写为 @click&#x3D;”方法”绑定的方法定义在 VUE实例的, method属性中 语法格式 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;!-- 使用v-on 绑定click 点击事件 --&gt; &lt;input type=&quot;button&quot; value=&quot;点击按钮&quot; v-on:click=&quot;方法名&quot;&gt; &lt;!-- 使用 @符号也可以绑定--&gt; &lt;input type=&quot;button&quot; value=&quot;点击按钮&quot; @click=&quot;方法名&quot;&gt;&lt;/div&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, //通过methods ,专门存放Vue中的方法 methods: &#123;方法名: function() &#123; alert(&quot;123!&quot;) &#125; &#125; &#125;)&lt;/script&gt; 代码示例 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用v-on 绑定click 点击事件 --&gt; &lt;input type=&quot;button&quot; value=&quot;点击按钮&quot; v-on:click=&quot;show&quot;&gt; &lt;!-- 简写 @方式 --&gt; &lt;input type=&quot;button&quot; value=&quot;点击按钮&quot; @click=&quot;show&quot;&gt; &lt;!-- 双击事件 --&gt; &lt;input type=&quot;button&quot; value=&quot;双击击按钮&quot; @dblclick=&quot;show&quot;&gt; &lt;!-- 绑定点击事件 --&gt; &lt;h2 @click=&quot;changeFood&quot;&gt; &#123;&#123;food&#125;&#125; &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; food: &quot;麻辣小龙虾&quot; &#125;, //通过methods ,专门存放Vue中的方法 methods: &#123; show: function() &#123; alert(&quot;程序员!&quot;) &#125;, changeFood: function() &#123; //使用this获取 console.log(this.food); //在VUE中不需要考虑如何更改DOM元素, 重点放在更改数据,数据更新之后,使用数据 的那个元素会同步更新 this.food+=&quot;真好吃!&quot;; &#125; &#125; &#125;) &lt;/script&gt; 2.4.4 计数器案例1）编码步骤 data中定义数据: 比如 num 值为1 methods中添加两个方法: 比如add(递增) ,sub(递减) 使用双大括号将num设置给 span标签 使用v-on 将add,sub 分别绑定给 + ,- 按钮 累加到10 停止 递减到0 停止 2）页面准备 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 计算功能区域 --&gt; &lt;div&gt; &lt;input type=&quot;button&quot; class=&quot;btn btn_plus&quot;&gt; &lt;span&gt; &#123;&#123;num&#125;&#125; &lt;/span&gt; &lt;input type=&quot;button&quot; class=&quot;btn btn_minus&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //创建VUE实例 var VM = new Vue(&#123; el:&quot;#app&quot;, data:&#123; num:1 &#125; &#125;) &lt;/script&gt; 3）案例演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt; Document &lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/inputNum.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 计算功能区域 --&gt; &lt;div&gt; &lt;input type=&quot;button&quot; class=&quot;btn btn_plus&quot; @click=&quot;add&quot;&gt; &lt;span&gt; &#123;&#123;num&#125;&#125; &lt;/span&gt; &lt;input type=&quot;button&quot; class=&quot;btn btn_minus&quot; @click=&quot;sub&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;vue.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; //创建VUE实例 var VM = new Vue(&#123; el:&quot;#app&quot;, data:&#123;num:1 &#125;, methods: &#123; add:function()&#123; //console.log(&quot;add&quot;); if(this.num &lt; 10)&#123; this.num++; &#125;else&#123; alert(&quot;别点啦!最大了!&quot;) &#125; &#125;, sub:function()&#123; //console.log(&quot;sub&quot;); if(this.num &gt; 0)&#123; this.num--; &#125;else&#123; alert(&quot;别点啦!最小了!&quot;) &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 4）案例总结 创建VUE实例时: el(挂载点) , data(数据) , methods(方法) v-on 指令的作用是绑定事件,简写为 @ 方法中使用this关键字,获取data中的数据 v-text 与 双大括号的作用都是用来 设置元素的文本值 2.4.5 v-show 指令作用: v-show指令, 根据真假值,切换元素的显示状态 123456789101112&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./img/car.gif&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt; 代码示例 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换状态&quot; @click=&quot;changeShow&quot; /&gt; &lt;img v-show=&quot;isShow&quot; src=&quot;./img/car.gif&quot; /&gt; &lt;img v-show=&quot;age &gt; 18&quot; src=&quot;./img/car.gif&quot; /&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; isShow: true, age: 19, &#125;, methods: &#123; changeShow: function() &#123; //触发方法, 对isShow进行取反 this.isShow = !this.isShow; &#125;, &#125;, &#125;); &lt;/script&gt; v-show 指令总结 原理是修改元素的display,实现显示或者隐藏 指令后面的内容,最终会解析为 布尔值 值为true 显示, 为false 则隐藏 数据改变之后,显示的状态会同步更新 2.4.6 v-if 指令作用: 根据表达值的真假,切换元素的显示和隐藏( 操纵dom 元素 ) 代码示例 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换显示状态&quot; @click=&quot;changeShow&quot;&gt; &lt;img v-if=&quot;isShow&quot; src=&quot;./img/car.gif&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; isShow: false &#125;, methods: &#123; changeShow: function() &#123; this.isShow = !this.isShow; &#125; &#125; &#125;)&lt;/script&gt; v-if 指令总结 v-if 指令的作用: 根据表达式的真假切换元素的显示状态 本质是通过操作dom元素,来切换显示状态 表达式为true 元素存在与dom树,为false从dom树中移除 频繁切换使用 v-show ,反之使用v-if 2.4.7 v-bind 指令作用: 设置元素的属性 （比如:src,title,class）语法格式: v-bind:属性名=表达式 或 :xxx=xxx 12345678910&lt;img v-bind:src=&quot;imgSrc&quot;&gt;&lt;img :src=&quot;imgSrc&quot;&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; imgSrc: &quot;图片地址&quot; &#125; &#125;)：&lt;/script&gt; 代码示例 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用v-bind设置src属性值 --&gt; &lt;img v-bind:src=&quot;imgSrc&quot; alt=&quot;&quot;&gt; &lt;!-- 简写 设置title --&gt; &lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot; :title=&quot;imgTitle&quot;&gt; &lt;!-- 设置class --&gt; &lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27;&#125;&quot;&gt; v-bind指令 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; imgSrc: &quot;https://gitee.com/Jasper-zh/blogImage/raw/master/Others/avg/hao.jpg&quot;, imgTitle: &quot;木瓜煲鸡脚&quot;, size: 100 &#125; &#125;)&lt;/script&gt; 2.4.8 v-for 指令作用: 根据数据生成列表结构 语法结构 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in arr&quot;&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; arr: [1, 2, 3, 4, 5], objArr: [&#123; name: &quot;tom&quot; &#125;, &#123; name: &quot;jack&quot; &#125;] &#125; &#125;)&lt;/script&gt; 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加数据&quot; @click=&quot;add&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;移除数据&quot; @click=&quot;remove&quot;&gt; &lt;ul&gt; &lt;!-- 在li标签中获取数组元素 --&gt; &lt;li v-for=&quot;(item,index) in arr&quot;&gt; &#123;&#123;index+1 &#125;&#125;城市: &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 使用h2标签显示 v-for 结合 v-bind一起使用 --&gt; &lt;h2 v-for=&quot;p in persons&quot; v-bind:title=&quot;p.name&quot;&gt; &#123;&#123;p.name&#125;&#125; &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; //普通数组 arr: [&quot;上海&quot;, &quot;北京&quot;, &quot;天津&quot;, &quot;杭州&quot;], //对象数组 persons: [&#123; name: &quot;尼古拉斯·赵四&quot; &#125;, &#123; name: &quot;莱安纳多·小沈阳&quot; &#125;] &#125;, methods: &#123; add: function() &#123; //push 添加 this.persons.push(&#123; name: &quot;多利安·刘能&quot; &#125;) &#125;, remove: function() &#123; this.persons.shift(); &#125; &#125; &#125;)&lt;/script&gt; v-for 指令总结 v-for 指令的作用: 根据数据生成列表结构 数组经常和 v-for结合使用,数组有两个常用方法: push() 向数组末尾添加一个或多个元素 shift() 把数组中的第一个元素删除 语法是: (item,index) in 数据 item和index 可以结合其他指令一起使用 数组的长度变化,会同步更新到页面上,是响应式的 2.4.9 v-on 指令补充 传递自定义参数 : 函数调用传参 事件修饰符: 对事件触发的方式进行限制 代码示例 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 函数传参 --&gt; &lt;input type=&quot;button&quot; value=&quot;礼物刷起来&quot; @click=&quot;showTime(666,&#x27;爱你老铁!&#x27;)&quot; /&gt; &lt;!-- 事件修饰符 指定哪些方式可以触发事件 --&gt; &lt;input type=&quot;text&quot; @keyup.enter=&quot;hi&quot; /&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, methods: &#123; showTime: function(p1, p2) &#123; console.log(p1); console.log(p2); &#125;, hi: function() &#123; alert(&quot;你好吗?&quot;); &#125;, &#125;, &#125;);&lt;/script&gt; 总结 事件绑定方法,可以传入自定义参数 定义方法时,需要定义形参,来接收实际的参数 事件的后面跟上 .修饰符 可以对事件进行限制 .enter 可以限制触发的按键为回车 事件修饰符有许多 使用时可以查询文档 2.4.10 MVVM模式 MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式. MVVM模式将页面,分层了 M 、V、和VM ,解释为： Model: 负责数据存储 View: 负责页面展示 View Model: 负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示 1234567891011121314151617181920&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- View 视图部分 --&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125; &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //创建的vue实例,就是 VM ViewModel var VM = new Vue(&#123; el: &quot;#app&quot;, //data就是MVVM模式中的 model data: &#123; name: &quot;hello&quot;, &#125;, &#125;);&lt;/script&gt; 首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。 从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据； 从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。 MVVM的思想,主要是为了让我们的开发更加的方便,因为MVVM提供了数据的双向绑定 2.4.11 v-mode 指令作用: 获取和设置表单元素的值(实现双向数据绑定) 双向数据绑定 单向绑定: 就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。 双向绑定: 用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。 什么情况下用户可以更新View呢？ 填写表单就是一个最直接的例子。当用户填写表单时，View的状态就被更新了，如果此时MVVM框架可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定： 代码示例 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;修改message&quot; @click=&quot;update&quot; /&gt; &lt;!-- View 视图 --&gt; &lt;!-- &lt;input type=&quot;text&quot; v-bind:value=&quot;message&quot; /&gt; --&gt; &lt;!-- v-model 实现双向数据绑定 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; &lt;input type=&quot;text&quot; v-model=&quot;password&quot; /&gt; &lt;h2&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //VM 业务逻辑控制 var VM = new Vue(&#123; el: &quot;#app&quot;, //Model 数据存储 data: &#123; message: &quot;Jasper&quot;, password: 123, &#125;, methods: &#123; update: function() &#123; this.message = &quot;hello&quot;; &#125;, &#125;, &#125;);&lt;/script&gt; v-model 指令总结 v-model 指令的作用是便捷的设置和获取表单元素的值 绑定的数据会和表单元素值相关联 双向数据绑定 2.5 实现简单记事本2.5.1 功能介绍 2.5.2 新增记录步骤 生成列表结构(v-for 数组) 获取用户输入(v-model 双向绑定) 回车,新增数据(v-on .enter事件修饰符) 页面布局不熟悉,可以通过审查元素的方式快速找到元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;body&gt; &lt;!-- VUE示例接管区域 --&gt; &lt;section id=&quot;app&quot;&gt; &lt;!-- 输入框 --&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt; VUE记事本 &lt;/h1&gt; &lt;!-- v-on 绑定事件 --&gt; &lt;input v-model=&quot;inputValue&quot; @keyup.enter=&quot;add&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;输入日程&quot; class=&quot;new-todo&quot; /&gt; &lt;/header&gt; &lt;!-- 列表区域 --&gt; &lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;listview&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt; &#123;&#123;index+1&#125;&#125; &lt;/span&gt; &lt;label&gt; &#123;&#123;item&#125;&#125; &lt;/label&gt; &lt;button class=&quot;destroy&quot;&gt; &lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;/section&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; list: [&quot;写代码&quot;, &quot;吃饭&quot;, &quot;睡觉&quot;], inputValue: &quot;996还是997&quot; &#125;, methods: &#123; //新增方法 add: function() &#123; //将用户输入的内容添加到list this.list.push(this.inputValue); &#125; &#125; &#125;)&lt;/script&gt; 2.5.3 删除记录步骤 点击删除指定的内容( 根据索引删除元素) 在methods中添加一个删除的方法,使用splice函数进行删除 123456789101112131415161718&lt;!-- 列表区域 --&gt;&lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;listview&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt; &#123;&#123;index+1&#125;&#125; &lt;/span&gt; &lt;label&gt; &#123;&#123;item&#125;&#125; &lt;/label&gt; &lt;!-- 删除按钮 --&gt; &lt;button class=&quot;destroy&quot; @click=&quot;remove(index)&quot;&gt; &lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/section&gt; 123456//删除方法 remove: function(index) &#123; console.log(index); //使用splice(元素索引,删除几个) 根据索引删除 this.list.splice(index, 1);&#125; 2.5.4 统计操作步骤 统计页面信息的个数,就是列表中的元素的个数. 获取 list数组的长度,就是信息的个数 123456789101112&lt;!-- 统计和清空 --&gt;&lt;footer class=&quot;footer&quot;&gt; &lt;span class=&quot;todo-count&quot;&gt; &lt;strong&gt; &#123;&#123;list.length&#125;&#125; &lt;/strong&gt; items left &lt;/span&gt; &lt;button class=&quot;clear-completed&quot;&gt; Clear &lt;/button&gt;&lt;/footer&gt; 总结 基于数据的开发方式 v-text设置的是文本,可以使用简化方式 &#123;&#123;&#125;&#125; 2.5.5 清空数据步骤： 点击清除所有信息 本质就是清空数组 1&lt;button class=&quot;clear-completed&quot; @click=&quot;clear()&quot;&gt;Clear&lt;/button&gt; 1234//清空数组元素 clear: function() &#123; this.list = [];&#125; 3. axios3.1 Ajax回顾3.1.1 什么是Ajax?Ajax 是指一种创建交互式网页应用的开发技术。Ajax &#x3D; 异步 JavaScript 和 XML。 3.1.2 Ajax的作用 Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新（局部更新）。传统的网页如果需要更新内容，必须重载整个网页页面。 简单记: Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术, 维护用户体验性, 进行网页的局部刷新 3.1.3 异步与同步 浏览器访问服务器的方式 同步访问: 客户端必须等待服务器端的响应,在等待过程中不能进行其他操作 异步访问: 客户端不需要等待服务的响应,在等待期间,浏览器可以进行其他操作 3.1.4 案例演示ajax.jsp 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt; Document &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Jquery发送异步请求&quot; onclick=&quot;run1()&quot; /&gt; &lt;/body&gt; &lt;script src=&quot;./jquery-1.8.3.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; function run1() &#123; //JQuery Ajax方式 发送异步请求 $.ajax(&#123; url: &quot;/ajax&quot;, async: true, data: &#123; name: &quot;天青&quot; &#125;, type: &quot;post&quot;, dataType: &quot;text&quot;, success: function(res) &#123; console.log(res) alert(&quot;响应成功&quot; + res); &#125;, error: function() &#123; alert(&quot;响应失败!&quot;); &#125; &#125;); &#125; &lt;/script&gt;&lt;/html&gt; servlet.java 1234567891011121314151617181920@WebServlet(&quot;/ajax&quot;) public class AjaxServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; //1.获取请求数据 String username = req.getParameter(&quot;name&quot;); //模拟业务操作,造成的延时效果 try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //2.打印username System.out.println(username); resp.getWriter().write(&quot;hello hello&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 3.1 axios介绍VUE中结合网络数据进行应用的开发 目前十分流行网络请求库,专门用来发送请求,其内部还是ajax,进行封装之后使用更加方便 axios作用: 在浏览器中可以帮助我们完成 ajax异步请求的发送 Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax 3.2 axios入门使用步骤: 导包 12&lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 请求方式,以GET和POST举例 GET 1axios.get(地址?key=value&amp;key2=value2).then(function(response)&#123;&#125;,function(error) &#123;&#125;); POST 1axios.post(地址,&#123;key:value,key2:value2&#125;).then(function(response) &#123;&#125;,function(error)&#123;&#125;) 根据接口文档, 访问测试接口,进行测试 接口1：随机笑话 1234请求地址:https://autumnfish.cn/api/joke/list 请求方法:get 请求参数:num(笑话条数,数字) 响应内容:随机笑话 接口2：用户注册 1234请求地址:https://autumnfish.cn/api/user/reg 请求方法:post 请求参数:username(用户名,字符串) 响应内容:注册成功或失败 代码示例 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;get请求&quot; id=&quot;get&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;post请求&quot; id=&quot;post&quot;&gt;&lt;/body&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* 请求地址:https://autumnfish.cn/api/joke/list 请求方法:get 请求参数:num(笑话条数,数字) 响应内容:随机笑话 */ document.getElementById(&quot;get&quot;).onclick = function() &#123; axios.get(&quot;https://autumnfish.cn/api/joke/list?num=1&quot;).then(function(response) &#123; //请求成功,调用 console.log(response); &#125;, function(error) &#123; //请求失败,调用 console.log(error) &#125;); &#125; /* 请求地址:https://autumnfish.cn/api/user/reg 请求方法:post 请求参数:username(用户名,字符串) 响应内容:注册成功或失败*/ document.getElementById(&quot;post&quot;).onclick = function() &#123; axios.post(&quot;https://autumnfish.cn/api/user/reg&quot;, &#123; username: &quot;张百万&quot; &#125;).then(function(response) &#123; console.log(response); &#125;, function(error) &#123; console.log(error); &#125;); &#125;&lt;/script&gt; 3.3 axios总结 axios 必须导包才能使用 使用get或者post方法,就可以发送请求 then方法中的回调函数,会在请求成功或者请求失败的时候触发 通过回调函数的形参可以获取响应的内容,或者错误信息 3.4 获取笑话案例通过vue+axios 完成一个获取笑话的案例。 接口: 随机获取一条笑话 1234请求地址:https://autumnfish.cn/api/joke/请求方法:get 请求参数:无 响应内容:随机笑话 代码示例 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击获取一个笑话&quot; @click=&quot;getJoke&quot;&gt; &lt;p&gt; &#123;&#123;joke&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- 引入vue + axios --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* 请求地址:https://autumnfish.cn/api/joke 请求方法:get 请求参数:无 响应内容:随机笑话 */ var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; joke: &quot;笑笑更健康&quot; &#125;, methods: &#123; getJoke: function() &#123; console.log(this.joke); //笑笑更健康 var that = this; //把this保存起来 //异步访问 axios.get(&quot;https://autumnfish.cn/api/joke&quot;).then( function(response)&#123; //获取data中的笑话 console.log(response.data); //console.log(this.joke); undefined 没有获取到this that.joke=response.data; &#125;,function(error)&#123; &#125; ) &#125; &#125; &#125;) &lt;/script&gt; 案例总结 axios回调函数中this指向已经改变,无法访问data中的数据 解决方案: 将this进行保存,回调函数中直接使用保存的this即可 3.5 天气查询案例 3.5.1 需求分析 功能分析: 回车查询 输入内容,点击回车 (v-on.enter) 访问接口,查询数据 (axios v-model) 返回数据,渲染数据 3.5.2 接口文档1234请求地址:http://wthrcdn.etouch.cn/weather_mini 请求方法:get 请求参数:city (要查询的城市名称) 响应内容:天气信息 3.5.3 案例演示自定义js文件作为一个标准的应用程序,我们将创建VUE实例的代码,抽取到main.js 文件中 12345678910111213141516171819202122232425var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; city: &#x27;&#x27;, //定义空数组接收天气信息 weatherList: [] &#125;, //编写查询天气方法 methods: &#123; searchWeather: function() &#123; console.log(&quot;天气查询&quot;); console.log(this.city); //保存this,方便在回调函数中使用 var that = this; //调用接口 axios.get(&quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot; + this.city).then(function(respose) &#123; //console.log(respose); //只获取天气数组 console.log(respose.data.data.forecast); that.weatherList = respose.data.data.forecast; &#125;, function(error) &#123;&#125;); &#125; &#125;&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;body&gt; &lt;div class=&quot;wrap&quot; id=&quot;app&quot;&gt; &lt;div class=&quot;search_form&quot;&gt; &lt;div class=&quot;logo&quot;&gt; 天气查询 &lt;/div&gt; &lt;div class=&quot;form_group&quot;&gt; &lt;!-- 3.绑定点击事件,回车触发,通过v-model绑定数据 --&gt; &lt;input v-model=&quot;city&quot; @keyup.enter=&quot;searchWeather&quot; type=&quot;text&quot; class=&quot;input_txt&quot; placeholder=&quot;请输入要查询的城市&quot; /&gt; &lt;button class=&quot;input_sub&quot;&gt; 回车查询 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=&quot;weather_list&quot;&gt; &lt;!-- 遍历天气信息 --&gt; &lt;li v-for=&quot;item in weatherList&quot;&gt; &lt;div class=&quot;info_type&quot;&gt; &lt;span class=&quot;iconfont&quot;&gt; &#123;&#123;item.type&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info_temp&quot;&gt; &lt;b&gt; &#123;&#123;item.low&#125;&#125; &lt;/b&gt; ~ &lt;b&gt; &#123;&#123;item.high&#125;&#125; &lt;/b&gt; &lt;/div&gt; &lt;div class=&quot;info_date&quot;&gt; &lt;span&gt; &#123;&#123;item.date&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt; &lt;/script&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt; &lt;/script&gt; &lt;!-- 2.引入自己的js --&gt; &lt;script src=&quot;./js/main.js&quot;&gt; &lt;/script&gt;&lt;/body&gt; 3.5.4 案例总结 应用的逻辑代码,建议与页面进行分离,使用单独的JS编写 axios回调函数中的 this的指向改变,无法正常使用, 需要另外保存一份 服务器返回的数据比较的复杂时,获取数据时要注意层级结构 3.6 解决页面闪烁问题我们发现访问天气预报案例页面时, 使用插值表达式的地方出现了闪烁问题,如何解决呢? v-cloak 指令 作用: 解决插值表达式闪烁问题 当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码。我们可以使用 v-cloak 指令来解决这一问题。 1）添加样式 123456&lt;style&gt; /* 通过属性选择器,设置 添加了v-cloak */ [v-cloak] &#123; display: none; &#125; &lt;/style&gt; 1）在id为app的div中添加 v-cloak 1&lt;div class=&quot;wrap&quot; id=&quot;app&quot; v-cloak&gt; 4 computed 计算属性4.1 什么是计算属性在Vue应用中，在模板中双向绑定一些数据或者表达式，但是表达式如果过长，或者逻辑更为复杂时，就会变得臃肿甚至难以维护和阅读，比如下面的代码: 123456&lt;div&gt; 写在双括号中的表达式太长了,不利于阅读 &#123;&#123;text.split(&#x27;,&#x27;).reverse().join(&#x27;,&#x27;)&#125;&#125; &lt;/div&gt;将这段操作text.split(&#x27;,&#x27;).reverse().join(&#x27;,&#x27;) 放到计算属性中,最终返回一个结果值就可以 computed 的作用: 减少运算次数, 缓存运算结果. 运用于重复相同的计算. 4.1 代码示例123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;h1&gt;&#123;&#123;a*b&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;a*b&#125;&#125;&lt;/h1&gt; --&gt; &lt;!-- &lt;h1&gt;&#123;&#123;res()&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;res()&#125;&#125;&lt;/h1&gt; --&gt; &lt;h1&gt; &#123;&#123;res2&#125;&#125; &lt;/h1&gt; &lt;h1&gt; &#123;&#123;res2&#125;&#125; &lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; a: 10, b: 20, &#125;, methods: &#123; res: function() &#123; console.log(&quot;res方法执行&quot;); return this.a * this.b; &#125;, &#125;, //使用计算属性进行优化 减少运算次数,用于重复相同的运算 computed: &#123; res2: function() &#123; console.log(&quot;res2方法执行&quot;); return this.a * this.b; &#125;, &#125;, &#125;);&lt;/script&gt; 4.2 computed总结 定义函数也可以实现与 计算属性相同的效果,都可以简化运算。 不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。 5. filter 过滤器5.1 什么是过滤器 过滤器是对即将显示的数据做进一步的筛选处理，然后进行显示，值得注意的是过滤器并没有改变原来的数据，只是在原数据的基础上产生新的数据。 数据加工车间,对值进行筛选加工. 5.2 过滤器使用位置 双括号插值内 1&#123;&#123; msg | filterA &#125;&#125; msg是需要处理的数据, filterA是过滤器, | 这个竖线是管道,通过这个管道 将数据传输给过滤器进行过滤 加工操作 v-bind绑定的值的地方。 1&lt;h1 v-bind:id=&quot; msg | filterA&quot;&gt; &#123;&#123; msg &#125;&#125; &lt;/h1&gt; 5.3 过滤器5.3.1 局部过滤器需求: 通过过滤器给电脑价格前面 添加一个符号¥ 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; 电脑价格: &#123;&#123;price | addIcon&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, //挂载点 data: &#123; price: 200, &#125;, methods: &#123;&#125;, //方法 computed: &#123;&#125;, //计算属性 //局部过滤器 filters: &#123; //处理函数,value = price ,是固定参数 addIcon(value) &#123; return &quot;¥&quot; + value; &#125;, &#125;, &#125;);&lt;/script&gt; 5.3.2 全局过滤器需求: 将用户名开头字母大写 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; &#123;&#123;user.name | changeName&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //在创建Vue实例之前 创建全局过滤器 Vue.filter(&quot;changeName&quot;, function(value) &#123; //将姓名开头字母大写,然后再重新拼接 return value.charAt(0).toUpperCase() + value.slice(1); &#125;); var VM = new Vue(&#123; el: &quot;#app&quot;, //挂载点 data: &#123; user: &#123; name: &quot;tom&quot; &#125;, &#125;, &#125;);&lt;/script&gt; 5.4 总结 过滤器常用来处理文本格式化的操作。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示 6. watch 侦听器6.1 什么是侦听器Vue.js 提供了一个方法 watch，它用于观察Vue实例上的数据变动。作用: 当你有一些数据需要随着其它数据变动而变动时，可以使用侦听属性 6.2 案例演示需求: 监听姓名变化,实时显示 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;label&gt; 名： &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt; &lt;/label&gt; &lt;label&gt; 姓： &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt; &lt;/label&gt; &#123;&#123;fullNameComputed&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;&quot;, lastName: &quot;&quot;, fullName: &quot;&quot;, &#125;, //监听，程序在运行的时候，实时监听事件 watch: &#123; //参数说明：1、新值，2、旧值 firstName(newValue, oldValue) &#123; this.fullName = newValue + &quot; &quot; + this.lastName; &#125;, lastName(newValue, oldValue) &#123; this.fullName = this.firstName + &quot; &quot; + newValue; &#125;, &#125;, computed: &#123; fullNameComputed() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;, &#125;, &#125;);&lt;/script&gt; 7. Component 组件7.1 组件介绍 组件（Component）是自定义封装的功能。在前端开发过程中，经常出现多个网页的功能是重复的，而且很多不同的页面之间，也存在同样的功能。 我们将相同的功能进行抽取,封装为组件,这样，前端人员就可以在组件化开发时，只需要书写一次代码，随处引入即可使用。 组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树 vue的组件有两种: 全局组件 和 局部组件 7.2 全局组件语法格式： 123456789101112Vue.component(&quot;组件名称&quot;, &#123; template: &quot;html代码&quot;, // 组件的HTML结构代码 data()&#123; //组件数据 return &#123;&#125; &#125;, methods: &#123; // 组件的相关的js方法 方法名()&#123; // 逻辑代码 &#125; &#125; &#125;) 注意： 组件名以小写开头，采用短横线分割命名: 例如 hello-Word 组件中的data 必须是一个函数,注意与Vue实例中的data区分 在template模板中, 只能有一个根元素 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用组件,可以使用多次 --&gt; &lt;lagou-header&gt; &lt;/lagou-header&gt; &lt;lagou-header&gt; &lt;/lagou-header&gt; &lt;lagou-header&gt; &lt;/lagou-header&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //全局组件 Vue.component(&quot;lagou-header&quot;, &#123; //组件的命名一般使用短横线方式,组件中的模板只能有一个根元素 template: &quot;&lt;div&gt;头部组件的HTML代码&lt;h1 @click=&#x27;hello&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;div&gt;&quot;, data() &#123; //组件中的data是一个函数 return &#123; msg: &quot;hello这里是组件中的data数据&quot;, &#125;; &#125;, methods: &#123; hello() &#123; alert(&quot;嗨 你好!&quot;); &#125;, &#125;, &#125;); var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, methods: &#123;&#125;, &#125;);&lt;/script&gt; 7.3 局部主键相比起全局组件，局部组件只能在同一个实例内才能被调用。局部组件的写法和全局组件差不多。 唯一不同就是：局部组件要写在Vue实例里面。 1234567891011121314new Vue(&#123; el: &quot;#app&quot;, components: &#123;组件名: &#123; // 组件结构 template: &quot;HTML代码&quot;, // data数据 data() &#123; return &#123; msg: &quot;xxxx&quot; &#125;; &#125;, &#125;, &#125;,&#125;); 注意：创建局部组件，注意 components，注意末尾有 ‘s’，而全局组件是不用+ ‘s’ 的。这意味着，components 里可以创建多个组件。 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;web-msg&gt; &lt;/web-msg&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, components: &#123; //组件名称 &quot;web-msg&quot;: &#123; //组件内容 template: &quot;&lt;div&gt;&lt;h1&gt;&#123;&#123;msg1&#125;&#125;&lt;/h1&gt;&lt;h1&gt;&#123;&#123;msg2&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&quot;, data() &#123; return &#123; msg1: &quot;开发ing...&quot;, msg2: &quot;开发完成!&quot;, &#125;; &#125;, &#125;, &#125;, &#125;);&lt;/script&gt; 7.4 组件与模板分离由于把html语言写在组件里面很不方便，也不太好看所以将它们分开写。 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;web-msg&gt; &lt;/web-msg&gt; &lt;/div&gt; &lt;!-- 将模板写在HTML中, 给模板指定一个ID --&gt; &lt;template id=&quot;tmp1&quot;&gt; &lt;div&gt; &lt;button @click=&quot;show&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, components: &#123; &quot;web-msg&quot;: &#123; template: &quot;#tmp1&quot;, data() &#123; return &#123; msg: &quot;点击查询&quot;, &#125;; &#125;, methods: &#123; show() &#123; alert(&quot;正在查询,请稍等...&quot;); &#125;, &#125;, &#125;, &quot;web-msg2&quot;: &#123;&#125;, &#125;, &#125;);&lt;/script&gt; 总结： 上面这种写法，浏览器会把 html 里的 template 标签过滤掉。所以 template 标签的内容是不会在页面中展示的。直到它被 JS 中的 Vue 调用。 在 html 中，template 标签一定要有一个 id，因为通过 id 是最直接被选中的。 data 和 methods等 参数，全部都要放到 Vue 实例里面写 8. Vue生命周期8.1 生命周期图示每个Vue实例在被创建之前都要经过一系列的初始化过程,这个过程就是vue的生命周期了解生命周期的好处: 找错误 解决需求 下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。 8.2 钩子函数介绍生命周期中的钩子函数钩子函数：钩子函数是在一个事件触发的时候，在系统级捕获到了他，然后做一些操作 函数 说明 beforeCreate() 在创建Vue实例之前,可以执行这个方法. 例如 加载动画操作 created() 实例创建完成,属性绑定好了,但是DOM还没有生成 beforeMount() 模板已经在内存中编辑完成了，尚未被渲染到页面中. mounted() 内存中的模板已经渲染到页面，用户已经可以看见内容. beforeUpdate() 数据更新的前一刻 , 组件在发生更新之前,调用的函数 updated() updated执行时，内存中的数据已更新，并且页面已经被渲染 beforeDestroy () 钩子函数在实例销毁之前调用 destroyed () 钩子函数在Vue 实例销毁后调用 案例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;next&quot;&gt; 获取下一句 &lt;/button&gt; &lt;h2 id=&quot;msg&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var VM = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;想当年,金戈铁马&quot;, &#125;, methods: &#123; next() &#123; this.message = &quot;气吞万里如虎!&quot;; &#125;, show() &#123; alert(&quot;show方法执行!&quot;); &#125;, &#125;, beforeCreate() &#123; alert(&quot;1.beforeCreate函数在组件实例化之前执行&quot;); alert(this.message); //undefined this.show(); // this.show is not a function &#125;, created() &#123; alert(&quot;2.created函数执行时,组件实例化完成,但是DOM(页面)还未生成&quot;); alert(this.message); this.show(); &#125;, beforeMount() &#123; alert(&quot;3.beforeMount函数执行时，模板已经在内存中编辑完成了，尚未被渲染到页面中&quot;); alert(document.getElementById(&quot;msg&quot;).innerText); //Cannot read property &#x27;innerText&#x27; of null &#125;, mounted() &#123; alert(&quot;4.mounted函数执行时,模板已经渲染到页面,执行完页面显示&quot;); alert(document.getElementById(&quot;msg&quot;).innerText); &#125;, beforeUpdate() &#123; alert(&quot;5.beforeUpdate执行时，内存中的数据已更新，但是页面尚未被渲染&quot;); alert(&quot;页面显示的内容:&quot; + document.getElementById(&quot;msg&quot;).innerText); alert(&quot;data中的message数据是: &quot; + this.message); &#125;, updated() &#123; alert(&quot;6.updated执行时，内存中的数据已更新,此方法执行完显示页面!&quot;); &#125;, &#125;);&lt;/script&gt; 9. Vue Router 路由9.1 什么是路由?在Web开发中，路由是指根据URL分配到对应的处理程序。 路由允许我们通过不同的 URL 访问不同的内容。通过 Vue.js 可以实现多视图单页面web应用（single page web application，SPA） 9.2 什么是SPA ? 百度百科单页面Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 单页应用不存在页面跳转，它本身只有一个HTML页面。我们传统意义上的页面跳转在单页应用的概念下转变为了 body 内某些元素的替换和更新，举个例子:整个body的内容从登录组件变成了欢迎页组件, 从视觉上感受页面已经进行了跳转。但实际上，页面只是随着用户操作，实现了局部内容更新,依然还是在index.html 页面中。 单页面应用的好处： 用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。 适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。 9.3 路由相关的概念 router : 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用（SPA）变得易如反掌 ,router 就相当于一个管理者，它来管理路由。 route: ruter相当于路由器, route就相当于一条路由.比如: Home按钮 &#x3D;&gt; home内容， 这是一条route,news按钮 &#x3D;&gt; news内容， 这是另一条路由。 routes : 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 &#x3D;&gt;home内容 }， {about按钮 &#x3D;&gt; about 内容}] router-link组件: router-link 是一个组件，是对标签的一个封装. 该组件用于设置一个导航链接，切换不同 HTML内容。 to 属性为目标地址， 即要显示的内容 router-view 组件: 路由导航到指定组件后,进行渲染显示页面 9.4 使用路由1） Vue.js 路由需要载入 vue-router 库 1234//方式1: 本地导入 &lt;script src=&quot;vue-router.min.js&quot;&gt;&lt;/script&gt; //方式2: CDN &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; 2） 使用步骤 1. 定义路由所需的组件 2. 定义路由 每个路由都由两部分 path (路径) 和component (组件) 3. 创建router路由器实例 ,管理路由 4. 创建Vue实例, 注入路由对象, 使用$mount() 指定挂载点 1Vue 的$mount()为手动挂载，在项目中可用于延时挂载（例如在挂载之前要进行一些其他操作、判断等）， 之后要手动挂载上。new Vue时，el和$mount并没有本质上的不同。 3）HTML代码 12345678910111213141516171819&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt; 渣浪.com &lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航,to属性指定链接 --&gt; &lt;router-link to=&quot;/home&quot;&gt; go to home &lt;/router-link&gt; &lt;router-link to=&quot;/news&quot;&gt; go to news &lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由的出口, 路由匹配到的组件(页面)将渲染在这里 --&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;/div&gt;&lt;/body&gt; 4） JS代码 12345678910111213141516171819202122232425262728293031&lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1.定义路由所需的组件 const home = &#123; template: &quot;&lt;div&gt;首页&lt;/div&gt;&quot; &#125;; const news = &#123; template: &quot;&lt;div&gt;新闻&lt;/div&gt;&quot; &#125;; //2.定义路由 每个路由都有两部分 path和component const routes = [&#123; path: &quot;/home&quot;, component: home &#125;, &#123; path: &quot;/news&quot;, component: news &#125;, ]; //3.创建router路由器实例,对路由对象routes进行管理. const router = new VueRouter(&#123; routes: routes, &#125;); //4.创建Vue实例, 调用挂载mount函数,让整个应用都有路由功能 const VM = new Vue(&#123; router, &#125;).$mount(&quot;#app&quot;);//$mount是手动挂载代替el &lt;/script&gt; 9.5 路由总结 router是Vue中的路由管理器对象,用来管理路由. route是路由对象,一个路由就对应了一条访问路径,一组路由用routes表示 每个路由对象都有两部分 path(路径)和component (组件) router-link 是对a标签的封装,通过to属性指定连接 router-view 路由访问到指定组件后,进行页面展示","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"那女孩对我说","slug":"那女孩对我说（吉他谱）","date":"2021-02-24T02:52:37.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2021/02/24/那女孩对我说（吉他谱）/","link":"","permalink":"http://yournotes.cn/2021/02/24/%E9%82%A3%E5%A5%B3%E5%AD%A9%E5%AF%B9%E6%88%91%E8%AF%B4%EF%BC%88%E5%90%89%E4%BB%96%E8%B0%B1%EF%BC%89/","excerpt":"《那女孩对我说》谱子收藏、全文查看","text":"《那女孩对我说》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"修炼爱情","slug":"修炼爱情（吉他谱）","date":"2021-02-24T02:52:17.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/02/24/修炼爱情（吉他谱）/","link":"","permalink":"http://yournotes.cn/2021/02/24/%E4%BF%AE%E7%82%BC%E7%88%B1%E6%83%85%EF%BC%88%E5%90%89%E4%BB%96%E8%B0%B1%EF%BC%89/","excerpt":"《修炼爱情》谱子收藏、全文查看","text":"《修炼爱情》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"LeetCode初级算法之动态规划：198.打家劫舍","slug":"打家劫舍","date":"2021-02-22T17:40:17.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2021/02/23/打家劫舍/","link":"","permalink":"http://yournotes.cn/2021/02/23/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"","text":"题目信息 题目地址：https://leetcode-cn.com/problems/house-robber/ 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 0 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 400 解法一：动态规划由题知道我们的这个小偷他偷一家必须得至少隔一家再偷不能连着偷，那我们可以从最简单的来推导看看： 1234一条街一开始只有一家：2块后来搬来了一家有钱人：7块后来陆陆续续来了几家：3块、4块、5块 那只有一家的时候只能偷2块f(1) = 2有两家了进行一次选择挑个富的f(2) = max(第一家，第二家) &#x3D; 7有三家的时候也要进行一次选择f(3) = max(f(1)+第三家，f(2)) &#x3D; 7到这个地方其实就出来了表达式dp[i] = max(dp[i - 2] + nums[i] , dp[i - 1])存储之前的结果推导下一个结果，也就是动态规划过滤掉一半的组合。比如（2，7，3，4）对于（2，7，3）我们已经得到最大方案是7并记录了，那么与第四家4块结合的必不是（2、3）里的。4家虽然有三种组合但（2+4）这种组合就不会出现在计算中 动态规划每次记录之前的偷的最多与前前偷的最多的值，进行取舍，要么是前前的累计最大金额算上当前房子大要么就还是之前的最大，避免树形展开 所以我们要准备存两个量一个是最新的最大金额也就是结果，要动态的选择结果还要一个前几个房子的最大金额，来决定下次偷还是不偷 代码如下： 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; // 两个量：到目前累计最大与之前房屋累计最大 int[] dp = [nums[0],Math.max(nums[0],nums[1])]; for (int i = 2; i &lt; length; i++) &#123; // 扫描到下一个了，两个量按次序变换 int temp = dp[1]; second = Math.max(dp[0] + nums[i], dp[1]); dp[0] = temp; &#125; return result; &#125;&#125; 总结其实这题和之前写的爬楼梯比较像，可以对照着总结。总体来说第一就是dp表也就是备忘录解决子问题重叠，第二就是空间的压缩我们需要明白是否必要存每个子问题的结果。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之动态规划：53.最大子序和","slug":"最大子序和","date":"2021-02-21T08:54:13.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2021/02/21/最大子序和/","link":"","permalink":"http://yournotes.cn/2021/02/21/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶:如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解法一：动态规划首先我们去划分一下子问题。整个数列的最大子序和，他是可能就等于n-1的最大子序和，它也可以是个新的值。至少是这两种情况 情况一： 123[-1,3,1,-4,1]当前数列的最大子序和就是4也就是(1,2)项。它也是前n-1项的最大子序和 情况二： 123[-1,3,1,-4,5]当前数列的最大子序和是5也就是(4)项而前n-1项的数列最大子序和还是4也就是(1,2)项 每次往后迭代一个值它的结果可能变化也可能不变化，这就是记录的点。我们算出当前最大的值然后与之前的result进行比较可能更新result也可能不变，进行下个迭代再次算当前最好的值再与result比较。 那么唯一的问题就是当前的最大值是怎么计算的，就是我们不是去暴力全部序列，而是跳过不必要的，即当前面sum为负的时候，即使后面有大的也没必要加上负的，也就是直接跳序列的首指针来达到减少遍历吃次数 123456[2,-1,-3,-4,7]我们大概需要四个变量result = 0 // 结果i = 0 // 序列的首指针j = 0 // 序列的尾指针sum = 0 //当前序列和 但我们记录sum就代表i至j了，所以不用指针变量代码如下： 12345678910public int maxSubArray(int[] nums) &#123; //sum表示上一个最大子序和也就是dp[n-1] int sum = 0; int result = nums[0]; for(int i = 0; i &lt; nums.length; i++)&#123; sum = sum &gt; 0 ? sum + nums[i] : nums[i]; max = max &gt; sum ? max : sum; &#125; return max;&#125; 总结这题的话虽然是简单但还是要点思考的，用到了动态与贪心的思想合起来减少了遍历一遍的次数。关于自顶向下的分治比较适合之后筹备的另一个系列，所以这里就不展开了","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之动态规划：121.买卖股票的最佳时机","slug":"买卖股票的最佳时机","date":"2021-01-30T08:15:37.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/01/30/买卖股票的最佳时机/","link":"","permalink":"http://yournotes.cn/2021/01/30/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 121 &lt;= prices.length &lt;= 1050 &lt;= prices[i] &lt;= 104 解法一：暴力解法这题的话暴力解法应该是每个小伙伴一看到题就想到的解法，这里也不例外先写个暴力解法。也就是穷举所有组合的收益再找最大 举个例子：[7,1,5,3,6,4] 1234567891011121314157 -&gt; 1 = -67 -&gt; 5 = -27 -&gt; 3 = -47 -&gt; 6 = -17 -&gt; 4 = -31 -&gt; 5 = +41 -&gt; 3 = +21 -&gt; 6 = +51 -&gt; 4 = +35 -&gt; 3 = -25 -&gt; 6 = +15 -&gt; 4 = -13 -&gt; 6 = +33 -&gt; 4 = +16 -&gt; 4 = -2 穷举所有的买卖组合后，最大收益是+5 实现步骤： 第一是扫描全部组合 第二是记录max 第三返回最终max 代码如下： 123456789101112public int maxProfit(int prices[]) &#123; int max = 0; for(int i = 0; i &lt; prices.length-1; i++)&#123; for(int j = i+1; j &lt; prices.length; j++)&#123; int income = prices[j] - prices[i]; if(income &gt; max)&#123; max = income; &#125; &#125; &#125; return max;&#125; 外循环是n-1次,内循环是(n-1、n-2、….1) 总共是$\\frac{n^2}{2}$次时间复杂度为O(n^2) 空间仅仅使用了两变量因此是O(1) 解法二：动态规划上个解法时间复杂度太高，在LeetCode种测试也是超时的。作为一个动态规划合集的题那我们肯定是要用动态规划来解一解。 我们怎样去思考： i天的最终最高收益可以怎样去划分呢？ 它可能就是前i-1天的最高收益是不变的 123[4,2,1,5,4]这5天最高收益是第三天买第四天卖最高为4也就是前4天的最高的组合。 它也可能变化比前i-1天的最高收益多 123[4,2,1,5,7]这5天的前4天最高收益是4算上第5天的话就应该是6 所以这里我们可以清楚它无非两种情况取最大 前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1天中的最小价格) 这里要迭代要存储的值不仅仅有收益结果还有最小值因此自底向上更好些。每后往遍历一个进来就判断max是不变还是有更大（记录下当前最小值以及当前的结果） 代码如下： 123456789101112public int maxProfit(int[] prices) &#123; if(prices.length &lt; 2)&#123; return 0; &#125; int min = prices[0]; int max = 0; for(int i = 1; i &lt; prices.length; i++) &#123; max = max &gt; (prices[i] - min) ? max : prices[i] - min; min = min &lt; prices[i] ? min : prices[i]; &#125; return max;&#125; 比起自底向上来说，自顶向下会麻烦一些。但思路是一样的。这里画个图 代码如下： 1234567891011121314151617181920212223public int maxProfit(int[] prices) &#123; return recurrent(prices,prices.length-1);&#125;int recurrent(int[] nums,int index)&#123; if(index == 0)&#123; return 0; &#125; int right = nums[index] - min(nums,index); int left = recurrent(nums,--index); if(left &gt; right)&#123; return left; &#125; return right;&#125;int min(int[] nums,int index)&#123; int min = nums[0]; for(int i = 1; i &lt; index; i++)&#123; if(nums[i] &lt; min)&#123; min = nums[i]; &#125; &#125; return min;&#125; 它的迭代深度是n,但是旁边都有一个找最小也是n所以时间复杂度O($n^2$),如果找最小也是用递归的话就差不多是O($2^n$)。不过即使是n的二次方也是从超时的和暴力一样复杂度。 归根到底还是因为只进行了迭代的思路没进行记录。这边因为递归部分就是线性的所以没有多余的，主要就是最小值那边平均每个进行n&#x2F;2次。所以是可以记录一下的如果当前索引的值不是之前那个最小值。说明剩下的数列最小值还在里面还是之前那个不用重新遍历。总体上还是复杂度还是不行的。 总结今日这题的话还是比较好做的，有点不同的是迭代的结构不是同一种类型。动态规划的题自顶向下与自底向上两个方向每题都可进行同时练习。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"去大理","slug":"去大理","date":"2021-01-17T09:31:38.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2021/01/17/去大理/","link":"","permalink":"http://yournotes.cn/2021/01/17/%E5%8E%BB%E5%A4%A7%E7%90%86/","excerpt":"《去大理》谱子收藏、全文查看","text":"《去大理》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"再见","slug":"再见","date":"2021-01-17T09:31:28.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2021/01/17/再见/","link":"","permalink":"http://yournotes.cn/2021/01/17/%E5%86%8D%E8%A7%81/","excerpt":"《再见》谱子收藏、全文查看","text":"《再见》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"LeetCode初级算法之动态规划：70.爬楼梯","slug":"爬楼梯","date":"2021-01-17T08:15:37.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2021/01/17/爬楼梯/","link":"","permalink":"http://yournotes.cn/2021/01/17/%E7%88%AC%E6%A5%BC%E6%A2%AF/","excerpt":"题目信息 题目地址： https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。","text":"题目信息 题目地址： https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意： 给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 思路一：斐波那契数列我们可以看先推演几个看看 一个台阶：只有一种跳法就是跳一格 两个台阶：跳一格跳两次和跳一次2格的 三个台阶：1+1+1、2+1、1+2（共三种） 四个台阶：1+1+1+1、2+1+1、1+2+1、1+1+2、2+2（共五种） 五个台阶1+1+1+1、2+1+1+1、1+2+1+1、1+1+2+1、1+1+1+2、2+2+1、2+1+2、1+2+2（共八种） 我们可以得到一个规律，他是一个斐波那契数列，题目正整数就不从数列的第0个搞起了直接从第一个开始 台阶数（n） 方法总数(result) 1 1 2 2 3 3 4 5 5 8 斐波那契数列它是有公式的通过n直接计算出result。 $$\\frac{1}{\\sqrt{5}}*[(\\frac{1+\\sqrt5}{2})^n - (\\frac{1-\\sqrt5}{2})^n]$$ 这里我们先假装不知道有公式 我们用迭代的方式推导: 每次要通过前两项记录新的值，再进行迭代直到最后是我们要的第n个。这里有个空间上的注意就是我们不必要记录整个斐波那契数列，只需要保留两个而已。 代码一： 1234567891011121314public int climbStairs(int n) &#123; // 初始值 if(n == 1)&#123; return n; &#125; int[] nums = &#123;1,2&#125;; // 上个值与新的值组成新的二元数组 for(int i = 2; i &lt; n; i++)&#123; int temp = nums[0] + nums[1]; nums[0] = nums[1]; nums[1] = temp; &#125; return nums[1];&#125; 总体来说还是不错的，时间O(n)，空间O(1) 然后就是通项公式解，不用说了它最优，不过我们不可忽视的是平方根的复杂度O(logn)。关于这些还有斐波那契状态公式的推导在另外一篇介绍 12345public int climbStairs(int n) &#123; double sqrt5 = Math.sqrt(5); double fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1); return (int) Math.round(fibn / sqrt5);&#125; 思路二：动态规划因为这题比较特殊，其实动态规划的解法代码上面就已经是了但思考的聚焦点不同。这里还是要用这题体会一下动态规划的思路。dp它是一种思想方式，用已知的问题的解解决新问题。递归或者迭代它只是实现这种想法的一种代码书写方式无论我们有没有去做空间优化它都属于这种思想，能压缩空间当然更好。这里先不单独探究这个概念。 那么就是用已解决的问题得出我们的问题解也就是划分子问题，爬第n阶楼梯的方法数量，等于 2 部分之和（就是最后一次的） 爬上 n-1 阶楼梯的方法数量。因为再爬一次1阶就能到第n阶 爬上 n-2 阶楼梯的方法数量。因为再爬一次2阶就能到第n阶 所以我们得到公式 1dp[n] = dp[n-1] + dp[n-2] 同时需要初始化 12dp[0]=1dp[1]=2 时间复杂度：O(n) 代码二： 123456789public int climbStairs(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 2; for(int i = 2; i &lt; n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n-1];&#125; 所以这里就存在空间优化嘛，记录子问题解的时候不需要全部的。用滑动数组的方式只留两个就行了 代码三： 就是解法一上面的解 12345678910public int climbStairs(int n) &#123; if(n == 1) return 1; int[] dp = &#123;1,2&#125;; for(int i = 2; i &lt; n; i++)&#123; int temp = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = temp; &#125; return dp[1];&#125; 这样的思路这样的状态式子，我们当然也可以用递归写啊 代码四： 12345678public int climbStairs(int n) &#123; //递归出口 if(n == 1 || n == 2) &#123; return n; &#125; //过程及主体 return climbStairs(n-1) + climbStairs(n-2);&#125; 这个东西是有问题待解决的在测试的时候也是超时的，就是我们在动态规划要思考的重复计算的问题，前面是自底向上所以我们每次记录新的二元数组往后继续是线性的，现在自顶向下比如第一层n-1与n-2的情况计算是重复的，我们来画个图看看 首先它不是一线性的，而且两边的计算是重复的，它的时间复杂度是 $2^n$ ，它本来一条线复杂度n就算完了但一直有重复计算n长的线变成的n层的树因为他们相互包含。所以我们要把子问题的结果存下来，再有这个不用去重新迭代计算直接取。 代码五： 123456789101112131415public int climbStairs(int n) &#123; int[] mind = new int[n+1]; mind[0] = 1; mind[1] = 1; return recur(n,mind);&#125;int recur(int n,int[] mind)&#123; //递归出口 if(mind[n] != 0)&#123; return mind[n]; &#125; //让递归出口不仅仅只有初始值 mind[n] = recur(n-1,mind) + recur(n-2,mind); return mind[n];&#125; 现在时间复杂度就变成了O(n) 总结本体是一个经典的动态规划例子，并且还可以转化问题为斐波那契数列的求解那就可以专注线性代数。最优解的通项公式复杂度O(logn)。这题有几个东西还挺有意思的。关于数论矩阵快速幂已加入素材库之后可以演示几个例子，这里的斐波那契数列的通项公式推导可以作为其中一个例子。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之排序和搜索：278.第一个错误版本","slug":"第一个错误版本","date":"2020-12-28T11:10:57.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/12/28/第一个错误版本/","link":"","permalink":"http://yournotes.cn/2020/12/28/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/first-bad-version/ 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/first-bad-version/ 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例： 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 解法一：暴力从第一个版本直接顺着遍历直到首次出现错误版本，不就是第一个嘛 123456789public int firstBadVersion(int n) &#123; //从第一个版本遍历起 for (int i = 1; i &lt; n; i++) &#123; if (isBadVersion(i)) &#123; return i; &#125; &#125; return n;&#125; 是真的狠，你开发了二十多个亿的个版本。产品经理呢，抓过来让他做，做不满二十多个亿版本不准走。 解法二：二分法其实这个问题，一开始我就想到电视上主持人手里拿着一个数字，让你从1-100的范围猜这个数字并且告诉你答案是大了还是小了。 肯定不可能像解法一一样猜1不中然后猜2不中猜3….. 这里就是使用二分的思想一次排除一半 代码如下： 123456789101112131415//注意是连续数字不是数组索引public int firstBadVersion(int n) &#123; int left = 1; int right = n; while (left &lt; right) &#123; //int mid = (right + left) / 2; int mid = left + (right - left) / 2; if (isBadVersion(mid)) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; 总结题挺简单的，一开始想到的就是二分因为太少了还是加上了暴力解法凑凑。本题主要吧还是是边界的考虑，也是一个典型的二分法的例子，除此之外处理两个数平均运算可能溢出的解决方式也在今后可以作为一个思考方向的参考","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之排序和搜索：88.合并两个有序数组","slug":"合并两个有序数组","date":"2020-12-27T09:32:42.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/12/27/合并两个有序数组/","link":"","permalink":"http://yournotes.cn/2020/12/27/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/merge-sorted-array/ 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/merge-sorted-array/ 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明： 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例： 12345输入：nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6] 提示： 123-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9nums1.length == m + nnums2.length == n 解法一：双指针（顺序扫描）很直接的就是双指针扫描，与上次我们在链表时写过【合并有序链表】同样的通过扫描与大小比较最终扫描完两个序列（m+n），前者是新建一个头节点然后遍历过程中慢慢连。这边也是可以创建一个数组，每扫描一个往里面设置值。看下题目可知实际的元素数量是m,n完整数组是可能有多余空间，并且num1的空闲可以容纳nums2的有效元素，就是说我们直接把nums1作为结果数组，新建的数组装num1的实际元素 有了思路之后理一下具体的过程： 123456789101112131415161718192021222324252627public void merge(int[] nums1, int m, int[] nums2, int n) &#123; // 1.得到num1实际元素的数组 int [] nums1_copy = new int[m]; /* for(int i = 0; i &lt; m; i++)&#123; nums1_copy[i] = nums[i]; &#125; */ System.arraycopy(nums1, 0, nums1_copy, 0, m); // 扫描两个素材数组的指针 int p = 0; int q = 0; // 结果数组（num1）待设值位置的指针 int cur = 0; // 2.挨个比较设值 while ((p &lt; m) &amp;&amp; (q &lt; n))&#123; nums1[cur++] = (nums1_copy[p] &lt; nums2[q]) ? nums1_copy[p++] : nums2[q++]; &#125; // 3.加入最后多余的一段 if (p &lt; m) System.arraycopy(nums1_copy, p, nums1, p + q, m + n - p - q); if (q &lt; n) System.arraycopy(nums2, q, nums1, p + q, m + n - p - q);&#125; 时间有三组操作m+min(m,n)+(m-n)或(n-m)因此为m+n,遍历了两组元素嘛O（m+n）空间就是nums1_copy也就是O（m） 解法二：双指针（逆序）解这题一开始我就在想是不是原地就可以（不用创建数组），但如果在解法一的过程中把num2的值设过去，那边就必须得存被替换的值。并且可能一直是num2小也是说那边还是需要一个中间数组。 也就是为了那一块的值创建了m大小的数组，为什么我们能拿num1为结果数组？不就是它有空闲的一块地方么，那么我们何必不用呢！反而另开一块呢！直接用后面的地方不就不存在替换了吗！ 因此我们就用后面这块，直接倒序设值，整理过程如下： 情况一：最终前面小的一块在num1 情况一：最终前面小的一块在num2 1234567891011121314public void merge(int[] nums1, int m, int[] nums2, int n) &#123; // 定义两个指针并指向元素末端 int p = m - 1; int q = n - 1; // 注意初始化当前指针在整个元素m+n的末端并不是整个num1的末端 int cur = m + n - 1; // 1.挨个比较设值 while (p &gt;= 0 &amp;&amp; q &gt;= 0)&#123; nums1[cur--] = (nums1[p] &lt; nums2[q]) ? nums2[q--] : nums1[p--]; &#125; // 2.可能nums2前面有余 System.arraycopy(nums2, 0, nums1, 0, q + 1);&#125; 时间复杂度仍然是不可避免的O(m+n)空间复杂度O(1) 总结这题还是比较简单的，主要是考虑到添加缓存与当前空间的问题。很多时候我们的中间变量或者中间数组是否真的该加。场上是否有不用的空间不用的变量，这是我们需要考虑的！剔除冗余无效代码","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之树：108.将有序数组转二叉树","slug":"将有序数组转二叉树","date":"2020-12-26T02:27:09.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/12/26/将有序数组转二叉树/","link":"","permalink":"http://yournotes.cn/2020/12/26/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 12345 0 / \\ -3 9 / /-10 5 题解：递归（中序）一个升序数组，转二叉树还是并且是搜索树（右子树小左子树），因此这个数组相当于是搜索树的中序遍历 对于示例的数组：[-10,-3,0,5,9]，转化为二叉搜索树结果是有很多 比如： 12345 0 / \\ -3 5 / \\-10 9 12345 5 / \\ -3 9 / \\ -10 0 题目当前是要得高度平衡的一个解（因此上面一个解是不满足的平衡的），因此尽量取中间作为根，就是最平衡的。 如果是偶数，取中间的两个任意的。如下要么-10为当前根-3为它的右子节点，要么-3为当前根-10为它的左子节点 因此我们可以推出递归 123456789101112public TreeNode sortedArrayToBST(int[] nums) &#123; return recurrence(nums, 0, nums.length - 1);&#125;public TreeNode recurrence(int[] nums, int left, int right) &#123; if (left &gt; right) return null; // 除法运算向下取整，所以偶数取左边 int mid = (left + right) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = recurrence(nums, left, mid - 1); root.right = recurrence(nums, mid + 1, right); return root;&#125; 时间复杂度当然是O（n），平衡的缘故栈的深度为log2n因此空间复杂度为O（logn） 总结总体来说还是比较好想的一个二分的这样一个东西，题目是求出满足条件的一解 1int mid = (left + right) / 2; 这样取就得到的就是遇偶数取左边的解，如果加个1之后再除2就是取右了，或者加个随机数（0&#x2F;1）。这样可以每次执行得到满足条件的树可能都不一样。 最后初级合集关于树这一章也结束了也是这个合集整个数据结构的篇章结束了，从开始对树这样的结构很生疏仅仅遍历操作就与线性数据结构有很大差别，到现在虽然短短5题已经对这样一个数据结构更熟悉了。从下个章节开始的就是关于算法思维向的篇章（排序、动态规划、数学等等）","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之树：102.二叉树的层序遍历","slug":"二叉树的层序遍历","date":"2020-12-24T13:56:49.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/12/24/二叉树的层序遍历/","link":"","permalink":"http://yournotes.cn/2020/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,null,null,15,7], 123456789101112 3 / \\ 9 20 / \\ 15 7返回其层序遍历结果：[ [3], [9,20], [15,7]] 解法一：广度优先遍历没想到这题居然还是中等，来人！ 言归正传，题目让你层序遍历也就是广度遍历然后放到容器里。就是纯遍历一次没有别的操作了 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //定义结果集 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //根节点为空 if(root = null) return result; //实现队列(也可以用别的LinkedList快一点) Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; //每一层的遍历 List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode node = queue.poll(); level.add(node); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; result.add(level); &#125; return result;&#125; 遍历整个树时间复杂度O（n），队列小于n空间复杂度为O（n） 解法二：深度优先遍历这里我们折腾一下，这题广度就是题目它的意思来的。但偏偏就要用深度写 不同的是广度每次内层循环就完成一层节点的遍历，外层去添加这一层的List，深度的话遍历第一个是第一层的第二个就是第二层了第三个就是第三层的第一个了，因此需要先记下层级 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //结果集 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return result; dfs(1,root,result); return result;&#125; public void dfs(int level, TreeNode root, List&lt;List&lt;Integer&gt;&gt; result) &#123; //容器大小小于层级则添加一个新层级 if(result.size()&lt;level) &#123; result.add(new ArrayList&lt;Integer&gt;()); &#125; //往对应的层级List添加值 result.get(level - 1).add(root.val); //往下面走，层级+1 if(root.left!=null) &#123; dfs(level+1, root.left, result); &#125; if(root.right!=null) &#123; dfs(level+1, root.right, result); &#125;&#125; 总结还是与之前一样，用来熟悉树的遍历，基本上一个题两大种遍历方式都是可以完成，只不过是适用性不一样。总之多思考多熟练树遍历的操作过程","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之树：101.对称二叉树","slug":"对称二叉树","date":"2020-12-23T11:36:36.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/12/23/对称二叉树/","link":"","permalink":"http://yournotes.cn/2020/12/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/symmetric-tree/ 给定一个二叉树，检查它是否是镜像对称的。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/symmetric-tree/ 给定一个二叉树，检查它是否是镜像对称的。 **示例1：**是对称的 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 **示例2：**不对称 12345 1 / \\2 2 \\ \\ 3 3 解法一：递归我们先来划分子问题，一个树对称也就最终根节点的左子树与右子树是对称的镜像的，那么要求左子节点与右子节点相等的同时左节点的左子树（右子树）与右节点的右子树（左子树）对称，还是画个图吧 我们传入这两颗树看是否对称，那么有三个操作： 第一两个根节点是否相等 第二它左子树是否与另外一个的右子树对称 第三它的右子树是否与另外一个的左子树对称 每次递归传递一对树，直到最后叶子只有节点节点比较 123456789101112public boolean isSymmetric(TreeNode root) &#123; //第一次传root让下面顺便进行空判断 return check(root, root);&#125;public boolean check(TreeNode p, TreeNode q) &#123; //都为空则没有子树，两个根相等就是对称 if (p == null &amp;&amp; q == null) return true; //不满足上面条件，则是一个有子树一个没有那么不对称 if (p == null || q == null) return false; //三个条件结合 return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);&#125; 遍历了整颗树时间复杂度为O（n）,递归系统栈占用大小取决于树的层度这里不是完全二叉树所以它只是小于n空间复杂度为O（n） 方法二：迭代递归思路写完了，栈换成队列使用广度的方式完成同样的思路，还是再画个图 通过队列依次按照顺序比较offer进队列时就是一个树的左（右）与另一个树的右（左），poll出队列的两个也就是对应的，直到对队列没有后续进来的为空了仍然没出现不满足情况的，则是对称二叉树 123456789101112131415161718192021222324public boolean isSymmetric(TreeNode root) &#123; return check(root, root);&#125;public boolean check(TreeNode p, TreeNode q) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(p); queue.offer(q); while (!queue.isEmpty()) &#123; //每次出两个 p = queue.poll(); q = queue.poll(); //按照条件 if (p == null &amp;&amp; q == null) continue; if ((p == null || q == null) || (p.val != q.val)) return false; //按顺序进队列 queue.offer(p.left); queue.offer(q.right); queue.offer(p.right); queue.offer(q.left); &#125; return true;&#125; 时间复杂度与空间复杂度同上 总结无外乎深度优先与广度优先，上面的两种解都是优的解在一次树的遍历过程中完成对是否是对称的判断。如果直接暴力的还可先遍历一遍得到序列或者数组再判断，比如先序遍历与后序遍历序列相反，比如中序遍历结果是回文的，总之我们要先对遍历熟悉。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之树：98.验证二叉搜索树","slug":"验证二叉搜索树","date":"2020-12-20T15:28:59.000Z","updated":"2025-04-17T08:34:52.025Z","comments":true,"path":"2020/12/20/验证二叉搜索树/","link":"","permalink":"http://yournotes.cn/2020/12/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/validate-binary-search-tree/ 给定一个二叉树，判断其是否是一个有效的二叉搜索树。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/validate-binary-search-tree/ 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \\ 1 3输出: true 示例 2: 123456789输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解法一：递归和上题一样可以很好的想到递归的思路，左边都是越来越小，右边是越来越大。这个地方容易产生一种错觉。错误思路及代码：就是只比较左右子节点的与父节点大小关系，如上图第一次是满足的，接下来递归左节点但他没有子节点结束并返回true,递归右节点也满足关系，继续递归其右节点因无子节点结束，左边同理。整个递归完成最终是true,但因为3比根节点5小应该在左子树不满足二叉搜索树 12345678public boolean isValidBST(TreeNode root) &#123; if(root == null) return true; if(root.left != null &amp;&amp; root.left.val &gt;= root.val) return false; if(root.right != null &amp;&amp; root.right.val &lt;= root.val) return false; return isValidBST(root.left) &amp;&amp; isValidBST(root.right);&#125; 那么问题就在于我们要比较的东西是什么？对于叶子节点2来说它比3小就可以没有限制，对于叶子节点6的位置它只能大于3并且小于5才有效也就是说我们往左边走即是小那么就有一个上限之后不能超过，往右边走即是大就有一个下限。按照整个过程如上图，从根节点开始往左进入递归，往左了以后这边的值都小于上限5并且3满足小于5继续递归找到2也是满足并且2之后的树上限是3，继续递归为空了出去，执行下一步的兄弟节点判断时超过了上线结束 代码如下： 123456789101112public boolean isValidBST(TreeNode root) &#123; return process(root, null, null);&#125;//递归方法public boolean process(TreeNode node, Integer min, Integer max) &#123; if (node == null) return true; if (min != null &amp;&amp; node.val &lt;= min) return false; if (max != null &amp;&amp; node.val &gt;= max) return false; if (!process(node.right, node.val, max)) return false; if (!process(node.left, min, node.val)) return false; return true;&#125; 解法二：中序遍历中序遍历是树的一种遍历方式，先数左子树在数中间在数右子树，那么通过中序遍历如果是真的二叉搜索树是一个从小打大的序列上图中序遍历：[2,3,6,5,3,6,7] 123456789101112//记录前一个Integer pre = null;public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; // 访问左子树 if (!isValidBST(root.left)) return false; // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点.即不满足 if (pre != null &amp;&amp; root.val &lt;= pre) return false; pre = root.val; // 访问右子树 return isValidBST(root.right);&#125; 总结其实两种解法也都是属于深度优先，一个在过程中处理遍历方式为后序，一个是中序。使用不同的遍历过程那么就需要想清楚在这种遍历下处理判断逻辑。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之树：104.二叉树的最大深度","slug":"二叉树的最大深度","date":"2020-12-19T13:21:19.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/12/19/二叉树的最大深度/","link":"","permalink":"http://yournotes.cn/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 给定一个二叉树，找出其最大深度。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 1234567给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 概述树的开篇第一题其实也是比较简单的，但它的目的是让我们初步认识树这样一个结构。二叉树每个节点有两个子节点也就是两个指针。大概结构如下： 123456789101112131415public class TreeNode &#123; //节点内容值 int val; //两个指针 TreeNode left; TreeNode right; //构造方法 TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 解法一：深度优先搜索（DFS）递归的想法，最大深度 &#x3D; 1 + Max( L0(left) , L0(right))。而每个子树再找到它最大的深度。下图就是这样一个过程，图中省略一些东西只画了一部分理解这样一个思路就ok 12345public int maxDepth(TreeNode root) &#123; //出口 if(root == null) return 0; return Math.max(this.maxDepth(root.left), this.maxDepth(root.right)) + 1;&#125; 解法二：广度优先搜索（BFS）上面是递归，这里是迭代的方式，输入root节点判断是否存在存在则深度+1，再判断下一层节点（输入1层两个节点）对一个节点判断有无子节点，无则出，有则把它的子节点先加进来再出，注意这里是一个先进先出的关系（排队）因为是一层一层的遍历完 12345678910111213141516public int maxDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int result = 0; while (!queue.isEmpty()) &#123; //每层每个节点的遍历 for(int i = quene.size(); i &gt; 0; i--)&#123; TreeNode node = queue.poll(); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; result++; &#125; return result;&#125; 总结合集中树的第一题，总体来说熟悉树的基本结构体会遍历的操作","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之链表：141.环形链表","slug":"环形链表","date":"2020-12-17T11:37:51.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/12/17/环形链表/","link":"","permalink":"http://yournotes.cn/2020/12/17/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/linked-list-cycle/ 给定一个链表，判断链表中是否有环。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/linked-list-cycle/ 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104]-105 &lt;&#x3D; Node.val &lt;&#x3D; 105pos 为 -1 或者链表中的一个 有效索引 。 解法一：快慢指针这题成环问题直接就联想想到快慢指针，一条道两个人跑步一快一慢，如果没环则永远不会追上，有环则会相遇。大概如下（慢的走一步、快的走两步）： 代码如下： 12345678910111213public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; //出发点相同所以先走再判断是否相等 slow = slow.next; fast = fast.next.next; if (slow.equals(fast)) &#123; return true; &#125; &#125; return false;&#125; 解法二：hash表这种环形问题一开始就想到快慢指针了，就没往其他方向想。快慢指针当然是最优的，但还是可以熟悉一下其他容器。和前面一样用容器存判断是否成环的条件即在不停的next不停的存的过程中出现了存的节点之前存过。那么可以hashmap计数但只判断是否出现两次所以用set就行 12345678public boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt; set = new HashSet(); while (head != null) &#123; if (!set.add(head)) return true; head = head.next; &#125; return false;&#125; 总结这题也完成了那就初级算法合集中的链表篇章结束，总体来说一共六题都确实比较简单可能需要熟悉和思考的点就是通过双指针的链表操作完成各种场景的定位。下一篇开始树的相关算法。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之链表：234.回文链表","slug":"回文链表","date":"2020-12-16T11:15:16.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/12/16/回文链表/","link":"","permalink":"http://yournotes.cn/2020/12/16/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/palindrome-linked-list/ 请判断一个链表是否为回文链表。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/palindrome-linked-list/ 请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解法一：数组比较容易想到的就是使用另一个容器存节点，再比较值，这里存到数组进行首尾比较。 1234567891011121314151617public boolean isPalindrome(ListNode head) &#123; List&lt;Integer&gt; vals = new ArrayList(); // 将链表的值复制到数组中 ListNode cur = head; while (cur != null) &#123; vals.add(cur.val); cur = cur.next; &#125; // 使用双指针判断是否回文 int length = vals.size(); for(int i = 0, j = length -1; i &lt; length/2; i++,j--)&#123; int val1 = vals.get(i); int val2 = vals.get(j); if( val1 != val2 ) return false; &#125; return true;&#125; 解法二：快慢指针我们仍然是要使空间复杂度为O(1) 的，所以还是要回到纯链表的操作。结合之前的练习可以采用原地链表反转的算法之后再和原链表挨个比较，整个反转再比较的话是行不通的因为我们要用原地的不存储另外的链表，并且本来只用比较一半，所以我们这里要去找到链表的中间，并把后一半反转再进行前一半比后一半即可。 通过快慢指针，fast为slow两倍速度，最后fast为空时slow就停在后一半的开头（长度为偶数）如果是奇数呢？ 定位之后进行反转，再进行双指针比较直到后一半走完 1234567891011121314151617181920212223242526272829303132333435363738public boolean isPalindrome(ListNode head) &#123; ListNode fast = head; ListNode slow = head; //通过快慢指针找到中点 while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; //如果fast不为空，说明链表的长度是奇数个 if (fast != null) &#123; slow = slow.next; &#125; //反转后半部分链表 slow = reverseList(slow); fast = head; while (slow != null) &#123; //然后比较，判断节点值是否相等 if (fast.val != slow.val) return false; fast = fast.next; slow = slow.next; &#125; return true;&#125;//反转链表public ListNode reverseList(ListNode head) &#123; ListNode cur = head; ListNode next = null; while( cur != null)&#123; //记住原链表的下一个 ListNode temp = cur.next; //设下next cur.next = next; //更新next与cur next = cur; cur = temp; &#125; return next;&#125; 总结先是解法一也是和前面写的几题一样无脑解决的方式就是用另外的容器操作解除只能往下取的限制无论是数组也好还是栈也好都是用另外的容器直接进行我们想要的指针操作，接下来就是去挖掘链表的操作，只能next不能像数组一样任意使用索引的情况下我们怎么定位我们想要的地方，快慢指针的一个应用无论是在这题还有前面的删除倒数第几个节点，以及明天要完成的一题环形链表都有体现多思考。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：21.合并两个有序列表","slug":"合并两个有序列表","date":"2020-12-15T11:17:22.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/12/15/合并两个有序列表/","link":"","permalink":"http://yournotes.cn/2020/12/15/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/","excerpt":"题目信息 题目地址:https://leetcode-cn.com/problems/merge-two-sorted-lists/ 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。","text":"题目信息 题目地址:https://leetcode-cn.com/problems/merge-two-sorted-lists/ 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解法一：迭代两个链表两个指针不停的比较拼接新链表直到都遍历完成，每个迭代四个变动（三个指针以及cur指针的next） 1234567891011121314151617public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode cur = head; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; cur.next = l1; l1 = l1.next; &#125; else &#123; cur.next = l2; l2 = l2.next; &#125; cur = cur.next; &#125; //处理最后的，另一个链表无论还剩多少个都是排好序的并且比当前大直接拼在当前之后就好 cur.next = l1 == null ? l2 : l1; return cur.next;&#125; 解法二：递归同样的改递归自顶向上，到l1&#x2F;l2为null时才完成全部，那么他就是我们的递归出口，除此之外循环迭代最后一步也就是比大小设置指向。这样去想如果l1.next与l2已完成顺序合并，那么l1改指向谁呢？ 123456789101112public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; else if (l2 == null) return l1; //谁是头 if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 总结也是比较简单并且与前几道题一样仍然是迭代调整同样也可以转一下递归","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之链表：206.反转链表","slug":"反转链表","date":"2020-12-14T11:34:48.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/12/14/反转链表/","link":"","permalink":"http://yournotes.cn/2020/12/14/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"题目信息 题目地址：https://leetcode-cn.com/problems/reverse-linked-list/submissions/ 反转一个单链表。","text":"题目信息 题目地址：https://leetcode-cn.com/problems/reverse-linked-list/submissions/ 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解法一：迭代反转一个链表和数组是不一样的，因为不能任意取值，只能说按照next的顺序依次往后放。那么把一个节点往后放的过程就是一次迭代 我们要迭代的有两个值，第一个不用说是当前节点cur每次迭代完它要换成原链表的下一个，第二个是转换过去的next，它是上一个当前节点。 1234567891011121314public ListNode reverseList(ListNode head) &#123; ListNode cur = head; ListNode next = null; while( cur != null)&#123; //记住原链表的下一个 ListNode temp = cur.next; //设下next cur.next = next; //更新next与cur next = cur; cur = temp; &#125; return next;&#125; 解法二：递归有了这样一个迭代，我们可以去转一下递归。在迭代当中我们去设置了头结点的next为空，之后的next都是推导的，反过来它是我们的递归出口 我们通过reverseListc传入头结点，完成整个链表的反转。如果我们传入头结点的next呢，那么就从图中4的节点开始反转，最终要实现真正的反转把4节点指向5节点并且5节点指向null。 12345678910public ListNode reverseList(ListNode head) &#123; if(head==null || head.next==null) &#123; return head; &#125; ListNode cur = reverseList(head.next); //最后操作 4指向5，且5指向null head.next.next = head; head.next = null; return cur;&#125; 解法三：栈解这一题栈也是可以用，我们迭代顺着从头结点开始，把自己作为下一个被指向。那么倒着先从最后节点开始把它的next指向前一个节点。但是对于这个单向链表找下一个next就可以取到，但找前一个取不到。 1234567891011121314151617181920public ListNode reverseList(ListNode head) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); //依次入栈 while (head != null) &#123; stack.push(head); head = head.next; &#125; if (stack.isEmpty()) return null; ListNode newHead = stack.pop(); ListNode cur = newHead; //依次出栈，next为下一个 while (!stack.isEmpty()) &#123; ListNode temp = stack.pop(); cur.next = temp; cur = cur.next; &#125; //处理最后一个next为null,否则成环 cur.next = null; return newHead;&#125; 总结解法二关于递归的改造作为算法学习还是可以多练习的，解法一正向遍历+过程反向（每个把自己作为后一个也就是下一个在前面）解法三反向遍历+过程正向（每个都是前一个它的next就是下一个），总体来说解法一最优，解法二与三熟悉其他数据结构以及某些算法思想","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"忽然之间","slug":"忽然之间","date":"2020-12-13T14:06:08.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/12/13/忽然之间/","link":"","permalink":"http://yournotes.cn/2020/12/13/%E5%BF%BD%E7%84%B6%E4%B9%8B%E9%97%B4/","excerpt":"《忽然之间》谱子收藏、全文查看","text":"《忽然之间》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"等你下课","slug":"等你下课","date":"2020-12-13T14:05:56.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/12/13/等你下课/","link":"","permalink":"http://yournotes.cn/2020/12/13/%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE/","excerpt":"《等你下课》谱子收藏、全文查看","text":"《等你下课》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"LeetCode初级算法之链表：19.删除链表的倒数第N个节点","slug":"删除链表的倒数第N个节点","date":"2020-12-13T09:58:39.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/12/13/删除链表的倒数第N个节点/","link":"","permalink":"http://yournotes.cn/2020/12/13/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"删除链表的倒数第N个节点 题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。","text":"删除链表的倒数第N个节点 题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 12给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明：给定的 n 保证是有效的。 进阶：你能尝试使用一趟扫描实现吗？ 解法一：倒数转正数很自然的是我只能通过头节点head多次的next，找到要被删除的节点，但我们获取的定位是倒数第几个。直观的就是我们通过总长度减去倒数就是我们的next次数 1234567891011121314151617181920212223public ListNode removeNthFromEnd(ListNode head, int n)&#123; // 1.统计链表长度 int count = 0; ListNode node = head; while(node != null)&#123; count++; node = node.next; &#125; //重置node node = head; // 2.找到被删除节点的前一个 for(int i = 0; i &lt; count - n - 1; i++)&#123; node = node.next; &#125; // 3.删除操作 if(count == n)&#123; //如果是头节点 head = head.next; &#125;else&#123; node.next = node.next.next; &#125; return head;&#125; 现在我们是完成了这样一个思路，但有个地方可以做一个调整，也是要养成的一个习惯。对于一个链表如下图：它是按某种应用逻辑存储的内容，内容都会有操作有修改的时候，因此为了方便操作以及操作的安全性。通常都会在真正存储数据的链头之前加一个节点它的值和内容无关，用这个额外的节点来做真正的链表节点。 我们第三步删除操作之所以这样分开操作就是因为，我们拿到的是删除节点之前的节点因此删除是头结点的话需要单独处理，这下就不需要了。最后我们去返回数据链的头，也就是真正头的next 1234567891011121314151617181920public ListNode removeNthFromEnd(ListNode head, int n)&#123; //加一个头结点 ListNode listHead = new ListNode(0,head); // 1.统计链表长度 int count = 0; ListNode node = head; while(node != null)&#123; count++; node = node.next; &#125; // 重置node node = listHead; // 2.找到被删除节点的前一个(比之前多一次) for(int i = 0; i &lt; count - n; i++)&#123; node = node.next; &#125; // 3.删除操作 node.next = node.next.next; return listHead.next;&#125; 时间O（n），空间O（1） 解法二：栈无论是倒序啊还是倒数都可以想到栈这样一个东西，上个解法我们完整遍历一次统计长度，把倒数转为正数再进行正数次数的next取被删除节点的前驱节点，这次一样进行完整遍历都放到我们的栈里面。 之后再进行倒数次数的出栈操作，之后剩下的栈顶即是被删除节点的前驱节点 123456789101112131415161718192021public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 创建真头结点 ListNode listHead = new ListNode(0, head); // 创建栈 Deque&lt;ListNode&gt; stack = new LinkedList&lt;ListNode&gt;(); // 从真头结点开始存入 ListNode node = listHead; while (node != null) &#123; stack.push(node); node = node.next; &#125; // 依次弹出 for (int i = 0; i &lt; n; i++) &#123; stack.pop(); &#125; // 取栈顶即被删节点的前驱节点 node = stack.peek(); // 删除操作 node.next = node.next.next; return listHead.next;&#125; 时间O（n），创建了栈空间O（n） 解法三：一次遍历两个解法都用到了两次遍历，那么我们有没有方法可以在一次遍历中完成呢？ 它就是我们处理链表的经典方式快慢指针,我们用两个指针，快指针领先n次（倒数次数），慢指针在起点，同时迭代。当快指针到了终点，那慢指针岂不是到了倒数第n个。fast起点可以取后一格那么slow就能拿到倒数第n个的前一个节点 12345678910111213141516public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode listHead = new ListNode(0, head); // 取的是被删除节点的前驱节点，fast初始化多一格 ListNode fast = head; ListNode slow = listHead; int i = 0; while (fast != null) &#123; // fast先移动n，之后在同步移动 fast = fast.next; if(i&gt;=n) slow = slow.next; i++; &#125; // 直到fast遍历完，slow就停在倒数第n个的前个 slow.next = slow.next.next; return listHead.next;&#125; 时间O（n）,空间O（1） 总结三种解法前两种解法比较常规就顺题意推导正着找和反着找，第三种快慢指针是链表比较常用的一种方式。比如有环，追击问题等等。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"gitee(码云)图片丢失问题","slug":"gitee-码云-图片丢失问题","date":"2020-12-13T02:57:49.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2020/12/13/gitee-码云-图片丢失问题/","link":"","permalink":"http://yournotes.cn/2020/12/13/gitee-%E7%A0%81%E4%BA%91-%E5%9B%BE%E7%89%87%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/","excerpt":"gitee(码云)图片丢失之前申请了博客园想着美化一番，于是换了BNDong的Silence主题，首页搞了一些封面图片存储在gitee","text":"gitee(码云)图片丢失之前申请了博客园想着美化一番，于是换了BNDong的Silence主题，首页搞了一些封面图片存储在gitee 但部分封面是显示不出来的并且提示是302重定向。 恰好在看这个的时候gitee我已经登陆了因此拿这个地址是可以访问到图片的，因此放着没有解决直到今天早上，直接访问提示302图片的地址发现提示大小超过1M的文件需要登陆才能访问然后跳到gitee的登录页。这就是为什么博客封面302的原因（资源存在但重定向） 解决方式无论是gitee还是github它都提供了一个静态对外访问的接口，需要的仓库开启服务中的Gitee Pages。使用它生成的服务地址再去访问仓库下对应文件的路径https://用户名.gitee.io/仓库名/文件路径但文件路径不能有中文，原始数据的访问方式可以有中文，但这个是不能的","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"LeetCode初级算法之链表：237.删除链表中的节点","slug":"删除链表中的节点","date":"2020-12-11T14:14:50.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/12/11/删除链表中的节点/","link":"","permalink":"http://yournotes.cn/2020/12/11/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"删除链表中的节点 题目地址：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。","text":"删除链表中的节点 题目地址：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 现有一个链表 – head &#x3D; [4,5,1,9]，它可以表示为: 示例 1： 输入：head &#x3D; [4,5,1,9], node &#x3D; 5输出：[4,1,9]解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2： 输入：head &#x3D; [4,5,1,9], node &#x3D; 1输出：[4,5,9]解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 提示： 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 题解作为合集中链表下的第一题，确实是较简单的只是一个单元操作，但如果不知道链表这种数据结构也还是是完成不了的。 链表是什么？ 链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，有一系列结点（地址）组成，结点可动态的生成，也就是包含值与模拟指针（引用）。大概如下： 每个节点对象除了内容值还有一个引用一共两个属性，这样以来各个节点对象之间就好像连接着一样 12345678910class ListNode&#123; //节点值 int val; //节点指向的下个节点 ListNode next; //构造器 ListNode(int x) &#123; val = x; &#125;&#125; 现在它传一条链表的一个节点，删除这个节点。因为一个节点的信息只有自己的值以及下个节点。所以传入一个节点是看不到整个链表的。也就是说我们只能拿到部分链就是传入的节点之后的5---&gt;1---&gt;9。值为4的节点是指向5这个节点的，删除5节点就是让4节点直接指向1节点就可以了，但我们拿不到4节点所以不能改变它的next属性的值。那么我们只能改它指向的节点把它的值由5改成1再指向9 这样就不用改变4节点的指向，只是把它指向的这个对象值与next都改掉，那么4还是指向0x001只不过是1了，而这个指向的又是0x004就是9，链表也就变成了4—&gt;1—&gt;9完成删除5的操作 123456public void deleteNode(ListNode node) &#123; //“被删节点”的值改为下个节点的值 node.val = node.next.val; //指向下下个 node.next = node.next.next;&#125; 总结开篇第一题主要是考察学习链表构成，本身是简单的但先要了解这样一个数据结构。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：14.最长公共前缀","slug":"最长公共前缀","date":"2020-12-10T10:57:15.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/12/10/最长公共前缀/","link":"","permalink":"http://yournotes.cn/2020/12/10/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"最长公共前缀题目地址：https://leetcode-cn.com/problems/longest-common-prefix/ 编写一个函数来查找字符串数组中的最长公共前缀。","text":"最长公共前缀题目地址：https://leetcode-cn.com/problems/longest-common-prefix/ 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl” 示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解法一：横向比较去找到多个串的公共前缀不知道，但我们至少知道找两个串的公共前缀。于是两两一组用上次公共串找下公共直到n-1次迭代完成最终公共前缀，那么像第一个示例三个串，就需要2次迭代 也就是说我们用一个公共前缀与下一个得到公共前缀然后更新覆盖，开始下一次迭代。那么一开始我们指定strs[0]为第一代的公共前缀，下面是初次提交成功的代码： 12345678910111213141516171819202122232425262728public String longestCommonPrefix(String[] strs)&#123; int n = strs.length; if(strs.length == 0) return &quot;&quot;; //最初公共前缀 String common = strs[0]; //两两一次共n-1次迭代 for(int i = 1; i &lt; n; i++)&#123; //一次迭代的过程 int j = 0; char[] cur = common.toCharArray(); char[] next = strs[i].toCharArray(); //strs数组与两个字符串边界 if(next.length == 0) return &quot;&quot;; while( j &lt; cur.length &amp;&amp; j &lt; next.length )&#123; // 扫描到不同了，那么这个索引在最后一个相同的后面一个 if(cur[j] != next[j])&#123; common = common.substring(0,j);//注意区间左闭右开 break; // 没有扫描到不同但但已经结尾了，那么索引就是相同的最后一个 &#125;else if(j == cur.length - 1 || j == next.length - 1)&#123; common = common.substring(0,j+1); break; &#125; j++; &#125; &#125; return common;&#125; 但这段代码是存在问题的，我们要考虑的问题是在循环里面的操作能不能减少，虽然时间复杂度不会变化。但减少循环体的操作也可以成倍的提升，观察代码首次迭代多少次就一个for循环没有什么问题，那么重点关注的是一次迭代这个过程的代码。我们这段代码拿出来： 123456789101112while( j &lt; cur.length &amp;&amp; j &lt; next.length )&#123; // 扫描到不同了，那么这个索引在最后一个相同的后面一个 if(cur[j] != next[j])&#123; common = common.substring(0,j);//注意区间左闭右开 break; // 没有扫描到不同但但已经结尾了，那么索引就是相同的最后一个 &#125;else if(j == cur.length - 1 || i == next.length - 1)&#123; common = common.substring(0,i+1); break; &#125; j++;&#125; 先看循环体，因为两段if都有break，那么有三段只能走一个。我们想一想两段if的操作是不是可以合并的。聪明的小伙伴应该能很快反应过来，无非是有木有扫描超过导致是截取[ 0 , j )和[ 0 , j+1 )，那么其实只要不满足两个相等就出循环那么索引都是在最后相等后加了1，根本不用判断截取[ 0 , j )即可。代码立刻可以减少一部分 1234while( j &lt; cur.length &amp;&amp; j &lt; next.length &amp;&amp; cur[j] == next[j])&#123; j++;&#125;common = common.substring(0,j);//注意区间左闭右开 同时它也减少了我们在循环里的操作。如果循环是n次，那么里面有2-3次操作那么次数就是2-3n，尽量去减少里层循环的操作次数。除了循环体之外while条件也是随着循环被执行因为是短路与可能执行一个结束也可能执行三个式子，所以我们可以减少一次 12345int length = cur.length &gt; next.length ? next.length : cur.length;while( j &lt; length &amp;&amp; cur[j] == next[j])&#123; j++;&#125;common = common.substring(0,j);//注意区间左闭右开 这就相当于我们往外层添加了一次操作但减少了循环的一次操作，这些其实优化都不大但是在不换解题思维以及数据结构等等我们可以去考虑的优化点 123456789101112131415161718192021public String longestCommonPrefix(String[] strs)&#123; int n = strs.length; if(strs.length == 0) return &quot;&quot;; //最初公共前缀 String common = strs[0]; //两两一次共n-1次迭代 for(int i = 1; i &lt; n; i++)&#123; //一次迭代的过程 int j = 0; char[] cur = common.toCharArray(); char[] next = strs[i].toCharArray(); //strs数组与两个字符串边界 if(next.length == 0) return &quot;&quot;; int length = cur.length &gt; next.length ? next.length : cur.length; while( j &lt; length &amp;&amp; cur[j] == next[j])&#123; j++; &#125; common = common.substring(0,j);//注意区间左闭右开 &#125; return common;&#125; 解法二：纵向比较其实最开始我想到的解法就是纵向比较同时扫描多个串每个串的字符都相等再同时往后扫描直到有第一个不同就终止。 但当时只有一个直观的想法想着一字排开比较相等然后感觉处理不了就想到横向的比较好写 1234int i = 0;while( i &lt; min(length) &amp;&amp; str1[i] == str2[i]==..... )&#123; i++;&#125; 其实这里取一个字符串遍历，在一次遍历里面遍历数组的其他的字符串都进行比较即可 1234567891011121314151617public String longestCommonPrefix(String[] strs) &#123; //为空返回&quot;&quot; if (strs.length == 0) return &quot;&quot;; //取数组减少charAt在循环体 char[] p = str[0].toCharArray(); int n = p.length; for (int i = 0; i &lt; n; i++) &#123; char c = p[i]; //依次判断直到不等出现，截取返回 for (int j = 1; j &lt; strs.length; j++) &#123; if (i == strs[j].length() || strs[j].charAt(i) != c) &#123; return strs[0].substring(0, i); &#125; &#125; &#125; return strs[0];&#125; 解法三：变体（解一）我们出了通过循环扫描比较得到两串的公共前缀，还可以通过前缀是否包含可以用a.startsWith(b)判断是否以起始索引包含另一个串，或者用a.indexOf(b) &#x3D;&#x3D; 0 来判断，没有则删减一位直到找到公共前缀开始下个迭代和解一是一样的只是找公共前缀的方式不同 1234567891011121314public String longestCommonPrefix(String[] strs) &#123; //为空返回&quot;&quot; if (strs.length == 0) return &quot;&quot;; String common = strs[0]; for (String str : strs) &#123; // 若common已经减为&quot;&quot;，则说明无公共前缀，直接返回 if (common == &quot;&quot;) return common; // 若common在当前str中匹配不上，则减少字符串common的长度，再次尝试匹配 while (!str.startsWith(common)) &#123; common = common.substring(0,common.length() - 1); &#125; &#125; return common;&#125; 总结总体而言的话其实时间复杂度都是比较高的，毕竟都使用了substring等方法超过n的三次方都差不多所以没有较优解。也是和上一题差不多两题都是体会迭代的一个过程因此也都可以转成递归的形式，那就还可以分治分到最后都是两两一组然后求解自底向上之后会介绍，到此LeetCode初级算法合集中的字符串系列全部完成，开启下个篇章链表。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：38.外观数列","slug":"外观数列","date":"2020-12-09T11:12:44.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/12/09/外观数列/","link":"","permalink":"http://yournotes.cn/2020/12/09/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/","excerpt":"外观数列题目地址：https://leetcode-cn.com/problems/count-and-say/ 给定一个正整数 n ，输出外观数列的第 n 项。","text":"外观数列题目地址：https://leetcode-cn.com/problems/count-and-say/ 给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 你可以将其视作是由递归公式定义的数字字符串序列： countAndSay(1) &#x3D; “1”countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 1234567//前五项如下：111211211111221 第一项是数字 1描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。 例如，数字字符串 “3322251” 的描述如下图： 示例 1： 输入：n &#x3D; 1输出：”1”解释：这是一个基本样例。 示例 2： 输入：n &#x3D; 4输出：”1211”解释：countAndSay(1) &#x3D; “1”countAndSay(2) &#x3D; 读 “1” &#x3D; 一 个 1 &#x3D; “11”countAndSay(3) &#x3D; 读 “11” &#x3D; 二 个 1 &#x3D; “21”countAndSay(4) &#x3D; 读 “21” &#x3D; 一 个 2 + 一 个 1 &#x3D; “12” + “11” &#x3D; “1211” 提示： 1 &lt;&#x3D; n &lt;&#x3D; 30 解法一：暴力解法很直观的我们要去扫描一个串并且按照顺序统计连续相同的数字数量，出现不同则中断重新统计。最后得到一个新串这是一次迭代。按照上面的例子要进行n次迭代，每次用上一次得到的串。 1234567891011121314151617181920212223242526public String countAndSay(int n)&#123; //上代串 String str = &quot;1&quot;; //本次迭代串 StringBuilder result = new StringBuilder(); //迭代n次 for(int c = 1; c &lt; n; c++)&#123; //1. 清空迭代串 result.delete(0,result.length()); //2. 双指针扫描 int i = 0, j = 0; while(i &lt; str.length() &amp;&amp; j &lt; str.length())&#123; if(str.charAt(i) != str.charAt(j))&#123; //拼接上相同数量和对应数字 result.append(j - i).append(str.charAt(i)); i = j; &#125; if(j == str.length() - 1)&#123; result.append(j - i + 1).append(str.charAt(i)); &#125; j++; &#125; str = result.toString(); &#125; return str;&#125; 解法二：递归（解一）换个花样的话，也可以把上面迭代n次该为递归调用n次的方式 1234567891011121314151617181920212223public String countAndSay(int n) &#123; // 递归终止条件 if (n == 1) &#123; return &quot;1&quot;; &#125; // 本次迭代串 StringBuilder result = new StringBuilder(); // 上代串 String str = countAndSay(n - 1); // 双指针扫描 int i = 0, j = 0; while(i &lt; str.length() &amp;&amp; j &lt; str.length())&#123; if(str.charAt(i) != str.charAt(j))&#123; result.append(j - i).append(str.charAt(i)); i = j; &#125; if(j == str.length() - 1)&#123; result.append(j - i + 1).append(str.charAt(i)); &#125; j++; &#125; return res.toString();&#125; 解法三 ：正则表达式玩的再花一点可以用下正则表达式。去匹配相同的数字为一组，用到java.util.regex下的Pattern与Matcher， 12345&quot;.&quot;是表示任意字符，&quot;//1&quot;引用前面括号表示的内容&quot;*&quot; 0个或多个&quot;(.)\\\\1*&quot;第一个字符是任意的第二个要么是前一个字符要么就没有，*后面都和第二位一样字符串&quot;aaabc&quot;过滤出来就是aaa、b、c 代码： 12345678910111213public String countAndSay(int n) &#123; String str = &quot;1&quot;; Pattern pattern = Pattern.compile(&quot;(.)\\\\1*&quot;); for (int i = 1; i &lt; n; i++) &#123; Matcher m = pattern.matcher(str); StringBuilder result = new StringBuilder(); while (m.find()) &#123; result.append(m.group().length() + String.valueOf(m.group().charAt(0))); &#125; str = result.toString(); &#125; return str;&#125; 总结对于这题的话还是比较好做的，因为在直接解法里面并没有多余的步骤本身就是优的。使用解法三目的只是熟悉一下Java类库关于正则的一些操作和正则表达式，本身对题来说里面很多操作是多余的因此效率是低的。解一解二在复杂度相同的情况下，解二虽然在这上面显示的好像快一点但递归循环调用方法创建栈帧进栈出栈还是有消耗的，较优解还是最开始的解一","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：28.实现 strStr()","slug":"实现-strStr","date":"2020-12-06T08:29:28.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/12/06/实现-strStr/","link":"","permalink":"http://yournotes.cn/2020/12/06/%E5%AE%9E%E7%8E%B0-strStr/","excerpt":"实现 strStr() 函数题目地址：https://leetcode-cn.com/problems/implement-strstr/ 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。","text":"实现 strStr() 函数题目地址：https://leetcode-cn.com/problems/implement-strstr/ 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack &#x3D; “hello”, needle &#x3D; “ll”输出: 2 示例 2: 输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba”输出: -1 说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解法一：暴力解法本题就是要实现一个indexOf函数，首先想到的就是双指针在两个串中比较。 暴力解法（BF）就依次扫描如果有相同的同步继续，出现不同就中断了，模式串回到起点主串回到下个开头点。也就是说主串的长度会遍历完，剩下的看模式串扫到什么时候中断。在最差的情况下每次模式串遍历到最后一个中断主串最末端才匹配到那就是O(n*m) 边界 索引越界 细节 循环结束条件 haystack空返回0 haystack比needle短返回-1 123456789101112131415161718public int strStr(String haystack, String needle) &#123; char[] hay = haystack.toCharArray(); char[] need = needle.toCharArray(); int h = hay.length; int n = need.length; int i=0,j=0; while(j &lt; h &amp;&amp; i &lt; n)&#123; if(hay[j] == need[i])&#123; i++; j++; &#125;else &#123; j=j-i+1; i=0; &#125; &#125; if(i &gt;= n) return j-i; else return -1;&#125; 解法二：截取子串除了两个指针依次比较之外，判断一个串是否含另一个串直接去依次截取目标长度的子串，判断有无相等的子串。这里截取我直接用的substring方法，这个也实现过很多次了，怎么写都一样但我们一定要知道它的实现是怎样的才能客观的分析它的复杂度，这里它就是一次遍历。因此下面代码的解法也是一个两层的遍历 12345678910public int strStr(String haystack, String needle) &#123; int n = needle.length(); int h = haystack.length(); for (int i = 0; i &lt; h - n + 1; i++) &#123; if (haystack.substring(i, i + n).equals(needle)) &#123; return i; &#125; &#125; return -1;&#125; 其实这种解法和解法一是一模一样只不过前者把截取和比较直接写了出来，它比解法一优的点只是少遍历了后面短的部分一个是h * (?)另一个是（h-n+1）* (?)，是因为两层遍历分开写可以这样做。外面遍历子串的开头，里面再遍历子串与模式串是否相等。而解法一放到了一个循环也做到了这个逻辑 总结字符串匹配算法算是一个比较经典的算法，也是在计算机领域实际应用超多的算法。上面无论是解一还是解二其实都是全遍历比较。许多科学家都发明了更多减少比较次数的方式，比如RK算法、BM算法以及KMP算法。这些在这里暂时不介绍。之后在其他系列会出单篇讲解这类以及其他的算法。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：8.字符串转换整数 (atoi)","slug":"字符串转换整数-atoi","date":"2020-12-04T12:33:57.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/12/04/字符串转换整数-atoi/","link":"","permalink":"http://yournotes.cn/2020/12/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/","excerpt":"字符串转换整数 (atoi)题目地址：https://leetcode-cn.com/problems/string-to-integer-atoi/ 请你来实现一个 atoi 函数，使其能将字符串转换成整数。","text":"字符串转换整数 (atoi)题目地址：https://leetcode-cn.com/problems/string-to-integer-atoi/ 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 **注意：**假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: “42”输出: 42 示例 2: 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。 示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。 示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解法一 严格来说这个问题其实没有太多考察算法的内容不涉及数据结构、算法思维的选取。它是一个数据的效验筛选，更多的像开发场景中的一些原始数据的处理参数的筛选。所以不难但有较多的判断语句涉及一些细节问题需要仔细对比 主体 去掉前导空格 处理正负号 识别数字 边界 整数溢出 索引越界 细节 无效转换返回0 123456789101112131415161718192021222324252627282930public int myAtoi(String str) &#123; char[] chars = str.toCharArray(); int n = chars.length; int index = 0; //1.去掉前导空格 while (index &lt; n &amp;&amp; chars[index] == &#x27; &#x27;) &#123; index++; &#125; //2.符号处理 int sign = 1; if(index &lt; n &amp;&amp; chars[index] == &#x27;+&#x27;)&#123; index++; &#125;else if(index &lt; n &amp;&amp; chars[index] == &#x27;-&#x27;)&#123; sign = -1; index++; &#125; //3.拼接数字 int result = 0; while (index &lt; n &amp;&amp; chars[index]-&#x27;0&#x27; &gt;= 0 &amp;&amp; chars[index]-&#x27;0&#x27; &lt;= 9) &#123; int num = chars[index] - &#x27;0&#x27;; if (result &gt; (Integer.MAX_VALUE - num) / 10) &#123; // 本来应该是 result * 10 + num &gt; Integer.MAX_VALUE // 但是 *10 和 + num 都有可能越界,所以在上面逆向判断 return sign &lt; 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; result = result * 10 + num; index++; &#125; return result * sign;&#125; 解法二：正则表达式 这样一个筛选串的过程我们除了自己去去遍历判断，也可以使用正则表达式的方式。用到Java类库的相关工具但本质上还是和解法一是一样的。需要引入java.util.regex包下的Pattern与Matcher 1234567891011121314public int myAtoi(String str) &#123; str = str.trim(); Pattern pattern = Pattern.compile(&quot;[-+]??[0-9]++&quot;); Matcher matcher = pattern.matcher(str); if (matcher.lookingAt()) &#123; String num = str.substring(0, matcher.end()); try &#123; return Integer.parseInt(num); &#125; catch (NumberFormatException nfe) &#123; return num.charAt(0) == &#x27;-&#x27; ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; &#125; return 0;&#125; 解法三：有限状态自动机 正则表达的所匹配的所有字符串构成都可以用有限自动机识别，其实上面解法的每个过程判定就是一个有限自动机的每个状态。从去除空格阶段到取符号阶段到数字阶段到结束。和KMP一样都可解决字符串匹配相关问题 状态机里面有 4 个概念： State ，状态。一个状态机至少要包含两个状态。 Event ，事件。事件就是执行某个操作的触发条件或者口令。 Action ，动作。事件发生以后要执行动作。 Transition ，变换。也就是从一个状态变化为另一个状态。 套到这道题里就是我们的程序在每个时刻有一个状态 s ，每次从序列中输入一个字符 c ，并根据字符 c 转移到下一个状态 s&#39; 。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s&#39; 的表格即可解决题目中的问题。 答案中给出的示例图是这样的： 用图表来表示： 我又画了下面一张图和上面两个同义。（0表示状态start，1表示状态signed，2表示状态int_number，3表示状态end，’其他’表示除[空格、正负号、数字]之外的字符） 意思就是说依次输入字符。首先字符是进入状态0（start）如果字符是空格那么下个仍然进入状态0.如果是其他则进入状态3（end）结束处理。那我们就可以实现这样一个自动机 1234567891011121314151617181920212223242526272829303132class Automata&#123; //下次的状态 private int state=0; //状态表 private int[][] table=&#123;&#123;0,1,2,3&#125;,&#123;3,3,2,3&#125;,&#123;3,3,2,3&#125;,&#123;3,3,3,3&#125;&#125;; //字符的四种情况 public int getCharState(char c)&#123; if(c==&#x27; &#x27;)return 0; if(c==&#x27;+&#x27;|| c==&#x27;-&#x27;)return 1; if(Character.isDigit(c))return 2; return 3; &#125; int result = 0; //结果 int sign = 1; //符号 public void input(char c)&#123; //通过这次的字符设定下个状态 state=table[state][getCharState(c)]; //state == 0 直接过 if(state==1 &amp;&amp;c==&#x27;-&#x27;) sign=-1; if(state==2)&#123; int num = c - &#x27;0&#x27;; //除了通过当前状态和字符来判断下个去往状态 //溢出发生时其实也应该把状态设为3（end） if (result &gt; (Integer.MAX_VALUE - num) / 10) &#123; result = sign &lt; 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE; sign = 1; state = 3; &#125;else result = result * 10 + num; &#125; //state == 3 直接过 &#125;&#125; 然后就是使用我们的自动机解题啦 12345678public int myAtoi(String str) &#123; Automata auto=new Automata(); char[] chars=str.toCharArray(); for(char c:chars)&#123; auto.input(c); &#125; return auto.sign*auto.result;&#125; 或者state为3这边也直接结束不去掉用空方法 12345678910public int myAtoi(String str) &#123; Automata auto=new Automata(); char[] chars=str.toCharArray(); int i = 0; while(i&lt;chars.length &amp;&amp; auto.state != 3)&#123; auto.input(chars[]); i++; &#125; return auto.sign*auto.result;&#125; 总结就这题本身来讲是比较简单的，主要是处理细节问题可能很多小伙伴在像解法一的处理过程中没有组织清晰导致虽然能解出题但有很多代码是冗余的或者重复判断了的地方。最终解法一其实也不过两个if而已没有像传闻中那样说很多ifelse，三个处理第一个空格处理是循环处理，第二符号只有首位所以单个if，第三个数字也是循环处理。因此三个必要的判断两个是while一个是if。最后还加上一个溢出的判断。除此之外这题也有学习到的地方，第一是对正则的回顾，第二是引出有限状态自动机这样一个计算机思想也是等于又温习下离散数学。对于这题没有什么算法思维理清思路书写下来就是解法一的这样一个过程。因此这一题的意图可能就是让我们学习到有限状态自动机封装这样一个机器或者规则往这个规则里输入语言串它去给我们输出相应的结果。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：125.验证回文串","slug":"验证回文串","date":"2020-12-03T11:19:29.000Z","updated":"2025-04-17T08:34:52.025Z","comments":true,"path":"2020/12/03/验证回文串/","link":"","permalink":"http://yournotes.cn/2020/12/03/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/","excerpt":"验证回文串题目地址：https://leetcode-cn.com/problems/valid-palindrome/ 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。","text":"验证回文串题目地址：https://leetcode-cn.com/problems/valid-palindrome/ 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 **说明：**本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解法一：双指针首先判断两个字符串是否是回文串，就是原串与倒序是否相等，那不就是前面写的反转字符串么。只不过就是首尾交换，换成首尾是否相等。但在此之前我们先要从原串中获取数字字母串并忽略大小写 123456789101112131415161718192021222324252627public boolean isPalindrome(String s) &#123; if(s == null || s.length() == 0) return true; char[] arr = s.toCharArray(); int n = arr.length; StringBuilder cs = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; char c = arr[i]; if (check(c)) &#123; cs.append(change(c)); &#125; &#125; n = cs.length(); for(int i = 0; i &lt; n/2; i++)&#123; if(cs.charAt(i) != cs.charAt(n-i-1))&#123; return false; &#125; &#125; return true;&#125;//是否是字母或数字public boolean check(char c)&#123; return c&gt;=48&amp;&amp;c&lt;=57 || c&gt;=65&amp;&amp;c&lt;=90 || c&gt;=97&amp;&amp;c&lt;=122;&#125;//大写统一转小写public char change(char c)&#123; return c&gt;=65&amp;&amp;c&lt;=90 ? c+=32 : c;&#125; 解法二：细节优化(双指针)我们刚刚是用了两个循环，第一个循环筛选了属于字母数字的。第二次循环再判断字母数字的串有木有重复。其实是冗余的，我们直接在第一个循环完成即可，最终的目的是看字母数字是否回文但没必要取出来再做。那样减少了一个容器和一次遍历。 123456789101112131415161718192021222324252627282930public boolean isPalindrome(String s) &#123; if(s == null || s.length() == 0) return true; char[] arr = s.toCharArray(); int n = arr.length; int start = 0; int end = n - 1; while(start &lt; end)&#123; while(start &lt; end &amp;&amp; !check(arr[start]))&#123; start++; &#125; while(start &lt; end &amp;&amp; !check(arr[end]))&#123; end--; &#125; if(change(arr[start])!=change(arr[end]))&#123; return false; &#125; start++; end--; &#125; return true;&#125;//是否是字母或数字public boolean check(char c)&#123; return c&gt;=48&amp;&amp;c&lt;=57 || c&gt;=65&amp;&amp;c&lt;=90 || c&gt;=97&amp;&amp;c&lt;=122;&#125;//大写统一转小写public char change(char c)&#123; return c&gt;=65&amp;&amp;c&lt;=90 ? c+=32 : c;&#125; 解法三：栈虽然这题双指针就是比较优的解法，但是前段时间学习了栈，因此在这题上用上温习一下不过空间和效率应该是最低的，我们都知道栈是后进先出（LIFO）一种数据结构。这里我们可以用数组实现一下栈完成一下基本的四个方法 123456789101112131415161718class Stack&lt;E&gt;&#123; List&lt;E&gt; arr = new ArrayList(); int top = -1; void push(E c)&#123; arr.add(++top,c); &#125; E pop()&#123; E c = peek(); arr.remove(top--); return c; &#125; E peek()&#123; return arr.get(top); &#125; boolean isEmpty()&#123; return top &lt; 0; &#125;&#125; 123456789101112131415161718192021public boolean isPalindrome(String s) &#123; if(s == null || s.length() == 0) return true; char[] arr = s.toCharArray(); int n = arr.length; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; char c = arr[i]; if (check(c))&#123; stack.push(change(c)); list.add(change(c)); &#125; &#125; int index = 0; while (!stack.isEmpty())&#123; if (stack.pop() != list.get(index++)) return false; &#125; return true;&#125; 总结回文串处理的大体方式还是双指针、反转或者栈。对于此题Character类中提供了判断是否为数字或字母的方法和转大小写的方法。我上面是单独写的check(char c)与change(char c)方法。 12isLetterOrDigit(char c)toLowerCase(char c) 利用Java类库的话直接有反转方法当然它里面也是一次遍历处理，反转再比较。当然效率是比较低的可以参考 123//cs为取出来的只含字母数字的字符串String fz = cs.reverse().toString();return cs.equals(fz); 总体来说呢可以实现的方式有很多，关注实现本身效率来说双指针是较优的。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：242.有效的字母异位词","slug":"有效的字母异位词","date":"2020-12-02T11:40:54.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/12/02/有效的字母异位词/","link":"","permalink":"http://yournotes.cn/2020/12/02/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"有效的字母异位词题目地址：https://leetcode-cn.com/problems/valid-anagram/ 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。","text":"有效的字母异位词题目地址：https://leetcode-cn.com/problems/valid-anagram/ 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram”输出: true 示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car”输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解法一：Hash表这题呢也是一个查找的一个操作，所以直接想到的就是hash表。两个字符串字母都一样就位置不一样，那就用Hash记录。最后key没有差别并且值相等就是异位词，两个值相等其实就换成是一个值等于0。用一个map完成 1234567891011121314151617181920212223public boolean isAnagram(String s, String t) &#123; char[] ss = s.toCharArray(); char[] tt = t.toCharArray(); //长度都不一样直接走开 if (ss.length != tt.length) &#123; return false; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; ss.length; i++) &#123; char c1 = ss[i]; char c2 = tt[i]; //统计如果是真的是异位词最后key值为0 map.put(c1, map.getOrDefault(c1, 0) + 1); map.put(c2, map.getOrDefault(c2, 0) - 1); &#125; //遍历表,不是异位词就有多也有少 for (int i = 0; i &lt; map.size(); i++) &#123; if (map.get(tt[i]) != 0) &#123; return false; &#125; &#125; return true;&#125; 解法二：数组和以前解题一样用Hash表能做就要考虑一下可不可以用数组来做，用数组的局限是它是固定的。所以如果记录的key是固定的不多就可以用。这里也就是26个字母 1234567891011121314151617181920212223public boolean isAnagram(String s, String t) &#123; char[] ss = s.toCharArray(); char[] tt = t.toCharArray(); //长度都不一样直接走开 if (ss.length != tt.length) &#123; return false; &#125; int[] table = new int[26]; for (int i = 0; i &lt; ss.length; i++) &#123; int c1 = ss[i] - &quot;a&quot;; int c2 = tt[i] - &quot;a&quot;; //统计如果是真的是异位词最后key值为0 table[c1]++; table[c2]--; &#125; //遍历表,不是异位词就有多也有少 for (int i = 0; i &lt; 26; i++) &#123; if (table[i] != 0) &#123; return false; &#125; &#125; return true;&#125; 解法三：排序不就是位置不同嘛，排个序不就是相等字符串了，就不用统计字符串中的每个字符数量。不过排序最优也是才nlogn，所以并不优只是解这题比较简单直接，甚至可以直接一句返回 12345678910public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) &#123; return false; &#125; char[] str1 = s.toCharArray(); char[] str2 = t.toCharArray(); Arrays.sort(str1); Arrays.sort(str2); return Arrays.equals(str1, str2);&#125; 总结总体来说解法二是最优的，但只限于当字符只是小写字母时，数组的解法确实是屡试不爽在key确定的情况下查找统计这类都可以用数组完成。其他两种解法就是通用的不限制字符，排序略优一点。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：387.字符串中的第一个唯一字符","slug":"字符串中的第一个唯一字符","date":"2020-12-01T12:41:35.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/12/01/字符串中的第一个唯一字符/","link":"","permalink":"http://yournotes.cn/2020/12/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/","excerpt":"字符串中的第一个唯一字符题目地址：https://leetcode-cn.com/problems/first-unique-character-in-a-string/ 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。","text":"字符串中的第一个唯一字符题目地址：https://leetcode-cn.com/problems/first-unique-character-in-a-string/ 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： 12345s = &quot;leetcode&quot;返回 0s = &quot;loveleetcode&quot;返回 2 提示： 你可以假定该字符串只包含小写字母。 解法一：双指针双指针比较，每指定一个值都要全文扫描有无重复 123456789101112131415161718public int firstUniqChar(String s) &#123; char[] arr = s.toCharArray(); int n = arr.length; for(int i = 0; i &lt; n; i++)&#123; boolean flag = true; //遍历每个值与当前值比较，有重复改false for(int j = 0; j &lt; n; j++)&#123; if(i != j &amp;&amp; arr[i] == arr[j])&#123; flag = false; &#125; &#125; //遍历完没有和当前值相同的 if(flag)&#123; return i; &#125; &#125; return -1;&#125; 然后LeetCode的测试用例字符串也是真的长（只截取了部分下面还可以翻页），所以在n^2的情况下超时。 解法二：细节优化上面的解法是有可优化的点的。我们去查找第一个只出现一次的，那么一个值找到相同的后我们就不必要再往后了遍历因为不需要看它有几个相同的，它不满足就应该看下一个值也就是应该加上break。 123456for(int j = 0; j &lt; n; j++)&#123; if(i != j &amp;&amp; arr[i] == arr[j])&#123; flag = false; break; &#125;&#125; 这一点是影响还是比较大的，第二点就是我们去判断遍历完了没有重复也就是找到了可以直接返回的处理我们除了定义flag在循环体标记，到循环去判断处理。其实我们去表达循环完后的处理也可以在循环体里面，也就是循环到最后了仍然不满足相等。 1234567for(int j = 0; j &lt; n; j++)&#123; if(i != j &amp;&amp; arr[i] == arr[j])&#123; break; &#125;else if(j == n-1)&#123; return i; &#125;&#125; 这样和前面的就是同一个意思，并且少定义一个变量flag，并且最后我们的代码不会超时 1234567891011121314public int firstUniqChar(String s) &#123; char[] arr = s.toCharArray(); int n = arr.length; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i != j &amp;&amp; arr[i] == arr[j])&#123; break; &#125;else if(j == n - 1)&#123; return i; &#125; &#125; &#125; return -1;&#125; 时间O（n^2），空间O（1） 解法三：Hash表那么使用hash表存信息，那么就不用重复遍历了 12345678910111213141516public int firstUniqChar(String s) &#123; char[] arr = s.toCharArray(); int n = arr.length; HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;(); //遍历存下所有信息 for (int i = 0; i &lt; n; i++) &#123; char c = arr[i]; count.put(c, count.getOrDefault(c, 0) + 1); &#125; //遍历查看key值为1的 for (int i = 0; i &lt; n; i++) &#123; if (count.get(arr[i]) == 1) return i; &#125; return -1;&#125; 时间O（n），空间O（n），虽然如此但效率反而比双指针要差，这主要是它的这些方法。 解法四：数组用Hash表能存，那用数组也应该是可以的，一样的key位索引值判断是不是1。同一个字母就是同一个地方对应值就加一。统计完之后遍历字符串按字符串的顺序去数组查率先等于1的就返回 12345678910111213public int firstUniqChar(String s) &#123; int[] chars = new int[26]; char[] arr = s.toCharArray(); for (char c : arr) &#123; chars[c - &#x27;a&#x27;] += 1; &#125; for (int i = 0; i &lt; arr.length; ++i) &#123; if (chars[arr[i] - &#x27;a&#x27;] == 1) &#123; return i; &#125; &#125; return -1;&#125; 和解法二同样的一个思路选取数组这种数据结构，效率就直接上去了。 解法五：细节优化上述数组解法在效率上仍然是有可优化点，因为我们去比较两个容器的时候谁短我们就遍历谁。更何况这里只需要拿值到另一个容器参考只需要一次遍历，那我们更应该遍历短的。那么当字符串长度小于26和上面一样遍历字符串到数组去记录，最后再遍历数组看结果，如果字符串长于26那么我们就遍历a-z这26个字母 12345678910int result = -1;for (char i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) &#123; int begin = s.indexOf(i); int end = s.lastIndexOf(i) // 在字符串中存在该字符并且唯一 if (begin != -1 &amp;&amp; begin == end &#123; // 不仅要唯一，且索引还要小。遍历完成拿到字符串最前的唯一 result = (result == -1 || result &gt; begin) ? begin : result; &#125;&#125; 那么在字符串长度很大的情况下也只需要完整遍历26次就能找到首个唯一，完整代码如下： 12345678910111213141516171819202122232425public int firstUniqChar(String s) &#123; // 字符串长度不超过26 if (s.length() &lt;= 26) &#123; int[] chars = new int[26]; char[] arr = s.toCharArray(); for (char c : arr) &#123; chars[c - &#x27;a&#x27;] += 1; &#125; for (int i = 0; i &lt; arr.length; ++i) &#123; if (chars[arr[i] - &#x27;a&#x27;] == 1) &#123; return i; &#125; &#125; &#125; //只遍历26个字母 int result = -1; for (char i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) &#123; int begin = s.indexOf(i); int end = s.lastIndexOf(i); if (begin != -1 &amp;&amp; begin == end) &#123; result = (result == -1 || result &gt; begin) ? begin : result; &#125; &#125; return result;&#125; 总结题目难度呢属于简单，双指针、hash表这样成对的解法就出来了，主要是通过此题去回顾一些注意点比如双循环的优化，循环中字符串的方法频繁的进出也是有一定的浪费，可以先拿数组出来操作会好一点。适合体会解题迭代的一个流程。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：7.整数反转","slug":"整数反转","date":"2020-11-30T05:47:29.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/11/30/整数反转/","link":"","permalink":"http://yournotes.cn/2020/11/30/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"整数反转题目地址：https://leetcode-cn.com/problems/reverse-integer/ 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。","text":"整数反转题目地址：https://leetcode-cn.com/problems/reverse-integer/ 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解法一：暴力解法主体 整数转字符串 字符串的反转 字符串转整数 边界 数值溢出边界：溢出返回0 细节 首位不为0 符号处理 123456789101112131415161718public int reverse(int x) &#123; //1.整数转字符串 String str = &quot;&quot; + x; char[] s = str.toCharArray(); //2.字符串的反转 int n = s.length; for(int i = 0; i &lt; n/2; i++)&#123; char temp = s[i]; s[i] = s[n-i-1]; s[n-i-1] = temp; &#125; //3.字符串转整数 //Integer result = Integer.valueOf(String.valueOf(array)); long value = Long.valueOf(String.valueOf(array)); boolean b = value &gt; Integer.MAX_VALUE || value &lt; Integer.MIN_VALUE; int result = b ? 0 : (int)value; return result;&#125; 在上述代码中已经完成主体代码以及反转后的数值越出边界的问题，首位不为零问题：Integer将整数字符串转整数时会自动去掉前面如果有高位的0。那么还剩下符号处理整数x如果是-123，反转字符串是”321-“肯定是不能的。要把负号拿出来之后的数字参与主体过程，最后再把结果加上负号。 1234//拿走符号signint sign = x &gt; 0 ? 1 : -1;//剩下绝对值x = x &lt; 0 ? x * -1 : x; 让处理之后的x参与主体代码，最后返回值加上符号 1return result * sign; 但上面拿绝对值的这个步骤是有问题的，因为最小值的绝对值是比最大值要大1的。当传入的int x &#x3D; Integer.MIN_VALUE时绝对值超过了int的范围。因此在符号拿取之前先进行判断，把极值（包括最大值）直接返回掉毕竟它们反转之后数字大小一定是溢出没必要经过主体三步之后在判断是否返回0。 1234567891011121314151617181920212223242526public int reverse(int x) &#123; //极值筛掉 if(x == Integer.MAX_VALUE || x == Integer.MIN_VALUE)&#123; return 0; &#125; //符号处理 int sign = x &gt; 0 ? 1 : -1; x = x &lt; 0 ? x * -1 : x; //1.整数转字符串 String str = &quot;&quot; + x; char[] s = str.toCharArray(); //2.字符串的反转 int n = s.length; for(int i = 0; i &lt; n/2; i++)&#123; char temp = s[i]; s[i] = s[n-i-1]; s[n-i-1] = temp; &#125; //3.字符串转整数 //Integer result = Integer.valueOf(String.valueOf(array)); long value = Long.valueOf(String.valueOf(s)); boolean b = value &gt; Integer.MAX_VALUE || value &lt; Integer.MIN_VALUE; int result = b ? 0 : (int)value; //加上符号 return result * sign;&#125; 时间复杂度O(n)，空间复杂度O(n) 解法二：数学思维既然是把一个整数变成另外一个整数面对这样的问题的完全可以找到数学的方式，在数组里我们使用索引指针取各个值，在数字里面我们就可以用除法和取模运算来获取各个值。上面我们数组或者字符串直接拼接各个字符。这里我们就累加拼接。效率提升一个次元。 123456789101112131415161718192021public int reverse(int x) &#123; //极值筛掉 if(x == Integer.MAX_VALUE || x == Integer.MIN_VALUE)&#123; return 0; &#125; int result = 0;//返回结果 int last = 0;//末位 while((last = x % 10) != x)&#123; result = result * 10 + last; x /= 10; &#125; //添加最后一位判断溢出 long value = result; value = value * 10 + last; if(value &gt; Integer.MAX_VALUE || value &lt; Integer.MIN_VALUE)&#123; return 0; &#125;else&#123; result = (int)value; &#125; return result;&#125; 时间复杂度O(n)，空间复杂度O(1) 总结总体上是两种思路但可以优化的点还有一些比如个位判断直接返回等等，这里主要体会的是关于数字处理的相关算法都是可以采用数学方式，它是远远比操作字符效率要高。第二就是关于实现主体与细节、边界的一个划分，尽量降低耦合性。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之字符串：344.反转字符串","slug":"反转字符串","date":"2020-11-29T04:43:48.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/11/29/反转字符串/","link":"","permalink":"http://yournotes.cn/2020/11/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"反转字符串题目地址：https://leetcode-cn.com/problems/reverse-string/ 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。","text":"反转字符串题目地址：https://leetcode-cn.com/problems/reverse-string/ 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2： 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 双指针 12345678public void reverseString(char[] s) &#123; int n = s.length; for(int i = 0; i &lt; n/2; i++)&#123; char temp = s[i]; s[i] = s[n-i-1]; s[n-i-1] = temp; &#125;&#125; 总结开篇一题也没太多可思考的，字符串也就是数组。遍历、逆序、交换、快慢指针等等。很显然倒过来逆序就完了，但题目要求不创建额外空间，也就剩首尾交换。总体来说这一类的题在数组内部进行变换就是交换值，只是看一次涉及多少个位置（指针）的变化。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之数组：48.旋转图像","slug":"旋转图像","date":"2020-11-25T12:11:11.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/11/25/旋转图像/","link":"","permalink":"http://yournotes.cn/2020/11/25/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"旋转图像题目地址：https://leetcode-cn.com/problems/rotate-image/ 给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。","text":"旋转图像题目地址：https://leetcode-cn.com/problems/rotate-image/ 给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 四指针这一题与前面写到的旋转数组一题相似，之前是一维的，现在相当于是二维版。同样是两种思路一种是直接设置值到最终的地方，被覆盖的值先用备份变量拿出来再往它的目的地去设。第二种就是反转的思路。 旋转上图过程 12345678910111213(1) backup = m[0][1]m[0][1] = m[0][0](2)temp = backupbackup = m[1][1]m[1][1] = temp(3)temp = backupbackup = m[1][0]m[1][0] = temp(4)m[0][0] = backup 由于是2×2所以一次旋转设值完事，如果是3×3 和之前那一题还是有点差别，这边设置值的传递固定是四个完成一组，然后需要判断一圈有多少组 1231×1 0组2×2 1组3×3 2组 四次设置值是一个单元操作，之后指针变动第一个指针是水平向右移动，第二个指针是垂直向下其他依次，直到头length-1。那么外循环条件是有几圈２×２，３×３都只有一圈，４×４与５×５是两圈。也就是length&#x2F;2圈，内循环为每圈要移动多少组数字它取决于终点索引，并且每往内一圈length都会少２两边都会靠近1格。 外圈（第一圈）起点matrix[0][0] 终点matrix[0][2] 有三组 内圈（第二圈）起点matrix[1][1] 终点matrix[1][1] 只有一组 也就是当外循环完毕内循环的起点是和外循环相同，也就是j &#x3D; i然后j在往后递增直到终点，终点会往内圈慢慢递减 我们这里只看首指针的变化，其他一样推总结在代码里 第一圈从[0][0]---&gt;[0][4] 5组 第二圈从[1][1]---&gt;[1][3] 3组 第三圈就[2][2] 1组 123456789101112131415161718192021public void rotate(int[][] matrix) &#123; int n = matrix.length; int s = n; for (int i = 0; i &lt; n/2; i++,s--) &#123; for (int j = i; j &lt; s-1; j++) &#123; int backup = matrix[j][n-i-1]; matrix[j][n-i-1] = matrix[i][j]; int temp = matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1] = backup; backup = temp; temp = matrix[n-j-1][i]; matrix[n-j-1][i] = backup; backup = temp; matrix[i][j] = backup; &#125; &#125;&#125; 总体实现了这样一个主线，但就是我们去存将被覆盖的值其实不需要另外添加一个变量backup我们可以直接把它存在首指针的地方，那个地方到最后才被设值中途是啥都没有关系我们就暂时用它存（空间已经存在了不用白不用）。 123456789101112131415161718192021public void rotate(int[][] matrix) &#123; int n = matrix.length; int s = n; for (int i = 0; i &lt; n/2; i++,s--) &#123; for (int j = i; j &lt; s-1; j++) &#123; int temp = matrix[i][j] matrix[i][j] = matrix[j][n-i-1]; matrix[j][n-i-1] = temp; temp = matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1] = matrix[i][j]; matrix[i][j] = temp; temp = matrix[n-j-1][i]; matrix[n-j-1][i] = matrix[i][j]; matrix[i][j] = temp; &#125; &#125;&#125; 两次反转第二种方式就反转和旋转数组一题一样我们直接观察输入图与目标图通过怎样的变换可以得到 旋转90度的关系肯定是没有直接方式的，这里我们肯定是用到的设值。通过图形变换反转类似的方式就两数交换完成就可能进行几组反转比起上面直接的一步的到位的设值方式在单元操作上两数交换比起四数看起来简一点。但有进行多组遍历的可能。它是转90而不是180如果是180就上下反转然后左右反转。所以这里只能对角反转加左右反转先后无所谓 无论怎么转都可以实现总之是通过两个数的交换就很简单，然后要进行两次。下面代码按照第一条进行，第一个变换只需要遍历左上一半即可每个完成和下面的交换即可因此列的起点是递增的j &#x3D; i，第二个变换循环时列只需要左边一半就换行所以j &#x3D; length&#x2F;2 123456789101112131415161718public void rotate(int[][] matrix) &#123; int n = matrix.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int tmp = matrix[j][i]; matrix[j][i] = matrix[i][j]; matrix[i][j] = tmp; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n / 2; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[i][n - j - 1]; matrix[i][n - j - 1] = tmp; &#125; &#125;&#125; 总结总体来说都是一个原地算法，时间也都是Ｏ(n^2)，像这一题与之前一题都是属于数组内原地的变化位置即多值交换以及换成多组反转即两值交换的组合。主要也是体会在数组这样的数据结构当中我们可以有的算法思想：遍历、逆序、原地交换、快慢指针。万变不离其中，那么从更新《LeetCode日常》系列开始到这篇为止LeetCode初级算法合集中的数组篇章完结即将开启下一篇章字符串相关算法","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之数组：36.有效数独","slug":"有效数独","date":"2020-11-21T09:07:42.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/11/21/有效数独/","link":"","permalink":"http://yournotes.cn/2020/11/21/%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/","excerpt":"有效数独题目地址：https://leetcode-cn.com/problems/valid-sudoku/ 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。","text":"有效数独题目地址：https://leetcode-cn.com/problems/valid-sudoku/ 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 示例1: 输入:[ [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出: true 示例2： 输入:[ [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出: false 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9×9 形式的。 暴力最直观的也就是按照题目流程的暴力解法，需要去判断每行每列每块有没有重复，那就去拿到每行每列每块的二维数组。判断这三组二维数组中的每个一维数组是有否重复。这里举个类似的4×4的例子（图画的少一点） 比如： row：[[‘1’，’2’，’3’，’4’],[‘5’，’.’，’6’，’.’],[‘.’，’7’，’8’，’.’],[‘7’，’.’，’.’，’3’]] col：[[‘1’，’5’，’.’，’7’],[‘2’，’.’，’7’，’.’],[‘3’，’6’，’8’，’.’],[‘4’，’.’，’.’，’3’]] box：[[‘1’，’2’，’5’，’.’],[‘3’，’4’，’6’，’.’],[‘.’，’7’，’7’，’.’],[‘8’，’.’，’.’，’3’]] 解法一 123456789101112131415161718192021222324252627282930313233343536373839public boolean isValidSudoku(char[][] board) &#123; //传入的board相当于就是row所以只需要初始化两个数组 char[][] col = new char[9][9]; char[][] box = new char[9][9]; //1.拿到三个二维数组分别表示多行数组，多列数组以及多块数组 for(int i = 0; i &lt; 9; i++)&#123; for(int j = 0; j &lt; 9; j++)&#123; col[j][i] = board[i][j]; box[(i/3)*3 + j/3][(i%3)*3 + j%3] = board[i][j]; &#125; &#125; //2.遍历每个二维数组中的数组判断有无重复 for(int i = 0; i &lt; 9; i++)&#123; if(checkRepeat(board[i]))&#123; return false; &#125; if(checkRepeat(col[i]))&#123; return false; &#125; if(checkRepeat(box[i]))&#123; return false; &#125; &#125; return true;&#125;/**检测单数组是否重复*/public boolean checkRepeat(char[] arr)&#123; for(int i = 0; i &lt; 9; i++)&#123; for(int j = i+1; j &lt; 9; j++)&#123; if(arr[i] != &#x27;.&#x27; &amp;&amp; arr[j] != &#x27;.&#x27;) if(arr[i] == arr[j])&#123; return true; &#125; &#125; &#125; return false;&#125; 上面解法实际上存在一个问题就是我们存完二维数组之后，再使用遍历查重的方式对每个单数组进行查重。 12col[j][i] = board[i][j];box[(i/3)*3 + j/3][(i%3)*3 + j%3] = board[i][j]; 也就是说在存这两个二维数组时只有只有第一个中括号的索引是有用的标记着是哪一列或者哪一块，但它是在一列(块&#x2F;行)的哪个位置是无所谓的，因为最后单独用了单数组查重的方式(无论顺序怎么样只要是在一个容器，最后容器单独用方法判断是否有重)。在编码中第二个中括号写的索引只不过是保留了在面板上我们去数数的顺序，换成别的0-9不重复的也可以。 是否重复的关键也就是数值是否一样，是否是同一块(行&#x2F;列)这些相同也就是无效数独，和在具体行(列&#x2F;块)里面的哪个位置无关。也就可以这样写 解法二 123456789101112131415161718public boolean isValidSudoku(char[][] board) &#123; HashSet&lt;String&gt; set = new HashSet(); //遍历存值 for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char num = board[i][j]; if (num != &#x27;.&#x27;) &#123; int n = num - &#x27;0&#x27;; int box_index = (i / 3 ) * 3 + j / 3; String row = n + &quot;是第&quot;+i+&quot;行&quot;; String col = n + &quot;是第&quot;+j+&quot;列&quot;; String box = n + &quot;是第&quot;+box_index+&quot;块&quot;; if(!set.add(row) || !set.add(col) || !set.add(box)) return false; &#125; &#125; &#125; return true;&#125; 其实这才是最直接的方式，也是效率最低的。 Hash表根据上述情况第二层容器的索引没有意义，只用第一层容器的索引判断存到哪个第二层容器(块&#x2F;列&#x2F;行)最后对所有第二层容器查重所以才无关。那我这里我们可以用上第二层容器的索引或者key把它的索引变得有意义，也就是等同于值。这样值就与位置相关，再存时就可以判断重复与否。而不用先存完之后在单独遍历每个第二层容器。 解法三 1234567891011121314151617181920212223242526272829303132public boolean isValidSudoku(char[][] board) &#123; //初始化数组 HashMap&lt;Integer, Integer&gt; [] rows = new HashMap[9]; HashMap&lt;Integer, Integer&gt; [] columns = new HashMap[9]; HashMap&lt;Integer, Integer&gt; [] boxes = new HashMap[9]; //初始化hashmap for (int i = 0; i &lt; 9; i++) &#123; rows[i] = new HashMap&lt;Integer, Integer&gt;(); columns[i] = new HashMap&lt;Integer, Integer&gt;(); boxes[i] = new HashMap&lt;Integer, Integer&gt;(); &#125; //遍历存值 for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char num = board[i][j]; if (num != &#x27;.&#x27;) &#123; int n = (int)num; int box_index = (i / 3 ) * 3 + j / 3; //以数值为key存下 rows[i].put(n, rows[i].getOrDefault(n, 0) + 1); columns[j].put(n, columns[j].getOrDefault(n, 0) + 1); boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1); //判断当前（行、列、块）此值有木有重复 if (rows[i].get(n) &gt; 1 || columns[j].get(n) &gt; 1 || boxes[box_index].get(n) &gt; 1) return false; &#125; &#125; &#125; return true;&#125; 按照上述解法存值标记key，通过key来判断有没有存过。同样也可以用数组实现用索引标记值和用key标记值是一样的并且效率上也会更快。因存的数值就是1-9，那就把9存到第九个也就是索引8。这样存进一个容器同一个数字就一定在同一个地方，通过值可以找到索引，通过索引又可以找到目前存的值。那么和map用key是一样的。都是做到用数值标记位置，那么同一个值即同一个地方在这个地方判断是否有重、 解法四 12345678910111213141516171819202122232425public boolean isValidSudoku(char[][] board) &#123; //初始化数组 char[][] rows = new char[9][9]; char[][] columns = new char[9][9]; char[][] boxes = new char[9][9]; //遍历存值 for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char num = board[i][j]; if (num != &#x27;.&#x27;) &#123; int n = num - &#x27;0&#x27;; int box_index = (i / 3 ) * 3 + j / 3; //以数值为索引存下 if(rows[i][n - 1] == num) return false; if(columns[j][n - 1] == num) return false; if(boxes[box_index][n - 1] == num) return false; rows[i][n - 1] = num; columns[j][n - 1] = num; boxes[box_index][n - 1] = num; &#125; &#125; &#125; return true;&#125; 两种解法同一个思路只是选取的数据结构不同，同样是使用值来标记位置，通过值就能查找位置。因此如果有同样的值就在同一个位置可以去判断。map是以值为key来实现，数组在此情景下因为数独盘面是9×9，里面的数字只能是1到9，所以数字如果是1就存在0位，是4就存在索引3的位置。通过值减一固定存的位置。 但上面数组解法仍是存在疏漏浪费了空间，通过遍历的一个数我拿到这个数找对应位置的数值是否和这个数相等。仔细想一想后面这一部分就是废话，我都存同一个索引或者同一个key了就是值相同，何必还去取再比较。只有两种情况这个地方没有存过那就是那就是null和当前值不同，然后存过后再有一个往这个索引或者key存那就是重复了不用比。因为索引和key就是值。因此改成boolean，没存过都是false，存了就是true，再存同一个地方时发现是true就是这个值已经存过这次是重复的 解法五（解法四优化） 12345678910111213141516171819202122232425public boolean isValidSudoku(char[][] board) &#123; //初始化数组 boolean[][] rows = new boolean[9][9]; boolean[][] columns = new boolean[9][9]; boolean[][] boxes = new boolean[9][9]; //遍历存值 for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char num = board[i][j]; if (num != &#x27;.&#x27;) &#123; int n = num - &#x27;0&#x27;; int box_index = (i / 3 ) * 3 + j / 3; //以数值为索引取看是否设过值 if(rows[i][n - 1]) return false; if(columns[j][n - 1]) return false; if(boxes[box_index][n - 1]) return false; rows[i][n - 1] = true; columns[j][n - 1] = true; boxes[box_index][n - 1] = true; &#125; &#125; &#125; return true;&#125; 有了解法四之后实际上是更加可以进行优化的，因为结果标记只存在是与否两种状态，那我们何不用0&#x2F;1位。可以进一步减少空间那我们需要一个9位的数字用byte类型只有1字节8位少了，所以只能用尽量小的short类型2字节也就是16位我们只用低9位。 现在用9位的一个数字（忽略高位）代替之前的9个元素的数组，也就没有子数组了 先以一个4×4的面板数字1-4做例子 扫描到第一个元素1那么它首先是第0块，在第0块里存第0位（数值-1）。那么上一个解法是子数组把里面的第0个设为true。现在不是子数组而是一个4位数把个位设成1。如果数字是3也就是把第2位设为1（true） 1234567891011//把第0位设为1 0000+ 1------- 0001//把第二位设为1 0000+ 100------- 0100 以前是数组，存一个9就找在这个数组索引8存下true，现在就是将1左移位运算8然后相加，同样是将一个值的第8位改为1。当前存的值是否是重复以前是判断这个地方是否已经是true，现在与num进行与运算看是不是0，比如存一个4，要存在第三位 1234567891011//第三位没有值 001000101&amp; 1000 ---------- 000000000//第三位有值 001001000&amp; 1000---------- 000001000 解法六(解法五优化) 123456789101112131415161718192021222324public boolean isValidSudoku(char[][] board) &#123; //初始化数组 short[] rows = new short[9]; short[] columns = new short[9]; short[] boxes = new short[9]; //遍历存值 for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char num = board[i][j]; if (num != &#x27;.&#x27;) &#123; num =(char)(1 &lt;&lt; (num - &#x27;0&#x27;)); int box_index = (i / 3 ) * 3 + j / 3; if((rows[i] &amp; num) != 0) return false; if((columns[j] &amp; num) != 0) return false; if((boxes[box_index] &amp; num) != 0) return false; rows[i] += num; columns[j] += num; boxes[box_index] += num; &#125; &#125; &#125; return true;&#125; 总结前部分算法都是抛开标记暴力判断，整理完信息然后才判断有没有重复信息。再之后通过值做第二层容器的索引或者key，同一个值如果是同一列（块&#x2F;行）就会存到同一个地方进而利用了第二层容器索引后可以在存的过程就判断是否有重，在之后这同一种思路在数据结构上有慢慢更好的选择，最终达到一个最优解。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之数组：1.两数之和","slug":"两数之和","date":"2020-11-18T12:15:55.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/11/18/两数之和/","link":"","permalink":"http://yournotes.cn/2020/11/18/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"两数之和题目地址：https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个整数，并返回他们的数组下标。","text":"两数之和题目地址：https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 123输入：nums = [2, 7, 11, 15], target = 9输出：[0, 1]因为 nums[0] + nums[1] = 2 + 7 = 9 暴力枚举这里想必大家很快就能得到思路也就是双指针遍历所有两两相加判断是否与目标值相等 123456789101112public int[] twoSum(int[] nums, int target) &#123; int n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return new int[0];&#125; 哈希表但实际上按照上面我们去到数组当中找两个数相加为目标值的方式也就是在确定nums[i]的情况下与遍历找target - nums[i].既然是这样子那我们直接遍历一次记下所有的target-nums[i]再看数组当中存在taget-nums[i]不。若存在即返回下标为i与taget-nums[i]这个值的下标。那么我们就使用hash表去记录数组值为key下标为value 1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (hashtable.containsKey(target - nums[i])) &#123; return new int[]&#123;hashtable.get(target - nums[i]), i&#125;; &#125; hashtable.put(nums[i], i); &#125; return new int[0];&#125; 总结前者比起哈希表的解法未添加缓存信息因此需要花O(n^2)的时间复杂度来匹配,采用hash表记录增加了空间消耗时间复杂度O(n)因为配对的过程转为hash表查找。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"夏天的风","slug":"夏天的风","date":"2020-11-05T11:48:27.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/11/05/夏天的风/","link":"","permalink":"http://yournotes.cn/2020/11/05/%E5%A4%8F%E5%A4%A9%E7%9A%84%E9%A3%8E/","excerpt":"《夏天的风》谱子收藏、全文查看","text":"《夏天的风》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"彩虹","slug":"彩虹","date":"2020-11-05T11:36:07.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/11/05/彩虹/","link":"","permalink":"http://yournotes.cn/2020/11/05/%E5%BD%A9%E8%99%B9/","excerpt":"《彩虹》谱子收藏、全文查看","text":"《彩虹》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"我喜欢上你时的内心活动","slug":"我喜欢上你时的内心活动","date":"2020-10-15T13:34:58.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/10/15/我喜欢上你时的内心活动/","link":"","permalink":"http://yournotes.cn/2020/10/15/%E6%88%91%E5%96%9C%E6%AC%A2%E4%B8%8A%E4%BD%A0%E6%97%B6%E7%9A%84%E5%86%85%E5%BF%83%E6%B4%BB%E5%8A%A8/","excerpt":"《我喜欢上你时的内心活动》谱子收藏、全文查看","text":"《我喜欢上你时的内心活动》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"夜夜夜夜","slug":"夜夜夜夜","date":"2020-10-15T13:34:31.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/10/15/夜夜夜夜/","link":"","permalink":"http://yournotes.cn/2020/10/15/%E5%A4%9C%E5%A4%9C%E5%A4%9C%E5%A4%9C/","excerpt":"《夜夜夜夜》谱子收藏、全文查看","text":"《夜夜夜夜》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"LeetCode初级算法之数组：283.移动零","slug":"移动零","date":"2020-09-24T13:03:00.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/09/24/移动零/","link":"","permalink":"http://yournotes.cn/2020/09/24/%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"移动零题目地址：https://leetcode-cn.com/problems/move-zeroes/ 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。","text":"移动零题目地址：https://leetcode-cn.com/problems/move-zeroes/ 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 题目信息输入：数组 输出：数组（将原数组的0都移动到后面） 额外：空间O(1)，时间尽量减少 思考对于这样一道题一开始看到要原地修改首先就想到了双指针遍历一次把不是零的往前设置。后面的再全部设置0，这样得到的算法也是满足空间复杂度O(1)，时间复杂度O(n). 12345678910111213public void moveZeroes(int[] nums) &#123; int j = 0; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i] != 0)&#123; nums[j]=nums[i]; j++; &#125; &#125; while(j&lt;nums.length)&#123; nums[j] = 0; j++; &#125;&#125; 两次循环执行时间0ms，这样就已经算是完美解决了。但确实还可以只花一次循环就能解决，我们在遍历过程当中是保证其他顺序不变然后零到后面。上面的想法不就是扫描非0然后扫描一个就往前面设置然后指针移动一。那么同样我们去确定零的位置然后交换始终保证数字在最左零的左边即可 12345678910111213public void moveZeroes(int[] nums) &#123; //两个指针i和j int j = 0; for(int i=0;i&lt;nums.length;i++) &#123; //当前元素!=0，就把其交换到左边，等于0的交换到右边 if(nums[i]!=0) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j++] = tmp; &#125; &#125;&#125; 总结总体来讲两种方式都是空间复杂度为O（1）的原地算法，时间复杂度也都为O（n）后者略优一点","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"面试五","slug":"莱博科技","date":"2020-09-23T06:03:55.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2020/09/23/莱博科技/","link":"","permalink":"http://yournotes.cn/2020/09/23/%E8%8E%B1%E5%8D%9A%E7%A7%91%E6%8A%80/","excerpt":"","text":"面向对象怎么理解的？ 面向对象三大特性说一下？ 事物有哪些特性？ 抽象类是什么？接口是什么？区别是什么？ 对JVM了解多少？内存结构怎么划分的？ HashMap有了解不？四指针为什么解决了头插问题？ 说一下redis缓存穿透？布隆过滤器是怎么实现的？ 说一下Spring MVC的流程 说一下IOC、AOP 说一下Spring Boot","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yournotes.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"LeetCode初级算法之数组：66.加一","slug":"加一","date":"2020-09-20T06:10:03.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/09/20/加一/","link":"","permalink":"http://yournotes.cn/2020/09/20/%E5%8A%A0%E4%B8%80/","excerpt":"加一题目地址：https://leetcode-cn.com/problems/plus-one/ 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。","text":"加一题目地址：https://leetcode-cn.com/problems/plus-one/ 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 题目信息输入：整数数组（整体表示一个数字每一位就是0-9，个十百千…位） 输出：整数数组（给这个数字加一之后用数组表达对应数字） 思考一开始想到的就是模拟加法，在仔细读题目后又得到了另一种解决方式，就是还原成表达的数字加一之后再还原成数组。 12[1,2,3]1*100 + 2*10 + 3*1 = 123 12[4,3,2,1]4*1000 + 3*100 + 2*10 + 1*1 = 4321 123456789101112131415161718//方式一public int[] plusOne(int[] digits) &#123; int len = digits.length; Long num = 0; //循环累加转化数字 for(int i = 0; i &lt; len; i++)&#123; num += digits[len-i-1]*Math.pow(10,i); &#125; //完成加一步骤 num = num + 1; //将结果数字转为字符串设置到数组当中 String str = String.valueOf(num); int[] result = new int[str.length()]; for(int i = 0; i &lt; str.length(); i++)&#123; result[i] = str.charAt(i) - &#x27;0&#x27;; &#125; return result;&#125; 这个代码在LeetCode上是没办法提交通过的，因为LeetCode使用的示例数组化成数字超过了long的范围，可以换成更大的BigInteger但LeetCode不识别。 还有一种方式就是最开始想到的，就是模拟加法手动去设置值。加一考虑的点就是低位连续的9。直到不是9的位加1其他设0 1234567891011121314//方式二public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; //完成加一 digits[i]++; //与10取余有则结束，无则进位再次循环 digits[i] = digits[i] % 10; if (digits[i] != 0) return digits; &#125; //全进位则新建容量多一的数组，最高位设一 digits = new int[digits.length + 1]; digits[0] = 1; return digits;&#125; 总结总体来说是简单的两种思路，一是化成数字不用管怎么加再化回数组，二是模拟加法过程。后者要优一点","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之数组：350.两个数组的交集 II","slug":"两个数组的交集II","date":"2020-09-20T03:32:48.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/09/20/两个数组的交集II/","link":"","permalink":"http://yournotes.cn/2020/09/20/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/","excerpt":"两个数组的交集 II题目地址：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ 给定两个数组，编写一个函数来计算它们的交集。","text":"两个数组的交集 II题目地址：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 题目信息输入：两个整数数组 输出：交集数组 额外：不考虑顺序 思考就相当于是数学集合求交集，很容易想到的就是双指针扫描比较判断是否存入结果。对于这样的方式就选择先排序再比较。 12345678nums1 = [4,5,9], nums2 = [4,4,8,9,9]nums1[0] == nums2[0] true 存4 nums1[1] == nums2[1] false且&gt; nums1指针不变nums1[1] == nums2[2] false且&lt; nums2指针不变nums1[2] == nums2[2] false且&gt; nums1指针不变nums1[2] == nums2[3] true 存9 nums1已遍历完毕结束结果为[4,9] 123456789101112131415161718192021222324public int[] intersect(int[] nums1, int[] nums2) &#123; //排序 Arrays.sort(nums1); Arrays.sort(nums2); //两个指针 int i = 0; int j = 0; //结果数组及其存储下标 int[] result = new int[nums1.length]; int index = 0; while(i&lt;nums1.length &amp;&amp; j&lt;nums2.length)&#123; if(nums1[i] == nums2[j])&#123; result[index] = nums1[i]; i++; j++; index++; &#125;else if(nums1[i] &gt; nums2[j])&#123; j++; &#125;else&#123; i++; &#125; &#125; return Arrays.copyOfRange(result,0,index);&#125; 空间复杂度O(n)，时间复杂度O(nlogn+mlogm)。 和前面写过的几道题一样都是除了双指针扫描之外还可以使用hash表来解决并且时间复杂度要比扫描比较的方式优。这里找到相同的值同样用hash表记录然后另一个再到hash表里比对。这样时间复杂度为O(n+m) 1234567891011121314151617181920212223 public int[] intersect(int[] nums1, int[] nums2) &#123; int[] result = new int[nums1.length]; int index = 0; Map&lt;Integer,Integer&gt; map = new HashMap(); for(int num1 : nums1)&#123; int count = map.getOrDefault(num1,0)+1; map.put(num1,count); &#125; for(int num2 : nums2)&#123; int count = map.getOrDefault(num2, 0); if (count &gt; 0) &#123; result[index] = num2; index++; count--; if (count &gt; 0) &#123; map.put(num2, count); &#125; else &#123; map.remove(num2); &#125; &#125; &#125; return Arrays.copyOfRange(result,0,index);&#125; 总结两种方法一种两个数组排序使用双指针同步比较，第二种先将一个数组统计到hash表另一个再对照查找存不存在，对于进阶里面的三条第一条是已经排好序那么遍历直接比较即可时间复杂度O(n+m)，如果两数组长度差距大的话首先空间优化创建的result数组用小的那个容量创建其他就是对使用hash表的方式有影响用短的数组记录。最后一种nums2过大就是内存不过并不能直接全部排序比较，那就使用hash表的方式，hash表统计完nums1然后nums2只需要一个一个对照即可不需要全部纳入。","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"一万次悲伤","slug":"一万次悲伤","date":"2020-09-15T13:33:52.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/09/15/一万次悲伤/","link":"","permalink":"http://yournotes.cn/2020/09/15/%E4%B8%80%E4%B8%87%E6%AC%A1%E6%82%B2%E4%BC%A4/","excerpt":"《一万次悲伤》谱子收藏、全文查看","text":"《一万次悲伤》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"春风十里","slug":"春风十里","date":"2020-09-15T13:33:42.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/09/15/春风十里/","link":"","permalink":"http://yournotes.cn/2020/09/15/%E6%98%A5%E9%A3%8E%E5%8D%81%E9%87%8C/","excerpt":"《春风十里》谱子收藏、全文查看","text":"《春风十里》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"LeetCode初级算法之数组：136.只出现一次的元素","slug":"只出现一次的元素","date":"2020-09-14T09:56:47.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/09/14/只出现一次的元素/","link":"","permalink":"http://yournotes.cn/2020/09/14/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"只出现一次的元素题目地址：https://leetcode-cn.com/problems/single-number/ 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。","text":"只出现一次的元素题目地址：https://leetcode-cn.com/problems/single-number/ 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 题目信息输入：整数数组（只有一个数单个，其他数全部是两次的数组） 输出：整数（那个单个的数） 额外：时间复杂度O(n)，空间复杂度O(1) 思考一开始看漏了信息以为只有数组里只有一个不重复其他都是重复不限次数，忽略了重复只有2次。所以想到的只有万能的map计数，无论是找出现次数最多的还是出现一次的啥都可以。但并不满足空间复杂度，为了满足空间复杂度不使用额外记录那就是暴力扫描n^2，说到扫描就还对应一个更优的方式就是排序后再扫描nlogn但这两种也都不满足线性的时间复杂度。（记得上一篇判断数组是否有重复也有这几种思路使用容器或者双指针扫描） 12345678910111213141516171819//方式一：Map计数public int singleNumber(int[] nums) &#123; //定义map存&lt;数字i,计数count&gt; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (Integer i : nums) &#123; //如果之前存在计数则加一否则计为第一个 Integer count = map.get(i); count = count == null ? 1 : ++count; map.put(i, count); &#125; //计数统计结束，遍历所有key找到对应计数是1的 for (Integer i : map.keySet()) &#123; Integer count = map.get(i); if (count == 1) &#123; return i; &#125; &#125; return -1;&#125; 1234567891011121314151617181920212223242526272829//方式二：扫描比较public int singleNumber(int[] nums) &#123; //排好序、定义两个指针 Arrays.sort(nums); int start = 0; int scan = 1; if(nums.length == 1)&#123; return nums[0]; &#125; /* 当start不等于scan时 scan停止移动 并且比较差距判断是否出现一次 或者scan停止的地方已经是最后一位 否则继续把start移动到新数字上 */ while(start &lt; nums.length)&#123; while(nums[start] == nums[scan])&#123; scan++; &#125; if(scan - start == 1)&#123; return nums[start]; &#125;else if(scan == nums.length -1)&#123; return nums[scan]; &#125; start = scan; &#125; return -1;&#125; 以上两种方法都没有考虑条件中重复数字只是出现两次（输入数组有且只有一个数字唯一其他都是两次），解决的是其他重复数字重复多少都可以，并找到唯一的那个数。目前来说确实在数组中找到唯一数是不可能达到既满足不使用额外空间又满足线性时间复杂度。因此一定是在给出其他重复数字都是两次这样的条件下才可以实现。在这样的条件下有一种方式比上面计数就要优一点点两次相消虽然会使用额外空间但空间与时间比起计数都优化了一点 12345678910//方式三public int singleNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet(); for (Integer i : nums) &#123; if(!set.add(i))&#123; set.remove(i); &#125; &#125; return set.iterator().next();&#125; 但最终是要求是时间O(n)，空间O(1)。那么只能是原地相消，扫描也不可能因为是时间O(nlogn)。只能遍历一遍并且记录到最后就只剩那一个，这个时候运算熟悉的就会想到使用异或，相同运算结果为0，累计消到最后就剩下单着的那一个 12345678//方式四public int singleNumber(int[] nums) &#123; int len = 0; for (int i : nums) &#123; len ^= i; &#125; return len;&#125; 总结这一道题很容易就能想到hash表或者扫描比较的解决方法，主要就是最后利用异或运算的方式实现原地相消和线性的时间复杂度","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"面试四","slug":"方正国际","date":"2020-09-14T04:51:05.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/09/14/方正国际/","link":"","permalink":"http://yournotes.cn/2020/09/14/%E6%96%B9%E6%AD%A3%E5%9B%BD%E9%99%85/","excerpt":"","text":"OSI参考模型 tcp&#x2F;ip模型 操作系统死锁","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yournotes.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"LeetCode初级算法之数组：217.存在重复元素","slug":"存在重复元素","date":"2020-09-13T02:47:55.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/09/13/存在重复元素/","link":"","permalink":"http://yournotes.cn/2020/09/13/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"存在重复元素题目地址：https://leetcode-cn.com/problems/contains-duplicate/ 给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false。","text":"存在重复元素题目地址：https://leetcode-cn.com/problems/contains-duplicate/ 给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false。 示例 1： 12输入: [1,2,3,1]输出: true 示例 2： 12输入: [1,2,3,4]输出: false 示例 3： 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 题目信息输入： 整数数组 输出： 布尔（数组是否有重复元素） 思考这一题比前几题都要简单，第一想法就用set存值会有成功与否判断来简单解决，不用工具类的话还有暴力比较那就是双指针比较采用嵌套循环，还有一种就是排好序再比较重复就是挨个了使用当前位置比较上一个只需要一次遍历。 代码总结12345678910//方法一public boolean containsDuplicate(int[] nums) &#123; Set set = new HashSet(); for(int i = 0; i &lt; nums.length; i++)&#123; if(!set.add(nums[i]))&#123; return true; &#125; &#125; return false;&#125; 空间复杂度：使用了set空间占用小于等于n，为O(n)时间复杂度：就一次遍历为n次，为O(n) 12345678//方法二public boolean containsDuplicate(int[] nums) &#123; Arrays.sort(nums); for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i - 1]) return true; &#125; return false;&#125; 空间复杂度：没用额外空间，为O(1)时间复杂度：有排序约nlogn次、有遍历为n次，为O(nlogn)。主要取决于排序的时间复杂度，平均最好的就是快排nlog2n 123456789//方法三public boolean containsDuplicate(int[] nums) &#123; for (int i = 0; i &lt; nums.length-1; i++) &#123; for (int j = i+1; j &lt; nums.length; j++) &#123; if (nums[j] == nums[i]) return true; &#125; &#125; return false;&#125; 空间复杂度：没用额外空间，为O(1)时间复杂度：双层遍历，外层遍历为n次，内层遍历次数逐步减少为小于n^2次，为O(n^2) 总结总体来说就是两种思路：一个利用set存值不容纳重复、一个就是扫描比较，在扫描比较中使用先排序的方式优一点点","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"Linux安装最新Mysql","slug":"Linux安装最新Mysql","date":"2020-09-12T06:55:39.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2020/09/12/Linux安装最新Mysql/","link":"","permalink":"http://yournotes.cn/2020/09/12/Linux%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0Mysql/","excerpt":"","text":"前言 之前自个需要在deepin下安装mysql，网上大家都是用软件源安装 sudo apt-get install -y mysql-server mysql-client 是安装的是mariaDB，关于MySQL与mariaDB，mariaDB是MySQL5.7源代码的一个分支，由于Oracle公司买下了Sun，在意识到Oracle可能会将MySQL闭源，于是先分离出了MySQL的衍生版MariaDB。虽然大部分兼容MySQL但是还是在我的项目出现问题，因此还是去装之前项目使用的MySQL8。 下载进入官网下载 点击跳转 这里我选择的通用包不同版本的都可以用下面方式安装，也可以对应自己linux系统进行选择。当然这里在deepin下安装也可以选择debian9的版本直接安装deb包 或者直接下debian的，如果是红帽系列就是rpm 下面只介绍使用通用压缩包的安装方式 安装mysql 解压并移动到&#x2F;usr&#x2F;local 1sudo tar -xvJf mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz -C /usr/local 创建软链接 12cd /usr/localsudo ln -s mysql-8.0.19-linux-glibc2.12-x86_64 mysql 添加mysql用户组和mysql用户 12sudo groupadd mysqlsudo useradd -r -g mysql -s /bin/false mysql 创建data文件夹存放数据库文件 12cd /usr/local/mysqlsudo mkdir /usr/local/mysql/data 修改当前目录拥有者为新建的mysql用户 1sudo chown -R mysql:mysql ./ 初始化安装 1sudo ./bin/mysqld --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --initialize 千万在这里记下初始化密码，8.2几版本没有查看初始密码的地方（虽然有配置可以越过密码） 开启服务 12cd /usr/local/mysql-8.0.19-linux-glibc2.12-x86_64/support-files sudo ./mysql.server start 使用初始密码已经可以登陆了 设置密码 1alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;; 总结总之呢就是下载解压安装设密码（中途有些权限还有软连接路径设定是必要的），对于deepin系统来说的话直接使用debian9的deb包进行安装即可更加简单","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"记录","slug":"日常/记录","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"LeetCode初级算法之数组：189.旋转数组","slug":"旋转数组","date":"2020-09-11T04:10:33.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/09/11/旋转数组/","link":"","permalink":"http://yournotes.cn/2020/09/11/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"旋转数组题目地址：https://leetcode-cn.com/problems/rotate-array/ 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。","text":"旋转数组题目地址：https://leetcode-cn.com/problems/rotate-array/ 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 题目信息输入：数组nums、整数k 输出：修改数组（nums向右移动k位） 额外条件：空间复杂度O(1) 思考首先想到的就是直接设置最终值，原地修改数据会丢失所以添加备份变量backup。备份值即原先值在移动时也需要与目的地数组值做交换则再需要一个中间值temp 以示例1数组演示 123456789101112131415[1,2,3,4,5,6,7] k=3//先原第1位移动三位到第4位[1,2,3,1,5,6,7] backup = 4//再移动原第4位值移动到第7位[1,2,3,1,5,6,4] backup = 7//再移动原第7位值移动到第3位[1,2,7,1,5,6,4] backup = 3//再移动原第3位值移动到第6位[1,2,7,1,5,3,4] backup = 6//再移动原第6位值移动到第2位[1,6,7,1,5,3,4] backup = 2//再移动原第2位值移动到第5位[1,6,7,1,2,3,4] backup = 5//再移动原第5位值移动到第1位[5,6,7,1,2,3,4] backup = 1 最后循环到设置第一位，结束所有值移动完毕。 但这样的过程其实有个问题，并不是所有的情况都能一次循环移动所有元素。举两个例子： 示例一的情况一次循环就移动的所有元素，但上面两个例子从第一位出发到最后设置第一位完成循环但并没有设置完所有元素。一个要用两次循环一个三次。这样去使用一个中间变量去循环设值需要多少个循环取决于数组长度与k的最大公约数。 这样思路大体形成，是一个双循环。那么找到双循环的出循环条件，小循环结束条件则是下一步要移动的元素索引就是环状替换的开始索引，条件比较即使用while循环。外层循环条件两种方式都可以解决一种就是得到length与k公约数，第二种使用count计数，由于最后是数组元素全部移动所以会移动length次，小循环里每完成一次设值count累加，小循环完后来到外层循环如果count小于length则还有下一组循环。全部完成最终count是一定等于length的，出循环结束。 12345678910111213//这里提供一个求最大公约数的辗转相除法int maxNumber(int m, int n) &#123; int temp; if (n &gt; m) &#123; temp = n; n = m; m = temp; &#125; if (m % n == 0) &#123; return n; &#125; return maxNumber(n, m % n);&#125; 123456789101112131415161718192021public void rotate(int[] nums, int k) &#123; int len = nums.length; for(int start = 0; start &lt; maxNumber(len,k); start++)&#123; /* 设置当前元素索引 将当前元素备份 */ int current = start; int backup = nums[current]; do&#123; //计数最终移动的索引 int next = (current + k) % len; //当前元素原来值backup与目的地元素交换 int temp = nums[next]; nums[next] = backup; backup = temp; //交换完毕更新当前索引 current = next; &#125;while(start != current); &#125;&#125; 上面外循环以公约数为条件即已知循环次数完成，下面使用count在小循环里计数在外循环判断完成 方式一12345678910111213141516public void rotate(int[] nums, int k) &#123; int count = 0; int len = nums.length; for(int start = 0; count &lt; len; start++)&#123; int current = start; int backup = nums[current]; do&#123; int next = (current + k) % len; int temp = nums[next]; nums[next] = backup; backup = temp; current = next; count++; &#125;while(start != current); &#125;&#125; 这样环状替换的解决方式是最先想到的，还有一种方式看题目示例就可以get到这个方向。也就是解决整体移动一次的逻辑，接下来就是循环就完了。整体移动一次时间复杂度就为n然后完成n次。比上面的算法就复杂度来看差一些。完成整体移动一次使用交换法即可（用备份值方式仅仅多了变量不会影响时间复杂度）。 123456//每次使用最后位与i位进行交换，i++[1,2,3,4,5] 1&lt;==&gt;5[5,2,3,4,1] 2&lt;==&gt;1[5,1,3,4,2] 3&lt;==&gt;2[5,1,2,4,3] 4&lt;==&gt;3[5,1,2,3,4] 12345for (int j = 0; j &lt; len; j++) &#123; temp = nums[j]; nums[j] = nums[len-1]; nums[len-1] = temp;&#125; 那么有了这样一个移动一次的代码，再结合K外层循环 方式二12345678910public void rotate(int[] nums, int k) &#123; int temp; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; temp = nums[j]; nums[j] = nums[nums.length-1]; nums[nums.length-1] = temp; &#125; &#125;&#125; 最后还有一个反转法，跳开设置值的思路，通过别的算法组合也能达到目标情况，在初高中数学当中也是常常有知道一个式子的值求一个很长的式子而不用把第一个式子解开而是将最终式子化成已知式子的组合最终简单求解。在这里也是一样一个反转算法这样的算法很简单 12345678while (i &lt; j) &#123; int temp = nums[i]; nums[1] = nums[j]; nums[j] = temp; i++; j--;&#125; 观察我们的要得到的一个结果 123//nums = [1 2 3 4 5 6], k=31 2 3 4 5 64 5 6 1 2 3 可以通过反转的组合实现 12341 2 3 4 5 66 5 4 3 2 1 全反转4 5 6 3 2 1 0到k-1反转4 5 6 1 2 3 k到len-1反转 这样就有新的方式解决，远远比直接带值要快（人脑层面），时间复杂度当然还是和方法一是相同的 方式三1234567891011121314151617public void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125;&#125;public void rotate(int[] nums, int k) &#123; k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之数组：122.买卖股票的最佳时机II","slug":"买卖股票的最佳时机II","date":"2020-09-10T04:32:43.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/09/10/买卖股票的最佳时机II/","link":"","permalink":"http://yournotes.cn/2020/09/10/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/","excerpt":"买卖股票的最佳时机 II题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。","text":"买卖股票的最佳时机 II题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234567输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 -1 + 5 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 -3 + 5 = 3 。 示例 2: 1234输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意：你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 问题信息输入：数组（表示几天的股价） 输出：整数（不同买进卖出的组合找到最大利润） 额外条件：买和卖可以多次但必须交替进行 思考 可多次买进卖出但必须交替保持一次交易，累计最大的场景实际就为波差之和。对于例1来说就是2-3天的差加上4-5天的差 示例 4: 123输入: [7,1,2,4,2,4,3]输出: 5解释：如下图2-4，5-6两段时间的价格差之和即位最高利润 那么也就是需要两个指针一个标记低位，一个往后扫描每次移动并与之前比较。当扫描指针当前比前一个要小则移动低位指针到当前扫描指针。 总结代码123456789101112131415int i = 0;//低位指针int nums = 0;//利润for(int j = 1; j &lt; prices.length; j++)&#123; /* 当出现下降则用前一个高峰减低位指针，再移动低位指针 但到数组结束有可能不出现低位一直增长就有else if */ if(prices[j]&lt;prices[j-1])&#123; nums += prices[j-1]-prices[i]; i = j; &#125;else if(j == prices.length)&#123; nums += prices[j]-prices[i]; &#125;&#125;return nums;","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"LeetCode初级算法之数组：26.删除排序数组中的重复项","slug":"删除排序数组中的重复项","date":"2020-09-09T10:24:47.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/09/09/删除排序数组中的重复项/","link":"","permalink":"http://yournotes.cn/2020/09/09/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"删除排序数组中的重复项题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。","text":"删除排序数组中的重复项题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 问题信息 输入：已排好序的数组 输出：去重后新数组的长度 额外条件：不创建额外空间直接修改原数组去重，不考虑新数组长度之后的元素 思考很显然需要遍历扫描重复项，在元素不同的时候设置值。那么需要两个指针，一个指针i的功能是设置值的位置下标当前位置设置值后加1，第二个指针j扫面全部判断是否重复若不重复则在i指针的地方存下每次加1。 1234567891011/*给定 nums = [0,0,1,1,1,2,2,3,3,4]，第一位是直接不变，从第二位才开始需要判断*/nums[1] == nums[0] 相等 nums[2] == nums[0] 不相等 存下第二位 num[1] = nums[2]nums[3] == nums[1] 相等nums[4] == nums[1] 相等nums[5] == nums[1] 不相等 存下第三位 nums[2] = nums[5]nums[6] == nums[2] 相等...... 代码12345678int i = 0；for(int j = 1; j &lt; nums.length; j++)&#123; if(nums[j] != nums[i])&#123; i++; nums[i] = nums[j]; &#125;&#125;return i+1 首先数组长度是固定的所以设置不重复的值后后面的值还是存在的，按照题意不去创建新数组只要得到新数组的大小即可，按照例子去重后原数组nums &#x3D; [0,1,2,3,4,2,2,3,3,4]。实际上就是得到遍历完之后坑位i就是新数组的最后一位它加一也就是新数组长度","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"}]},{"title":"github上传ssh-key后仍须输入密码的问题","slug":"github上传ssh-key后仍须输入密码的问题","date":"2020-09-06T05:54:35.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2020/09/06/github上传ssh-key后仍须输入密码的问题/","link":"","permalink":"http://yournotes.cn/2020/09/06/github%E4%B8%8A%E4%BC%A0ssh-key%E5%90%8E%E4%BB%8D%E9%A1%BB%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"github上传ssh-key后仍须输入密码的问题出现这种问题是本地clone的仓库使用的https的方式，这种方式连接服务就会使用用户名密码的方式。","text":"github上传ssh-key后仍须输入密码的问题出现这种问题是本地clone的仓库使用的https的方式，这种方式连接服务就会使用用户名密码的方式。 1git clone https://github.com/name/project.git 我们添加了ssh-key之后是希望使用ssh连接，所以要用下面的ssh的clone方式 1git clone git@github.com:name/project.git 但往往我们的仓库是已经以https的方式clone下来了，现在想用ssh连接。这里也是可以直接去改配置文件.&#x2F;git&#x2F;config当中改url这一项把https的链接改为ssh的 1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote &quot;origin&quot;] url = git@github.com:xxx/xxx fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;xxx&quot;] remote = origin merge = refs/heads/xxx","categories":[{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Spring bean的生命周期","slug":"Spring-bean的生命周期","date":"2020-08-29T08:08:13.000Z","updated":"2025-04-17T08:34:52.017Z","comments":true,"path":"2020/08/29/Spring-bean的生命周期/","link":"","permalink":"http://yournotes.cn/2020/08/29/Spring-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"概述Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。因此关于bean的生成过程生命周期是重要的知识点。也是在对Spring的认识的重要考察点。在传统的Java应用中，bean的生命周期很简单","text":"概述Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。因此关于bean的生成过程生命周期是重要的知识点。也是在对Spring的认识的重要考察点。在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化（实例化时可使用有参构造方法进行初始化，或者实例化后使用set方法进行初始化），然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强。因此在这里做一个梳理分析bean的生命周期。 bean怎么生成bean即是一个对象，那么我们怎么去生成一个对象呢。比如创建User类的对象那么首先是需要一个User class，然后直接去new最后再完成赋值初始化对象 1234567@Componentclass User&#123; @Autowired private Dog dog; private String beanName; ...&#125; 123User user = new User();user.setDog(new Dog());user.setBeanName(&quot;user&quot;); 那现在使用Spring这个bean是交由Spring去生成的，我们都是从Spring容器去拿到 1User user = context.getBean(&quot;user&quot;,User.class) 因此它已经生成好了我们才能拿到。那么它是怎么生成的呢，难道是在源码里去new User()么？那肯定不会这样去写它是通过反射去调用构造方法得到的，这个时候就是最初的对象userBean里面的属性还没赋值。所以之后还会进行依赖注入将创建好的对象里面的属性进行赋值也是通过反射的方式越过私有直接赋值。 123Field field = userBean.getClass().getDeclaredField(&quot;dog&quot;);field.setAccessible(true);field.set(userBean, dogBean); 到这里好像就完整的初始化好了需要的对象，但实际上是不够的，依赖注入并没有办法给上面User类的beanName赋值。它只能在池中找到类型一样的bean或者和属性名相同beanName的bean，拿这样的bean进赋值。但这里属性赋值的是当前bean的beanName而不是匹配其他bean。在这里可以通过依赖注入就初始化的属性它们的赋的值就是已经被Spring管理的bean。但有些属性它们是在Spring单例池找不到的，它们可能是某个特定的字符串，有可能是某些特殊的对象。 这个时候Spring也提供了方式去传入，依赖注入之后判断是否实现aware接口（BeanNameAware、BeanFactoryAware….）。如果有则调用接口对应的set方法并传入对应数据。因此当bean类当中有某些属性是非单例池中的无法通过依赖注入赋值，但这些值是Spring中具有的就可以通过Spring提供的一些aware接口的方式让spring自己去传入那些值然后我们在方法体中定义赋值。 12345678910111213141516@Componentclass User implements BeanNameAware&#123; @Autowired private Dog dog; private String beanName; /* 方法在依赖注入后会被执行 并且将当前beanName作为参数传入 方法体自定义（这里赋值给上面属性） */ @override public void setBeanName(String name)&#123; this.beanName = name; &#125; ...&#125; 除此之外还有既不是bean容器中的，也不是Spring含有的一些数据。那么就不能依赖注入，也没有aware传入。它需要你自己传入比如查询数据库赋值或者其他的自定义操作取值然后赋值。这就有第四个阶段初始化 1234567891011121314151617@Componentclass User implements InitializingBean&#123; @Autowired private Dog dog; private String userName; private int age; /* 方法在aware处理完后会被执行 方法体自定义（这里赋值给上面属性） */ @override public void afterPropertiesSet() throws Exception&#123; //this.userName = &quot;张三&quot;; //this.age = 18; &#125; ...&#125; 像上面两个属性username与age就是不能通过autowired或者awrare完成赋值的。spring提供InitializingBean初始化接口，当bean的生成从新建到依赖注入再到aware判断处理之后若有实现InitializingBean接口则去调用初始化方法afterPropertiesSet()在这里进行自定义的属性赋值，或者其他操作。 到此为止（class——新生对象——依赖注入——aware——初始化），bean从新建到最后属性都是完善的。但最终存在单例池中当中的对象可能是代理对象而不是原对象，否则做的那些切面都是无意义的。得到一个bean然后调用其方法，它可能是真正那个bean的代理对象其方法比原方法做了扩展。因此在初始化之后还会有一步就是aop判断是否要生成代理对象最终才得到的bean放入单例池 这里就出来了狭义的生命周期 广义的生命周期实际上上面的生命周期还是存在问题的，aop之后得到最终的bean它是直接返回还是存进单例池是取决于这个bean它的作用域scope 1&lt;bean id=&quot;user&quot; class=&quot;com.hao.User&quot; scope=&quot;prototype&quot;/&gt; 默认是单例但也有多例的存在像上面配置的，实际上在Spring当中是存在一个bean的包装类BeanDefinition。它当中的各个字段就包含着bean的各种信息比如bean实际的class类、创建的工厂、初始化方法、作用域、是否懒加载等等。 1234567BeanDefinition 1.scope 2.initMethod 3.byName byType 4.dependsOn 5.beanClass .... bean的创建初始化到最终根据这些信息来完成的，因此我们并不是直接通过class得到新生对象，而是先有BeanDefinition。根据BeanDefinition里的beanClass属性完成创建新生bean，而新建对象需要工厂所以有了该bean的BeanDefinition后再由BeanFactory完成创建bean对象 那么BeanDefinition的beanClass就是配置信息中的class，在生成新生对象之前如果去改变了BeanDefinition的beanClass属性那么之后新建对象就不是以前那个class的实例了。BeanFactory也是提供了后置处理器BeanFactoryPostProcessor就可以完成在对象创建前做一些操作。BeanFactory组建完毕里面有所有的BeanDefinition在通过这些BeanDefinition创建各个bean对象存在Spring容器中。在创建之前就会判断有没有后置处理器BeanFactoryPostProcessor。没有就直接创建对象，有则执行完后置处理器中的方法再创建 12345678910111213141516171819public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; /** * 主要是用来自定义修改持有的bean * @param beanFactory * @throws BeansException */ public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; String[] names = beanFactory.getBeanDefinitionNames(); // 获取了所有的bean名称列表 for(int i=0; i&lt;names.length; i++)&#123; String name = names[i]; BeanDefinition beanDefinition = beanFactory.getBeanDefinition(name); System.out.println(name + &quot; bean properties: &quot; + beanDefinition.getPropertyValues().toString()); &#125; &#125;&#125; 执行到后置处理器，beanFactory包含全部的BeanDefinition所以可以获取BeanDefinition做自定义修改，也可以往beanFactory当中注册bean（mybatis自动生成的mapper代理类就是这样进到了Spring容器）。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"},{"name":"Spring","slug":"JAVA/Spring","permalink":"http://yournotes.cn/categories/JAVA/Spring/"}],"tags":[{"name":"java框架","slug":"java框架","permalink":"http://yournotes.cn/tags/java%E6%A1%86%E6%9E%B6/"}]},{"title":"面试三","slug":"吉屋科技","date":"2020-08-28T10:31:18.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/08/28/吉屋科技/","link":"","permalink":"http://yournotes.cn/2020/08/28/%E5%90%89%E5%B1%8B%E7%A7%91%E6%8A%80/","excerpt":"","text":"Dubbox与Dubbo的区别 项目中遇到的问题 ActiveMQ的用途 Redis的用途 Solr的用途 事物的隔离级别有哪些 MySQL索引的数据结构 说一下Spring(主要模块与bean生命周期) 说一下HashMap","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yournotes.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试二","slug":"仁聚汇通","date":"2020-08-16T00:59:07.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/08/16/仁聚汇通/","link":"","permalink":"http://yournotes.cn/2020/08/16/%E4%BB%81%E8%81%9A%E6%B1%87%E9%80%9A/","excerpt":"","text":"说一下Synchronized以及锁升级的过程 缓存穿透是什么？怎么解决？两种解决方式的优缺点？布隆过滤器的底层数据结构知道吗？ 事物的隔离级别有哪些？ 说一下CG 手写一下你知道的单例模式 介绍一下项目，商城项目当中微信公众服务的支付是自己申请的吗？","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yournotes.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"曾经的你","slug":"曾经的你","date":"2020-08-15T13:33:02.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/08/15/曾经的你/","link":"","permalink":"http://yournotes.cn/2020/08/15/%E6%9B%BE%E7%BB%8F%E7%9A%84%E4%BD%A0/","excerpt":"《曾经的你》谱子收藏、全文查看","text":"《曾经的你》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"遇见","slug":"遇见","date":"2020-08-15T13:32:48.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2020/08/15/遇见/","link":"","permalink":"http://yournotes.cn/2020/08/15/%E9%81%87%E8%A7%81/","excerpt":"《遇见》谱子收藏、全文查看","text":"《遇见》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"HashMap","slug":"HashMap","date":"2020-08-12T00:22:39.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2020/08/12/HashMap/","link":"","permalink":"http://yournotes.cn/2020/08/12/HashMap/","excerpt":"HashMap概述 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，","text":"HashMap概述 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。——百度百科 HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型（键值对集合）。随着JDK版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。文章先基于1.7描述，最后再提1.8与之更改的地方。 123HashMap&lt;String,String&gt; hashMap = new HashMap();hashMap.put(&quot;张三&quot;,&quot;男&quot;);hashMap.get(&quot;张三&quot;); 那么它里面存的元素就key和value么？（它其实里面封装成一个entry可以看到除了key与value之外还有next属性，所以HaspMap里的元素不仅仅含有键值对还有指向下一节点的元素的信息） 123456static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key;//Key-value结构的key V value;//存储值 Entry&lt;K,V&gt; next;//指向下一个链表节点 final int hash;//哈希值&#125; HashMap的数据结构在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap底层就是一个数组结构，数组中的每一项又是一个链表。在1.8之后当链表长度大于等于8时转为红黑树（自平衡的二叉树这里不详细展开，以后有机会再讲）。 那么它是如何去存储？（每个元素存进来如何找到内置数组的位置） 1234hashMap.put(&quot;战三&quot;,&quot;work&quot;);hashMap.put(&quot;里的&quot;,&quot;energer&quot;);hashMap.put(&quot;约翰&quot;,&quot;cookie&quot;);.... 假如和ArrayList一样初始化一个index变量值为0作为下标，当arrayList.add(“a”)时将元素存在内置数组array[index]再index自增。即每次往后添加元素。至到数组满了再依次从第一个往后添加链。 在这种情况下我们去hashMap.get(“约翰”)，怎么去找到。很显然没办法定位。只能从数组第一位开始找比较entry的key值如不同再下一个比较直到找到相同的key。那么数量很多而且对应的entry位置比较偏后查找是及其费时的。虽然添加没毛病速度也快但查找是遍历比较所以是不合理的。 在HashMap当中实际上存储时它会去给key进行类似hash得到的hashCode与数组的容量取模的得到的就是数组的位置在这样的位置存下。 在使用key查找时也是对查找的key进行相同的hash直接定位到当初存的位置。这样的一个位置在数组是随机的，不同的code取模有可能会出现相同的位置即形成链表。然后在链表当中找到对应key的entry返回。下面伪代码描述了它的get方法的一个大概意思。直接找到数组所在的entry如果不是就是该entry的next。如果还不是就是next的next直到找到对应key的entry。 1234567get(key)&#123; int hashcode = key.hashCode(); int index = hashcode%table.length; Entry entry = table[index]; ... return entry;&#125; 那么在这里所谓的链表就是在逻辑上理解为它们在数组同一个位置，实际上就是先找到数组的这个位置得到了一个entry1然后这个entry1里的next属性引用的就是一个entry2，通过这个entry2的next就能找到entry3。这样的一个链表，基于找到第一个（数组中的entry）然后通过next字段一个一个的引用。下图与上图相对应 ![](https://gitee-blogimage.oss-cn-beijing.aliyuncs.com/blogImage/HashMap/HashMap3 .png) 上图数组存的entry3变量引用堆中的0x003的一个entry对象，这个对象里的next属性引用了地址0x004的entry对象。put时它是去怎样去插入的。当发生碰撞是找到这个链表的最下的entry把它的next&#x3D;null换成当前插入的entry地址，还是把当前插入的entry的next改为第一个就是数组中的table[index]。也就是头插还是尾插。 那么怎样去存下面使用伪代码说明大概流程（实际源码还有判断空判断key是否重复先忽略） 假设是尾插 123456789101112131415161718put(key,value)&#123; int code = key.hashCode(); int index = code%table.length; Entry e = table[index]; /* 1.数组当前位置空 table[index] = new Entry(key,value,null); 2.当前位置有entry就将它的next设为当前创建的entry table[index].next = new Entry(key,value,null); 3.当前有entry并且next也有 table[index].next.next = new Entry(key,value,null); 遍历链表找到最后一个entry也就是next为空的entry,将它的next设成当前创建的entry */ while(e!=null)&#123; e = e.next; &#125; e.next = new Entry(key,value,null);&#125; 假设是头插 12345678put(key,value)&#123; int code = key.hashCode(); int index = code%table.length; //1.new当前的entry,并将next设成现在第一个也就是数组上的table[index] //2.将当前的entry设成第一个就是放在数组上。 //它的next就是以前的第一个entry对象,现在把当前对象放数组 table[index] = new entry(key,value,table[index]);&#125; 两种方式首先头插法明显要快。直接插然后下移只要一句代码而尾插需要遍历。所以我们在jdk1.7当中是的确使用的头插法，但在1.8之后修改成尾插法下面会提。 容量问题123456789101112131415public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; // 初始默认容量 16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量值 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; ......&#125; 默认容量16，加载因子0.75。通过构造方法可以自己传入容量与加载因子。但值得一提的是容量一定是2的指数幂 12345678910/*** Inflates the table.*/private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY+1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity);&#125; 为什么它的容量一定要求为2的指数幂呢。桶数组用来去定位存储，hashCode与容量取模定位。确实不管是不是2的指数幂都能进行取模运算，因此这个要求大概是与效率有关。可以看到源码得index的方式 12345//并不是index = h % lengthindexFor(h,length)&#123; index = h &amp; (length - 1);&#125; 那么就可能是在容量位2的指数幂的情况下通过这样的运算就能代替取模运算，并且位运算与减运算效率高于除运算。下面可以试一下： 1234//假如入容量16，一个随机hashCodehashCode 1011 0010 0111length 0000 0000 1111index 0000 0000 0111 1234//假如入容量10，一个随机hashCodehashCode 1011 0010 0111length 0000 0000 1001index 0000 0000 0001 通过与运算结果肯定是小于的。所以结果不会越界，但如果容量不为2的指数幂有某些下标是永远取不到的，在例子二中比容量1001（10）小的是0-9也就是全部的下标。但111（7），101（5），11（3）永远取不到。所以只有满足2的指数幂减一与运算的结果才是具有全部下标的可能性和取模实际一样。扩容之后所有元素也要遍历重新定位这个时候也要进行大量的这个运算所以采用这个h&amp;(length-1)效率要更高。 加载因子第二就是加载因子为何是0.75，这个大家可能都知道等桶数组满了再扩容哈希碰撞一定挺多的很容易长链1.8会生成红黑树，但装到一半就扩容就空位太多很浪费空间，0.75也就是这样的一个折中的选择。总而言之就是这样规定。也是通过统计出来的比较好的结果。下面这段注释也说明了取0.75发生8次碰撞的概率已经是一亿分之六红黑树并不会那么容易生成那样就够了，其实关于为什么是0.75就把他当做一个折中的选择。这里包括下面注释内容其实上并没有说明，这个东西泊松分布和红黑树为什么在设定在链表到8的时候生成有关系下面会讲 1234567891011121314151617181920212223* Because TreeNodes are about twice the size of regular nodes, we* use them only when bins contain enough nodes to warrant use* (see TREEIFY_THRESHOLD). And when they become too small (due to* removal or resizing) they are converted back to plain bins. In* usages with well-distributed user hashCodes, tree bins are* rarely used. Ideally, under random hashCodes, the frequency of* nodes in bins follows a Poisson distribution* (http://en.wikipedia.org/wiki/Poisson_distribution) with a* parameter of about 0.5 on average for the default resizing* threshold of 0.75, although with a large variance because of* resizing granularity. Ignoring variance, the expected* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /* factorial(k)). The first values are:** 0: 0.60653066* 1: 0.30326533* 2: 0.07581633* 3: 0.01263606* 4: 0.00157952* 5: 0.00015795* 6: 0.00001316* 7: 0.00000094* 8: 0.00000006 扩容问题扩容源码(1.7) 123456789101112void resize(int newCapacity)&#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; ...... //创建一个新的Hash Table Entry[] newTable = new Entry[newCapacity]; //将Old Hash Table上的数据迁移到New Hash Table上 transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor);&#125; 1234567891011121314151617//put时当达到容量的0.75，进行扩容resize方法创建新数组后就是调用transfervoid transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length;//新数组的长度 for (Entry&lt;K,V&gt; e : table) &#123;//遍历旧数组 while(null != e) &#123;//遍历旧数组中的每个链表结点 Entry&lt;K,V&gt; next = e.next;//next指向当前遍历结点e的下一个结点 if (rehash) &#123;//再hash e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity);//重新计算当前元素在新数组中的位置 /*********关键的 3行代码（头插法移动元素）*********/ e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; put时当达到阈值后进行扩容也就是执行resize方法创建新数组，再执行transfer方法里面双循环遍历数组与链表，重新定位放入新桶数组，在1.7的扩容会有死环问题，这里先根据源码的扩容步骤作出了如下的扩容步骤图 扩容流程 假设上图数组正在扩容，首先循环到null !&#x3D; e的时候才能执行while的内容，e是遍历table数组的元素所以e &#x3D; first，next &#x3D; e.next这时代码中的next &#x3D; sec。 然后求e.hash重新计算使用indexFor得到新数组的下标i（假设为3，第4个位置），让e.next改为newTable[i]的引用，再将newTable[i]改为当前e也就是fist，也就是头插法 代码第三步e &#x3D; next 将变量e的引用原先是fist改为next的引用也就是e &#x3D; sec。因此while里面就是遍历链表的元素赋值给e，在判断e是否为空当前e是sec，再进行同样的操作（定位，头插，移位） 现在新数组就变成图中右下的样子了，可以看到就是sec的next变成first，first的next为空比起原先数组的关系就是反过来的。因为头插嘛第一个先插过去后面的插过去就更靠前第一个就是最下面。接下来e就是sec的next也就是遍历到第三个了然后没有下一个while结束，for循环下一个数组元素。就这样循环往复遍历所有的元素转移到新数组。 死环问题就是在并发的情况下做这些扩容步骤出现的问题，通过上述演示单线程的一个扩容流程。假设现在两个线程同时对一个hashmap扩容。那么同时访问resize方法两个线程里面都创建了一个自己线程里的新数组，然后再执行transfer方法共同执行到while里的第一句next &#x3D; e.next时的情况如下图。两个线程里都有自己的e与next还有新数组。 这时线程1停在这里。线程2继续全部执行完（while循环两次直到e为空），这时线程2的新数组已经移完原来的两个元素 第一次循环 第二次循环 这时候线程1又往后开始执行了。其实问题就在于此时堆中的fisrt对象和sec已经被改了。first对象里的next属性现在其实是空，然后sec里的next值为first。按照步骤 第一步完成后e（first）到新数组，之后e改为next（sec）。 到这一步问题就来了，处理完first之后现在e引用sec，再次while循环 得next &#x3D; e.next。现在e.next &#x3D; first而不是null，就出现循环了。处理完sec到时候e再引用first再循环一遍之后e才为空 将sec移过去然后next为first（其实它的next本来就是first了因为开始那个线程已经改了因此前面next就不等于null，而是first）。导致接下来e 不是null，是first。然后再进while循环e &#x3D;first，next&#x3D;null。这时first就要插在sec上就是first的next改为sec。就形成了死循环 总结这个问题产生就是因为头插法导致从旧数组到新数组的时候链表方向会反过来，再因为并发的问题开始读取的是first并且next是sec。但中途却被别的线程改了因为扩容next反过来。它还拿着之前的循环一次再取就是有问题了本来应该链表结束了为0，结果可以连到fisrt。 JDK8的优化 resize 扩容优化 解决了resize时多线程死循环问题 引入了红黑树，目的是避免单条链表过长而影响查询效率 关于resize优化，在1.7上面扩容源码里拿到元素重新类似取模运算h &amp; (length-1)得到位置，实际上在扩容是原来的两倍，这个时候取模结果就是原来的位置或原来的位置加原数组长度就这两种情况。 1234//扩容前长度16length-1 0000 0000 1111hashCode1 1011 0010 0111 （111）3hashCode2 0001 0101 0111 （111）3 1234//扩容后长度32length-1 0000 0001 1111hashCode1 1011 0010 0111 （111）3hashCode2 1101 0101 0111 （10111）19 所以hashcode之前没用到的高一位要么是0要么是1。新数组容量是以前两倍高位多了个1，hashcode如果高一位是0和以前就没有区别，如果是1就多了1 一个原数组大小。从以前的111要么没有要么还是111要么是10111就是看那个高位所以我们只需要判断h &amp; length的结果。就看那一个位就可以判断它的新下标是不变还是加上老数组容量 1234//扩容前长度16length 0000 0001 0000hashCode1 1011 0010 0111 （0000 0000）0hashCode2 0001 0101 0111 （0001 0000）16 123456//这段代码放在遍历原数组里面if((h&amp;length)=0)&#123; 当前遍历的下标i就是新数组下标&#125;else&#123; 当前遍历的i+oldTable.length就是新下标&#125; 1.8源码当中也就是这样去确定新的下标位置 1234567891011121314151617181920212223242526272829Node&lt;K,V&gt; loHead = null, loTail = null;Node&lt;K,V&gt; hiHead = null, hiTail = null;Node&lt;K,V&gt; next;do &#123; next = e.next; //判断是低指针还是高指针 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125;&#125; while ((e = next) != null);if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead;&#125;if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead;&#125; 在上述源码中，除了新坐标的计算外。内部定义的两组共四个指针（低头、低尾、高头、高尾）低高区分新下标是保持原样的还是增加的和上面提的一样不需要rehash，无论是低指针还是高指针都有两个头尾指针head、tail，标记头尾也是解决1.7当中由于体位倒置会出现的死循环问题","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yournotes.cn/tags/Java/"}]},{"title":"Volatile简述","slug":"Volatile简述","date":"2020-08-10T03:22:01.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2020/08/10/Volatile简述/","link":"","permalink":"http://yournotes.cn/2020/08/10/Volatile%E7%AE%80%E8%BF%B0/","excerpt":"Volatile概念 volatile是一个特征修饰符（type specifier）。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile的变量是说这变量可能会被意想不到地改","text":"Volatile概念 volatile是一个特征修饰符（type specifier）。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile的变量是说这变量可能会被意想不到地改变，这样编译器就不会去假设这个变量的值了。——百度百科 所以呢它主要是两个作用：一个是线程可见（保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。），一个是防止指令重排序。要理解这些首先呢需要了解我们java的一个内存模型（Java Memory Model，JMM） Java Memory Model我们知道在java中，实例域、静态域和数组元素都存储在堆内存中，堆内存是线程共享，而其他的一些虚拟机栈等它们的的一些内容是线程独占不会有内存可见的问题也不受内存模型影响。Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。Java内存模型的抽象示意图如下： 线程从主内存拿取到某以变量到自己本地内存进行操作，完毕之后再将新的值覆盖到主内存。之后再有其他线程拿到此变量得到一个新的值。通过这样的方式达到了一个不同线程之间的通讯，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。 线程可见当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，这样的方式来保证单次读写操作的同步性。 **例子1：**j的值会是多少呢？ 12345// 线程A执行的代码k = 5;//线程B执行的代码int j = k; 答案是无法确定。因为即使线程A已经把k的值更新为5，但是这个操作是在线程A的本地内存中完成的，本地内存所更新的变量并不会立即同步回主内存，因此线程B从主内存中得到的变量k的值是不确定的。这就是可见性问题，线程A对变量k修改了之后，线程B没有立即看到线程A修改的值。 例子2： 新线程会打印出end么？ 1234567891011121314public class Test &#123; private static /*volatile*/ boolean flag = true public static void main (String[] args) throws I interrupted Exception &#123; new Thread(()-&gt; &#123; while (flag) &#123; //do sth &#125; System•out•println(&quot;end&quot;); &#125;,name: &quot;server&quot;) .start(); Thread.sleep( millis: 1GGG); flag = false &#125;&#125; 答案是不会，新线程的本地内存拿到的flag是true，它一直使用的就是true。即使主线程已经将flag更改并同步到了主内存。新线程的本地空间已经有了flag也不会再去主内存取了。这时使用volatitle关键字修饰该变量就可以保证变量更改进行立刻同步，并且其他地方使用该变量每次都要重新从主内存拿取。 通过两个例子大概可以知道的是volatile修饰的变量，变动会及时更新并且线程都会去主内存取而不是到本地 指令重排序实际上就是在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 这里先用一个列子说明重排序的存在，看下面伪代码： 1a=0,b=0,x=0,y=0 123//线程一a=1;x=b; 123//线程二b=1;y=a; 假如不会发生重排序。那么执行过程中两个线程四条指令至少a&#x3D;1一定在x&#x3D;b之前，b&#x3D;1一定在y&#x3D;a之前。执行顺序可能出现六种情况 12345678910111213//情况一：(串)线程一执行完后线程二才开始a=1;x=b;b=1;y=a;//结果x=0,y=1//情况二：(串)线程一开始时线程二已执行完b=1;y=a;a=1;x=b;//结果x=1,y=0 123456789101112131415161718192021222324252627//情况三：(并)两线程交叉执行a=1;b=1;x=b;y=a;//结果x=1,y=1//情况四：(并)两线程交叉执行b=1;a=1;y=a;x=b;//结果x=1,y=1//情况五：(并)线程一执行中途线程二开始并执行完a=1;b=1;y=a;x=b;//结果x=1,y=1//情况五：(并)线程二执行中途线程一开始并执行完b=1;a=1;x=b;y=a;//结果x=1,y=1 在不会被调整顺序的情况中结果无非三种（1,0）、（0,1）、（1,1）但实际结果会出现x&#x3D;0,y&#x3D;0。也就是说线程的指令是乱序的会进行调整。对于单线程来说调整是不会影响结果的只是提升了效率比如省略一加一减相互抵消的指令或者调整顺序，最后结果不影响。 123456789101112/*下面这三组就不会发生指令重排因为改了顺序就会影响结果*/a=1;b=a;a=1;a=2;a=b;b=1; 在上面双线程的例子中无论是线程一的a&#x3D;1,x&#x3D;b还是线程二的b&#x3D;1,y&#x3D;a。在它们本线程中两条语句并不是依赖的，所以调换不影响结果所以会出现调换。但两个线程放一起变量是依赖的，最后因为重排导致结果不一致。所以在多线程中往往会出现问题所以需要禁止重排，使用volatile那么指令之间加入内存屏障指令就可以禁止重排。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yournotes.cn/tags/Java/"}]},{"title":"Synchronized简述","slug":"Synchronized关键字","date":"2020-07-19T16:00:00.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2020/07/20/Synchronized关键字/","link":"","permalink":"http://yournotes.cn/2020/07/20/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"Synchronized概念 Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步","text":"Synchronized概念 Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。——百度百科 synchronized锁定的是一个对象而不是代码块相当于对门加锁，房间里面做什么自定义。但只有拿到这个锁定的对象才能进入房间才能做接下来自定义的操作。使用同一把锁也就是同一个对象，那么一个线程拿走了就可以进入执行，其他的线程就拿不到进不了房间，直到那个线程执行完毕释放对象，那么其他线程再去共同竞争那一个对象，这样来达到一个互斥的效果避免共享数据错误。在字节码层表现monitorenter加锁和monitorexit释放锁。 1234//源代码synchronized (this) &#123; int i = 1;&#125; 123456//反汇编3: monitorenter //加锁4: iconst_15: istore_16: aload_16: monitorexit //释放锁 对象的内存结构了解对象加锁原理那么首先需要了解在JVM（hotspot）当中一个对象的内存结构 1.对象头 对象头分为MarkWord与Class对象指针，其中MarkWord标识了对象运行时的各种属性与状态值。哈希码、GC分代 年状 态标志、线程持有的锁、偏向线程ID、偏向时间戳等。（哈希，GC信息，锁信息）Class对象指针：这段空间是用来保存自己的父类通过类加载器加载到内存后生成的类的Class对象的地址，这样就可以通过对象知道它是属于哪个类的。 2.实例数据 实例数据是保存对象真正有效的数据，也就是对象的各种字段信息，其中也包括从父类中继承的字段，都保存在这里，当然方法不在这里，在类中。而且它的内存具体分配结构是受jvm分配策略与字段在源码中的顺序来决定的，默认是相同宽度的字段分配在一起，在这个前提下父类字段在子类字段前面,而且子类中较窄的字段也可能被分配到父类中的间隙中。 3.对齐填充 因为hotspot虚拟机64位的内存管理系统要求内存的起始地址必须是8个字节的整数倍，所以这段填充就是为了保证地址是8个字节的整数倍。 markword在这里就是记录着各种信息64位的二进制串其中三位标记着锁信息 自旋锁CASCAS：Compare and Swap，即比较再交换。 jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。 Synchronized锁升级 给对象加锁，实际上是改变的是对象的markword内容。通过标志位的一些记录来判断当前的锁信息，从下面例子打印结果可以看到锁标记位（第一个字节后三位）由001变为000，对象创建没有开启偏向锁进而加锁直接升级自旋锁。 123456Object o = new Object()；System.out.println(ClassLayout.parselnstonce(o).toPrintable())； synchronized (o) &#123; System.out.println(ClassLayout.porselnstonce(o).toPrintable())； &#125; 早期synchronized属于重量级锁申请和注销必须得向内核层申请。但有些需要同步的地方大多数情况下也确实只有一个线程访问。这样的情况下仍然去找操作系统申请锁资源浪费比例大。所以1.6之后对Synchronized进行了优化有偏移锁与自旋锁。 偏向锁：这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。也就是说:在此线程之后的执行过程中，如果再次进入或者退出同一段同步块代码，并不再需要去进行加锁或者解锁操作，而是会做以下的步骤： Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致。 如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码。 如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。 如果还未偏向，则利用CAS操作来竞争锁（保证原子操作），也即是第一次获取锁时的操作。 如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。 锁撤销 在一个安全点停止拥有锁的线程。 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。 唤醒当前线程，将当前锁升级成轻量级锁。 所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭。 轻量级锁 锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。下面先简单描述下锁撤销之后，升级为轻量级锁的过程： 线程在自己的栈桢中创建锁记录 LockRecord。 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。 将锁记录中的Owner指针指向锁对象。 将锁对象的对象头的MarkWord替换为指向锁记录的指针。 重量级锁 轻量级锁膨胀之后，就升级为重量级锁了（默认一个线程循环10次或者线程数量超过cpu一半的核数）。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁，加锁解锁向内核层申请相对麻烦但不占用cpu资源。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yournotes.cn/tags/Java/"}]},{"title":"故乡","slug":"故乡","date":"2020-07-15T13:32:34.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/07/15/故乡/","link":"","permalink":"http://yournotes.cn/2020/07/15/%E6%95%85%E4%B9%A1/","excerpt":"《故乡》谱子收藏、全文查看","text":"《故乡》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"后来","slug":"后来","date":"2020-07-15T13:32:15.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2020/07/15/后来/","link":"","permalink":"http://yournotes.cn/2020/07/15/%E5%90%8E%E6%9D%A5/","excerpt":"《后来》谱子收藏、全文查看","text":"《后来》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"隐形的翅膀","slug":"隐形的翅膀(吉他谱)","date":"2020-06-18T16:00:00.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2020/06/19/隐形的翅膀(吉他谱)/","link":"","permalink":"http://yournotes.cn/2020/06/19/%E9%9A%90%E5%BD%A2%E7%9A%84%E7%BF%85%E8%86%80(%E5%90%89%E4%BB%96%E8%B0%B1)/","excerpt":"《隐形的翅膀》谱子收藏、全文查看","text":"《隐形的翅膀》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"我真的受伤了","slug":"我真的受伤了","date":"2020-06-15T13:31:30.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/06/15/我真的受伤了/","link":"","permalink":"http://yournotes.cn/2020/06/15/%E6%88%91%E7%9C%9F%E7%9A%84%E5%8F%97%E4%BC%A4%E4%BA%86/","excerpt":"《我真的受伤了》谱子收藏、全文查看","text":"《我真的受伤了》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"面试一","slug":"小鹅通","date":"2020-05-19T16:00:00.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/05/20/小鹅通/","link":"","permalink":"http://yournotes.cn/2020/05/20/%E5%B0%8F%E9%B9%85%E9%80%9A/","excerpt":"","text":"事务的隔离级别有哪些？ 多表查询有哪些方式？区别是什么？ 介绍一下项目？你项目中下订单与支付之间的逻辑关系是什么？ 写项目过程中遇到过哪些的问题？怎么解决的？","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yournotes.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"童年","slug":"童年","date":"2020-05-15T13:14:47.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2020/05/15/童年/","link":"","permalink":"http://yournotes.cn/2020/05/15/%E7%AB%A5%E5%B9%B4/","excerpt":"《童年》谱子收藏、全文查看","text":"《童年》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"异乡人","slug":"异乡人(吉他谱)","date":"2020-05-14T16:00:00.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/05/15/异乡人(吉他谱)/","link":"","permalink":"http://yournotes.cn/2020/05/15/%E5%BC%82%E4%B9%A1%E4%BA%BA(%E5%90%89%E4%BB%96%E8%B0%B1)/","excerpt":"《异乡人》谱子收藏、全文查看","text":"《异乡人》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"乐谱","slug":"算法/乐谱","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"面试资料","slug":"java面试","date":"2020-04-19T16:00:00.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2020/04/20/java面试/","link":"","permalink":"http://yournotes.cn/2020/04/20/java%E9%9D%A2%E8%AF%95/","excerpt":"","text":"ZooKeeperCAP定理：一个分布式系统不可能同时满足以下三种,一致性（C:Consistency）,可用性（A:Available）,分区容错性（P:Partition Tolerance）.在此ZooKeeper保证的是CP，ZooKeeper不能保证每次服务请求的可用性，在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。另外在进行leader选举时集群都是不可用，所以说，ZooKeeper不能保证服务可用性。（Base理论CA强一致性和最终一致性） ZAB协议：ZAB协议包括两种基本的模式：崩溃恢复和消息广播。当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致少于过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。 选举算法和流程：LeaderElection(默认提供的选举算法)目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下： 服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。 服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。 服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为leader，服务器1,2成为follower。 服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为follower。 服务器5启动，后面的逻辑同服务器4成为follower。 Redis应用场景 缓存 共享Session 消息队列系统 分布式锁 单线程的Redis为什么快 纯内存操作 单线程操作，避免了频繁的上下文切换 合理高效的数据结构 采用了非阻塞I&#x2F;O多路复用机制 Redis 的数据结构及使用场景 String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等。 Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。 List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。 Redis 的数据过期策略Redis 中数据过期策略采用定期删除+惰性删除策略 定期删除策略：Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除。这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。 惰性删除策略：在获取 key 时，先判断 key 是否过期，如果过期则删除。这种方式存在一个缺点：如果这个 key 一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。 这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求。但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。淘汰策略分为： 当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略） 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用） 当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。 Redis的LRU具体实现：​ 传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行select *的时候大量非热点数据占领头部数据，所以需要改进。Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。 如何解决 Redis 缓存雪崩问题 使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉 缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效 限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务 如何解决 Redis 缓存穿透问题 在接口做校验 存null值（缓存击穿加锁） 布隆过滤器拦截： 将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在。 Redis的持久化机制 RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。 AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。 使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。 缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。 Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。 Redis和memcached的区别 存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。 数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。 用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value的大小：redis可以达到1GB，而memcache只有1MB。 Redis并发竞争key的解决方案 分布式锁+时间戳 利用消息队列 Redis与Mysql双写一致性方案先更新数据库，再删缓存。数据库的读操作的速度远快于写操作的，所以脏数据很难出现。可以对异步延时删除策略，保证读请求完成以后，再进行删除操作。 Redis的管道pipeline对于单线程阻塞式的Redis，Pipeline可以满足批量的操作，把多个命令连续的发送给Redis Server，然后一一解析响应结果。Pipelining可以提高批量处理性能，提升的原因主要是TCP连接中减少了“交互往返”的时间。pipeline 底层是通过把所有的操作封装成流，redis有定义自己的出入输出流。在 sync() 方法执行操作，每次请求放在队列里面，解析响应包。 Mysql事务的基本要素 原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。 隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 幻读：A事务读取了B事务已经提交的新增数据。注意和不可重复读的区别，这里是新增，不可重复读是更改（或删除）。select某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。 MySQL事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 不可重复读 否 是 是 可重复读 否 否 是 串行化 否 否 否 在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。 通过索引加锁，间隙锁，next key lock可以解决幻读的问题。 Mysql的逻辑结构 最上层的服务类似其他CS结构，比如连接处理，授权处理。 第二层是Mysql的服务层，包括SQL的解析分析优化，存储过程触发器视图等也在这一层实现。 最后一层是存储引擎的实现，类似于Java接口的实现，Mysql的执行器在执行SQL的时候只会关注API的调用，完全屏蔽了不同引擎实现间的差异。比如Select语句，先会判断当前用户是否拥有权限，其次到缓存（内存）查询是否有相应的结果集，如果没有再执行解析sql，优化生成执行计划，调用API执行。 SQL执行顺序SQL的执行顺序：from—where–group by—having—select—order by Mysql如何保证一致性和持久性MySQL为了保证ACID中的一致性和持久性，使用了WAL(Write-Ahead Logging,先写日志再写磁盘)。Redo log就是一种WAL的应用。当数据库忽然掉电，再重新启动时，MySQL可以通过Redo log还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新Redo log就足够了。 InnoDB的行锁模式 共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁。 为什么选择B+树作为索引结构 Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。 平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。 B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。 B+树的叶子节点都可以存哪些东西可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引 覆盖索引指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 查询在什么时候不走（预期中的）索引 模糊查询 %like 索引列参与计算,使用了函数 非最左前缀顺序 where对null判断 where不等于 or操作有至少一个字段没有索引 需要回表的查询结果集过大（超过配置的范围） 数据库优化指南 创建并使用正确的索引 只返回需要的字段 减少交互次数（批量提交） 设置合理的Fetch Size（数据每次返回给客户端的条数） JVM运行时数据区域 程序计数器：程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。是线程私有”的内存。 Java虚拟机栈：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧 ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 本地方法栈：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 Java堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 分代回收HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过**-XX:MaxTenuringThreshold**来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 常见的垃圾回收机制 引用计数法：引用计数法是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器,当有引用连接至对象时,引用计数加1。当引用离开作用域或被置为null时,引用计数减1。虽然管理引用计数的开销不大,但这项开销在整个程序生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上遍历,当发现某个对象引用计数为0时,就释放其占用的空间。 可达性分析算法：这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。 G1和CMS的比较 CMS收集器是获取最短回收停顿时间为目标的收集器，因为CMS工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的（只有初始标记和重新标记会STW）。但是CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。 CMS仅作用于老年代，是基于标记清除算法，所以清理的过程中会有大量的空间碎片。 CMS收集器无法处理浮动垃圾，由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。 G1是一款面向服务端应用的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短STW的停顿时间，它满足短时间停顿的同时达到一个高的吞吐量。 从JDK 9开始，G1成为默认的垃圾回收器。当应用有以下任何一种特性时非常适合用G1：Full GC持续时间太长或者太频繁；对象的创建速率和存活率变动很大；应用不希望停顿时间长(长于0.5s甚至1s)。 G1将空间划分成很多块（Region），然后他们各自进行回收。堆比较大的时候可以采用，采用复制算法，碎片化问题不严重。整体上看属于标记整理算法,局部(region之间)属于复制算法。 G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。所以 CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB。 哪些对象可以作为GC Roots 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。 GC中Stop the world（STW）在执行垃圾收集算法时，Java应用程序的其他所有除了垃圾收集收集器线程之外的线程都被挂起。此时，系统只能允许GC线程进行运行，其他线程则会全部暂停，等待GC线程执行完毕后才能再次运行。这些工作都是由虚拟机在后台自动发起和自动完成的，是在用户不可见的情况下把用户正常工作的线程全部停下来，这对于很多的应用程序，尤其是那些对于实时性要求很高的程序来说是难以接受的。 但不是说GC必须STW,你也可以选择降低运行速度但是可以并发执行的收集算法，这取决于你的业务。 垃圾回收算法 停止-复制：先暂停程序的运行,然后将所有存活的对象从当前堆复制到另一个堆,没有被复制的对象全部都是垃圾。当对象被复制到新堆时,它们是一个挨着一个的,所以新堆保持紧凑排列,然后就可以按前述方法简单,直接的分配了。缺点是一浪费空间,两个堆之间要来回倒腾,二是当程序进入稳定态时,可能只会产生极少的垃圾,甚至不产生垃圾,尽管如此,复制式回收器仍会将所有内存自一处复制到另一处。 标记-清除：同样是从堆栈和静态存储区出发,遍历所有的引用,进而找出所有存活的对象。每当它找到一个存活的对象,就会给对象一个标记,这个过程中不会回收任何对象。只有全部标记工作完成的时候,清理动作才会开始。在清理过程中,没有标记的对象会被释放,不会发生任何复制动作。所以剩下的堆空间是不连续的,垃圾回收器如果要希望得到连续空间的话,就得重新整理剩下的对象。 标记-整理：它的第一个阶段与标记&#x2F;清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。 分代收集算法：把Java堆分为新生代和老年代，然后根据各个年代的特点采用最合适的收集算法。新生代中，对象的存活率比较低，所以选用复制算法，老年代中对象存活率高且没有额外空间对它进行分配担保，所以使用“标记-清除”或“标记-整理”算法进行回收。 Minor GC和Full GC触发条件 Minor GC触发条件：当Eden区满时，触发Minor GC。 Full GC触发条件： 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 JVM类加载过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。 加载：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在内存中生成一个代表这个类的Class对象，作为方法去这个类的各种数据的访问入口 验证：验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟自身的安全。 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法去中进行分配。这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 解析：解析阶段是虚拟机将常量池内的符号（Class文件内的符号）引用替换为直接引用（指针）的过程。 初始化：初始化阶段是类加载过程的最后一步，开始执行类中定义的Java程序代码（字节码）。 双亲委派模型双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。 JVM锁优化和膨胀过程 自旋锁：自旋锁其实就是在拿锁时发现已经有线程拿了锁，自己如果去拿会阻塞自己，这个时候会选择进行一次忙循环尝试。也就是不停循环看是否能等到上个线程自己释放锁。自适应自旋锁指的是例如第一次设置最多自旋10次，结果在自旋的过程中成功获得了锁，那么下一次就可以设置成最多自旋20次。 锁粗化：虚拟机通过适当扩大加锁的范围以避免频繁的拿锁释放锁的过程。 锁消除：通过逃逸分析发现其实根本就没有别的线程产生竞争的可能（别的线程没有临界量的引用），或者同步块内进行的是原子操作，而“自作多情”地给自己加上了锁。有可能虚拟机会直接去掉这个锁。 偏向锁：在大多数的情况下，锁不仅不存在多线程的竞争，而且总是由同一个线程获得。因此为了让线程获得锁的代价更低引入了偏向锁的概念。偏向锁的意思是如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作。 轻量级锁：当存在超过一个线程在竞争同一个同步代码块时，会发生偏向锁的撤销。当前线程会尝试使用CAS来获取锁，当自旋超过指定次数(可以自定义)时仍然无法获得锁，此时锁会膨胀升级为重量级锁。 重量级锁：重量级锁依赖对象内部的monitor锁来实现，而monitor又依赖操作系统的MutexLock（互斥锁）。当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现。 什么情况下需要开始类加载过程的第一个阶段加载 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。 i++操作的字节码指令 将int类型常量加载到操作数栈顶 将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中 将int类型变量从局部变量表的第1个Slot中取出，并放到操作数栈顶 将局部变量表的第1个Slot中的int类型变量加1 表示将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中，即i中 Java基础(重点)HashMap和ConcurrentHashMap由于HashMap是线程不同步的，虽然处理数据的效率高，但是在多线程的情况下存在着安全问题，因此设计了CurrentHashMap来解决多线程安全问题。 HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。 HashMap的环：若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next &#x3D; new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。 在JDK1.7版本中，ConcurrentHashMap维护了一个Segment数组，Segment这个类继承了重入锁ReentrantLock，并且该类里面维护了一个 HashEntry&lt;K,V&gt;[] table数组，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。在JDK1.8版本中，ConcurrentHashMap摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap。 HashMap如果我想要让自己的Object作为K应该怎么办 重写**hashCode()**是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞； 重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性； volatilevolatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。(共享内存，私有内存) Atomic类的CAS操作CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。如 Intel 处理器，比较并交换通过指令的 cmpxchg 系列实现。 CAS操作ABA问题：如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。 Synchronized和Lock的区别 首先synchronized是java内置关键字在jvm层面，Lock是个java类。 synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁，并且可以主动尝试去获取锁。 synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁。 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。 synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 AQS理论的数据结构AQS内部有3个对象，一个是state（用于计数器，类似gc的回收计数器），一个是线程标记（当前线程是谁加锁的），一个是阻塞队列。 如何指定多个线程的执行顺序 设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。 在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值，不是，则 wait，是则执行本线程。 为什么要使用线程池 减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下 核心线程池ThreadPoolExecutor内部参数 corePoolSize：指定了线程池中的线程数量 maximumPoolSize：指定了线程池中的最大线程数量 keepAliveTime：线程池维护线程所允许的空闲时间 unit: keepAliveTime 的单位。 workQueue：任务队列，被提交但尚未被执行的任务。 threadFactory：线程工厂，用于创建线程，一般用默认的即可。 handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。 线程池的拒绝策略 ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务 线程池的线程数量怎么确定 一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。 一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。 在IO优化中，线程等待时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 &#x3D; （（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目 ThreadLocal的原理和实现ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。 一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。而我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。 HashSet和HashMapHashSet的value存的是一个static finial PRESENT &#x3D; newObject()。而HashSet的remove是使用HashMap实现,则是map.remove而map的移除会返回value,如果底层value都是存null,显然将无法分辨是否移除成功。 Boolean占几个字节未精确定义字节。Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。 Spring什么是三级缓存 第一级缓存：单例缓存池singletonObjects。 第二级缓存：早期提前暴露的对象缓存earlySingletonObjects。（属性还没有值对象也没有被初始化） 第三级缓存：singletonFactories单例对象工厂缓存。 Spring如何解决循环依赖问题Spring使用了三级缓存解决了循环依赖的问题。在populateBean()给属性赋值阶段里面Spring会解析你的属性，并且赋值，当发现，A对象里面依赖了B，此时又会走getBean方法，但这个时候，你去缓存中是可以拿的到的。因为我们在对createBeanInstance对象创建完成以后已经放入了缓存当中，所以创建B的时候发现依赖A，直接就从缓存中去拿，此时B创建完，A也创建完，一共执行了4次。至此Bean的创建完成，最后将创建好的Bean放入单例缓存池中。 BeanFactory和ApplicationContext的区别 BeanFactory是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。 ApplicationContext应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能。如国际化，访问资源，载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，消息发送、响应机制，AOP等。 BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化。ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init&#x3D;true来让Bean延迟实例化 动态代理的实现方式，AOP的实现方式 JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。 CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。 Spring的的事务传播机制 required（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。 supports：支持使用当前事务，如果当前事务不存在，则不使用事务。 mandatory：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。 requires_new：创建一个新事务，如果当前事务存在，把当前事务挂起。 not_supported：无事务执行，如果当前事务存在，把当前事务挂起。 never：无事务执行，如果当前有事务则抛出Exception。 nested：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。 Spring的后置处理器 BeanPostProcessor：Bean的后置处理器，主要在bean初始化前后工作。 InstantiationAwareBeanPostProcessor：继承于BeanPostProcessor，主要在实例化bean前后工作； AOP创建代理对象就是通过该接口实现。 BeanFactoryPostProcessor：Bean工厂的后置处理器，在bean定义(bean definitions)加载完成后，bean尚未初始化前执行。 BeanDefinitionRegistryPostProcessor：继承于BeanFactoryPostProcessor。其自定义的方法postProcessBeanDefinitionRegistry会在bean定义(bean definitions)将要加载，bean尚未初始化前真执行，即在BeanFactoryPostProcessor的postProcessBeanFactory方法前被调用。 操作系统进程和线程 进程是操作系统资源分配的最小单位，线程是CPU任务调度的最小单位。一个进程可以包含多个线程，所以进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。 不同进程间数据很难共享，同一进程下不同线程间数据很易共享。 每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉。 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 进程的组成部分进程由进程控制块（PCB）、程序段、数据段三部分组成。 进程的通信方式 无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。 进程间五种通信方式的比较 管道：速度慢，容量有限，只有父子进程能通讯。 FIFO：任何进程间都能通讯，但速度慢。 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。 信号量：不能传递复杂消息，只能用来同步。 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。 死锁的4个必要条件 互斥条件：一个资源每次只能被一个线程使用； 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放； 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺； 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 如何避免（预防）死锁 破坏“请求和保持”条件：让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。还有一种方法是，要求进程在申请资源前，要释放自己拥有的资源。 破坏“不可抢占”条件：允许进程进行抢占，方法一：如果去抢资源，被拒绝，就释放自己的资源。方法二：操作系统允许抢，只要你优先级大，可以抢到。 破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出（指定获取锁的顺序，顺序加锁）。 计算机网路Get和Post区别 Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 Get执行效率却比Post方法好。Get是form提交的默认方法。 GET产生一个TCP数据包；POST产生两个TCP数据包。（非必然，客户端可灵活决定） Http请求的完全过程 浏览器根据域名解析IP地址（DNS）,并查DNS缓存 浏览器与WEB服务器建立一个TCP连接 浏览器给WEB服务器发送一个HTTP请求（GET&#x2F;POST）：一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。 服务端响应HTTP响应报文，报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。 浏览器解析渲染 tcp和udp区别 TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接。 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。 TCP首部开销20字节，UDP的首部开销小，只有8个字节。 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。 tcp和udp的优点 TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。 UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输。什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP。 三次握手 第一次握手：建立连接时，客户端发送syn包（syn&#x3D;x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（syn&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 为什么不能两次握手TCP是一个双向通信协议，通信双方都有能力发送信息，并接收响应。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认 四次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些 为什么连接的时候是三次握手，关闭的时候却是四次握手因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 数据结构与算法排序算法 冒泡排序 选择排序：选择排序与冒泡排序有点像，只不过选择排序每次都是在确定了最小数的下标之后再进行交换，大大减少了交换的次数 插入排序：将一个记录插入到已排序的有序表中，从而得到一个新的，记录数增1的有序表 快速排序：通过一趟排序将序列分成左右两部分，其中左半部分的的值均比右半部分的值小，然后再分别对左右部分的记录进行排序，直到整个序列有序。 1234567891011121314151617int partition(int a[], int low, int high)&#123; int key = a[low]; while( low &lt; high )&#123; while(low &lt; high &amp;&amp; a[high] &gt;= key) high--; a[low] = a[high]; while(low &lt; high &amp;&amp; a[low] &lt;= key) low++; a[high] = a[low]; &#125; a[low] = key; return low;&#125;void quick_sort(int a[], int low, int high)&#123; if(low &gt;= high) return; int keypos = partition(a, low, high); quick_sort(a, low, keypos-1); quick_sort(a, keypos+1, high);&#125; 堆排序：假设序列有n个元素,先将这n建成大顶堆，然后取堆顶元素，与序列第n个元素交换，然后调整前n-1元素，使其重新成为堆，然后再取堆顶元素，与第n-1个元素交换，再调整前n-2个元素…直至整个序列有序。 希尔排序：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。 归并排序：把有序表划分成元素个数尽量相等的两半，把两半元素分别排序，两个有序表合并成一个 实际问题高并发系统的设计与实现在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。 缓存：缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件，你也可以认为是一种分布式的数据缓存。 降级：服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。 限流：限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。 常见的限流算法：常见的限流算法有计数器、漏桶和令牌桶算法。漏桶算法在分布式环境中消息中间件或者Redis都是可选的方案。发放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。 秒杀并发情况下库存为负数问题 for update显示加锁 把udpate语句写在前边，先把数量-1，之后select出库存如果&gt;-1就commit,否则rollback。 12update products set quantity = quantity-1 WHERE id=3;select quantity from products WHERE id=3 for update; update语句在更新的同时加上一个条件 12quantity = select quantity from products WHERE id=3;update products set quantity = ($quantity-1) WHERE id=3 and queantity = $quantity;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yournotes.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"七里香","slug":"七里香","date":"2020-04-15T12:47:35.000Z","updated":"2025-04-17T08:34:52.020Z","comments":true,"path":"2020/04/15/七里香/","link":"","permalink":"http://yournotes.cn/2020/04/15/%E4%B8%83%E9%87%8C%E9%A6%99/","excerpt":"《七里香》谱子收藏、全文查看","text":"《七里香》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"送别","slug":"送别","date":"2020-04-15T12:22:46.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2020/04/15/送别/","link":"","permalink":"http://yournotes.cn/2020/04/15/%E9%80%81%E5%88%AB/","excerpt":"《送别》谱子收藏、全文查看","text":"《送别》谱子收藏、全文查看 您的浏览器不支持视频标签","categories":[{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"}]},{"title":"项目上线部署发布","slug":"项目上线部署发布","date":"2020-03-13T10:59:01.000Z","updated":"2025-04-17T08:34:52.025Z","comments":true,"path":"2020/03/13/项目上线部署发布/","link":"","permalink":"http://yournotes.cn/2020/03/13/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83/","excerpt":"","text":"1. 前言1.1 服务器与操作系统 服务器是计算机的一种，它比普通计算机运行更快、负载更高、价格更贵。 服务器从硬件上等同于电脑PC。而服务器跟PC都是由CPU、内存、主板、硬盘、电源等组成；但服务器的性能要远远超过PC，因为它要保证全年无休。 操作系统: 操作系统是作为应用程序与计算机硬件之间的一个接口 没有安装操作系统的计算机，被称为裸机, 如果想在裸机上运行自己的程序，就需要使用机器语言 安装操作系统之后，就可以配置一些高级语言的环境，进行高级语言的开发 Linux操作系统 Linux系统是最具稳定性的系统 Linux是天生就比Windows更具安全性 免费, Linux服务器在应用开发上更能节约成本 1.2 项目的发布部署 项目的开发流程大致要经过一下几个步骤: 项目立项\\ 需求分析阶段 原型图设计阶段 开发阶段 测试阶段 系统上线 2. 后台项目部署2.1 安装软件环境以下软件,在Linux都已安装完成.具体操作可点击下面按钮参考 点我试试 软件 版本 JDK 11 Tomcat 9 Mysql 8 2.2 项目打包发布 修改项目的数据库配置文件, 数据库的IP ,用户名 密码 修改 Constants常量类中的项目URL 12//生产环境地址 public static final String LOCAL_URL = &quot;http://192.168.52.100:8080&quot;; 修改后启动项目,测试一下 保证数据库连接没有问题 检查POM文件,打包方式必须是war,编译版本为JDK11（与服务器保持一致） 1234567&lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; 执行打包命令 12mvn cleanmvn package 复制出target目录下的 war包 修改下项目名称 上传到Tomcat进行测试 3. 前端项目部署3.1 修改配置文件 前端项目的配置文件有两个,一个是开发环境的配置文件,一个是生产环境的配置文件 先修改一下开发环境文件的 后端服务器访问地址,然后进行一下测试 12// .env.development 文件 VUE_APP_API_BASE = http://192.168.52.100:8080/lagou_edu_home 修改生产环境的配置文件 12//.env.production VUE_APP_API_BASE = http://192.168.52.100:8080/lagou_edu_home 3.2 前端项目打包 修改 vue.config.js 配置文件 复制下面内容即可 123456789101112131415module.exports = &#123; // relative path for dev publicPath: process.env.NODE_ENV === &quot;production&quot; ? &quot;/edu-boss/&quot; : &quot;./&quot;, // for gh-pages indexPath: &quot;index.html&quot;, assetsDir: &quot;static&quot;, lintOnSave: process.env.NODE_ENV !== &quot;production&quot;, productionSourceMap: false, css: &#123; // sourceMap: process.env.NODE_ENV !== &#x27;production&#x27; &#125;, devServer: &#123; open: true, port: 8081 &#125; &#125;; 执行下面的打包命令 1npm run build 在项目下会生成一个 dist 目录 在本地tomcat的webapps目录下,创建一个edu-boss文件夹,将dist目录中的文件拷贝到里面 启动本地tomcat ,访问前端项目 路径为: 1http://localhost:8081/edu-boss/ 3.3 前端项目发布 验证没有问题后,将edu-boos项目压缩,上传到tomcat服务器 12345678//复制一份tomcat cp -r /usr/tomcat/ /usr/tomcat2 //上传 edu-boss.zip ,并解压 unzip edu-boss.zip //删除edu-boss.zip rm -rf edu-boss.zip 修改tomcat2的server.xml 配置文件,修改3个端口,避免与tomcat1冲突 运行前端项目 12345//进入tomcat2,启动项目 ./bin/startup.sh //动态查看日志 tail -f logs/catalina.out 运行后端项目 12345//进入tomcat1,启动项目 ./bin/startup.sh //动态查看日志 tail -f logs/catalina.out","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"hexo搭建博客","slug":"hexo搭建博客","date":"2020-01-12T16:00:00.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2020/01/13/hexo搭建博客/","link":"","permalink":"http://yournotes.cn/2020/01/13/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前言 很早之前呢也是写过博客系统（旧版），那时是学生时代练习java web基础对于前端也是使用基本的三剑客完成配合一下后端。真正的作为个人的博客使用起来还是不舒服当时但也懒得写个。这次选择直接使用hexo做一个长期日常使用的博客系统（hexo版） Hexo是什么Hexo是基于nodejs的，那么我们需要知道nodejs是什么 node.js是一个运行在chromeJavascript运行环境下（俗称GoogleV8引擎）的开发平台，用来方便快捷的创建服务器端网络应用程序。你可以把它理解为一个轻量级的JSP或PHP环境，但是用来开发Web应用的话，有时要便捷很多。 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上 环境准备首先到官网安装nodejs 安装完成后查看nodejs和其包管理器npm的版本 12node -vnpm -v 下面可选：我们通过包管理器npm来安装hexo,但由于源是国外的访问有可能慢。可以添加下国内镜像再安装 1npm install -g cnpm --registry=https://registry.npm.taobao.org 执行完出现如图所示即添加完成，当使用cnpm指令就是使用的国内源，也可以使用原先的npm 安装hexo1cnpm install -g hexo-cli 执行完成可以查看下版本 1hexo -v hexo使用初始化博客目录在本地创建一个目录比如blog作为博客项目工作区 在你选择的目录下执行初始化命令hexo init,在此之前如果你没有安装git那要先把git安装一下 之后下面的命令如果识别不了hexo指令，可以在指令前面统一加上npx 1F:\\blog&gt;hexo init 在blog下就会完成初始化生成初始工程 这样一个静态的博客项目就生成了，可以本地启动看一下初始状态 1hexo s 服务开启成功，在浏览器访问一下本地的4000端口。 添加文章执行语句实际上就是在&#x2F;source&#x2F;_posts&#x2F;目录下添加了md文件。你可以去编辑这个md文件 1hexo new post &quot;文章名&quot; 写文章通过markdown语法，就简单的写了一点 编辑完重新生成静态项目，每次变更都要重新生成一下 123456hexo clean //删除之前的静态文件hexo g //重新生成新的 hexo s //开启服务 重新访问，在Hello World文章上面就是我们刚刚写的文章。基本博客功能完成了，接下来部署到github上面进行公网访问 部署到github现在本地可以访问了，由于他只是一个静态项目把它部署在github上就可以做一个公开访问了。这里就用github演示。没有就注册一个然后创建库，作为个人博客部署一定要用 (你的github用户名).github.io 来作为库名创建就可以。我的是Jasper-zh.github.io 这一步设置username.github.io是为了开启静态服务，页面项目上传到仓库要想直接访问这些静态资源需要开启静态服务。 接下来在blog目录下安装hexo的git部署插件（作用是一键将环境生成的静态页项目放到github当中）手动push也是一样的 1cnpm install --save hexo-deployer-git 安装完在目录中的_config.yml中配置上部署的方式和地址。比如这里是 git类型、git仓库是github的一个仓库、仓库的分支是master 1234deploy: type: git repository: https://github.com/Jasper-zh/Jasper-zh.github.io.git branch: master 部署工具和部署配置都完成后就可以通过你的库名访问了，基本上呢没有什么问题。一些自定义个性化的配置可以在之后慢慢的改造 为啥使用hexo第一是简单，第二用的比较多生态好真的遇到问题也比较容易查，主题也多 我的hexo博客展示","categories":[{"name":"博客系统","slug":"博客系统","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"name":"hexo","slug":"博客系统/hexo","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yournotes.cn/tags/Hexo/"}]},{"title":"开发环境搭建和Shell编程","slug":"开发环境搭建和Shell编程","date":"2020-01-12T05:19:43.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2020/01/12/开发环境搭建和Shell编程/","link":"","permalink":"http://yournotes.cn/2020/01/12/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8CShell%E7%BC%96%E7%A8%8B/","excerpt":"","text":"1. 开发环境搭建（掌握）1.1 Xshell和Xftp工具（1）下载和安装方式 下载地址：https://www.netsarang.com/zh/ 安装方式：直接一路点击下一步即可，安装过程选择免费版。 （2）使用方式 （3）网络模式设置 这里连接的服务器主机是用VM启的虚拟机，所以才需要配置下它的主机地址并且调整为静态IP。否则的话就不需要（3）（4）（5）步啦！ 设置网络连接模式为NAT模式，步骤如下： 打开虚拟机设置 选择网络适配器，选中NAT模式 （4）修改配置文件 查看虚拟机网络信息 打开编辑中虚拟机网络编辑 上一步网络模式已调成NAT，因此选中NAT 打开NAT Settings 可看到子网IP、子网掩码、网关IP 打开DHCP Settings 看IP范围 使用root用户打开&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eno16777736文件，添加内容如下（根据自己的地址填）： 123456BOOTPROTO=static # 改成静态IPONBOOT=yes # 重启更新IPADDR=192.168.40.129 # 我的在192.168.40.128与192.168.40.254之间 GATEWAY=192.168.40.2 # 网关IP按照NAT Settings看到的填写NETMASK=255.255.255.0 # 子网掩码按照NAT Settings看到的填写DNS1=114.114.114.114 （5）配置文件生效 1使用命令使得配置文件生效：service network restart 1.2 JDK的下载和安装（1）下载和安装方式 下载地址：https://www.oracle.com/java/technologies/javase-downloads.html 安装方式：将下载好的jdk安装包通过Xftp工具传输到CentOS系统中，使用tar命令解压即可。 （2）配置环境变量 使用root用户打开配置文件&#x2F;etc&#x2F;profile，向文件末尾追加内容如下： 12export JAVA_HOME=/usr/javajdk export PATH=$JAVA_HOME/bin:$PATH 保存退出后让文件生效并验证是否配置成功 12source /etc/profile javac -version 1.3 Tomcat的下载和安装（1）下载和安装方式 下载地址：https://tomcat.apache.org/download-80.cgi 安装方式：将下载好的Tomcat安装包通过Xftp工具传输到CentOS系统中，使用tar命令解压即可。 （2）启动和关闭方式 12startup.sh shutdown.sh （3）开放防火墙端口 1/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT 开启8080端口（暂时开通） （4）配置环境变量 使用root用户打开配置文件&#x2F;etc&#x2F;profile，向文件末尾追加内容。 1export CATALINA_HOME=/usr/tomcat export PATH=$CATALINA_HOME/bin:$PATH 保存退出后让文件生效并验证是否配置成功 12source /etc/profile startup.sh （5）发布Web项目 将Web项目打成war包，通过Xftp工具将war包放在tomcat&#x2F;webapp目录并启动 1.4 Mysql的安装和连接（1）安装 点击查看 （2）远程连接安装配置完成后使用管理工具去连接我们的远端Mysql可能会遇到如下问题： （3）解决方案 使用root权限登录数据库后选择mysql库 12mysql -u root -p use mysql; 查看mysql库中的user表的host值后修改为通配符%或者就自己的地址 123select host from user where user=&#x27;root&#x27;; update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;; flush privileges; 查看修改结果并重新测试 1select User,Host from user; 2. Shell编程（熟悉）2.1 基本概念 Shell是一个命令行解释器，可以接收应用程序或用户命令，然后访问操作系统内核。 Shell是一个功能相当强大的编程语言，易编写、易调试、灵活性强； 2.2 编写第一个程序 使用vi工具创建xxx.sh的文件。 以#!/bin/bash开头并编写代码后保存。 2.3 执行Shell程序的方式 方式一：.&#x2F;文件名，此方式需要执行权限。 方式二：&#x2F;bin&#x2F;bash 文件名，此方式不需要执行权限。 2.4 变量的定义（1）语法格式 定义变量：变量&#x3D;值 撤销变量：unset 变量 （2）定义规则 变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。 不能使用bash里的关键字。 中间不能有空格，可以有下划线。 在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。 变量的值如果有空格，需要使用双引号或单引号括起来。 2.5 常用运算符（1）算术运算符 （2）关系运算符 2.6 流程控制语句（1）if判断 1234if [ 条件判断式 ] then 程序 fi （2）case语句 12345678910case $变量名 in &quot;值1&quot;） 如果变量的值等于值1，则执行程序1 ;; &quot;值2&quot;） 如果变量的值等于值2，则执行程序2 ;; …省略其他分支… *）如果变量的值都不是以上的值，则执行此程序 ;; esac （3）for循环 1234for (( 初始值;循环控制条件;变量变化 )) do 程序 done （4）while循环 1234while [ 条件判断式 ] do 程序 done 2.7 函数123456[ function ] funname[()] &#123; Action; [return int;] &#125;funname","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Linux系统概述和编程基础","slug":"Linux系统概述和编程基础","date":"2020-01-12T04:07:10.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2020/01/12/Linux系统概述和编程基础/","link":"","permalink":"http://yournotes.cn/2020/01/12/Linux%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. Linux系统概述（常识）1.1 计算机的体系结构 计算机由计算机硬件和计算机软件两个部分组成，其中计算机软件(Computer Software)可分为系统软件和应用软件，系统软件就是操作系统，是其他软件的基础。 目前主流的操作系统有：Windows系列、Unix系列、Linux系列、Android系列、IOS系列、… 1.2 Linux系统的概述 Linux系统诞生于1991年，在林纳斯·托瓦兹（Linus Torvalds）上大学期间因不满意教学中使用的MINIX操作系统并出于个人爱好设计和研发的。 Linux系统是一套免费、自由、开发源代码的类Unix操作系统，是一个基于Posix(Portable Operating System Interface)标准和多用户、多任务、支持多线程的操作系统。 Linux能运行主要的Unix工具软件、应用程序和网络协议，支持32位和64位硬件。 1.3 主要发行版本 Redhat：目前最大的Linux发行商，功能全面并且稳定，于2018年10月被IBM以340亿美元的价格收购。 Ubuntu：目前最好的Linux桌面版，拥有很人性化的亮丽的交互界面，强大的软件源支持。 CentOS：是RHEL的克隆版本，可以认为是免费版本的Redhat系统。 2. CentOS系统安装（掌握）2.1 Vmware的下载和安装 下载地址：https://www.vmware.com/cn.html 按照安装教程一步步操作即可。 2.2 CentOS系统的下载和安装下载地址：https://www.centos.org/按照安装教程通过Vmware软件进行CentOS系统的安装。。 3. 目录结构（熟悉）3.1 框架结构 3.2 目录详解 目录名称 功能介绍 /bin binarie:存放二进制可执行文件 (例如tomcat的bin目录) /sbin super binaries:存放二进制文件,只有root用户才能访问 /boot 系统启动核心目录,存放系统启动程序文件，例:查看启动文件的大小 /dev devices:用于存放硬件设备文件 /etc etcetera:存放系统配置文件(字体文件等) /home 家目录,每一个用户都有一个”家”，用户的起始目录,创建用户跟随创建相应的家目录 /lib library:系统资源文件类库 /proc 内存映射目录,可以查看系统相关硬件的信息 /var variable:可变的,变量. 部署项目用的 /tmp temporary:用来存放临时文件 /root 超级用户root的家目录 /usr unix shared resouce: 存放unix共享系统资源，类似于” C:/ Program Files”,用于安装各种软件 4. 常用命令（重点）4.1 Shell的概念 Shell俗称外壳，是提供用户使用界面的一种软件，叫做命令解释器。 主要负责接受用户输入的命令，然后调用相应的应用程序，最后向用户输出程序运行的结果。 4.2 命令的格式 命令 [-选项] [参数] 命令区分大小写，其中选项和参数是可选的，中间采用空格隔开。 4.3 常用命令的详解（1）查看目录下文件&#x2F;目录 命令 功能概述 ls list显示文件 ls -l 或 ll list -list显示详细信息 ls -a list -all显示全部(包含隐藏文件)文件 ls -al list -all list 上两个合体 ls 目录名 查看目录下有什么东西 （2）目录切换 命令 功能概述 cd .. 上一级目录 cd dirname 进入目录 cd 或 cd ~ 直接回到用户的家目录 cd / 回到系统根目录 相对路径和绝对路径的概念。（3）查看完整路径 命令 功能概述 pwd 看当前目录所在的位置 **（4）查看当前用户** 命令 功能概述 whoami 查看当前用户的名称 **（5）用户切换** 命令 功能概述 su 普通用户切换到root用户 su root 切换到root用户 su 用户名 切换到普通用户 exit 退回到原来用户 * 最好使用su和exit搭配使用，否则多次使用su指令会导致用户的”叠加”。 **（6）管理用户** 命令 功能概述 useradd xxx 创建用户 passwd xxx 为创建的用户设置密码 userdel 删除用户 **（7）查看命令的所在目录** 命令 功能概述 which命令 查看指定命令所在的路径信息 **（8）文件操作** 命令 功能描述 touch fileName 创建名字为fileName的文件 touch dir/fileName 在dir目录下创建名字为fileName的文件 echo 内容 > fileName 把内容覆盖写到文件中，若文件不存在则创建 echo 内容 >> fileName 把内容追加到文件中 cat fileName 打印文件内容到终端 more fileName 分屏查看文件各行内容，不支持回看 less fileName 查看文件各部分内容，支持回看 head -n fileName 查看文件的前n行内容 tail -n fileName 查看文件末尾n行内容 wc fileName 查看文件的行数 （9）目录操作 命令 功能描述 mkdir 目录名 创建普通文件夹 mkdir -p 目录/目录/目录 递归方式创建多级父子文件夹 mv dir1 dir2 将dir1移动到dir2中 mv dir1/dir2 ./ 将dir1中dir2移动到当前目录下 mv dir1 name 将dir1改名为name cp dir1 name 将dir1拷贝为name cp -r dir1 dir2 需要设置参数 -r (recursive递归) 无视目录层次 rm 文件 删除文件 rm -r 目录 递归删除目录(无视目录层次) rm -rf 文件/目录 -r force(强制) 删除文件/目录 **（10）查找操作** 命令 功能描述 find / -name passwd[完整名称] 查找passwd文件 find ./ -name “p*” 查找带”p”的文件 find ./ -type f 查找所有文件 grep 内容 fileName 从指定文件中查找指定的内容 （11）权限管理 命令 功能描述 chmod 权限 文件/目录名 管理指定文件的权限信息，r读:4 w写:2 x执行:1 **（12）进程管理** 命令 功能描述 ps 查看当前终端窗口里的进程 ps -aux 查看系统中的所有进程 ps -ef 查看进程列表 kill 进程号 杀死指定的进程 kill -9 进程号 强制杀死指定的进程 **（13）其它命令** 命令 功能描述 ifconfig 查看当前系统的IP地址等信息 tar zcvf 压缩文件名.tar.gz 路径1 路径2 ... 实现一组文件或文件夹的打包 tar zxvf 压缩文件名.tar.gz 实现解压缩解包 man [章节号] 命令/函数名 查询指定的命令或函数 5 vi工具的使用（重点）5.1 基本概念 vi和vim是Linux系统命令行下的文本编辑器，通常格式为：vi 文件名 或 vim 文件名。 5.2 三种模式 5.3 使用方式（1）命令模式的编辑命令 123i：在当前位置之前插入 a：在当前位置之后插入 o：在当前行下插入 （2）命令行模式的删除命令 12345x 删除一个字符 dw 删除当前词 3dw 删除三个词 dd 删除当前行 5dd 删除五行 （3）命令行模式的修改命令 1234r 替换一个字符 cw 替换一个单词 cc 替换一行 C 替换从光标至行尾 （4）命令行模式的拷贝命令 123456yw 拷贝词 yy 拷贝行(或Y) dd 剪切行 p 当前行下粘贴 u 撤销 ctrl+r 取消撤销 （5）底行模式的命令 12345678:w 存盘 :w newfile 存成新文件 :wq 存盘退出Vi(或ZZ，或:x) :q! 强行退出不存盘 :1,2co3 拷贝行1，行2在行3之后 :4,5mo6 移动行4，行5在行6之后 :%s /源字符串/目标字符串 :%s /源字符串/目标字符串/g 替换每一行中的所有 （6）注意使用 使用vimtutor 命令用来练习vi命令。 用户主目录下.vimrc文件可以实现vi的简单设置。 比如设置开启行号显示 1vim ~/.vimrc 在里面添加上set nu即可开启行号 1set nu 行号效果","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Filter+Listener核心技术","slug":"Filter-Listener核心技术","date":"2020-01-12T02:54:23.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2020/01/12/Filter-Listener核心技术/","link":"","permalink":"http://yournotes.cn/2020/01/12/Filter-Listener%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","excerpt":"","text":"1. Filter过滤器（重点）1.1 基本概念 Filter本意为”过滤“的含义，是JavaWeb的三大组件之一，三大组件为：Servlet、Filter、Listener。 过滤器是向 Web 应用程序的请求和响应处理添加功能的 Web 服务组件。 过滤器相当于浏览器与Web资源之间的一道过滤网，在访问资源之前通过一系列的过滤器对请求进行修改、判断以及拦截等，也可以对响应进行修改、判断以及拦截等。 1.2 工作方式 1.3 使用方式 自定义类实现Filter接口并重写doFilter方法。 123456789public class LoginFilter implements Filter &#123; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,ServletException &#123; //TODO 处理逻辑，必须调用下面的方法 chain.doFilter(request,response); &#125; &#125; 在web.xml文件中配置过滤器。 12345678&lt;filter&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lagou.LoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 1.4 Filter接口（1）基本概念 javax.servlet.Filter接口主要用于描述过滤器对象，可以对资源的请求和资源的响应操作进行筛选操作。 （2）常用方法 方法声明 功能介绍 void init(FilterConfig filterConfig) 实现过滤器的初始化操作 void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) 执行过滤操作的功能 void destroy() 实现过滤器的销毁操作 1.5 FilterConfig接口（1）基本概念 javax.servlet.FilterConfifig接口主要用于描述过滤器的配置信息。 （2）常用方法 方法声明 功能介绍 String getFilterName() 获取过滤器的名字 String getInitParameter(String name) 获取指定的初始化参数信息 Enumeration getInitParameterNames() 获取所有的初始化操作名称 ServletContext getServletContext() 获取ServletContext对象 1.6 多个过滤器的使用 如果有多个过滤器都满足过滤的条件，则容器依据映射的先后顺序来调用各个过滤器。 1.7 过滤器的优点 实现代码的“可插拔性”，即增加或减少某个功能模块，不会影响程序的正常执行。 可以将多个相同处理逻辑的模块集中写在过滤器里面，可实现重复利用、也方便代码的维护。 2 Listener监听器（重点）2.1 基本概念 Servlet规范中定义的一种特殊的组件，用来监听Servlet容器产生的事件并进行相应的处理。 容器产生的事件分类如下： 生命周期相关的事件。 属性状态相关的事件。 存值状态相关的事件。 底层原理是采用接口回调的方式实现。 2.2 基本分类 监听器类型 功能介绍 javax.servlet.ServletRequestListener 监听request作用域的创建和销毁 javax.servlet.ServletRequestAttributeListener 监听request作用域的属性状态变化 javax.servlet.http.HttpSessionListener 监听session作用域的创建和销毁 javax.servlet.http.HttpSessionAttributeListener 监听session作用域的属性状态变化 javax.servlet.ServletContextListener 监听application作用域的创建和销毁 javax.servlet.ServletContextAttributeListener 监听application作用域的属性状态变化 javax.servlet.http.HttpSessionBindingListener 监听对象与session的绑定和解除 javax.servlet.http.HttpSessionActivationListener 监听session数值的钝化和活化 2.3 监听器详解（1）ServletRequestListener监听器 在ServletRequest创建和关闭时都会通知ServletRequestListener监听器。 常用方法如下： 方法声明 功能介绍 void requestInitialized(ServletRequestEvent sre) 实现ServletRequest对象的初始化 void requestDestroyed(ServletRequestEvent sre) 实现ServletRequest对象的销毁 **（2）ServletRequestAttributeListener监听器** * 向ServletRequest添加、删除或者替换一个属性的时候，将会通知ServletRequestAttributeListener监听器。 * 常用方法如下： 方法声明 功能介绍 void attributeAdded(ServletRequestAttributeEvent srae) 增加属性时触发 void attributeReplaced(ServletRequestAttributeEvent srae) 修改属性时触发 void attributeRemoved(ServletRequestAttributeEvent srae) 删除属性时触发 （3）HttpSessionListener监听器 当一个HttpSession刚被创建或者失效（invalidate）的时候，将会通知HttpSessionListener监听器。 常用方法如下： 方法声明 功能介绍 void sessionCreated(HttpSessionEvent se) 当一个HttpSession对象被创建时会调用这个方法 void sessionDestroyed(HttpSessionEvent se) 当一个HttpSession超时或者调用HttpSession的invalidate()方法让它销毁时，将会调用这个方法 （4）HttpSessionAttributeListener监听器 HttpSession中添加、删除或者替换一个属性的时候，将会通知HttpSessionAttributeListener监听器。 常用方法如下： 方法声明 功能介绍 void attributeAdded(HttpSessionBindingEvent se) 当往会话中加入一个属性的时候会调用这个方法 void attributeRemoved(HttpSessionBindingEvent se) 当从会话中删除一个属性的时候会调用这个方法 void attributeReplaced(HttpSessionBindingEvent se) 当改变会话中的属性的时候会调用这个方法 （5）ServletContextListener监听器 在ServletContext创建和关闭时都会通知ServletContextListener监听器。 常用方法如下： 方法声明 功能介绍 void contextInitialized(ServletContextEvent sce) 当ServletContext创建的时候，将会调用这个方法 void contextDestroyed(ServletContextEvent sce) 当ServletContext销毁的时候（例如关闭应用服务器或者重新加载应用），将会调用这个方法 （6）ServletContextAttributeListener监听器 向ServletContext添加、删除或者替换一个属性的时候，将会通ServletContextAttributesListener监听器 常用方法如下： 方法声明 功能介绍 void attributeAdded(ServletContextAttributeEvent scae) 往ServletContext中加入一个属性的时候触发 void attributeRemoved(ServletContextAttributeEvent scae) 从ServletContext中删除一个属性的时候触发 void attributeReplaced(ServletContextAttributeEvent scae) 改变ServletContext中属性的时候触发 （7）HttpSessionBindingListener监听器 HttpSession中绑定和解除绑定时，将会通知HttpSessionListener监听器。 常用方法如下： 方法声明 功能介绍 void valueBound(HttpSessionBindingEvent event) 有对象绑定时调用该方法 void valueUnbound(HttpSessionBindingEvent event) 有对象解除绑定时调用该方法 （8）HttpSessionActivationListener监听器 当有session数值的钝化和活化操作时，将会通知HttpSessionActivationListener监听器。 常用方法如下： 方法声明 功能介绍 void sessionWillPassivate(HttpSessionEvent se) 有钝化操作时调用该方法 void sessionDidActivate(HttpSessionEvent se) 有活化操作时调用该方法 * 配置context.xml文件的方式如下： 1234&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; saveOnRestart=&quot;true&quot;&gt; &lt;!-- 配置文件存放的路径信息，可以自由指定 --&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;C:\\session&quot;/&gt; &lt;/Manager&gt; 2.4 实战案例 自定义类实现监听器接口并重写相关的方法。 123456789101112131415161718192021public class OnlineUser implements HttpSessionListener,ServletContextListener &#123; ServletContext ctx = null; // 初始化 ServletContext public void contextInitialized(ServletContextEvent e) &#123; ctx = e.getServletContext(); &#125; // 销毁 ServletContext public void contextDestroyed(ServletContextEvent e) &#123; //将ServletContext设置成null; &#125; // 当新创建一个HttpSession对象时 public void sessionCreated(HttpSessionEvent e) &#123; //将当前的在线人数加上1，并且保存到ServletContext(application)中 &#125; // 当一个HttpSession被销毁时（过期或者调用了invalidate()方法） public void sessionDestroyed(HttpSessionEvent e) &#123; //将当前人数减去1，并且保存到ServletContext(application)中 &#125; &#125; 在web.xml中配置监听器 123&lt;listener&gt; &lt;listener-class&gt; com.hao.listener.OnlineUser &lt;/listener-class&gt; &lt;/listener&gt;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"EL和JSTL核心技术","slug":"EL和JSTL核心技术","date":"2020-01-11T02:54:11.000Z","updated":"2025-04-17T08:34:51.958Z","comments":true,"path":"2020/01/11/EL和JSTL核心技术/","link":"","permalink":"http://yournotes.cn/2020/01/11/EL%E5%92%8CJSTL%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","excerpt":"","text":"1. EL表达式（熟悉）1.1 基本概念 EL（Expression Language）表达式提供了在JSP中简化表达式的方法，可以方便地访问各种数据并输出。 1.2 主要功能 依次访问pageContext、request、session和application作用域对象存储的数据。 获取请求参数值。 访问Bean对象的属性。 访问集合中的数据。 输出简单的运算结果。 1.3 访问内置对象的数据（1）访问方式 &lt;%&#x3D;request.getAttribute(“ varName”)%&gt; 用EL实现: ${ varName } （2）执行流程 1.4 访问请求参数的数据 在EL之前使用下列方式访问请求参数的数据 request.getParameter(name); request.getParameterValues(name); 在EL中使用下列方式访问请求参数的数据 param：接收的参数只有一个值。 paramValues：接受的参数有多个值。 1234&lt;!-- 获取指定参数的数值 --&gt; $&#123;param.name&#125; &lt;!-- 获取指定参数中指定下标的数值 --&gt; $&#123;paramValues.hobby[0]&#125; 1.5 访问Bean对象的熟悉（1）访问方式 方式一： $ { 对象名 . 属性名 }，例如：$&#123;user.name&#125; 方式二： $ { 对象名 [“属性名”] }，例如：$&#123;user[&quot;name&quot;]&#125; （2）主要区别 当要存取的属性名中包含一些特殊字符，如： . 或 ,等并非字母或数字的符号，就一定要使用 [ ]而不是.的方式 使用[]的方式可以动态取值，具体方式如下： 123&lt;% request.setAttribute(“prop”,“age”); %&gt;&lt;!-- 相当于表达式中写一个变量 --&gt; $&#123; user[prop] &#125; 1.6 访问集合中的数据12&lt;!-- student为ArrayList类型的对象 --&gt; $&#123;student[0].name&#125; 1.7 常用的内置对象 类别 标识符 描述 JSP pageContext PageContext 处理当前页面 作用域 pageScope 同页面作用域属性名称和值有关的Map类 requestScope 同请求作用域属性的名称和值有关的Map类 sessionScope 同会话作用域属性的名称和值有关的Map类 applicationScope 同应用程序作用域属性的名称和值有关的Map类 请求参数 param 根据名称存储请求参数的值的Map类 paramValues 把请求参数的所有值作为一个String数组来存储的Map类 请求头 header 根据名称存储请求头主要值的Map类 headerValues 把请求头的所有值作为一个String数组来存储的Map类 Cookie cookie 根据名称存储请求附带的cookie的Map类 初始化参数 initParam 根据名称存储Web应用程序上下文初始化参数的Map类 1.8 常用的运算符（1）常用的算术运算符 算术运算符 说 明 范 例 运算结果 + 加 ${1+2} 3 － 减 ${2-1} 1 * 乘 ${2*3} 6 / 或 div 除 ${16/5}或${16div5} 3.2 % 或 mod 取余 ${16%5}或${16mod5} 1 （2）常用的关系运算符 关系运算符 说 明 范 例 运算结果 ==或eq 等于 ${1==2}或${1 eq 2} false != 或ne 不等于 ${2!=1}或${1 ne 2} true < 或lt 小于 ${2 或 gt 大于 ${16>5}或${16 gt 5} true =5}或${16 ge 5} true **（3）常用的逻辑运算符** 逻辑运算符 说 明 范 例 运算结果 && 或 and 与运算 ${true&&true}或${true and true} true || 或or 或运算 ${true||false}或${true or false} true ! 或not 非运算 ${!true}或${not true } false **（4）条件运算符** 1$&#123;条件表达式? 语句1 : 语句2&#125; （5）验证运算符 12$&#123;empty 表达式&#125; 返回布尔值判断表达式是否为&quot;空&quot;值，null值、无元素的集合或数组、长度为零的String被认为是空值。 2. JSTL标签（熟悉）2.1 基本概念 JSTL( JSP Standard Tag Library ) 被称为JSP标准标签库。 开发人员可以利用这些标签取代JSP页面上的Java代码，从而提高程序的可读性，降低程序的维护难度。 2.2 使用方式 下载JSTL的jar包并添加到项目中，下载地址为：https://tomcat.apache.org/download/taglibs.cgi 在JSP页面中使用taglib指定引入jstl标签库，方式为： 123&lt;!-- prefix属性用于指定库前缀 --&gt; &lt;!-- uri属性用于指定库的标识 --&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; % 2.3 常用核心标签（1）输出标签 1&lt;c:out&gt;&lt;/c:out&gt; 用来将指定内容输出的标签 （2）设置标签 1&lt;c:set&gt;&lt;/c:set&gt; 用来设置属性范围值的标签 （3）删除标签 1&lt;c:remove&gt;&lt;/c:remove&gt; 用来删除指定数据的标签 （4）单条件标签 123&lt;c:if test =“EL条件表达式”&gt; 满足条件执行 &lt;/c:if &gt; （5）多条件判断标签 12345678&lt;c:choose &gt; &lt;c:when test =“EL表达式”&gt; 满足条件执行 &lt;/c:when&gt; … &lt;c:otherwise&gt; 不满足上述when条件时执行 &lt;/c:otherwise&gt; &lt;/c:choose &gt; （6）循环标签 123&lt;c:forEach var=“循环变量” items=“集合”&gt; … &lt;/c:forEach&gt; 2.4 常用函数标签1&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; 2.5 常用格式化标签1&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; 2.6 自定义标签 如果上面几个标签不能满足需求，程序员也可以自定义标签，步骤如下： 编写标签类继承SimpleTagSupport类或TagSupport类并重写doTag方法或doStartTag方法。 12345678910111213public class HelloTag extends SimpleTagSupport &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public void doTag() throws JspException, IOException &#123; JspWriter out = this.getJspContext().getOut(); out.println(&quot;自定义标签的参数为：&quot; + name); &#125; &#125; 定义标签库文件（tld标签库文件）并配置标签说明文件到到WEB-INF下： 123456789&lt;tag&gt; &lt;name&gt;helloTag&lt;/name&gt; &lt;tag-class&gt;com.hao.tag.HelloTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;name&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;/attribute&gt; &lt;/tag&gt; 在JSP中添加taglib指令引入标签库使用： 1&lt;%@ taglib prefix=&quot;hello&quot; uri=&quot;/WEB-INF/mytag.tld&quot; %&gt;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"JSP核心技术","slug":"JSP核心技术","date":"2020-01-09T03:15:05.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2020/01/09/JSP核心技术/","link":"","permalink":"http://yournotes.cn/2020/01/09/JSP%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","excerpt":"","text":"1.JSP的概述（熟悉）1.1 JSP的概念 JSP是Java Server Pages的简称，跟Servlet一样可以动态生成HTML响应， JSP文件命名为xxx.jsp。 与Servlet不同，JSP文件以HTML标记为主，然后内嵌Java代码段，用于处理动态内容。 1.2 JSP的示例12345678910&lt;%@ page import=&quot;java.util.Date&quot; %&gt; &lt;%@ pagecontentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello Time&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 现在的时间是：&lt;%= new Date()%&gt; &lt;/body&gt;&lt;/html&gt; 1.3 JSP与Servlet的关系 2. JSP的语法（熟悉）2.1 JSP语法结构 声明区 程序代码区 表达式 注释 指令和动作 内置对象 2.2 声明区 基本语法：&lt;%! %&gt; 说明：可以定义全局变量、方法、类。 1234&lt;%! int i; public void setName()&#123;… …&#125; %&gt; 2.3 程序代码区 基本语法：&lt;% 程序代码区 %&gt; 说明：可以定义局部变量以及放入任何的Java程序代码 123456&lt;% int j; for (int k=0; k&lt;10; k++) &#123; … … &#125; %&gt; 2.4 表达式 基本语法：&lt;%=… …%&gt; 说明：可以输出一个变量或一个具体内容，但&#x3D;后面必须是字符串变量或者可以被转换成字符串的表达式。 注意：不需要以;结束，只有一行 12&lt;%=“hello world”%&gt; &lt;%=i+1%&gt; 案例题目 123456使用for循环输出一个html语言的表格，具体表头如下： id name age salary 1 1 1 1 2 2 2 2 ... 5 5 5 5 2.5 注释123456格式： &lt;!--… …--&gt; HTML文件的注释，浏览器可以查看到 &lt;%--… …--%&gt; JSP文件的注释，浏览器看不到 &lt;%//… …%&gt; Java语言中的单行注释，浏览器看不到 &lt;%/*… …*/%&gt; Java语言中的多行注释，浏览器看不到 注释的内容不会被执行 2.6 指令和动作 指令格式：&lt;%@指令 属性=“属性值” %&gt; 指令的属性可以设定多个。 JSP常用指令有：page、taglib、include。 （1）page指令 page执行用于导包和设置一些页面属性，常用属性如下： 1234567import 导入相应的包，惟一允许在同一文档中多次出现的属性 contentType 设置Content-Type响应报头，标明即将发送到浏览器的文档类型 pageEncoding 设置页面的编码 language 指定页面使用的语言 session 控制页面是否参与HTTP会话 errorPage 处理当前页面中抛出但未被捕获的任何异常 isErrorPage 当前页是否可以作为其他页面的错误处理页面 （2） taglib指令 taglib指令用来扩展JSP程序的标签元素，引入其他功能的标签库文件。 123&lt;!-- prefix属性用于指定库前缀 --&gt; &lt;!-- uri属性用于指定库的标识 --&gt; &lt;%@taglib uri=“tagLibary” prefix=“prefix”%&gt; （3）include指令 include指令用于引入另一个JSP程序或HTML文件等，格式如下： 1&lt;%@include file=“被包含的文件地址%&gt; JSP引擎会在JSP文件的转换时期先把file属性设定的文件包含进来，然后开始执行转换及编译的工作。 （4）jsp:include&#x2F;jsp:param jsp:include动作用于引入另一个JSP程序或HTML文件等。 执行到include时，被include的文件才会被编译。 如果include的是jsp文件，那它不会被转换成Servlet文件。 1234&lt;jsp:include page=“URLSpec” flush=“true”/&gt; &lt;jsp:include page=“URLSpec” flush=“true”&gt; &lt;jsp:param name=“key” value=“value”/&gt; &lt;/jsp:include&gt; （5）include指令和include动作的区别 include指令是在JSP程序的转换时期就将file属性所指定的程序内容嵌入再编译执行（静态包含）。 include动作在转换时期是不会被编译的，只有在客户端请求时期被执行到才会被动态的编译载入（动态包含，推荐）。 （6）jsp:forward&#x2F;jsp:param forward动作用于在JSP中实现转发，将请求转发到另一个指定的JSP程序或者Servlet中处理。 12345&lt;jsp:forward page=“urlSpec” flush=“true”/&gt; &lt;jsp:forward page=“urlSpec”&gt; &lt;!-- 用于指定参数和其对应的值 --&gt; &lt;jsp:param name=“key” value=“value”/&gt; &lt;/jsp:forward&gt; 3. JSP内置对象（重点）3.1 基本感念 在JSP程序中有9个内置对象由容器为用户进行实例化，程序员可以不用定义就直接使用这些变量。 在JSP转换成Servlet后，会自动追加这些变量的定义，使用内置对象可以简化JSP的开发。 3.2 对象名称 对象变量 对象类型 作用 out JSPWriter 输出流 request HttpServletRequest 请求信息 response HttpServletResponse 响应信息 session HttpSession 会话 application ServletContext 全局的上下文对象 pageContext PageContext JSP页面上下文 page Object JSP页面本身 config ServletConfig Servlet配置对象 exception Throwable 捕获网页异常 3.3 out内置对象 out内置对象是一个缓冲的输出流，用来给客户端输出信息。 常用方法如下： 方法声明 功能介绍 void println(String x) 向客户端输出各种类型数据 void newLine() 输出一个换行符 void close() 关闭输出流 int getBufffferSize() 返回缓冲区的大小 int getRemaining() 返回缓冲区中未使用的字节数 flush() 输出缓冲区里的数据 void clearBuffffer() 清除缓冲区里的数据，同时把数据输出到客户端 void clear() 清除缓冲区里的数据，但不把数据输出到客户端 3.4 request内置对象 request对象封装的是调用JSP页面的请求信息，它是HttpServletRequest接口的一个实例。 该对象的属性值只在一个请求中保存。 常用方法如下： 方法声明 功能介绍 String getMethod() 返回客户端向服务器端传送数据的方式 String getParameter(String name） 返回客户端向服务器端传送的参数值 String[] getParameterValues( String name) 获得指定参数的所有值 String getRequestURI() 获得请求地址 String getRemoteAddr() 返回发送请求的客户端或最后一个代理的IP地址 int getRemotePort() 返回发送请求的客户端或最后一个代理的端口号 String getServerName() 获取服务器的名字 int getServerPort() 获取服务器端的端口 void setAttribute(String name,Object o) 在此请求中存储属性。属性在请求之间重置 Object getAttribute(String name) 将指定属性的值作为对象返回，若不存在则返回空 3.5 response内置对象 response对象用于给客户端相应输出处理结果，它是HttpServletResponse接口的一个实例。 经常用于设置HTTP标题，添加cookie、设置响应内容的类型和状态、发送HTTP重定向和编码URL。 常用方法如下： 方法声明 功能介绍 void addCookie(Cookie cookie) 添加一个Cookie对象，用于在客户端保存特定的信息 void addHeader(String name, String value) 添加HTTP头信息，该Header信息将发送到客户端 boolean containsHeader(String name) 判断指定名字的HTTP文件头是否存在 void sendRedirect(String location) 重定向JSP文件 void setContentType(String type) 设置类型与编码方式 3.6 session内置对象 session对象表示浏览器和服务器之间的一次会话，一次会话可以包含多次请求，在多次请求之间可以借助session对象存储信息，它是HttpSession类型的一个实例。 该对象的属性值在一次会话范围中保存，保存在服务器端，只要不关闭浏览器，默认半个小时内都可以访问。 常用方法如下： 方法声明 功能介绍 void setAttribute(String name,Object value) 使用指定的名称将对象绑定到此会话 Object getAttribute(String name) 返回在此会话中用指定名称绑定的对象，如果没有对象在该名称下绑定则返回空值 3.7 application内置对象 application对象是一个web程序的全局变量，它是ServletContext类型的一个实例。 在整个服务器上保存数据，所有用户共享。 常用方法如下： 方法声明 功能介绍 void setAttribute(String name, Object object) 将对象绑定到此servlet上下文中的给定属性名 Object getAttribute(String name) 返回给定名称的servlet容器属性，若没有该名称的属性返回null 3.8 pageContext内置对象 pageContext对象是PageContext类型的对象，可以使用这个对象来管理其他的隐含对象。 只在一个页面中保存数据。 方法声明 功能介绍 void setAttribute(String name, Object value, int scope) 使用适当的作用域设置指定的名称和值 Object getAttribute(String name, int scope) 返回指定作用域中名称关联的对象，若找不到则返回null ServletRequest getRequest() 获取请求对象 ServletResponse getResponse() 获取响应对象 HttpSession getSession() 获取会话对象 ServletConfig getServletConfifig() 获取配置对象 JspWriter getOut() 获取输出对象 Object getPage() 获取页面对象 Exception getException() 获取异常对象 3.9 exception内置对象 exception 对象是Throwable的实例，表示的是JSP的异常信息。 如果要使用它，必须将对应页面page指令的isErrorPage属性设置成true。 单个页面的处理方式 1&lt;%@page errorPage=&quot;error.jsp&quot; %&gt; 在web.xml中配置统一的异常处理页面。 1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 4. JavaBean组件（熟悉）（1）基本概念 JavaBean 是使用 Java 语言开发的一个可重用的组件，在 JSP 开发中可以使用 JavaBean 减少重复代码，使整个 JSP 代码的开发更加简洁。 JavaBean本质上就是Java类，通常要求如下： 属性：全部私有化，通过get和set方法进行访问。 方法：必须是public关键字修饰。 构造器 ：必须有无参构造方法。 （2）使用方式 使用jsp:useBean的方式创建javaBean实例 12&lt;jsp:useBean id=“对象名” scope=“保存范围 class=“包名.类名” /&gt; 保存范围有：page|request|sessin|application，默认为page范围。 使用jsp:setProperty的方式设置javaBean的属性值 1&lt;jsp:setProperty name=&quot;对象名&quot; property=&quot;属性名&quot; value=&quot;属性值&quot; param=&quot;参数名&quot;/&gt; 使用jsp:getProperty的方式获取javaBean的属性值 1&lt;jsp:getProperty name=&quot;对象名&quot; property=&quot;属性名&quot;/&gt; （3）保存范围 JavaBean的保存范围有page、request、session以及application，默认是page范围。 （4）删除方式1&lt;% 内置对象.removeAttribute(“JavaBean的名字”); %&gt; 5. MVC设计模式（重点）5.1 基本概念 MVC是模型(Model)和视图(View)以及控制器(Controller)的简写，是一种将数据、界面显示和业务逻辑进行分离的组织方式，这样在改进界面及用户交互时，不需要重新编写业务逻辑，从而提高了代码的可维护性。 M：主要用于封装业务数据的JavaBean(Bean) 和 业务逻辑的JavaBean(Service)及访问数据库的DAO对象。 V：主要负责数据收集 和 数据展现，通常由JSP文件完成。 C：主要负责流程控制 和 页面跳转，通常由Servlet完成。 5.2 基本类型","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Servlet核心技术（下）","slug":"Servlet核心技术（下）","date":"2020-01-07T08:52:30.000Z","updated":"2025-04-17T08:34:52.017Z","comments":true,"path":"2020/01/07/Servlet核心技术（下）/","link":"","permalink":"http://yournotes.cn/2020/01/07/Servlet%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"1. Servlet + JDBC应用（重点） 在Servlet中可以使用JDBC技术访问数据库，常见功能如下： 查询DB数据，然后生成显示页面，例如：列表显示功能。 接收请求参数，然后对DB操作，例如：注册、登录、修改密码等功能。 为了方便重用和便于维护等目的，经常会采用DAO（Data Access Object）模式对数据库操作进行独立封装。 DAO工厂（工厂模式）工厂类：封装了对象的创建细节，为调用者提供符合要求的对象。 2. 重定向和转发（重点）","text":"1. Servlet + JDBC应用（重点） 在Servlet中可以使用JDBC技术访问数据库，常见功能如下： 查询DB数据，然后生成显示页面，例如：列表显示功能。 接收请求参数，然后对DB操作，例如：注册、登录、修改密码等功能。 为了方便重用和便于维护等目的，经常会采用DAO（Data Access Object）模式对数据库操作进行独立封装。 DAO工厂（工厂模式）工厂类：封装了对象的创建细节，为调用者提供符合要求的对象。 2. 重定向和转发（重点）2.1 重定向的概述（1）重定向的概念 首先客户浏览器发送http请求，当web服务器接受后发送302状态码响应及对应新的location给客户浏览器，客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址，服务器根据此请求寻找资源并发送给客户。 （2）重定向的实现 实现重定向需要借助javax.servlet.http.HttpServletResponse接口中的以下方法： 方法声明 功能介绍 void sendRedirect(String location) 使用指定的重定向位置URL向客户端发送临时重定向响 （3）重定向的原理 （4）重定向的特点 重定向之后，浏览器地址栏的URL会发生改变。 重定向过程中会将前面Request对象销毁，然后创建一个新的Request对象。 重定向的URL可以是其它项目工程。 2.2 转发的概述（1）转发的概念 一个Web组件（Servlet&#x2F;JSP）将未完成的处理通过容器转交给另外一个Web组件继续处理，转发的各个组件会共享Request和Response对象。 （2）转发的实现 绑定数据到Request对象 方法声明 功能介绍 Object getAttribute(String name) 将指定属性值作为对象返回，若给定名称属性不存在，则返回空值 void setAttribute(String name,Object o) 在此请求中存储属性值 获取转发器对象 方法声明 功能介绍 RequestDispatcher getRequestDispatcher(String path) 返回一个RequestDispatcher对象，该对象充当位于给定路径上的资源的包装器 转发操作 方法声明 功能介绍 void forward(ServletRequest request, ServletResponse response) 将请求从一个servlet转发到服务器上的另一个资源（Servlet、JSP文件或HTML文件） （3）转发的原理 转发之后浏览器地址栏的URL不会发生改变。 转发过程中共享Request对象。 转发的URL不可以是其它项目工程。 （4）重定向和转发的比较 3. Servlet线程安全（重点） 服务器在收到请求之后，会启动一个线程来进行相应的请求处理。 默认情况下，服务器为每个Servlet只创建一个对象实例。当多个请求访问同一个Servlet时，会有 多个线程访问同一个Servlet对象，此时就可能发生线程安全问题。 多线程并发逻辑，需要使用synchronized对代码加锁处理，但尽量避免使用。 4. 状态管理（重点） Web程序基于HTTP协议通信，而HTTP协议是”无状态”的协议，一旦服务器响应完客户的请求之后，就断开连接，而同一个客户的下一次请求又会重新建立网络连接。 服务器程序有时是需要判断是否为同一个客户发出的请求，比如客户的多次选购商品。因此，有必要跟踪同一个客户发出的一系列请求。 把浏览器与服务器之间多次交互作为一个整体，将多次交互所涉及的数据保存下来，即状态管理。多次交互的数据状态可以在客户端保存，也可以在服务器端保存。状态管理主要分为以下两类： 客户端管理：将状态保存在客户端。基于Cookie技术实现。 服务器管理：将状态保存在服务器端。基于Session技术实现。 5. Cookie技术（重点）5.1 基本概念 Cookie本意为”饼干“的含义，在这里表示客户端以“名-值”形式进行保存的一种技术。 浏览器向服务器发送请求时，服务器将数据以Set-Cookie消息头的方式响应给浏览器，然后浏览器会将这些数据以文本文件的方式保存起来。 当浏览器再次访问服务器时，会将这些数据以Cookie消息头的方式发送给服务器。 5.2 相关方法 使用javax.servlet.http.Cookie类的构造方法实现Cookie的创建。 方法声明 功能介绍 Cookie(String name, String value) 根据参数指定数值构造对象 使用javax.servlet.http.HttpServletResponse接口的成员方法实现Cookie的添加。 方法声明 功能介绍 void addCookie(Cookie cookie) 添加参数指定的对象到响应 使用javax.servlet.http.HttpServletRequest接口的成员方法实现Cookie对象的获取。 方法声明 功能介绍 Cookie[] getCookies() 返回此请求中包含的所有Cookie对象 使用javax.servlet.http.Cookie类的构造方法实现Cookie对象中属性的获取和修改。 方法声明 功能介绍 String getName() 返回此Cookie对象中的名字 String getValue() 返回此Cookie对象的数值 void setValue(String newValue) 设置Cookie的数值 5.3 Cookie的生命周期 默认情况下，浏览器会将Cookie信息保存在内存中，只要浏览器关闭，Cookie信息就会消失。 如果希望关闭浏览器后Cookie信息仍有效，可以通过Cookie类的成员方法实现。 方法声明 功能介绍 int getMaxAge() 返回cookie的最长使用期限（以秒为单位） void setMaxAge(int expiry) 设置cookie的最长保留时间（秒） 5.4 Cookie的路径问题 浏览器在访问服务器时，会比较Cookie的路径与请求路径是否匹配，只有匹配的Cookie才会发送给服务器。 Cookie的默认路径等于添加这个Cookie信息时的组件路径，例如：&#x2F;项目名&#x2F;目录&#x2F;add.do请求添加了一个Cookie信息，则该Cookie的路径是 &#x2F;项目名&#x2F;目录。 访问的请求地址必须符合Cookie的路径或者其子路径时，浏览器才会发送Cookie信息。 方法声明 功能介绍 void setPath(String uri) 设置cookie的路径信息 5.5 Cookie的特点 Cookie技术不适合存储所有数据，程序员只用于存储少量、非敏感信息，原因如下： 将状态数据保存在浏览器端，不安全。 保存数据量有限制，大约4KB左右。 只能保存字符串信息。 可以通过浏览器设置为禁止使用。 6. Session技术（重点）6.1 基本概念 Session本意为”会话”的含义，是用来维护一个客户端和服务器关联的一种技术。 浏览器访问服务器时，服务器会为每一个浏览器都在服务器端的内存中分配一个空间，用于创建一个Session对象，该对象有一个id属性且该值唯一，我们称为SessionId，并且服务器会将这个SessionId以Cookie方式发送给浏览器存储。 浏览器再次访问服务器时会将SessionId发送给服务器，服务器可以依据SessionId查找相对应的Session对象 6.2 相关方法 使用javax.servlet.http.HttpServletRequest接口的成员方法实现Session的获取。 方法声明 功能介绍 HttpSession getSession() 返回此请求关联的当前Session，若此请求没有则创建一个 使用javax.servlet.http.HttpSession接口的成员方法实现判断和获取。 方法声明 功能介绍 boolean isNew() 判断是否为新创建的Session String getId() 获取Session的编号 使用javax.servlet.http.HttpSession接口的成员方法实现属性的管理。 方法声明 功能介绍 Object getAttribute(String name) 返回在此会话中用指定名称绑定的对象，如果没有对象在该名称下绑定，则返回空值 void setAttribute(String name, Object value) 使用指定的名称将对象绑定到此会话 void removeAttribute(String name) 从此会话中删除与指定名称绑定的对象 6.3 Session的生命周期 为了节省服务器内存空间资源，服务器会将空闲时间过长的Session对象自动清除掉，服务器默认的超时限制一般是30分钟。 使用javax.servlet.http.HttpSession接口的成员方法实现失效实现的获取和设置。 方法声明 功能介绍 int getMaxInactiveInterval() 获取失效时间 void setMaxInactiveInterval(int interval) 设置失效时间 可以配置web.xml文件修改失效时间。 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 6.4 Session的特点 数据比较安全。 能够保存的数据类型丰富，而Cookie只能保存字符串。 能够保存更多的数据，而Cookie大约保存4KB。 数据保存在服务器端会占用服务器的内存空间，如果存储信息过多、用户量过大，会严重影响服务器的性能。","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Servlet核心技术（上）","slug":"Servlet核心技术（上）","date":"2020-01-07T07:20:01.000Z","updated":"2025-04-17T08:34:52.016Z","comments":true,"path":"2020/01/07/Servlet核心技术（上）/","link":"","permalink":"http://yournotes.cn/2020/01/07/Servlet%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"1. 基础概念（常识）1.1 C&#x2F;S架构的概念","text":"1. 基础概念（常识）1.1 C&#x2F;S架构的概念 C&#x2F;S架构（Client&#x2F;Server，客户端&#x2F;服务器模式），是一种比较早的软件体系结构，也是生活中很常见的结构。这种结构将需要处理的业务合理地分配到客户端和服务器端，客户端通常负责完成与用户的交互任务，服务器通常负责数据的管理。 C&#x2F;S架构的主要优点如下： 客户端的界面和功能可以很丰富。 应用服务器的负荷较轻。 响应速度较快。 C&#x2F;S架构的主要缺点如下： 适用面窄，用户群固定。 维护和升级的成本高，所有的客户端都需要更新版本。 1.2 B&#x2F;S架构的概念 B&#x2F;S架构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），是互联网兴起后的软件体系结构，该结构将系统功能实现的主要业务逻辑集中到服务器端，极少数业务逻辑在浏览器实现，浏览器通常负责完成与用户的交互任务，服务器通常负责数据的管理。 B&#x2F;S架构的主要优点如下： 无需安装客户端，只要有浏览器即可。 适用面广，用户群不固定。 通过权限控制实现多客户访问的目的，交互性较强。 维护和升级的成本低，无需更新所有客户端版本。 B&#x2F;S架构的主要缺点如下： 应用服务器的负荷较重。 浏览器的界面和功能想要达到客户端的丰富程度需要花费大量的成本。 在跨浏览器上不尽如人意，适配比较麻烦。 1.3 JavaWeb的概念 Web本意为网页的含义，这里表示互联网上供外界访问的资源。 互联网上供外界访问的资源主要分为以下两种： 静态资源：主要指Web页面中供人们浏览的数据始终是不变。 动态资源：主要指Web页面中供人们浏览的数据由程序产生，不同时间点访问页面看到的内容各不相同。 JavaWeb主要指使用Java语言进行动态Web资源开发技术的统称，是解决相关Web互联网领域的技术总和。 早期的B&#x2F;S架构: 后来的B&#x2F;S架构 2. HTTP协议（熟悉）2.1 HTTP协议的概念 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是由W3C（万维网联盟）组织制定的一种应用层协议，是用来规范浏览器与Web服务器之间如何通讯的数据格式，主要涉及浏览器的发请求格式和服务器的响应格式。 HTTP协议通常承载于TCP协议之上，而承载于TLS或SSL协议层之上的协议就是常说的HTTPS协议。 HTTP默认的端口号为80，HTTPS默认的端口号为443。 2.2 HTTP请求格式 客户端发送一个HTTP请求到服务器的请求消息主要包括：请求行、请求头、空白行和请求体。 12345请求行：用来说明请求类型和要访问的资源以及所使用的HTTP版本，格式如下： 请求类型：请求的路径 协议的版本(1.1) 请求头：是紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息，格式（key:value）如下： 主机 请求长度 请求的浏览器相关信息 空白行就是请求头部的空行，即使后面的请求数据为空则必须有空行。 请求体：也叫请求数据，可以添加任意的其他数据。 举例如下 1234567POST /task01_demo01/demo1.html HTTP/1.1 Host: localhost:8088 Content-Length: 21 Cache-Control: max-age=0 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) name=scott&amp;pwd=123456 2.3 HTTP响应格式 通常情况下服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息，主要包括：响应行、响应头、空白行和响应体。 1234567响应行：用来说明HTTP协议版本号和状态码以及状态消息，格式如下： 协议的版本(1.0 1.1) 状态码 (200 成功 404 路径错误 500 服务错误) 状态信息：响应头用来说明客户端要使用的一些附加信息，格式（key:value）。 空白行：就是响应头部的空行，即使后面的请求数据为空则必须有空行。 响应体：用来服务器返回给客户端的文本信息。 举例如下： 123456789HTTP/1.1 200 OK Content-Type: text/html Content-Length: 588 Date: Thu, 08 Sep 2021 12:59:54 GMT &lt;html&gt;&lt;head&gt;&lt;title&gt;示例1&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;这是一个HTML页面&lt;/h1&gt;&lt;/body&gt; &lt;/html&gt; 3. Tomcat服务器（重点）3.1 基本概念 Tomcat本意为公猫的含义，最初是由Sun公司的软件架构师詹姆斯·邓肯·戴维森开发的，后来他帮助将其变为开源项目并由Sun公司贡献给Apache软件基金会。 Tomcat 服务器是一个开源的轻量级Web应用服务器，在中小型系统和并发量小的场合下被普遍使用，是开发和调试Servlet、JSP 程序的首选。 3.2 安装方式 下载地址：http://tomcat.apache.org/ 3.3 目录结构 bin： 主要存放二进制可执行文件和脚本。 conf： 主要存放各种配置文件。 lib： 主要用来存放Tomcat运行需要加载的jar包。 logs： 主要存放Tomcat在运行过程中产生的日志文件。 temp： 主要存放Tomcat在运行过程中产生的临时文件。 webapps： 主要存放应用程序，当Tomcat启动时会去加载该目录下的应用程序。 work： 主要存放tomcat在运行时的编译后文件，例如JSP编译后的文件。 3.4 启动和关闭 启动方式： 使用bin目录下的批处理文件startup.bat来启动Tomcat服务器，若出现一个毫秒数说明启动成功。 关闭方式 使用bin目录下的批处理文件shutdown.bat来关闭Tomcat服务器。 注意事项 启动之前首先安装JDK并配置环境变量JAVA_HOME，若希望Tomcat服务器可以在任意路径启动，则需要配置环境变量CATALINA_HOME。 启动信息乱码的处理方式：logging.properties文件修改为java.util.logging.ConsoleHandler.encoding = GBK 3.5 配置文件 server.xml文件是服务器的主配置文件，可以设置端口号、设置域名或IP、默认加载的项目、请求编码等。 123&lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; tomcat-users.xml文件用来配置管理Tomcat服务器的用户与权限 。 12&lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;user username=&quot;admin&quot; password=&quot;123456&quot; roles=&quot;manager-gui&quot;/&gt; 4. Servlet的概念和使用（重点）4.1基本概念 Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，是Java语言编写的服务器端程序，换句话说，Servlet就是运行在服务器上的Java类。 Servlet用来完成B&#x2F;S架构下客户端请求的响应处理，也就是交互式地浏览和生成数据，生成动态Web内容。 4.2 Servlet的编程步骤 建立一个Java Web Application项目并配置Tomcat服务器。 自定义类实现Servlet接口或继承 HttpServlet类（推荐） 并重写service方法。 将自定义类的信息配置到 web.xml文件并启动项目，配置方式如下： 1234567891011121314&lt;!-- 配置Servlet --&gt; &lt;servlet&gt; &lt;!-- HelloServlet是Servlet类的别名 --&gt; &lt;servlet-name&gt; HelloServlet &lt;/servlet-name&gt; &lt;!-- com.lagou.task01.HelloServlet是包含路径的真实的Servlet类名 --&gt; &lt;servlet-class&gt; com.lagou.task01.HelloServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射Servlet --&gt; &lt;servlet-mapping&gt; &lt;!-- HelloServlet是Servlet类的别名，与上述名称必须相同 --&gt; &lt;servlet-name&gt; HelloServlet &lt;/servlet-name&gt; &lt;!-- /hello是供浏览器使用的地址 --&gt; &lt;url-pattern&gt; /hello &lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在浏览器上的访问方式为： 1http://localhost:8080/工程路径/url-pattern的内容 4.3 Servlet接口(1) 基本概念 javax.servlet.Servlet接口用于定义所有servlet必须实现的方法 (2) 常用方法 方法声明 功能介绍 void init(ServletConfig config) 由servlet容器调用，以向servlet指示servlet正在被放入服务中 void service(ServletRequest req,ServletResponse res) 由servlet容器调用，以允许servlet响应请求 ServletConfig getServletConfig() 返回ServletConfig对象，该对象包含此servlet的初始化和启动参数 String getServletInfo() 返回有关servlet的信息，如作者、版本和版权 void destroy() 由servlet容器调用，以向servlet指示该servlet正 4.4 GenericServlet类(1) 基本概念 javax.servlet.GenericServlet类主要用于定义一个通用的、与协议无关的servlet，该类实现了Servlet接口。 若编写通用servlet，只需重写service抽象方法即可。 (2) 常用方法 方法声明 功能介绍 abstract void service(ServletRequest req,ServletResponse res) 由servlet容器调用允许servlet响应 4.5 HttpServlet类(1) 基本概念 javax.servlet.http.HttpServlet类是个抽象类并继承了GenericServlet类。 用于创建适用于网站的HTTP Servlet，该类的子类必须至少重写一个方法。 (2) 常用方法 方法声明 功能介绍 void doGet(HttpServletRequest req,HttpServletResponse resp) 处理客户端的GET请求 void doPost(HttpServletRequest req,HttpServletResponse resp) 处理客户端的POST请求 void init() 进行初始化操作 void service(HttpServletRequest req,HttpServletResponse resp) 根据请求决定调用doGet还是doPost方法 void destroy() 删除实例时释放资源 4.6 Servlet的生命周期 构造方法只被调用一次，当第一次请求Servlet时调用构造方法来创建Servlet的实例。 init方法只被调用一次，当创建好Servlet实例后立即调用该方法实现Servlet的初始化。 service方法被多次调用，每当有请求时都会调用service方法来用于请求的响应。 destroy方法只被调用一次，当该Servlet实例所在的Web应用被卸载前调用该方法来释放当前占用的资源。 5. POST和GET请求（重点）5.1 GET请求发出GET请求的主要方式：（1）在浏览器输入URL按回车（2）点击&lt;a&gt;超链接（3）点击submit按钮，提交 &lt;form method=&quot;get&quot;&gt;表单GET请求特点：会将请求数据添加到请求URL地址的后面，只能提交少量的数据、不安全 5.2 POST请求发出POST请求的方法如下： 点击submit按钮，提交 &lt;form method=&quot;post&quot;&gt;表单 POST请求的特点： 请求数据添加到HTTP协议体中，可提交大量数据、安全性好 5.3 ServletRequest接口(1) 基本概念 javax.servlet.ServletRequest接口主要用于向servlet提供客户端请求信息，可以从中获取到任何请求信息。 Servlet容器创建一个ServletRequest对象，并将其作为参数传递给Servlet的service方法。 (2) 常用方法 方法声明 功能介绍 String getParameter(String name) 以字符串形式返回请求参数的值，如果该参数不存在，则返回空值 String[] getParameterValues(String name) 返回一个字符串对象数组，其中包含给定请求参数所具有的所有值，如果该参数不存在，则返回空值 Enumeration getParameterNames() 返回包含此请求中包含的参数名称的字符串对象的枚举。如果请求没有参数，则方法返回空枚举 Map&lt;String, String[]&gt; getParameterMap() 返回请求参数的键值对，一个键可以对应多个值 String getRemoteAddr() 返回发送请求的客户端或最后一个代理的IP地址 int getRemotePort() 返回发送请求的客户端或最后一个代理的端口号 5.4 HttpServletRequest接口(1) 基本概念 javax.servlet.http.HttpServletRequest接口是ServletRequest接口的子接口，主要用于提供HTTP请求信息的功能。 不同于表单数据，在发送HTTP请求时，HTTP请求头直接由浏览器设置。 可直接通过HttpServletRequest对象提供的一系列get方法获取请求头数据。 (2) 常用方法 方法声明 功能介绍 String getRequestURI() 返回此请求的资源路径信息 StringBuffffer getRequestURL() 返回此请求的完整路径信息 String getMethod() 返回发出此请求的HTTP方法的名称，例如GET、POST String getQueryString() 返回路径后面请求中附带的参数 String getServletPath() 返回此请求中调用servlet的路径部分 5.5 ServletResponse接口(1) 基本概念 javax.servlet.ServletResponse接口用于定义一个对象来帮助Servlet向客户端发送响应。 Servlet容器创建ServletResponse对象，并将其作为参数传递给servlet的service方法。 (2) 常用方法 方法声明 功能介绍 PrintWriter getWriter() 返回可向客户端发送字符文本的PrintWriter对象 String getCharacterEncoding() 获取响应内容的编码方式 void setContentType(String type) 如果尚未提交响应，则设置发送到客户端响应的内容类型。内容类型 5.6 HttpServletResponse接口(1) 基本概念 javax.servlet.http.HttpServletResponse接口继承ServletResponse接口，以便在发送响应时提供特定于HTTP的功能。 (2) 常用方法 方法声明 功能介绍 void sendRedirect(String location) 使用指定的重定向位置URL向客户端发送临时重定向响应 5.7 使用示例1234567891011121314// 继承HttpServlet public class HelloWorld extends HttpServlet &#123; // 重写HttpServlet中的doGet方法 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; // 设置响应输出编码，避免中文乱码 response.setContentType(“text/html;charset=utf-8”); // 获取响应输出流 PrintWriter out= response.getWriter(); // 利用输出流输出信息 out.println(“&lt;html&gt;&lt;body&gt; Hello world！&lt;/body&gt;&lt;/html&gt;”); //关闭流 out.close(); &#125; &#125; 案例题目 使用Servlet获取在服务器获取一个1~100之间的随机数并发送给客户端进行显示。 6. Servlet接收中文乱码（重点）6.1 接收乱码原因 浏览器在提交表单时，会对中文参数值进行自动编码。当Tomcat服务器接收到浏览器请求后自动解码，当编码与解码方式不一致时,就会导致乱码。 6.2 解决POST接收乱码1234//接收之前设置编码方式： request.setCharacterEncoding(“utf-8”) //提示：//必须在调用request.getParameter(“name”)之前设置 6.3 解决GET接收乱码12345//将接收到的中文乱码重新编码: // 接收到get请求的中文字符串 String name = request.getParameter(&quot;name&quot;); // 将中文字符重新编码，默认编码为ISO-8859-1 String userName = new String(name.getBytes(“ISO-8859-1”),“utf-8&quot;); 7. ServletConfig接口（熟悉）(1) 基本概念 javax.servlet.ServletConfifig接口用于描述Servlet本身的相关配置信息，在初始化期间用于将信息传递给Servlet配置对象。 (2) 配置方式123456789101112&lt;!-- 在web.xml中配置ServletConfig初始化参数 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;actionservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lagou.demo01.ActionServlet&lt;/servlet-class&gt; &lt;!-- 配置 Serlvet 的初始化参数 --&gt; &lt;init-param&gt; &lt;!-- 参数名 --&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;!-- 参数值 --&gt; &lt;param-value&gt;struts.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; (3) 常用方法 方法声明 功能介绍 String getServletName() 返回Servlet的别名 String getInitParameter(String name) 返回包含初始化参数值的字符串，如果该参数不存在，则返回null Enumeration getInitParameterNames() 将servlet的初始化参数的名称作为字符串对象的枚举返回，如果servlet没有初始化参数，则返回空枚举 ServletContext getServletContext() 返回对调用方正在其中执行的ServletContext的引用 8 ServletContext接口（熟悉）(1) 基本概念 javax.servlet.ServletContext接口主要用于定义一组方法，Servlet使用这些方法与它的Servlet容器通信。 服务器容器在启动时会为每个项目创建唯一的一个ServletContext对象，用于实现多个Servlet之间的信息共享和通信。 在Servlet中通过this.getServletContext()方法可以获得ServletContext对象。 (2) 配置方式12345678910&lt;!--在web.xml中配置ServletContext初始化参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;scott&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;tiger&lt;/param-value&gt; &lt;/context-param&gt; (3) 常用方法 方法声明 功能介绍 String getInitParameter(String name) 返回包含初始化参数值的字符串，如果该参数不存在，则返回null Enumeration getInitParameterNames() 将servlet的初始化参数的名称作为字符串对象的枚举返回，如果servlet没有初始化参数，则返回空枚举 String getRealPath(String path) 返回包含给定虚拟路径的实际路径的字符串 String getContextPath() 返回与此上下文关联的主路径 InputStream getResourceAsStream(String path) 将位于指定路径的资源作为InputStream对象返回 void setAttribute(String name, Object object) 将指定的属性名和属性值绑定到当前对象 Object getAttribute(String name) 根据执行的属性名获取属性值 void removeAttribute(String name) 删除指定的属性名信息","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Bootstrap详解","slug":"Bootstrap详解","date":"2020-01-05T10:37:14.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2020/01/05/Bootstrap详解/","link":"","permalink":"http://yournotes.cn/2020/01/05/Bootstrap%E8%AF%A6%E8%A7%A3/","excerpt":"1.bootstrap简介1.1 什么是Bootstrap？ Bootstrap来自 Twitter，是目前最受欢迎的响应式前端框架。","text":"1.bootstrap简介1.1 什么是Bootstrap？ Bootstrap来自 Twitter，是目前最受欢迎的响应式前端框架。 Bootstrap是基于 HTML、CSS、JavaScript的，它简洁灵活，使得 Web 开发更加快捷。 1.2 为什么使用 Bootstrap？ 移动设备优先：自 Bootstrap3 起，框架包含了贯穿于整个库移动设备优先的样式。 不是简单的增加一些可选的针对移动设备的样式，而是直接融合进了框架的内核中。 也就是说，针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。 浏览器支持：所有的主流浏览器都支持 Bootstrap。 容易上手：只要您具备 HTML 和 CSS 的基础知识，您就可以开始学习 Bootstrap。 响应式设计：Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。 它为开发人员创建接口提供了一个简洁统一的解决方案。 它包含了功能强大的内置组件，易于定制。 它还提供了基于 Web 的定制。 它是开源的。 1.3 下载与使用中文官网：https://www.bootcss.com/英文官网：http://getbootstrap.com 下载好的，压缩包解压出来。就得到了bootstrap的资源文件了。分别是css、js、font字体，全部放在项目的根目录即可 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;title&gt;木瓜煲鸡脚&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;padding:100px;&quot;&gt; &lt;h1&gt;Hello, Bootstrap!&lt;/h1&gt; &lt;!-- 注意：这两个按钮的class样式是Bootstrap定义的 --&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;学习充电&lt;/button&gt; &lt;button class=&quot;btn btn-success&quot;&gt;更多文章&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 2.Bootstrap的使用2.1 表格和之前的表格相比，标签更丰富更加语义化，效果更佳美观 2.1.1 丰富的标签 &lt;table&gt; 为表格添加基础样式 &lt;thead&gt; 表格标题行的容器元素（&lt;tr&gt;） &lt;tbody&gt; 表格主体中的表格行的容器元素（&lt;tr&gt;） &lt;tr&gt; 表格行 &lt;td&gt; 默认的表格单元格。 &lt;th&gt; 特殊的表格单元格，（居中和加粗的效果）。必须在&lt;thead&gt; 内使用。 &lt;caption&gt; 关于表格存储内容的描述或总结。 2.1.2 好看的类样式 .table 为任意 &lt;table&gt; 添加基本样式 (只有横向分隔线) .table-striped 在 &lt;tbody&gt; 内添加斑马线形式的条纹 ( IE8 不支持) ，隔行变色 .table-bordered 为所有表格的单元格添加边框 .table-hover 在 &lt;tbody&gt; 内的任一行启用鼠标悬停状态，鼠标悬停高亮突出显示 .table-condensed 让表格更加紧凑 2.1.3 情景色类样式适合应用在&lt;th&gt;、&lt;tr&gt;，&lt;td&gt; .active 激活效果（悬停颜色） .success 表示成功或积极的动作 .info 表示普通的提示信息或动作 .warning 表示警告或需要用户注意 .danger 表示危险或潜在的带来的负面影响的动作 2.1.4 响应式表格表格的父元素设置响应式，小于768px，出现边框 12345678910111213141516171819202122232425262728293031323334353637&lt;table class=&quot;table table-responsive&quot;&gt; &lt;caption&gt;经营产品大全&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;产品&lt;/th&gt; &lt;th&gt;付款日期&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;info&quot;&gt; &lt;td&gt;产品1&lt;/td&gt; &lt;td&gt;2020-1-1&lt;/td&gt; &lt;td&gt;待发货&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;active&quot;&gt; &lt;td&gt;产品2&lt;/td&gt; &lt;td&gt;2020-1-2&lt;/td&gt; &lt;td&gt;已发货&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;success&quot;&gt; &lt;td&gt;产品3&lt;/td&gt; &lt;td&gt;2020-1-3&lt;/td&gt; &lt;td&gt;未付款&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;warning&quot;&gt; &lt;td&gt;产品4&lt;/td&gt; &lt;td&gt;2020-1-4&lt;/td&gt; &lt;td&gt;已退货&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;danger&quot;&gt; &lt;td&gt;产品5&lt;/td&gt; &lt;td&gt;2020-1-5&lt;/td&gt; &lt;td&gt;已退款&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 2.2 表单2.2.1 表单布局默认布局 123456789101112131415&lt;body style=&quot;padding:100px;&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;邮箱&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;请输入邮箱&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type=&quot;passowd&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 内联布局 让所有表单元素居于一行 注意：当小于768px时,会自动还原成移动端样式. 1&lt;form class=&quot;form-inline&quot;&gt; 2.2.2 表单控件输入框 123456&lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;输入框&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入文本...&quot;&gt; &lt;/div&gt;&lt;/form&gt; 文本框 1234&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;文本框&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; cols=&quot;30&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;&lt;/div&gt; 复选框 checkbox 默认 checkbox-inline 内联 123456789101112131415161718192021&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; 抽烟 &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; 喝酒 &lt;/label&gt;&lt;/div&gt; &lt;hr&gt;&lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; 洗澡 &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; 烫头 &lt;/label&gt;&lt;/div&gt; 复选按钮 12345678910111213141516171819&lt;form&gt; &lt;div class=&quot;btn-group&quot; data-toggle=&quot;buttons&quot;&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 音乐 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 体育 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 美术 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 电脑 &lt;/label&gt; &lt;/div&gt;&lt;/form&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 单选框 12345678910111213141516&lt;label class=&quot;radio&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 男&lt;/label&gt;&lt;label class=&quot;radio&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 女&lt;/label&gt;&lt;hr&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt; 耕&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt; 织&lt;/label&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 单选按钮 1234567891011&lt;div class=&quot;btn-group&quot; data-toggle=&quot;buttons&quot;&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt; 男 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt; 女 &lt;/label&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 2.3 按钮 1234567&lt;button class=&quot;btn btn-default&quot;&gt;默认按钮&lt;/button&gt;&lt;button class=&quot;btn btn-primary&quot;&gt;主要按钮&lt;/button&gt;&lt;button class=&quot;btn btn-success&quot;&gt;成功按钮&lt;/button&gt;&lt;button class=&quot;btn btn-info&quot;&gt;信息按钮&lt;/button&gt;&lt;button class=&quot;btn btn-warning&quot;&gt;警告按钮&lt;/button&gt;&lt;button class=&quot;btn btn-danger&quot;&gt;危险按钮&lt;/button&gt;&lt;button class=&quot;btn btn-link&quot;&gt;连接按钮&lt;/button&gt; 按钮大小 1234&lt;button class=&quot;btn btn-primary btn-lg&quot;&gt;超大按钮（高清大屏台式机）&lt;/button&gt;&lt;button class=&quot;btn btn-primary&quot;&gt;大按钮（笔记本屏幕）&lt;/button&gt;&lt;button class=&quot;btn btn-primary btn-sm&quot;&gt;小按钮（平板电脑）&lt;/button&gt;&lt;button class=&quot;btn btn-primary btn-xs&quot;&gt;超小按钮（手机）&lt;/button&gt; 按钮状态 激活状态：按钮在激活时将呈现为被按压的外观（深色的背景、深色的边框、阴影）; 禁用状态：当您禁用一个按钮时，它的颜色会变淡 50%，并失去渐变; 123&lt;button class=&quot;btn btn-default&quot;&gt;默认按钮&lt;/button&gt;&lt;button class=&quot;btn btn-default active&quot;&gt;激活按钮&lt;/button&gt;&lt;button class=&quot;btn btn-default&quot; disabled&gt;禁用按钮&lt;/button&gt; 2.4 图片 .img-rounded：添加 border-radius:6px 来获得图片圆角。 .img-circle：添加 border-radius:50% 来让整个图片变成圆形。 .img-thumbnail：添加一些内边距（padding）和一个灰色的边框 123&lt;img src=&quot;img/1.jpg&quot; class=&quot;img-rounded&quot; width=&quot;33%&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; class=&quot;img-circle&quot; width=&quot;33%&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; class=&quot;img-thumbnail&quot; width=&quot;33%&quot;&gt; 响应式图片 1&lt;img src=&quot;img/1.jpg&quot; class=&quot;img-responsive&quot;&gt; 2.5 下拉菜单组件 1234567891011&lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;btn btn-primary&quot; data-toggle=&quot;dropdown&quot;&gt;拉勾教育 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前沿技术&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;名师制作&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;24小时导师&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 用法的关键核心 外围容器使用 class&#x3D;”dropdown”包裹 内部点击按钮事件绑定 data-toggle&#x3D;”dropdown” 菜单元素使用 class&#x3D;”dropdown-menu” 2.6 分页组件 1234567&lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;previous&quot;&gt; &lt;a href=&quot;#&quot;&gt; &amp;laquo; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;active&quot;&gt; &lt;a href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next&quot;&gt; &lt;a href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 1&lt;ul class=&quot;pager&quot;&gt; 2.7 栅格系统 bootstrap的栅格系统会将整个页面水平方向上平均分成12个小格子 当浏览器大小发生变化的时候，我们可以控制每行的元素占用几个格子，从而达到响应式的效果 显示屏幕的扩大和缩小. 实现如下效果 123456789101112131415161718192021222324252627282930313233&lt;style&gt; .a&#123; height: 50px; border: 1px solid black; background-color: #eeeeee; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- col-lg-3 当大屏幕时，一个div占3份，一行显示4个div --&gt; &lt;!-- col-md-4 当中屏幕时，一个div占4份，一行显示3个div --&gt; &lt;!-- col-sm-6 当小屏幕时，一个div占6份，一行显示2个div --&gt; &lt;!-- 超小屏幕时，一个div占12份，一行显示1个div，默认 --&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 a&quot;&gt;x&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 2.8 缩略图组件 配合响应式的栅格系统 12345678910111213141516171819202122232425&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/2.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 其余3张图片 --&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/2.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/2.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/2.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 自定义内容 123456789101112131415161718192021&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/2.jpg&quot;&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h3&gt;an入门到精通&lt;/h3&gt; &lt;p&gt;木瓜煲机脚&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;试看&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-warning&quot;&gt;购买&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--其余2个省略--&gt; &lt;/div&gt;&lt;/div&gt; 2.9 模态框组件 data-toggle&#x3D;”modal” 触发类型:模态框modal data-target&#x3D;”#myModal” 触发的节点 data-backdrop&#x3D;”static” 点击黑灰色背景，不会关闭模态框 12345678910111213141516171819202122232425262728293031&lt;button class=&quot;btn btn-warning&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt;弹框&lt;/button&gt;&lt;!-- 声明定义模态框组件 --&gt;&lt;div class=&quot;modal&quot; id=&quot;myModal&quot; data-backdrop=&quot;static&quot;&gt; &lt;!-- 窗口声明 --&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;!-- 内容声明 --&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;!-- 1.框的标题 --&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt; &lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;友情提示&lt;/h4&gt; &lt;/div&gt; &lt;!-- 2.框内信息 --&gt; &lt;div class=&quot;modal-body&quot;&gt; 服务器错误，请稍后再试！ &lt;hr&gt; &lt;img src=&quot;img/1.jpg&quot; width=&quot;200px&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot;&gt; &lt;/div&gt; &lt;!-- 3.框的按钮 --&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button class=&quot;btn btn-info&quot;&gt;确定&lt;/button&gt; &lt;button class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3.案例3.1 首页轮播大图 大小屏幕自动适应,扩大缩小浏览器 滚动数字区点击左右切换图片 左右区域点击切换 默认5秒钟自动切换下一张 最后一张,回到第一张 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;myCarousel&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- 滚动圆点区 --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-slide-to=&quot;0&quot; data-target=&quot;#myCarousel&quot;&gt;&lt;/li&gt; &lt;li data-slide-to=&quot;1&quot; data-target=&quot;#myCarousel&quot;&gt;&lt;/li&gt; &lt;li data-slide-to=&quot;2&quot; data-target=&quot;#myCarousel&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- 图片区 --&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;img/1.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/2.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/3.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 左右切换 --&gt; &lt;a href=&quot;#myCarousel&quot; data-slide=&quot;prev&quot; class=&quot;carousel-control left&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#myCarousel&quot; data-slide=&quot;next&quot; class=&quot;carousel-control right&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; data 属性解释： data-slide 接受关键字 prev 或 next，用来改变幻灯片相对于当前位置的位置； data-slide-to 来向轮播底部创建一个原始滑动索引，data-slide-to&#x3D;”2” 将把滑动块移动到一个特定的索引，索引从 0 开始计数。 data-ride&#x3D;”carousel”属性用户标记轮播在页面加载时开始动画播放 3.2 响应式导航条 12345678910111213141516171819202122232425262728&lt;!-- 默认的导航条样式 --&gt;&lt;div class=&quot;navbar navbar-default&quot;&gt; &lt;!-- 响应式的容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 导航条的头部 --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;Jasper科技股份有限公司&lt;/a&gt; &lt;!-- data-toggle=&quot;collapse&quot; 数据切换的事件，特效是折叠--&gt; &lt;!-- data-target=&quot;#nav&quot; 折叠效果的目标是下面的#nav容器--&gt; &lt;button class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#nav&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;!-- 导航项 --&gt; &lt;div id=&quot;nav&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li class=&quot;active&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-home&quot;&gt;&lt;/span&gt; 主页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-camera&quot;&gt;&lt;/span&gt; 产品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-tint&quot;&gt;&lt;/span&gt; 竞争&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-earphone&quot;&gt;&lt;/span&gt; 联系我们&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"ECMAScript6详解","slug":"ECMAScript6详解","date":"2020-01-05T10:00:26.000Z","updated":"2025-04-17T08:34:51.958Z","comments":true,"path":"2020/01/05/ECMAScript6详解/","link":"","permalink":"http://yournotes.cn/2020/01/05/ECMAScript6%E8%AF%A6%E8%A7%A3/","excerpt":"1.ECMAScript6 简介ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标","text":"1.ECMAScript6 简介ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言 1.1 ECMAScript 和 JavaScript 的关系 要讲清楚这个问题，需要回顾历史。 1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准 ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。 因此，ECMAScript （宪法）和 JavaScript（律师） 的关系是，前者是后者的规格，后者是前者的一种实现 1.2 ES6 与 ECMAScript 2015 的关系 2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等 2.搭建前端环境2.1 Node 环境2.1.1 什么是Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。JavaScript程序，必须要依赖浏览器才能运行！没有浏览器怎么办？OK，nodejs帮你解决Node.js是脱离浏览器环境运行的JavaScript程序，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 2.1.2 Node.js有什么用如果你是前端程序员，你不懂得像PHP、Python或Ruby等动态编程语言，然后你想创建自己的服务，那Node.js是一个非常好的选择。Node.js 是运行在服务端的 JavaScript，如果你熟悉Javascript，那么你将会很容易的学会Node.js。当然，如果你是后端程序员，想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。 2.1.3 安装下载 官网：https://nodejs.org/en/中文网：http://nodejs.cn/LTS：长期支持版本Current：最新版安装：Windows下双击点击安装——&gt;Next——&gt;finish 注意： node-v14.5.0-x64.msi 最新版本，如果是win7系统的话，可能安装不了。 如果是win7系统，安装node-v10.14.2-x64.msi这个版本 查看版本在dos窗口中执行命令查看版本号 1node -v 创建文件夹 my-node用vscode打开目录，其目录下创建 hello.js 1console.log(&quot;hello,nodejs&quot;); 打开命令行终端：Ctrl + Shift + y输入命令 1node hello.js 第一次运行，可能会报错！兼容性的问题，以管理员身份运行即可 这样，没有使用浏览器，我们也可以运行js程序了 2.1.4 服务器端应用开发（了解） 创建 node-server.js 12345678910111213const http = require(&quot;http&quot;); // node中自带的require引入方法，http也是node中自带的服务对象http.createServer( function(request,response)&#123; // 发出http请求的头部信息 // http的状态码：200；OK // 请求的内容类型：text/plain response.writeHead(200,&#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); //响应的数据 &quot;hello,welcome！&quot; ,此时，并不支持中文（以后一定会解决！） response.end(&quot;hello,welcome!&quot;);&#125; ).listen(8888); // 监听端口console.log(&quot;服务器已启动，请访问 http://127.0.0.1:8888&quot;); 服务器启动成功后，在浏览器中输入：http://localhost:8888/ 查看webserver成功运行，并输出html页面 停止服务：ctrl + c 2.2 NPM环境2.2.1 什么是NPMNPM全称Node Package Manager，是Node.js包管理工具 是全球最大的模块生态系统，里面所有的模块都是开源免费的，也是Node.js的包管理工具，相当于前端的Maven 如果一个项目需要引用很多第三方的js文件，比如地图，报表等，文件杂而乱，自己去网上下载，到处是广告和病毒 那么，我们就想办法，把这些js文件统一放在一个仓库里，大家谁需要，谁就去仓库中拿过来，方便多了 npm就是这个仓库系统，如果你需要某个js文件，那就去远程仓库中下载，放在本地磁盘中，进而引用到我们的项目中 管理前端工程 so easy！ 2.2.2 NPM工具的安装位置node的环境在安装的过程中，npm工具就已经安装好了。 Node.js默认安装的npm包和工具的位置：Node.js目录\\node_modules 在这个目录下你可以看见 npm目录，npm本身就是被NPM包管理器管理的一个工具，说明 Node.js已经集成了npm工具 12#在命令提示符输入 npm -v 可查看当前npm版本npm -v 2.2.3 使用npm管理项目2.2.3.1 项目初始化 全新创建一个目录，作为项目目录，使用dos命令进入此目录，输入命令 12345678910111213npm init# 接下来是一堆项目信息等待着你输入，如果使用默认值或你不知道怎么填写，则直接回车即可。# package name: 你的项目名字叫啥# version: 版本号# description: 对项目的描述# entry point: 项目的入口文件（一般你要用那个js文件作为node服务，就填写那个文件）# test command: 项目启动的时候要用什么命令来执行脚本文件（默认为node app.js）# git repository: 如果你要将项目上传到git中的话，那么就需要填写git的仓库地址（这里就不写地址了）# keywirds： 项目关键字（我也不知道有啥用，所以我就不写了）# author: 作者的名字（也就是你叫啥名字）# license: 发行项目需要的证书（这里也就自己玩玩，就不写了） 最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml我们之后也可以根据需要进行修改。上述初始化一个项目也太麻烦了，要那么多输入和回车。想简单点，一切都按照默认值初始化即可，ok，安排 1npm init -y 2.2.4 修改npm镜像 和 存储地址NPM官方的管理的包都是从 http://npmjs.com下载的，但是这个网站在国内速度很慢。 这里推荐使用淘宝 NPM 镜像 http://npm.taobao.org/ ，淘宝 NPM 镜像是一个完整npmjs.com 镜像，同步频率目前为 10分钟一次，以保证尽量与官方服务同步。 设置镜像和存储地址： 12345678#经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载npm config set registry https://registry.npm.taobao.org#设置npm下载包时保存在本地的地址（建议英文目录）npm config set prefix &quot;E:\\\\repo_npm&quot;#查看npm配置信息npm config list 2.2.5 npm install命令的使用1npm install jquery 使用 npm install 安装依赖包的最新版 模块安装的位置：项目目录\\node_modules 安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本 同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的 &lt;dependencies&gt; jQuery版本有很多，上述命令下载的什么版本的？ 最新版 如果我的项目使用1.9.1版本进行开发的，通过npm安装的3.5.1版本太新，会导致项目失效，如何安装指定版本库？ 1npm install jquery@1.9.1 3. ES6基本语法 ES标准中不包含 DOM 和 BOM的定义，只涵盖基本数据类型、关键字、语句、运算符、内建对象、内建函数等通用语法。 本部分只学习前端开发中ES6的必要知识，方便后面项目开发中对代码的理解。 3.1 let声明变量 与我们的JavaScript中var声明变量有什么区别？ 1、作用域不同 1234567&#123; var a = 0; // var声明的变量是全局变量 let b = 0; // let声明的变量是局部变量&#125;console.log(a);console.log(b); //b is not defined：b没有定义 2、声明次数不同 123456789// var可以声明多次// let只能声明一次var m = 1;var m = 2;let n = 3;let n = 4; //SyntaxError: Identifier &#x27;n&#x27; has already been declared（语法错误：n已经声明过了）console.log(m);console.log(n); 3、声明与使用顺序不同 12345678// var 声明的变量会全局存储// let 声明的变量只能在执行后才存储console.log( x ); //没有报错，输出：undefinedvar x = &quot;苹果&quot;;console.log(y); //y is not defined（y没有定义）let y = &quot;香蕉&quot;; 3.2 const声明常量const 声明常量,为只读变量 一旦声明之后，其值是不允许改变的 一但声明必须初始化，否则会报错 SyntaxError: Missing initializer in const declaration（语法错误，声明常量丢失了初始化） 1234const PI = 3.14;PI = 3.1415; //Assignment to constant variable.（声明的是常量）console.log( PI ); 3.3 解构赋值 解构赋值是对赋值运算符的扩展 它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。 解构，顾名思义，就是将集合型数据进行分解，拆分，把里面的值逐一遍历获取 在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。 3.3.1 数组解构1234567891011var arr = [1,2,3];// 传统的jslet a = arr[0];let b = arr[1];let c = arr[2];console.log(a,b,c);//es6的解构var [x,y,z] = arr;console.log(x,y,z); 3.3.2 对象解构123456789101112131415var user = &#123; username : &quot;吕布&quot;, weapon:&quot;方天画戟&quot;, horse:&quot;赤兔马&quot;&#125;;// 传统的jslet mingzi = user.username;let wuqi = user.weapon;let zuoji = user.horse;console.log(&quot;姓名:&quot;+mingzi+&quot;,武器:&quot;+wuqi+&quot;,坐骑:&quot;+zuoji);//es6的解构let &#123;username,weapon,horse&#125; = user; // 注意：解构的变量名必须是对象中的属性console.log(&quot;姓名:&quot;+username+&quot;,武器:&quot;+weapon+&quot;,坐骑:&quot;+horse); 3.4 模板字符串 模板字符串相当于加强版的字符串 用反引号 &#96;,除了作为普通字符串，还可以用来定义多行字符串 还可以在字符串中加入变量和表达式。 3.4.1 定义多行字符串再见了&quot;\\n&quot; 12345let str = `hello,你俩在哪呢？心情不好，出来喝点啊！`;console.log(str); 3.4.2 字符串插入变量和表达式再见了，字符串的拼接用 &quot;+&quot; 12345678910let name = `吕布`;let age = 24;// 传统的拼接字符串var info1 = &quot;我叫:&quot;+ name +&quot;,我今年&quot;+age+&quot;岁！&quot;;console.log(info1);// es6的拼接字符串var info2 = `我叫:$&#123;name&#125;,我明年$&#123;age+1&#125;岁！`;console.log(info2); 3.4.3 字符串中调用函数还能这么玩 123456function test()&#123; return &quot;吃喝玩乐&quot;;&#125;let str = `悲催的人生，从$&#123;test()&#125;开始`;console.log( str ); 3.5 声明对象简写定义对象的时候，可以用变量名作为属性名 12345678910111213let name = `吕布`;let age = 28;//传统let user1 = &#123; name : name, age : age&#125;;console.log(user1);//es6新语法中的简写let user2 = &#123;name,age&#125;;console.log(user2); 3.6 定义方法简写1234567891011121314151617// 传统let user1 = &#123; say : function()&#123; console.log(&quot;大家好！&quot;); &#125;&#125;;user1.say();//es6let user2 = &#123; say()&#123; console.log(&quot;大家好啊！&quot;); &#125;&#125;;user2.say(); 3.7 对象拓展运算符拓展运算符 {…} 将参数对象中所有可以遍历的属性拿出来，然后拷贝给新对象 3.7.1 拷贝对象(深拷贝)科幻电影中的一滴血，就可以制作出一个完全一模一样的克隆人 123456789let user1 = &#123; name:&quot;项羽&quot;, age:34&#125;;let user2 = &#123;...user1&#125;; // 深拷贝（克隆）console.log(user1);console.log(user2); 3.7.2 合并对象吞噬合并（两个对象合并成一个对象） 12345678910let user1 = &#123; name:&quot;项羽&quot;, age:34&#125;;let user2 = &#123;head:&quot;诸葛亮&quot;&#125;;let user = &#123;...user1,...user2&#125;;console.log( user ); 3.8 函数的默认参数形参处已声明，但不传入实参会怎样？ 123456789function test(name , age = 18)&#123; console.log(`我叫$&#123;name&#125;，我今年$&#123;age&#125;岁`);&#125;test(&quot;吕布&quot;,33); //我叫吕布，我今年33岁test(&quot;貂蝉&quot;); //我叫貂蝉，我今年18岁test(&quot;关羽&quot;,null); //我叫关羽，我今年null岁test(&quot;马超&quot;,&quot;&quot;); //我叫马超，我今年岁test(&quot;张飞&quot;,undefined); //我叫张飞，我今年18岁 3.9 函数的不定参数定义方法时，不确定有几个参数？ 123456789101112function test( ...arg )&#123; console.log(`传入了$&#123;arg.length&#125;个参数`); for(var i = 0 ;i&lt;arg.length;i++)&#123; console.log(arg[i]); &#125;&#125;test(1);test(1,2);test(1,2,3,4,5,6);test();test(&quot;郭&quot;,&quot;嘉&quot;,28); 3.10 箭头函数箭头函数提供了一种更加简洁的函数书写方式。基本语法是：参数 &#x3D;&gt; 函数体 12345678910111213141516171819202122232425// 传统var f1 = function(a)&#123; return a*10;&#125;console.log( f1(10) );// es6var f2 = a=&gt;a*10;console.log( f2(20) );// 当箭头函数一个参数时，（）可以省略// 当箭头函数没有参数或者有多个参数，要用（）括起来// 当箭头函数的函数体有多行语句，用｛｝括起来，表示代码块// 当只有一条语句，并且需要返回时，可以省略｛｝，结果会自动返回var f3 = (a,b) =&gt; &#123; let sum = a+b; return sum;&#125;console.log( f3(3,7) );// 可以将f3进行简化var f4 = (a,b) =&gt; a + b;console.log( f3(11,22) ); 3.11 Promise（了解） 用来解决回调函数的嵌套噩梦 （后面学习ajax才能更好的理解） 我们回顾一下嵌套噩梦： 你和我打架，我打不过你，我说：你在这等着，我找我哥来揍你！ “哥，我被老王打了，你帮我揍他！”，“行，我先把饭做完，你先去找刘备，把刘备找来，我和刘备再一起帮你报仇！” “刘备，我被老王打了，我哥叫我来找你，一起帮我报仇！”，“没问题，兄弟，我去交电话费，你去找我二弟关羽，他打架厉害，把他叫来，我们一起更有把握！” “关羽，我被人打了，我哥叫我找刘备，刘备让我来找你，一起帮我报仇！”，“没问题，兄弟，我有点事，你先去找我三弟张飞，把张飞找来，我这边就办完事了，我们一起帮你报仇去！” “张飞，我让老王打了，谁谁谁，哎，反正关羽让我找你，你跟我走，一起帮我报仇去！”，“行啊，老铁，我一会从老丈人回来就去找你，你去把我二哥的儿子关平找来，正好打一架让这小子练练胆。找到了我们一起帮你报仇！” 。。。 满嘴的兄弟情深，一个拖一个，就是不想帮我报仇 使用promise解决掐架找人的噩梦 “哥，老王打我！”，“走，但老王厉害，我们去找刘备一起帮你报仇！” “刘备，走着，我们一起揍老王去”，“没问题！”，“二弟，过来，有人欺负我们，去揍他！” 。。。找人过程中，都是立刻跟着走，没人拖！ 最终，我们108人一起找到了老王！！！！ 找到一个人成功后，再继续找下一个人。逐渐形成了“队伍” 组建队伍的过程中，如果找某个人失败了，则“队伍”失败 其实有点类似“击鼓传花”的游戏，一个成功拿到花之后，才能传递给下一个人。依次类推！ 123456789101112setTimeout(()=&gt;&#123; console.log(1); setTimeout(()=&gt;&#123; console.log(2); setTimeout(()=&gt;&#123; console.log(3); setTimeout(()=&gt;&#123; console.log(4); &#125;,1000); &#125;,1000); &#125;,1000);&#125;,1000); 使用promise 123456789101112131415161718192021222324next = n =&gt; //Promise的构造函数接收一个参数，是函数， //并且传入两个参数：resolve(异步操作执行成功后的回调函数)，reject(异步操作执行失败后的回调函数) new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(n); &#125;, 1000); &#125;);next(1) .then(res =&gt; &#123; // 成功 console.log(res); return next(2); //在then方法中调用的next方法，一定要用return ，否则不会通过resolve把数据往下传递 &#125;) .then(res =&gt; &#123; console.log(res); return next(3); &#125;) .then(res =&gt; &#123; console.log(res); &#125;) .catch(() =&gt; &#123; //处理失败：catch方法的第二个参数是失败的回调 console.log(&quot;出错啦！&quot;); &#125;); 3.12 模块化 如果在a.js文件中定义了5个方法，现在b.js文件中想使用a中的5个方法，怎么办？ java语言的做法是import引入之后，就能使用了。es6的模块化，就是这个过程 将一个js文件声明成一个模块导出之后，另一个js文件才能引入这个模块 每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。 3.12.1 传统的模块化创建user.js文件 12345678910111213141516171819function addUser(name)&#123; return `保存$&#123;name&#125;成功！`;&#125;function removeUser(id)&#123; return `删除$&#123;id&#125;号用户！`;&#125;// 声明模块并导出// module.exports=&#123;// save:addUser,// delete:removeUser// &#125;// 声明模块导出的简写module.exports=&#123; addUser, removeUser&#125; test.js 123456789let user = require(&quot;./user.js&quot;); //引入user模块console.log( user );let result1 = user.addUser(&quot;吕布&quot;);let result2 = user.removeUser(101);console.log(result1);console.log(result2); 3.12.2 ES6的模块化user.js 123456789101112let name = &quot;老孙&quot;;let age = 66;let fn = function()&#123; return `我是$&#123;name&#125;!我今年$&#123;age&#125;岁了！`;&#125;// 声明模块并导出export&#123; name, age, fn&#125; test.js 12345import &#123;name,age,fn&#125; from &quot;./user.js&quot;console.log(name);console.log(age);console.log(fn); 运行test.js，报错：SyntaxError: Unexpected token { （语法错误，在标记{的位置 ） 原因是node.js并不支持es6的import语法，我们需要将es6转换降级为es5！ 3.13 babel环境babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有的环境中执行。 这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 3.13.1 安装babel客户端环境创建新目录 lagou-babel，在终端中打开，运行命令： 1npm install --global babel-cli 查看版本 1babel --version 如果报错1：（win7系统中） ‘babel’ 不是内部或外部命令，也不是可运行的程序或批处理文件。（babel命令在当前系统中不被认可） 由于babel是通过npm安装，所以babel会默认安装到 E:\\repo_npm 在 E:\\repo_npm 这个目录下，进入dos命令，执行 babel –version， 如果是成功的，说明babel已经安装成功 但是在vscode的终端中打不开，那么只可能是两个原因： 环境变量没有配置 系统环境变量中 path中加入 ;E:\\repo_npm; 在任意位置进入dos窗口，babel –version可以了，说明环境变量配置成功 vscode关掉，重新以“管理员身份运行 ” 如果报错2：（win10系统中） windows10默认禁止运行有危险的脚本，修改一下系统策略就好了 开始菜单-&gt; Windows PowerShell (切记要以管理员身份运行)，输入代码 1set-ExecutionPolicy RemoteSigned 现在，就可以看版本号了。 3.13.2 安装转码器 创建lagou-babel专属目录，在其中初始化项目 1npm init -y 创建babel配置文件 .babelrc ，并输入代码配置： 1234&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: []&#125; 安装转码器 1npm install --save-dev babel-preset-es2015 转码 创建dist目录，用来存放转码后的文件 123babel user.js --out-file .\\dist\\user.js或babel user.js -o .\\dist\\user.js 运行转码后的文件 1node .\\dist\\test.js 3.14 ES6模块化的另一种写法3.14.1 as的用法user.js：如果你不想暴露模块当中的变量名字，可以通过as来进行操作: 123456789101112let name = &quot;木瓜煲鸡脚&quot;;let age = 20;let fn = function()&#123; return `我是$&#123;name&#125;!我今年$&#123;age&#125;岁了！`;&#125;// 声明模块并导出export&#123; name as a, age as b, fn as c&#125; test.js 12345import &#123;a,b,c&#125; from &quot;./user.js&quot;;console.log(a);console.log(b);console.log( c() ); 也可以接收整个模块 test.js 12345import * as info from &quot;./user.js&quot;; // 通过*来批量接收，as来指定接收的名字console.log(info.a);console.log(into.b);console.log( into.c() ); 3.14.2 默认导出可以将所有需要导出的变量放入一个对象中，然后通过default export进行导出 1234567891011/*****************导出****************************/export default&#123; name:&quot;木瓜煲鸡脚&quot;, eat()&#123; return &quot;吃点啥！&quot;; &#125;&#125;/*****************导入****************************/import p from &quot;./person.js&quot;;console.log( p.name, p.eat() ); 3.14.3 重命名export和import如果导入的多个文件中，变量名字相同，即会产生命名冲突的问题， 为了解决该问题，ES6为提供了重命名的方法，当你在导入名称时可以这样做： 123456789101112/*******************student1.js**************************/export let name = &quot;我是来自student1.js&quot;;/*******************student2.js************************/export let name = &quot;我是来自student2.js&quot;;/*******************test_student.js************************/import &#123;name as name1&#125; from &#x27;./student1.js&#x27;;import &#123;name as name2&#125; from &#x27;./student2.js&#x27;;console.log( name1 ); // 我是来自student1.jsconsole.log( name2 ); // 我是来自student2.js","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"JQuery详解","slug":"JQuery详解","date":"2020-01-05T09:28:10.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2020/01/05/JQuery详解/","link":"","permalink":"http://yournotes.cn/2020/01/05/JQuery%E8%AF%A6%E8%A7%A3/","excerpt":"1.jQuery介绍 jQuery由美国人John Resig（约翰·莱西格）于2006年创建","text":"1.jQuery介绍 jQuery由美国人John Resig（约翰·莱西格）于2006年创建 jQuery是目前最流行的JavaScript程序库，它是对JavaScript对象和函数的封装 它的设计思想是write less,do more 实现隔行变色效果，JavaScript要循环加判断，而jQuery只需一句关键代码 1$(&quot;tr:even&quot;).css(&quot;background-color&quot;,&quot;#ccc&quot;); 1.1 jQuery能做什么? 访问和操作DOM元素 控制页面样式 对页面事件进行处理 扩展新的jQuery插件 与Ajax技术完美结合 jQuery能做的JavaScript也都能做，但使用jQuery能大幅提高开发效率 其实，jQuery和JavaScript的之间关系，可以理解为“成语”和“白话文”之间的关系。成语是对白话文的高度压缩，而jQuery也是对JavaScript的高度压缩库 1.2 jQuery的优势 体积小，压缩后只有100KB左右 强大的选择器 出色的DOM封装 可靠的事件处理机制 出色的浏览器兼容性 1.3 jQuery下载进入jQuery官网：http://jQuery.com 我们使用压缩版就可以。体积更小，内容已经通过算法进行压缩， 不会浪费资源空间！而开发版就针对修改jQuery源码的专业前端开发者的。就是一个压缩了格式一个没压缩便于看源码 2 jQuery的使用jQuery作为一个单独存在的js文件，并不会与其他的js文件发生冲突在页面中使用传统引入js文件的方式引入即可。 1&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; 2.1 基本的语法介绍123&lt;script&gt; $(selector).action();&lt;/script&gt; 说明： 工厂函数 $() ：将DOM对象转化为jQuery对象 选择器 selector：获取需要操作的DOM 元素（没错，用法基本上和css一致 ） 方法action()：jQuery中提供的方法，其中包括绑定事件处理的方法“$”等同于“ jQuery ” 例如： 1234567&lt;body&gt; &lt;p&gt;hello&lt;/p&gt;&lt;/body&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; alert( $(&quot;p&quot;).text() );&lt;/script&gt; 2.2 jQuery对象与DOM对象DOM对象和jQuery对象分别拥有一套独立的方法，不能混用 123$(&quot;#title&quot;).html();// 等同于document.getELementById(&quot;title&quot;).innerHTML; 想混用，要转换 DOM对象转jQuery对象 12var a = document.getElementById(&quot;name&quot;); // a是DOM对象var b = $(a); // b是jQuery对象 jQuery对象转DOM对象 12var a = $(&quot;#name&quot;); // a是jQuery对象var b = jqObject.get(0); // b是DOM对象 2.3 选择器2.3.1 基本选择器基本选择器包括标签选择器、类选择器、ID选择器、并集选择器、交集选择器和全局选择器 名称 语法构成 描述 示例 标签选择器 element 根据给定的标签名匹配元素 $(“h2” )选取所有h2元素 类选择器 .class 根据给定的class匹配元素 $(“ .title”)选取所有class为title的元素 ID选择器 #id 根据给定的id匹配元素 $(“ #title”)选取id为title的元素 并集选择器 selector1,selector2,…,selectorN 将每一个选择器匹配的元素合并后一起返回 $(“div,p,.title” )选取所有div、p和拥有class为title的元素 交集选择器 element.class或element#id 匹配指定class或id的某元素或元素集合 $(“h2.title”)选取所有拥有class为title的h2元素 1234567891011121314&lt;p&gt;中国&lt;/p&gt;&lt;p&gt;武汉&lt;/p&gt;&lt;p class=&quot;jy&quot;&gt;加油&lt;/p&gt;&lt;p id=&quot;wan&quot;&gt;祖国万岁&lt;/p&gt;&lt;h3 class=&quot;jy&quot;&gt;祖国万岁&lt;/h3&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //$(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;); // 标签选择器，获得所有的p //$(&quot;.jy&quot;).css(&quot;color&quot;,&quot;red&quot;); //类选择器 //$(&quot;#wan&quot;).css(&quot;color&quot;,&quot;red&quot;); //ID选择器,更具备唯一性 //$(&quot;.jy,#wan&quot;).css(&quot;color&quot;,&quot;red&quot;); // 并集选择器，.jy和#wan $(&quot;h3.jy&quot;).css(&quot;color&quot;,&quot;red&quot;); // 交集选择器，既是h3标签，又拥有.jy的元素&lt;/script&gt; 2.3.2 层次选择器 名称 语法构成 描述 示例 后代选择器 ancestor descendant 选取ancestor元素里的所有descendant（后代）元素 $(“#menu span” )选取#menu下的&lt;span&gt;元素 子选择器 parent&gt;child 选取parent元素下的child（子）元素 $(“ #menu&gt;span” )选取#menu的子元素&lt;span&gt; 相邻元素选择器 prev+next 选取紧邻prev元素之后的next元素 $(“ h2+dl “ )选取紧邻&lt;h2&gt;元素之后的同辈元素&lt;dl&gt; 同辈元素选择器 prev~sibings 选取prev元素之后的所有siblings元素 $(“ h2~dl “ )选取&lt;h2&gt;元素之后所有的同辈元素&lt;dl&gt; 123456789101112131415161718&lt;h3&gt;000&lt;/h3&gt;&lt;div id=&quot;x&quot;&gt; 111 &lt;p&gt;p1&lt;/p&gt; &lt;div&gt; &lt;p&gt;p2&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;h3&gt;222&lt;/h3&gt; &lt;h3&gt;333&lt;/h3&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //$(&quot;#x p&quot;).css(&quot;color&quot;,&quot;red&quot;); // 后代选择器，忽略层级 //$(&quot;#x&gt;p&quot;).css(&quot;color&quot;,&quot;red&quot;); // 子代选择器，只负责子级 //$(&quot;#x+h3&quot;).css(&quot;color&quot;,&quot;red&quot;); // 相邻元素选择器，下一个紧邻的兄弟h3 $(&quot;#x~h3&quot;).css(&quot;color&quot;,&quot;red&quot;); // 同辈元素选择器，下面的所有兄弟h3&lt;/script&gt; 2.3.3 属性选择器 名称 语法构成 描述 示例 属性选择器 [attribute] 选取包含给定属性的元素 $(“ [href]” )选取含有href属性的元素 [attribute&#x3D;value] 选取等于给定属性是某个特定值的元素 $(“ [href &#x3D;’#’]” )选取href属性值为“#”的元素 [attribute !&#x3D;value] 选取不等于给定属性是某个特定值的元素 $(“ [href !&#x3D;’#’]” )选取href属性值不为“#”的元素 [attribute^&#x3D;value] 选取给定属性是以某些特定值开始的元素 $(“ [href^&#x3D;’en’]” )选取href属性值以en开头的元素 [attribute$&#x3D;value] 选取给定属性是以某些特定值结尾的元素 $(“ [href$&#x3D;’.jpg’]” )选取href属性值以.jpg结尾的元素 [attribute*&#x3D;value] 选取给定属性是以包含某些值的元素 $(“ [href* &#x3D;’txt’]” )选取href属性值中含有txt的元素 [s1] [s2] [sN] 选取满足多个条件的复合属性的元素 $(“li[id][title&#x3D;新闻]” )选取含有id和title属性为新闻的&lt;li&gt;元素 123456789101112131415161718&lt;a href=&quot;www.lagou.com&quot;&gt;拉勾网&lt;/a&gt;&lt;a href=&quot;www.sina.com.cn&quot;&gt;新浪网&lt;/a&gt;&lt;a href=&quot;http://www.163.com&quot;&gt;网易&lt;/a&gt;&lt;p href=&quot;x&quot;&gt;哈哈1&lt;/p&gt;&lt;p href=&quot;x&quot; title=&quot;x&quot;&gt;哈哈2&lt;/p&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //$(&quot;[href]&quot;).css(&quot;color&quot;,&quot;red&quot;); // 选取拥有href属性的元素 //$(&quot;[href=&#x27;x&#x27;]&quot;).css(&quot;color&quot;,&quot;red&quot;); // 选取拥有href=x的元素 //$(&quot;a[href!=&#x27;x&#x27;]&quot;).css(&quot;color&quot;,&quot;red&quot;); // 选取a标签中href不等于x的元素 //$(&quot;[href^=&#x27;www&#x27;]&quot;).css(&quot;color&quot;,&quot;red&quot;); // 选取href属性以www开头的元素 //$(&quot;[href$=&#x27;com&#x27;]&quot;).css(&quot;color&quot;,&quot;red&quot;); // 选取href属性以com结尾的元素 //$(&quot;[href*=&#x27;a&#x27;]&quot;).css(&quot;color&quot;,&quot;red&quot;); // 选取href属性包含a的元素 $(&quot;p[href][title=&#x27;x&#x27;]&quot;).css(&quot;color&quot;,&quot;red&quot;); // 选取拥有href属性和title属性，并且title=x的p元素&lt;/script&gt; 2.3.4 过滤选择器 语法构成 描述 示例 :first 选取第一个元素 $(“ li:first” )选取所有元素中的第一个元素 :last 选取最后一个元素 $(“ li:last” )选取所有元素中的最后一个元素 :even 选取索引是偶数的所有元素（index从0开始） $(“ li:even” )选取索引是偶数的所有元素 :odd 选取索引是奇数的所有元素（index从0开始） $(“ li:odd” )选取索引是奇数的所有元素 :eq(index) 选取索引等于index的元素（index从0开始） $(“li:eq(1)” )选取索引等于1的元素 :gt(index) 选取索引大于index的元素（index从0开始） $(“ li:gt(1)” )选取索引大于1的元素（注：大于1，不包括1） :lt(index) 选取索引小于index的元素（index从0开始） $(“li:lt(1)” )选取索引小于1的元素（注：小于1，不包括1） 123456789101112131415161718192021&lt;h2 id=&quot;h2#x&quot;&gt;修仙小说&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;凡人修仙传&lt;/li&gt; &lt;li&gt;遮天&lt;/li&gt; &lt;li&gt;神墓&lt;/li&gt; &lt;li&gt;残袍&lt;/li&gt; &lt;li&gt;大主宰&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //$(&quot;li:first&quot;).css(&quot;color&quot;,&quot;red&quot;); // 第一个li //$(&quot;li:last&quot;).css(&quot;color&quot;,&quot;red&quot;); // 最后一个li //$(&quot;li:even&quot;).css(&quot;color&quot;,&quot;red&quot;); // 偶数行的li //$(&quot;li:odd&quot;).css(&quot;color&quot;,&quot;red&quot;); // 奇数行的li //$(&quot;li:eq(2)&quot;).css(&quot;color&quot;,&quot;red&quot;); // 下标为2的li //$(&quot;li:gt(1)&quot;).css(&quot;color&quot;,&quot;red&quot;); // 下标大于1的li //$(&quot;li:lt(2)&quot;).css(&quot;color&quot;,&quot;red&quot;); // 下标小于2的li $(&quot;#h2\\\\#x&quot;).css(&quot;color&quot;,&quot;red&quot;); // 使用转义符&lt;/script&gt; 2.4 事件2.4.1 鼠标事件鼠标事件是当用户在文档上移动或单击鼠标时而产生的事件，常用鼠标事件有： 方法 描述 执行时机 click( ) 触发或将函数绑定到指定元素的click事件 单击鼠标时 mouseover( ) 触发或将函数绑定到指定元素的mouse over事件 鼠标移过时 mouseout( ) 触发或将函数绑定到指定元素的mouse out事件 鼠标移出时 1234567891011121314151617181920&lt;img src=&quot;img/1.jpg&quot; width=&quot;300&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; width=&quot;300&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; width=&quot;300&quot;&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;img&quot;).click( function()&#123; //点击一下，换照片 $(this).attr( &quot;src&quot;,&quot;img/2.jpg&quot; ); //this就是事件触发的源头 &#125; ); $(&quot;img&quot;).mouseover( function()&#123; //移动到元素上 $(this).css( &quot;border&quot;,&quot;2px solid red&quot; ); &#125; ); $(&quot;img&quot;).mouseout( function()&#123; //离开元素 $(this).css( &quot;border&quot;,&quot;2px solid white&quot; ); &#125; );&lt;/script&gt; 2.4.2 键盘事件用户每次按下或者释放键盘上的键时都会产生事件，常用键盘事件有： 方法 描述 执行时机 keydown( ) 触发或将函数绑定到指定元素的keydown事件 按下键盘时 keyup( ) 触发或将函数绑定到指定元素的keyup事件 释放按键时 12345678910&lt;input&gt;&lt;h3&gt;&lt;/h3&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;input&quot;).keyup( function()&#123; var str = $(this).val(); // 获取框中的值 $(&quot;h3&quot;).text( str ); // 将h3元素中的文本内容更改为str &#125; );&lt;/script&gt; 2.4.3 表单事件当元素获得焦点时，会触发focus事件，失去焦点时，会触发blur事件，详见下表： 方法 描述 执行时机 focus( ) 触发或将函数绑定到指定元素的focus事件 获得焦点 blur( ) 触发或将函数绑定到指定元素的blur事件 失去焦点 1234567891011121314151617&lt;form action=&quot;&quot;&gt; &lt;p&gt;帐号: &lt;input id=&quot;a&quot; value=&quot;请输入帐号...&quot;&gt; &lt;/p&gt; &lt;p&gt;电话: &lt;input id=&quot;b&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //获得焦点（激活/点击一下） $(&quot;#a&quot;).focus(function()&#123; $(this).val(&quot;&quot;); &#125;); //失去焦点（未激活/未点击） $(&quot;#a&quot;).blur(function()&#123; $(this).val(&quot;请输入帐号...&quot;); &#125;);&lt;/script&gt; 2.4.4 鼠标悬停复合事件hover()方法相当于mouseover与mouseout事件的组合 12345678910111213&lt;img src=&quot;img/3.jpg&quot; width=&quot;400&quot;&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;img&quot;).hover( function()&#123; $(this).css(&quot;border&quot;,&quot;5px solid red&quot;); &#125;, function()&#123; $(this).css(&quot;border&quot;,&quot;5px solid white&quot;); &#125; );&lt;/script&gt; 2.4.5 连续点击复合事件toggle()除了可以模拟鼠标的连续单击事件 123456789101112131415&lt;h2&gt;修仙小说&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;凡人修仙传&lt;/li&gt; &lt;li&gt;遮天&lt;/li&gt; &lt;li&gt;神墓&lt;/li&gt; &lt;li&gt;残袍&lt;/li&gt; &lt;li&gt;大主宰&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;h2&quot;).click(function()&#123; $(&quot;ul&quot;).toggle(); // 连续点击，ul的可见和隐藏进行切换 &#125;);&lt;/script&gt; 2.4.6 事件的动态绑定对dom元素绑定事件的另一种写法 绑定一个事件 123$(&quot;.del&quot;).on(&#x27;click&#x27;, function() &#123; alert(&#x27;hello&#x27;);&#125;) 绑定多个事件 123$(&quot;.del&quot;).on(&#x27;click mouseover&#x27;, function() &#123; alert(&#x27;hello&#x27;);&#125;) 2.5 元素的隐藏和显示2.5.1 改变元素的宽和高（带动画效果） show( speed )：显示 hide( speed )：隐藏 toggle( speed )等价于show+hide : 显示的隐藏，隐藏的显示 可选的 speed 参数规定隐藏&#x2F;显示的速度，可以取以下值：”slow”、”fast” 或毫秒 1234567891011121314151617181920212223242526272829303132&lt;style&gt; div&#123; width: 200px; height: 200px; background-color: black; &#125;&lt;/style&gt;&lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;显示&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;隐藏&lt;/button&gt; &lt;button id=&quot;btn3&quot;&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;#btn2&quot;).click(function()&#123; //fast:快速的 //slow:缓慢的 //毫秒：自定义 $(&quot;div&quot;).hide(2000); &#125;); $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div&quot;).show(&#x27;slow&#x27;); &#125;); $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div&quot;).toggle(1000); &#125;); &lt;/script&gt;&lt;/body&gt; 2.5.2 改变元素的高（拉伸效果） slideDown( speed ) ：显示 slideUp( speed )：隐藏 slideToggle( speed )等价于slideDown+slideUp 可选的 speed 参数规定隐藏&#x2F;显示的速度，可以取以下值：”slow”、”fast” 或毫秒 12345678910111213&lt;script&gt; $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div&quot;).slideUp(1000); //向上收缩 &#125;); $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div&quot;).slideDown(1000); //向下伸展 &#125;); $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div&quot;).slideToggle(1000); //切换 &#125;);&lt;/script&gt; 2.5.3 不改变元素的大小（淡入淡出效果） fadeIn( speed ) 显示 fadeOut( speed ) 隐藏 fadeToggle( speed ) 等价于fadeIn+fadeOut动画 fadeTo( speed , 透明度 ) 方法允许渐变为给定的不透明度（值介于 0 与 1 之间） 可选的 speed 参数规定隐藏&#x2F;显示的速度，可以取以下值：”slow”、”fast” 或毫秒 1234567891011121314151617&lt;script&gt; $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div&quot;).fadeOut(1000); // 隐藏：淡出我的视线 &#125;); $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div&quot;).fadeIn(1000); // 显示：映入眼帘 &#125;); $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div&quot;).fadeToggle(1000); // 切换 &#125;); $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div&quot;).fadeTo(1000,0.5); // 1秒内变成50%的透明度 &#125;);&lt;/script&gt; 2.5.4 链链是允许我们在同一个元素上在一条语句中运行多个jQuery方法，可以把动作&#x2F;方法链接在一起 ；例如：点击一次按钮，让div完成4个指定动作 背景变粉 字体变绿 收缩 拉伸 12345678910111213141516171819&lt;style&gt; div&#123; width: 200px; height: 200px; background-color: black; color:white; font-size: 3em; &#125; &lt;/style&gt;&lt;body&gt; &lt;button&gt;试试&lt;/button&gt; &lt;div&gt;hello&lt;/div&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;button&quot;).click(function()&#123; $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;).css(&quot;color&quot;,&quot;green&quot;).slideUp(1000).slideDown(1000); &#125;); &lt;/script&gt;&lt;/body&gt; 2.6 DOM和CSS的操作2.6.1 属性函数 attr( “属性” ); 获得元素的属性值 attr( “属性” , “新值” ); 修改元素的属性值 attr( 样式参数 ) ：样式参数可以写成json格式 1234567891011121314&lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;点我试试&lt;/button&gt; &lt;hr&gt; &lt;img src=&quot;img/1.jpg&quot; title=&quot;美女大图&quot; width=&quot;300&quot;&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;#btn1&quot;).click(function()&#123; $(&quot;img&quot;).attr(&quot;src&quot;,&quot;img/2.jpg&quot;); $(&quot;img&quot;).attr(&quot;title&quot;,&quot;高清无码&quot;); $(&quot;img&quot;).attr( &#123;width:&quot;200&quot;,height:&quot;200&quot;&#125; ); &#125;); &lt;/script&gt;&lt;/body&gt; val() ; 获得表单元素中的value值 val(“x”) 修改表单元素中的value值 html(); 获得元素中的内容（标签+文本） html(“x”) 修改元素中的内容（标签+文本） text(); 获得元素中的文本 text(“x”) 修改元素中的文本 12345678910111213141516171819&lt;button&gt;试试&lt;/button&gt;&lt;hr&gt;&lt;input id=&quot;username&quot;&gt;&lt;div&gt; &lt;h1&gt;&lt;i&gt;中国加油！&lt;/i&gt;&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;button&quot;).click(function()&#123; //alert($(&quot;input&quot;).val()); //input框中的值 //$(&quot;input&quot;).val(&quot;哈哈哈&quot;); //修改input框中的值 //alert( $(&quot;div&quot;).html() ); //获得div中的内容（包含标签信息） //alert( $(&quot;div&quot;).text() ); //获得div中的内容（不包含标签信息，只包含文本内容） $(&quot;div&quot;).text(&quot;祖国万岁！&quot;); //修改div中的内容（全部内容都覆盖） &#125;);&lt;/script&gt; 2.6.2 样式函数 css( “属性”); 获得该属性值 css( “属性”,”值”); 设置属性的值 css( { json} ); 设置多个属性的值 123456789101112131415161718192021222324252627282930313233&lt;style&gt; div&#123; width: 150px; height: 150px; background-color: #000; &#125;&lt;/style&gt;&lt;body&gt; &lt;button&gt;试试&lt;/button&gt; &lt;hr&gt; &lt;div&gt;&lt;/div&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;button&quot;).click(function()&#123; //var w = $(&quot;div&quot;).css(&quot;width&quot;); // 获取css属性，width的值 //1.一个键值对 //$(&quot;div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;); //2.链式编程 //$(&quot;div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;).css(&quot;border-radius&quot;,&quot;50%&quot;); //3.json为参数 $(&quot;div&quot;).css(&#123; opacity:&quot;0.4&quot;, background:&quot;orange&quot;, borderRadius:&quot;50%&quot; &#125; ); &#125;); &lt;/script&gt;&lt;/body&gt; width(); 获得元素的宽度 width( number ); 修改元素的宽度 height(); 获得元素的高度 height( number ); 修改元素的高度 1234567891011121314151617181920212223&lt;style&gt; div&#123; width: 150px; height: 150px; background-color: #000; &#125;&lt;/style&gt;&lt;body&gt; &lt;button&gt;试试&lt;/button&gt; &lt;hr&gt; &lt;div&gt;&lt;/div&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;button&quot;).click(function()&#123; var w = $(&quot;div&quot;).width(); // （无参）获取宽度 var h = $(&quot;div&quot;).height();// （无参）获取高度 // alert(&quot;宽:&quot;+w+&quot;px，高:&quot;+h+&quot;px&quot;); $(&quot;div&quot;).width(&quot;300&quot;); // （传参）修改宽度 $(&quot;div&quot;).height(&quot;300&quot;); //（传参）修改高度 &#125;); &lt;/script&gt;&lt;/body&gt; 2.6.3 类样式函数 addClass(); 为元素添加类样式 removeClass(); 将元素的类样式移除 toggleClass(); 样式的切换（有-&gt;无，无-&gt;有） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; div&#123; width: 100px; height: 100px; background-color: #000; &#125; .a&#123; background: palevioletred; border-radius: 50%; &#125; .b&#123; border:5px dashed darkcyan; opacity: 0.6; &#125; .cn&#123; background: #000; color:#FFF; font-family: 字魂49号-逍遥行书; &#125;&lt;/style&gt;&lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;试试&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;取消透明度&lt;/button&gt; &lt;button id=&quot;btn3&quot;&gt;样式切换&lt;/button&gt; &lt;hr&gt; &lt;div&gt;&lt;/div&gt; &lt;h1&gt;中华人民共和国，万岁！&lt;/h1&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;#btn1&quot;).click(function()&#123; // $(&quot;div&quot;).addClass(&quot;a&quot;); $(&quot;div&quot;).addClass(&quot;a b&quot;); &#125;); $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div&quot;).removeClass(&quot;b&quot;); &#125;); $(&quot;#btn3&quot;).click(function()&#123; $(&quot;h1&quot;).toggleClass(&quot;cn&quot;); &#125;); &lt;/script&gt;&lt;/body&gt; 2.6.4 节点操作 创建节点 工厂函数$()用于获取或创建节点 插入节点 插入子节点 语法 功能 append(content) $(A).append(B)表示将B追加到A中，如：$(“ul”).append($newNode1); appendTo(content) $(A).appendTo(B)表示把A追加到B中，如：$newNode1.appendTo(“ul”); prepend(content) $(A). prepend (B)表示将B前置插入到A中，如：$(“ul”). prepend ($newNode1); prependTo(content) $(A). prependTo (B)表示将A前置插入到B中，如：$newNode1. prependTo (“ul”); 插入同辈节点 语法 功能 after(content) $(A).after (B)表示将B插入到A之后，如：$(“ul”).after($newNode1); insertAfter(content) $(A). insertAfter (B)表示将A插入到B之后，如：$newNode1.insertAfter(“ul”); before(content) $(A). before (B)表示将B插入至A之前，如：$(“ul”).before($newNode1); insertBefore(content) $(A). insertBefore (B)表示将A插入到B之前，如：$newNode1.insertBefore(“ul”); 替换节点 replaceWith() replaceAll() 复制节点 clone() 删除节点 remove()删除整个节点 empty()清空节点内容 123456789101112131415161718192021222324252627282930313233343536373839&lt;input&gt; &lt;button id=&quot;test&quot;&gt;测试&lt;/button&gt;&lt;ul&gt; &lt;li&gt;金瓶梅&lt;/li&gt; &lt;li&gt;貂蝉往事&lt;/li&gt; &lt;li&gt;东京热不热&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;#test&quot;).click(function()&#123; var bookname = $(&quot;input&quot;).val(); var newli = $(&quot;&lt;li&gt;&quot;+bookname+&quot;&lt;/li&gt;&quot;); //通过工厂函数，创建新的li节点 /*添加子节点*/ //$(&quot;ul&quot;).append(newli); // newli添加到ul后面 //newli.appendTo(&quot;ul&quot;); // newli添加到ul后面 //$(&quot;ul&quot;).prepend(newli); // newli添加到ul前面 //newli.prependTo(&quot;ul&quot;); /*添加同辈节点*/ //$(&quot;li:last&quot;).after( newli ); // newli添加到最后的li的后面 //newli.insertAfter(&quot;li:last&quot;); //$(&quot;li:last&quot;).before(newli); //newli添加到最后的li的前面 //newli.insertBefore(&quot;li:last&quot;); /*替换节点*/ //$(&quot;li:eq(1)&quot;).replaceWith(newli); // 将第二个li替换成newli //newli.replaceAll( &quot;li:eq(1)&quot; ); /*复制节点*/ //$(&quot;li:first&quot;).clone().insertAfter(&quot;li:last&quot;); // 复制第一个li，并插入到最后一个li的后面 /*删除节点*/ //$(&quot;li:eq(1)&quot;).empty(); // 清空了节点上的文本（节点并没有消失） $(&quot;li:eq(1)&quot;).remove(); //删除节点 &#125;);&lt;/script&gt; 2.7 遍历节点2.7.1 祖先元素用于向上遍历 DOM 树的方法 parent() 返回被选元素的直接父元素，仅仅是上一级 （找爸爸） parents() 返回被选元素的所有祖先元素，它一路向上直到文档的根元素，可以选择辈分 123456789101112131415161718&lt;p&gt;&lt;button&gt;测试&lt;/button&gt;&lt;/p&gt;&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt; &lt;b&gt;b&lt;/b&gt; &lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;button&quot;).click(function()&#123; //var x = $(&quot;b&quot;).parent().html(); // 找爸爸 //var x = $(&quot;b&quot;).parents(&quot;ul&quot;).html(); // 找祖宗 ul //var x = $(&quot;b&quot;).parents(&quot;body&quot;).html(); // 找祖宗 body alert( x ); &#125;);&lt;/script&gt; 2.7.2 同辈元素 next() 获取紧邻匹配元素之后的元素 prev() 获取紧邻匹配元素之前的元素 siblings( [selector] ) 获取位于匹配元素前面和后面的所有同辈元素 12345678910111213141516171819202122232425&lt;button&gt;测试&lt;/button&gt;&lt;p&gt;p1&lt;/p&gt;&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt; &lt;b&gt;b&lt;/b&gt; &lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;p2&lt;/p&gt;&lt;p id=&quot;x&quot;&gt;p3&lt;/p&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;button&quot;).click(function()&#123; //var x = $(&quot;ul&quot;).next().text(); // 紧邻的下一个元素 //var x = $(&quot;ul&quot;).prev().text(); // 紧邻的上一个元素 //var x = $(&quot;ul&quot;).siblings(&quot;#x&quot;).text(); // 所有的兄弟中，id=x的 var arr = $(&quot;ul&quot;).siblings(); // ul的所有兄弟,1个button，3个p，2个script for(var i = 0 ;i&lt; arr.length ;i++)&#123; alert(arr[i]); &#125; &#125;);&lt;/script&gt; 2.7.3 后代元素后代是子、孙、曾孙等等 children( [selector] ) 方法返回被选元素的所有直接子元素，“孩子” 123456789101112131415&lt;button&gt;测试&lt;/button&gt;&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;button&quot;).click(function()&#123; //var x = $(&quot;ul&quot;).children().text(); //所有子节点：abc var x = $(&quot;ul&quot;).children(&quot;li:first&quot;).text(); //ul中的第一个子节点 alert(x); &#125;);&lt;/script&gt; find( 选择器 ) 方法返回被选元素的后代元素，一路向下直到最后一个后代。 12345678910111213141516171819&lt;button&gt;测试&lt;/button&gt;&lt;ul&gt; &lt;li&gt;盘古&lt;/li&gt; &lt;li&gt;蚩尤&lt;/li&gt; &lt;li&gt;刑天 &lt;p&gt;龚工&lt;/p&gt; &lt;/li&gt; &lt;h3&gt;祝融&lt;/h3&gt;&lt;/ul&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;button&quot;).click(function()&#123; //var x = $(&quot;ul&quot;).find(&quot;p&quot;).text(); //在ul中查找p元素，忽略层级 //var x = $(&quot;ul&quot;).find(&quot;h3&quot;).text(); //在ul中查找h3元素，忽略层级 var x = $(&quot;ul&quot;).find().text(); // 找什么？不知道！ alert(x); &#125;);&lt;/script&gt; 2.7.4 元素的过滤 first()：过滤第一个元素 last()：过滤最后一个元素 eq(index)：过滤到下标为index的元素 not()：除了什么之外的元素 is()：返回布尔，判断是不是这种元素 12345678910111213141516171819&lt;button&gt;测试&lt;/button&gt;&lt;ul&gt; &lt;li&gt;盘古&lt;/li&gt; &lt;li&gt;蚩尤&lt;/li&gt; &lt;li&gt;刑天&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;button&quot;).click(function()&#123; //var x = $(&quot;li&quot;).first().text(); // 第一个li //var x = $(&quot;li&quot;).last().text(); // 最后一个li //var x = $(&quot;li&quot;).eq(1).text(); // 下标为1的li //var x = $(&quot;li&quot;).not(&quot;li:eq(1)&quot;).text(); // 除了下标为1的其余所有li var x = $(&quot;li&quot;).parent().is(&quot;ul&quot;); // 返回布尔型，li的父节点是不是ul alert(x); &#125;);&lt;/script&gt; 3 案例3.1 手风琴特效12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; dd&#123; display: none; /*隐藏元素*/ &#125;&lt;/style&gt;&lt;body&gt; &lt;nav&gt; &lt;header&gt;拉勾网&lt;/header&gt; &lt;ul&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt;求职&lt;/dt&gt; &lt;dd&gt;1.简历&lt;/dd&gt; &lt;dd&gt;2.面试&lt;/dd&gt; &lt;dd&gt;3.入职&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt;教育&lt;/dt&gt; &lt;dd&gt;1.看视频&lt;/dd&gt; &lt;dd&gt;2.做作业&lt;/dd&gt; &lt;dd&gt;3.24小时在线辅导&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt;3W创业&lt;/dt&gt; &lt;dd&gt;1.帮助小企业&lt;/dd&gt; &lt;dd&gt;2.头脑风暴&lt;/dd&gt; &lt;dd&gt;3.赚钱啦&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;nav dt&quot;).click(function()&#123; //所有的dd全部都闭合上，除了自己的兄弟 $(&quot;dd&quot;).not( $(this).siblings() ).slideUp(500); // 自己的兄弟进行切换，显示闭合上，闭合的显示出来 $(this).siblings().slideToggle(500); &#125;); &lt;/script&gt;&lt;/body&gt; 3.2 购物车结算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;style&gt; .jian,.jia&#123; border:1px solid #999; display: inline-block; /*超链接a是行内元素，只能转换成行内块元素，才能改变宽和高*/ width: 20px; height: 20px; text-align: center; text-decoration: none; &#125;&lt;/style&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;400&quot;&gt; &lt;tr&gt; &lt;td&gt;商品编号&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;单价&lt;/td&gt; &lt;td&gt;数量&lt;/td&gt; &lt;td&gt;总价&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;炸香肠&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; class=&quot;jian&quot;&gt;-&lt;/a&gt; &lt;span&gt;1&lt;/span&gt; &lt;a href=&quot;#&quot; class=&quot;jia&quot;&gt;+&lt;/a&gt; &lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;王八&lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; class=&quot;jian&quot;&gt;-&lt;/a&gt; &lt;span&gt;1&lt;/span&gt; &lt;a href=&quot;#&quot; class=&quot;jia&quot;&gt;+&lt;/a&gt; &lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;恐龙&lt;/td&gt; &lt;td&gt;1000&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; class=&quot;jian&quot;&gt;-&lt;/a&gt; &lt;span&gt;1&lt;/span&gt; &lt;a href=&quot;#&quot; class=&quot;jia&quot;&gt;+&lt;/a&gt; &lt;/td&gt; &lt;td&gt;1000&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p style=&quot;width: 400px; text-align: right;&quot;&gt; 总价：&lt;b style=&quot;color:red;&quot;&gt;111&lt;/b&gt; &lt;button&gt;提交订单&lt;/button&gt; &lt;/p&gt;&lt;/body&gt;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"JavaScript详解","slug":"JavaScript","date":"2020-01-05T00:50:39.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2020/01/05/JavaScript/","link":"","permalink":"http://yournotes.cn/2020/01/05/JavaScript/","excerpt":"1. JavaScript介绍 虽然是java作为前缀，但java和javascript的关系，就像老婆和老婆饼、孙悟空与孙中山之间的关系，没有一毛钱关系！","text":"1. JavaScript介绍 虽然是java作为前缀，但java和javascript的关系，就像老婆和老婆饼、孙悟空与孙中山之间的关系，没有一毛钱关系！ 网景公司在Netscape2.0首先推出了JavaScript JavaScript 的正式名称是 “ECMAScript”，此标准由 ECMA 组织发展和维护，简称“js” JavaScript 是一种网页编程技术，用来向 HTML 页面添加交互行为 JavaScript 是一种基于对象和事件驱动的解释性脚本语言，直接嵌入 HTML 页面，由浏览器解释执行代码，不进行预编译 1.1 js的特点 可以使用任何文本编辑工具编写，只需要浏览器就可以执行程序 （后面会学习不用浏览器也能运行） 解释执行：事先不编译，逐行执行 基于对象：内置大量现成对象 适宜： 客户端数据计算 客户端表单合法性验证 浏览器事件的触发 网页特殊显示效果制作 1.2 js的组成 ECMAScript：定义核心语法，关键字，运算符，数据类型等系列标准 DOM：文档对象模型，将一个html页面的所有节点看成是一个一个的对象。更有层次感的管理每一个节点。 BOM：浏览器对象模型，是对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的准。 弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口大小 提供 Web 浏览器详细信息的定位对象 提供用户屏幕分辨率详细信息的屏幕对象 对 cookie 的支持 IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX对象，进而实现ajax局部刷新技术 2. HTML与JavaScript结合方式与CSS一样使用JS的也是有三种方式 2.1 行内脚本直接编辑在标签里面只对当前标签有效，比如下面的按钮：onclick&#x3D;”xxx” 123&lt;button onclick=&quot;aler(弹框测试)&quot;&gt; 点我一下&lt;/button&gt; 2.2 内部脚本 使用&lt;script&gt; &lt;/script&gt; 标准是写在head和body之间（脖子位置），但其实只要写在html文件内部就可以，无论什么位置&lt;html&gt;外，&lt;p&gt;&lt;/p&gt;内部，都可以。 12345&lt;body&gt; &lt;script&gt; alert(&quot;弹框&quot;); &lt;/script&gt; &lt;/body&gt; 2.3 外部脚本 在项目根目录下创建一个目录js 在js目录中创建一个文件，后缀名是.js 在html页面中，使用： 1&lt;script src=&quot;js/xx.js&quot;&gt;&lt;/script&gt; 以上使用脚本的三种方式的优先级，谁在上，谁先执行。因为是解释性语言。 3. JavaScript的使用3.1 变量 因为js是弱类型语言，所以，在定义变量的时候，所有的数据类型都是var 声明变量： var x ; var x,y; 数值类型：number 不区分整型数值和浮点型数值 所有数字都采用 64 位浮点格式存储，类似于double 格式 字符串：string 首尾由单引号或双引号括起1var a = &quot;欢迎来到JavaScript世界&quot; 布尔类型 仅有两个值：true和false也代表1和0 在实际运算中true&#x3D;1，false&#x3D;0 3.1.1 自动类型转换1234数字 + 字符串：数字转换为字符串 10+’a’ -&gt; 10a 数字 + 布尔值：true转换为1，false转换为0 true+5-&gt;6 字符串 + 布尔值：布尔值转换为字符串true或false true+’a’-&gt;truea 布尔值 + 布尔值：布尔值转换为数值1或0 true+true-&gt;2 3.1.2 数据类型转换函数 parseInt：强制转换成整数 如果不能转换，则返回 NaN （NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字） 例如：parseInt(“6.32”)&#x3D;6 parseFloat：强制转换成浮点数 如果不能转换，则返回 NaN 例如：parseFloat(“6.32”)&#x3D;6.32 typeof：查询数值当前类型，返回 string &#x2F; number &#x2F; boolean &#x2F; object 例如：typeof(“test”+3)&#x3D;&#x3D;”string” 3.1.3 null 与undefined null 在程序中代表”无值”或者”无对象” 可以通过给一个变量赋值 null 来清除变量的内容 undefinded 声明了变量但从未赋值或者对象属性不存在 3.1.4 算术运算 加(＋)、 减(－)、 乘( * ) 、除( &#x2F; ) 、余数( % ) -可以表示减号，也可以表示负号，如：x &#x3D; -y +可以表示加法，也可以用于字符串的连接 递增( ++ ) 、递减( – ) i++ 相当于 i&#x3D;i+1 i– 相当于 i&#x3D;i-1 3.1.5 关系运算 严格相等：&#x3D;&#x3D;&#x3D; 类型相同 数值相同 非严格相等：&#x3D;&#x3D; 123456var a = &quot;10&quot;; var b = 10; if (a == b) alert(&quot;equal&quot;); if (a === b) alert(&quot;same&quot;); 3.1.6 逻辑运算 逻辑非（!）、逻辑与（&amp;&amp;）、逻辑或（||） 逻辑运算的操作数均为 boolean 表达式 我要吃两碗拉面或者10个包子才能吃饱！问题是，我只吃两碗面，饱了！ 我只吃10个包子，饱了 我要吃两碗拉面并且10个包子才能吃饱！问题是，我只吃两碗面，没饱！ 我只吃10个包子，没饱 3.1.7 控制语句12345if（关系表达式） &#123; // 语句块 1 &#125;else &#123; // 语句块 2 &#125; 123456789if (表达式1) &#123; // 语句1; &#125;else if (表达式2)&#123; // 语句2; &#125;else if (表达式3)&#123; // 语句3; &#125;else&#123; // 语句4; &#125; 12345678910switch (表达式) &#123; case 值1: // 语句1; break; case 值2: // 语句2; break; default: // 语句4; &#125; 123for (var i=1 ; i&lt;=5 ; i++)&#123; alert(i); &#125; 123while (条件)&#123; // 语句1; ... &#125; 3.2 常用字符串API length:获取字符串的长度（字符串中字符的个数） 属性，没有小括号12var str = &quot;hello&quot;;console.log(str.length); toUpperCase&#x2F;toLowerCase :转大小写123var name = &quot;AngierSun&quot;; console.log( &quot;大写：&quot;+name.toUpperCase() ); console.log( &quot;小写：&quot;+name.toLowerCase() ); charAt(下标) ： 返回某个下标上的字符123456var str1 = &quot;javascript网页教程&quot;; var str2 = str1.charAt(12); // 下标12上的字符 console.log(str2); //教 var str3 = str1.charCodeAt(12); console.log(str3); //25945:（汉字“教”在unicode编码中的编号） indexof(字符)：查找字符串中字符出现的首次下标 lastIndexof(字符)：查找字符串中字符最后一次出现的下标123456var str1 = &quot;javascript网页教程&quot;; var str2 = str1.indexOf(&quot;a&quot;); console.log(str2); // 1 , a字符在str1中第一次出现的下标 var str3 = str1.lastIndexOf(&quot;a&quot;); //3,a字符在str1中最后一次出现的下标 console.log(str3); substring(开始,结束)：截取字符串中一部分（结束是不包含的） 123var str1 = &quot;abcdefgh&quot;; var str2 = str1.substring(2,4); console.log(str2); //cd，从2开始（包含），4结束（不包含） replace(旧的,新的)：将字符串中的旧字符替换成新字符123var str1 = &quot;abcde&quot;; var str2 = str1.replace(&quot;cd&quot;,&quot;XXX&quot;); console.log(str2); // abXXXe，将str1中的cd替换成XXX split(分割的节点)：一个字符串切割成N个小字符串，所以返回的是数组类型1234var str1 = &quot;一,二,三,四,五&quot;;var arr = str1.split(&quot;,&quot;); // 将str1 以逗号进行分割，分割成N份，所以返回的结果一定 是数组结构 console.log( &quot;共分割成：&quot;+arr.length+&quot;份&quot; ); console.log( &quot;第三份是：&quot; + arr[2] ); // 三 3.3 数组3.3.1 创建数组1var arr = new Array(); 3.3.2 初始化数组的三种方式123456789101112// 第一种 var arr1 = new Array(); arr1[0] = 110; arr1[1] = 119; arr1[2] = 120; // 第二种 var arr1 = new Array(10,&quot;a&quot;,true); // 第三种 var arr1 = [10,&quot;a&quot;,true]; for (var i = 0; i &lt; arr1.length; i++) &#123; console.log(arr1[i]); &#125; 3.3.3 数组的常用的方法 toString(): 将数组转字符串 12345var arr = [1,2,3,4]; console.log(&quot;类型为：&quot; + typeof( arr ) ); var str = arr.toString(); // 将数组转换成字符串 console.log( str +&quot;,类型为：&quot; + typeof( str ) ); join(连接符号)：将数组中的每个元素用连接符号连接成一个新的字符串。 123var arr = [1,2,3,4]; var str = arr.join(&quot;-&quot;); // 将数组中每个元素用-进行连接，并形成一个全新的字符串 console.log( str +&quot;,类型为：&quot; + typeof( str ) ); concat(新元素)：将原来的数组连接新元素，原数组不变。 1234var arr = [1,2,3,4]; var arrnew = arr.concat(5,6); // 在arr数组的后面添加新的元素，形成一个新数组，但是 原数组是不变的 console.log( arrnew +&quot;,类型为：&quot; + typeof( arrnew ) ); console.log(&quot;原数组：&quot; + arr); slice(开始，结束)：在数组中提取一部分，形成新的数组。 1,2,3,4,5 slice(2,4) 结果：3,4 123var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;]; var arrnew = arr.slice( 2,4 ); // 在arr数组中截取，从2开始（包含），4结束（不包 含）console.log( arrnew ); // cd reverse()：数组的反转（倒序） 1234var arr = [31,12,111,444]; console.log( arr.toString() ); arr.reverse(); // 将数组中的元素倒置 console.log( arr.toString() ); sort()：数组排序 arr.sort() 字符排序 123var arr = [31,12,111,444]; arr.sort(); // 字符排序（不会按照字面量的大小） console.log( arr ); arr.sort(func) 数值排序 123456var arr = [31,12,111,444]; arr.sort( f ); // 数字排序（会按照字面量的大小） console.log( arr ); // 定义排序函数 function f(a,b)&#123; return a-b; &#125; 3.4 Math数学对象 Math 对象用于执行数学任务 没有构造函数 Math() 无需创建，直接把 Math 作为对象使用就可以调用其所有属性和方法 1234// 返回0-9之间任意一个随机数字 var i = Math.random() * 10; var j = Math.floor(i); console.log(j); 3.5 Number对象Number.fixed(2); 自带四舍五入技能 12345var n = new Number( 12.345 ); var n1 = n.toFixed(2); // 12.35，固定两位小数，第三位小数四舍五入 console.log( n1 ); var x = new Number( 12.3 ); var n2 = x.toFixed(2); // 12.30，固定两位小数，位数不够，0来补齐 console.log( n2 ); 3.6 正则表达式对字符串执行模式匹配的强大工具 12var reg1 = /^\\d&#123;3,6&#125;$/; // 匹配纯数字3-6个 var reg2 = new RegExp(“^\\\\d&#123;3,6&#125;$&quot;); 123456789101112131415161718// 方式1 var age = &quot;18&quot;; // 判断：1-3位纯数字 var reg = /^\\d&#123;1,3&#125;$/; // 以/^开始，中间写正则内容，以$/结束 var b = reg.test(age); // 验证age变量的是否符合reg的匹配 if (b == true) &#123; console.log(&quot;验证通过！&quot;); &#125; else &#123; console.log(&quot;格式错误&quot;);&#125;// 方式2 var name = &quot;abc123&quot;; // 大小写字母和数字的组合（特殊字符不能出现）, 5~8位 var reg = new RegExp(&quot;^[a-zA-Z0-9]&#123;5,8&#125;$&quot;); // 以^开始，中间写正则内容，以$结束 if (reg.test(name)) &#123; console.log(&quot;验证通过！&quot;); &#125; else &#123; console.log(&quot;格式错误&quot;); &#125; 3.7 日期对象123456789var time = new Date(); console.log( time ); // Tue Jul 14 2020 11:09:46 GMT+0800 (中国标准时间) var year = time.getFullYear(); // 年份 var month = time.getMonth() + 1; //月份从0开始，11结束，所以国内习惯要+1 var day = time.getDate(); // 几号 var hour = time.getHours(); // 几点 var mm = time.getMinutes(); // 分钟 var s = time.getSeconds(); //秒 var ms = time.getMilliseconds(); // 毫秒， 1000毫秒 = 1秒 var timestr = year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;号 &quot;+hour+&quot;点&quot;+mm+&quot;分&quot;+s+&quot;秒&quot;+ms+&quot;毫秒&quot;; console.log( timestr ); 3.8 函数 使用关键字function定义函数 123function 函数名( 形参列表 )&#123; // 函数体 return 返回值; &#125; 函数声明后不会立即执行，会在我们需要的时候调用到。 注意： 形参：一定不要带数据类型 分号是用来分隔可执行JavaScript语句。 由于函数声明不是一个可执行语句，所以不以分号结束。 3.8.1 无返回值12345function qiuhe(a, b) &#123; var he = a + b; console.log(&quot;两数之和：&quot; + he); &#125;qiuhe(3,4); 3.8.2 有返回值123456function qiuhe(a, b) &#123; var he = a + b; return &quot;两数之和：&quot; + he; &#125;var s = qiuhe(3,4); console.log( s ); 3.8.3 参数对象在函数内部，调用参数列表的属性 1234function func(a,b,c)&#123; console.log( arguments.length ); // 获得参数的个数 console.log( arguments[1] ); // 获得下标为1的参数 &#125; 3.8.4 构造函数函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义 123var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;); var x = myFunction(4, 3); console.log(x); 注： 上述函数以分号结尾，因为它是一个执行语句。 3.8.5 构造函数没有名称的函数 1234var fn = function(a, b) &#123;// 没有名字的函数，应该用一个变量来接收 return a * 10 + b; &#125;;console.log( fn(3, 4) ); 3.8.6 全局函数 isNaN：检查其参数是否是非数字值 1234567console.log( isNaN( 123 ) ); // 数字，false console.log( isNaN( &quot;hello&quot; ) ); // 非数字，true console.log( isNaN( 4-1 ) ); // 数字，false console.log( isNaN( 123 ) ); // 数字，false console.log( isNaN( -10 ) ); // 数字，false console.log( isNaN( &quot;123&quot; ) ); // 数字，false console.log( isNaN( &quot;1a23&quot; ) ); // 非数字，true eval：用来转换字符串中的运算 12var str = &quot;1+3&quot;; console.log( str ); // 1+3 , +会认定为一种字符符号而已，没有加法的作用 console.log( eval( str ) ); // 让字符串中的运算符号生效 encodeURI 与 decodeURI 12345var name = &quot;木瓜煲鸡脚&quot;; console.log( &quot;转码前：&quot; + name ); name = encodeURI(name); console.log( &quot;转码后：&quot; + name ); name = decodeURI(name); console.log( &quot;解码后：&quot; + name ); 3.8.7 闭包 闭包的概念：指有权访问另一个函数作用域中的变量的函数，一般情况就是在一个函数中包含另一个函数。 闭包的作用：访问函数内部变量、保持函数在环境中一直存在，不会被垃圾回收机制处理；简单地说：就是在函数的局部范围内声明一个封闭的环境，此环境不会被垃圾回收探测到。保证了数据的安全唯一性想了解闭包，首先要了解什么是全局变量，什么是局部变量 123456789101112a = 10; // 全局变量，声明的时候可以不使用var function test1()&#123; b = 20; // 不适用var声明的变量，就是全局变量 var c = 30; // 用var声明，并且在函数的内部。这样的变量叫做局部变量，有效范围只能 在其声明的函数内部 console.log(c); &#125;function test2()&#123; console.log(c); //c is not defined (c变量没有定义) &#125;test1(); test2(); 需求：统计方法执行了多少次 1234567function test1()&#123; count++; // 自增+1 &#125;test1(); test1(); test1(); console.log( count ); 谁都可以访问count，所以count变量并不安全，因为是全局变量。 如何才能安全呢？将count声明为局部变量 12345678function test1()&#123; var count = 0; //局部变量 return count++; //外部无法访问count，只能通过return才能将count变量返回，并输 出 &#125;test1(); test1(); test1(); console.log( test1() ); // 每次调用方法，首先就是将变量还原为0 结果一直是0，因为每次调用test1()，方法体的第一句代码就是还原，无论曾经的值是多少。 突发奇想，如果在test1()函数里面，再嵌套一个函数，js是支持函数嵌套的 123456789101112function test1()&#123; var count = 0; //局部变量 function jia()&#123; return count++; &#125; jia(); return count; &#125; test1(); test1(); test1(); console.log( test1() ); // 每次调用方法，首先就是将变量还原为0 如果每次只调用test1()里面的jia()就好了。ok，闭包帮你解决此问题！ 1234567891011function test1()&#123; var count = 0; //局部变量 function jia()&#123; return count+=1; &#125; return jia; &#125;var fn = test1(); // fn =&gt; function jia()&#123;return count+=1; &#125; fn(); fn(); console.log( fn() ); // 每次调用方法，首先就是将变量还原为0 闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不 受外界干扰。 直观的说就是形成一个不销毁的栈环境。 闭包的优点： 方便调用上下文中声明的局部变量 逻辑紧密，可以在一个函数中再创建个函数，避免了传参的问题 闭包的缺点： 因为使用闭包，可以使函数在执行完后不被销毁，保留在内存中，如果大量使用闭包就会造 成内存泄露，内存消耗很大 3.9 弹框输出 普通弹框 alert(&quot;hello，木瓜煲鸡脚&quot;); 控制台日志输出 console.log(&quot;谷歌浏览器按F12进入控制台&quot;); 页面输出 document.write(&quot;&lt;h2&gt;我爱你中国&lt;/h2&gt;&quot;); 将&lt;h2&gt;元素输出到&lt;body&gt;中 确认框 confirm(“确定删除吗？”); 123456var b = confirm(&quot;确定删除吗？&quot;); if(b)&#123; document.write( &quot;&lt;h1&gt;删除成功！&lt;/h1&gt;&quot; ); &#125;else&#123; document.write( &quot;&lt;h1&gt;你取消了操作&lt;/h1&gt;&quot; ); &#125; 输入框 prompt(“请输入姓名：”); 12var name = prompt(&quot;请输入你的名字：&quot;); document.write( &quot;&lt;h1&gt;大名：&quot;+name+&quot;！&lt;/h1&gt;&quot; ); 4. DOM 操作 在一个html页面中，会使用很多标签来规划制作页面。 每个标签都有它存在的意义，如果我们想要动态的修改某个标签的值。那我们就需要在页面中查找到这个标签元素 如何查找到这个元素是个难题，W3C组织的工程师们，突然看到了一棵大树。我要是想找到某一片叶子，应该怎么做？ “顺藤摸瓜”，主树干有分支，每个分支还有许多小分支，只要把这个分支的结构整理清楚，任何一片叶子都不是难事了 叶子和大树的一些启发，工程师们开会讨论就定了这个理论“文档对象模型”， 文档对象模型，就是将页面中所有的标签元素都看成是一个对象（一片叶子），主树干定义为根节点（根元素），所有的标签都是从根元素延伸出去的，摸清结构，找到某个标签就不再困难了 在节点树中，顶端节点就是根节点（root） 每个节点都有父节点（除了根节点） 任何一个节点都可以拥有任意数量的子节点 同胞是拥有相同父节点的节点 12345678910&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;DOM来了&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;HTML DOM&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 从上面的 HTML 中： &lt;html&gt; 节点没有父节点；它是根节点 &lt;head&gt; 和 &lt;body&gt; 的父节点是 &lt;html&gt; 节点 文本节点 “Hello world!” 的父节点是 &lt;p&gt; 节点 并且： &lt;html&gt; 节点拥有两个子节点：&lt;head&gt; 和 &lt;body&gt; &lt;head&gt; 节点拥有两个子节点：&lt;meta&gt; 与 &lt;title&gt; 节点 &lt;title&gt; 节点也拥有一个子节点：文本节点 “DOM 来了”&lt;h1&gt; 和 &lt;p&gt; 节点是同胞节点，同时也是&lt;body&gt; 的子节点 并且： &lt;head&gt; 元素是 &lt;html&gt; 元素的首个子节点 &lt;body&gt; 元素是 &lt;html&gt; 元素的最后一个子节点 &lt;h1&gt; 元素是 &lt;body&gt; 元素的首个子节点 &lt;p&gt; 元素是 &lt;body 元素的最后一个子节点 js为我们提供了很多种方法来实现在页面找查找某个元素节点 4.1 DOM访问 getElementById：通过id属性获得元素节点对象 案例：当帐号为空时，阻止表单提交 1234567891011121314151617&lt;body&gt; &lt;form action=&quot;xxx&quot; onsubmit=&quot;return login()&quot;&gt; &lt;p&gt;帐号：&lt;input id=&quot;username&quot;/&gt;&lt;/p&gt; &lt;p&gt;电话：&lt;input id=&quot;phone&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;button&gt;登录&lt;/button&gt;&lt;/p&gt; &lt;/form&gt; &lt;script&gt; function login() &#123; var name = document.getElementById(&quot;username&quot;).value ; if(name == &quot;&quot;)&#123; alert(&quot;帐号不能为空！&quot;); return false; // 阻止表单的提交 &#125; return true; // 放行，让表单提交 &#125; &lt;/script&gt; &lt;/body&gt; getElementsByName：通过name属性获得元素节点对象集 案例：购物车全选效果 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;h2&gt;我的购物车&lt;/h2&gt; &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; onchange=&quot;quan(this)&quot; /&gt; 全选&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;单价&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;one&quot; /&gt;1&lt;/td&gt; &lt;td&gt;功能性饮料-尖叫&lt;/td&gt; &lt;td&gt;4.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;one&quot; /&gt;2&lt;/td&gt; &lt;td&gt;火腿肠&lt;/td&gt; &lt;td&gt;2.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;one&quot; /&gt;3&lt;/td&gt; &lt;td&gt;包子&lt;/td&gt; &lt;td&gt;1.5&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;button&gt;提交订单&lt;/button&gt; &lt;/p&gt; &lt;script&gt; function quan(all) &#123; var arr = document.getElementsByName(&quot;one&quot;); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].checked = all.checked; // 将全选框的状态，赋值给每一个复选框 &#125; &#125; &lt;/script&gt; &lt;/body&gt; getElementsByTagName：通过标签名称获得元素节点对象集 案例：表格隔行变色 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; onchange=&quot;quan(this)&quot; /&gt; 全选&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;单价&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;one&quot; /&gt;1&lt;/td&gt; &lt;td&gt;功能性饮料-尖叫&lt;/td&gt; &lt;td&gt;4.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;one&quot; /&gt;2&lt;/td&gt; &lt;td&gt;火腿肠&lt;/td&gt; &lt;td&gt;2.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;one&quot; /&gt;3&lt;/td&gt; &lt;td&gt;包子&lt;/td&gt; &lt;td&gt;1.5&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script&gt; var rows = document.getElementsByTagName(&quot;tr&quot;); //通过标签名获得元素对象 集合 for (var i = 0; i &lt; rows.length; i++) &#123; if(i % 2 == 1)&#123; // 奇数 rows[i].style.backgroundColor = &quot;pink&quot;; &#125; &#125; &lt;/script&gt; &lt;/body&gt; 4.2 DOM修改 修改 HTML DOM 意味着许多不同的方面： 改变 HTML 内容 改变 CSS 样式 改变 HTML 属性 创建新的 HTML 元素 删除已有的 HTML 元素 改变事件（处理程序） 改变一个 &lt;h2&gt; 元素的 HTML 内容 : 123456789&lt;body&gt; &lt;button onclick=&quot;test()&quot;&gt;点我试试&lt;/button&gt; &lt;script&gt; function test()&#123; document.getElementById(&quot;hello&quot;).innerHTML = &quot;走哇，喝点去~！&quot;; &#125; &lt;/script&gt; &lt;h2 id=&quot;hello&quot;&gt;你好！&lt;/h2&gt; &lt;/body&gt; 改变一个&lt;h2&gt;的 HTML 样式 12345678910&lt;body&gt; &lt;button onclick=&quot;chou()&quot;&gt;你瞅啥&lt;/button&gt; &lt;script&gt; function chou()&#123; document.getElementById(&quot;hello&quot;).style.color = &quot;red&quot;; document.getElementById(&quot;hello&quot;).style.fontFamily = &quot;华文彩云&quot;; &#125; &lt;/script&gt; &lt;h2 id=&quot;hello&quot;&gt;你好！&lt;/h2&gt; &lt;/body&gt; 4.2.1 添加节点 点击按钮，在页面中创建一张图片 12345678910111213141516171819&lt;body&gt; &lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; function add()&#123; // &lt;img&gt; var img = document.createElement(&quot;img&quot;); // &lt;img src=&quot;../lagou-html/img/cat.gif&quot;&gt; img.setAttribute(&quot;src&quot;,&quot;../lagou-html/img/cat.gif&quot;); // &lt;img src=&quot;../lagou- html/img/cat.gif&quot; title=&quot;小猫咪&quot;&gt; img.setAttribute(&quot;title&quot;,&quot;小猫咪&quot;); // &lt;img src=&quot;../lagou- html/img/cat.gif&quot; title=&quot;小猫咪&quot; id=&quot;cat&quot;&gt; img.setAttribute(&quot;id&quot;,&quot;cat&quot;); var divs = document.getElementsByTagName(&quot;div&quot;); divs[0].appendChild(img); &#125; &lt;/script&gt; &lt;/body&gt; 4.2.2 删除节点 点击按钮，把上面刚创建的图片从页面上删除 1234567891011121314&lt;body&gt; &lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt; &lt;button onclick=&quot;del()&quot;&gt;删除&lt;/button&gt; &lt;div&gt; &lt;/div&gt; &lt;script&gt; function add()&#123; 。。。略。。。 &#125; function del()&#123; var img = document.getElementById(&quot;cat&quot;); img.parentNode.removeChild(img); // 必须通过父节点，才能删除子节点 &#125; &lt;/script&gt; &lt;/body 4.2.3 替换节点 点击按钮，把上面刚创建的图片替换成另一张 12345678910111213141516171819202122&lt;body&gt; &lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt; &lt;button onclick=&quot;del()&quot;&gt;删除&lt;/button&gt; &lt;button onclick=&quot;rep()&quot;&gt;替换&lt;/button&gt; &lt;div&gt; &lt;/div&gt; &lt;script&gt; function add()&#123; 。。。略。。。 &#125; function del()&#123; 。。。略。。。 &#125; function rep()&#123; var imgold = document.getElementById(&quot;cat&quot;); // 通过修改元素的属性，做的替换 // img.setAttribute(&quot;src&quot;,&quot;../lagou-html/img/2.jpg&quot;); var imgnew = document.createElement(&quot;img&quot;); imgnew.setAttribute(&quot;src&quot;,&quot;../lagou-html/img/1.jpg&quot;); imgold.parentNode.replaceChild( imgnew, imgold ); &#125; &lt;/script&gt; &lt;/body&gt; 4.3 事件js捕获某个动作而做出的反馈 HTML 事件的例子： 当用户点击鼠标时 当网页已加载时 当图片已加载时 当鼠标移动到元素上时 当输入字段被改变时 当 HTML 表单被提交时 当用户触发按键时 4.3.1 窗口事件仅在 body 和 frameset 元素中有效。 onload 当文档被载入时执行脚本 1234567&lt;body onload=&quot;test()&quot;&gt; &lt;script&gt; function test() &#123; document.write(&quot;木瓜煲鸡脚&quot;); &#125; &lt;/script&gt; &lt;/body&gt; 4.3.2 表单元素事件（Form Element Events）仅在表单元素中有效。 onblur 当元素失去焦点时执行脚本 onfocus 当元素获得焦点时执行脚本 1234567891011121314&lt;body&gt; &lt;script&gt; function a() &#123; console.log(&quot;获得焦点==被激活&quot;); &#125; function b() &#123; console.log(&quot;失去焦点&quot;); &#125; &lt;/script&gt; &lt;form action=&quot;&quot;&gt; &lt;p&gt;帐号：&lt;input onfocus=&quot;a()&quot; onblur=&quot;b()&quot; /&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input /&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt; 4.3.3 鼠标事件（ Mouse Events） onclick 当鼠标被单击时执行脚本 ondblclick 当鼠标被双击时执行脚本 onmouseout 当鼠标指针移出某元素时执行脚本 onmouseover 当鼠标指针悬停于某元素之上时执行脚本 12345678910111213141516171819202122232425&lt;style&gt; img&#123; width: 30%; border: 5px solid white; &#125; &lt;/style&gt; &lt;body&gt; &lt;img src=&quot;img/logo.png&quot; onmouseover=&quot;shang(this)&quot; onmouseout=&quot;xia(this)&quot; onclick=&quot;dan()&quot;&gt; &lt;img src=&quot;img/logo.png&quot; onmouseover=&quot;shang(this)&quot; onmouseout=&quot;xia(this)&quot; ondblclick=&quot;shuang()&quot;&gt; &lt;img src=&quot;img/logo.png&quot; onmouseover=&quot;shang(this)&quot; onmouseout=&quot;xia(this)&quot; &gt; &lt;script&gt; function dan()&#123; alert(&quot;点了一下&quot;); &#125; function shuang()&#123; alert(&quot;连续快读点两下&quot;); &#125; function shang(img)&#123; img.style.border = &quot;5px solid red&quot;; &#125; function xia(img)&#123; img.style.border = &quot;5px solid white&quot;; &#125; &lt;/script&gt;&lt;/body&gt; 4.3.4 键盘事件 onkeydown 按下去 onkeyup 弹上来 12345678910111213&lt;script&gt; window.onkeydown = function()&#123; // event：事件源（按键） // console.log( &quot;按键编码：&quot;+event.keyCode ); if(event.keyCode == &quot;13&quot;)&#123; // 回车键 alert(&quot;登录成功！&quot;); &#125; &#125; window.onkeyup = function()&#123; console.log(event.keyCode); // 按住按键不松手是不会触发的。当松手时，按键回弹则 触发 &#125; &lt;/script&gt; 4.3.5 事件冒泡 创建两个div，一个大一些，一个小一些 123456789101112131415161718192021222324252627&lt;style&gt; #father &#123; width: 200px; height: 200px; background: black; padding: 10px; &#125; #child &#123; width: 100px; height: 100px; background: greenyellow; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 代码不重要，重要是知道这个事件发生，是正常现象 document.getElementById(&quot;father&quot;).addEventListener(&quot;click&quot;, function()&#123; alert(&quot;父级元素的事件被触发：&quot; + this.id); &#125;); document.getElementById(&quot;child&quot;).addEventListener(&quot;click&quot;, function(e) &#123; e.stopPropagation() //取消事件的冒泡机制 alert(&quot;子级元素的事件被触发：&quot; + this.id); &#125;); &lt;/script&gt; &lt;/body&gt; 先子，后父。事件的触发顺序自内向外，这就是事件冒泡； 4.3.6 事件捕获 还是刚才创建两个div，一个大一些，一个小一些 12345678910111213141516171819202122&lt;style&gt; #father &#123; width: 200px; height: 200px; background: black; padding: 10px; &#125; #child &#123; width: 100px; height: 100px; background: greenyellow; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.getElementById(&quot;father&quot;).addEventListener(&quot;click&quot;,function()&#123; alert(&quot;父级：&quot; + this.id); &#125;,true); document.getElementById(&quot;child&quot;).addEventListener(&quot;click&quot;,function()&#123; alert(&quot;子级：&quot; + this.id); &#125;,true); &lt;/script&gt; &lt;/body&gt; 先父,后子。事件触发顺序变更为自外向内，这就是事件捕获； 4.4 面向对象OOP 使用Object创建通用对象 1234567891011121314var user = new Object(); user.name = &quot;吕布&quot;; user.age = 21; user.say = function()&#123; console.log(&quot;大家好，我叫：&quot;+this.name+&quot;，我今年&quot;+this.age+&quot;岁了！&quot;);&#125;user.say(); var dog = new Object(); dog.nickname = &quot;屎尿多&quot;; dog.wang = function()&#123; console.log(&quot;我饿了，我要拆家了！&quot;); &#125;dog.wang(); 使用构造函数 123456789function userinfo(name , age)&#123; this.name = name; this.age = age; this.say = function()&#123; console.log(&quot;大家好，我叫：&quot;+this.name+&quot;，我今年&quot;+this.age+&quot;岁了！&quot;); &#125; &#125;var user = new userinfo(&quot;詹姆斯&quot;,35); user.say(); 使用直接量 123456789var user = &#123; username : &quot;孙悟空&quot;, age : 527, say : function()&#123; console.log(&quot;大家好，我叫：&quot;+this.username+&quot;，我今年&quot;+this.age+&quot;岁了！&quot;); &#125; &#125;;user.say(); 4.5 JSON 大家在互联网上来回传递数据，如果没有一个统一的格式，解析起来的难度很大（每个人的编码喜好不一样） JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写，同时也易于机器解析和生成 12345&#123;属性1：值1，属性2：值2，... ...&#125; 12345678910111213&lt;script&gt; var json1 = &#123; username: &quot;吕布&quot;, age: 31 &#125;; console.log(&quot;姓名：&quot; + json1.username + &quot;，年龄：&quot; + json1.age + &quot;岁&quot;); // json数组 var josnarr = [&#123; name: &quot;貂蝉&quot;, age: 18 &#125;, &#123; name: &quot;小乔&quot;, age: 17 &#125;]; console.log(&quot;貂蝉&quot; + josnarr[0].age + &quot;岁了&quot;); console.log(&quot;小乔&quot; + josnarr[1].age + &quot;岁了&quot;); // 复杂的json对象 var long = &#123; name: &quot;赵云&quot;, sex: &quot;男&quot;, hobby: [&quot;玉兰白龙驹&quot;, &quot;龙胆亮银枪&quot;, &quot;青釭剑&quot;] &#125;; console.log(long.name + &quot;的主攻武器：&quot; + long.hobby[1]); &lt;/script&gt; 5. BOM操作是javascript对浏览器的一些常规操作的方法 5.1 window对象 12345678&lt;button onclick=&quot;Jasper()&quot;&gt;看看更多技术文章&lt;/button&gt; &lt;script&gt; function Jasper()&#123; window.open(&quot;http://yournotes.cn&quot; , &quot;木瓜煲鸡脚&quot;,&quot;width=500,height=300,left=400&quot;); //window.open(&quot;http://yournotes.cn&quot; , &quot;木瓜煲鸡脚&quot; , &quot;fullscreen=yes&quot;); // IE才 生效 &#125;&lt;/script&gt; 5.1.1 screen屏幕对象我想知道我的电脑屏幕多大？实际上，得到的就是分辨率 12345678&lt;body&gt; &lt;button onclick=&quot;kai()&quot;&gt;求大小&lt;/button&gt; &lt;/body&gt; &lt;script&gt; function kai() &#123; alert(window.screen.width + &quot;|&quot; + window.screen.height); &#125; &lt;/script&gt; 5.1.2 location定位包含有关当前 URL 的信息，通常用来做页面跳转 1234567&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt; &lt;script&gt; function test()&#123; console.log( &quot;当前页面的URL路径地址：&quot;+ location.href ); location.reload(); // 重新加载当前页面（刷新） location.href = &quot;http://lagou.com&quot;; // 跳转页面 &#125; &lt;/script&gt; 5.1.3 history浏览器历史history对象会记录浏览器的痕迹 a.html 1&lt;a href=&quot;b.html&quot;&gt;去b页面&lt;/a&gt; b.html 123456&lt;button onclick=&quot;hui()&quot;&gt;返回&lt;/button&gt; &lt;script&gt; function hui()&#123; //history.go(-1); //上一级页面 history.back(); // 与go(-1)是等价的 &#125; &lt;/script&gt; 5.1.4 navigator导航（了解）window.navigator 对象包含有关访问者浏览器的信息 12345678910&lt;script&gt; var str = &quot;&quot;; str += &quot;&lt;p&gt;浏览器的代号：&quot;+ navigator.appCodeName +&quot;&lt;/p&gt;&quot;; str += &quot;&lt;p&gt;浏览器的名称：&quot;+ navigator.appName+&quot;&lt;/p&gt;&quot;; str += &quot;&lt;p&gt;浏览器的版本：&quot;+ navigator.appVersion+&quot;&lt;/p&gt;&quot;; str += &quot;&lt;p&gt;硬件平台：&quot;+ navigator.platform+&quot;&lt;/p&gt;&quot;; str += &quot;&lt;p&gt;用户代理：&quot;+ navigator.userAgent +&quot;&lt;/p&gt;&quot;; str += &quot;&lt;p&gt;启用Cookies：&quot;+navigator.cookieEnabled+&quot;&lt;/p&gt;&quot;; document.write(str); &lt;/script&gt; 5.1.5 存储对象用起来和我们在java中map很相似，都是键值对的方式存数据 本地存储 localStorage 保存数据 1localStorage.setItem(&quot;name&quot;,&quot;curry&quot;); 提取数据 1localStorage.getItem(&quot;name&quot;); 删除数据 1localStorage.removeItem(&quot;name&quot;); 多样化操作 123456789101112131415161718192021// 三种方式保存数据 localStorage[&quot;a&quot;] = 1; localStorage.b = 2; localStorage.setItem(&quot;c&quot;,3); // 查看数据类型 console.log( typeof localStorage[&quot;a&quot;] )console.log( typeof localStorage[&quot;b&quot;] ) console.log( typeof localStorage[&quot;c&quot;] ) // 第一种方式读取 var a = localStorage.a; console.log(a); // 第二种方式读取 var b = localStorage[&quot;b&quot;]; console.log(b); // 第三种方式读取 var c = localStorage.getItem(&quot;c&quot;); console.log(c); 会话存储 sessionStorage 会话，就是保持浏览器别关闭。关闭浏览就等于结束了一次会话。开启浏览器就意味着创建了一次会话。 保存数据 1sessionStorage.setItem(&quot;name&quot;, &quot;klay&quot;); 提取数据 1var lastname = sessionStorage.getItem(&quot;name&quot;); 删除指定键的数据 1sessionStorage.removeItem(&quot;name&quot;); 删除所有数据 1sessionStorage.clear(); 案例：记录点击了几下按钮 1234567891011&lt;button onclick=&quot;dian()&quot;&gt;点我&lt;/button&gt; &lt;h3 id=&quot;result&quot;&gt;&lt;/h3&gt; &lt;script&gt; function dian()&#123; if( sessionStorage.getItem(&quot;clickCount&quot;) )&#123; sessionStorage.setItem(&quot;clickCount&quot;,Number(sessionStorage.getItem(&quot;clickCount&quot;)) + 1); &#125;else&#123; sessionStorage.setItem(&quot;clickCount&quot;, 1); &#125; document.getElementById(&quot;result&quot;).innerHTML = &quot;已经点击了&quot;+ sessionStorage.getItem(&quot;clickCount&quot;) +&quot;次！&quot; &#125; &lt;/script&gt; 5.2 计时操作5.2.1 周期性定时器setIntervalsetInterval(1,2)：周期性触发代码exp （常用）1：执行语句2：时间周期，单位为毫秒 案例：闪烁的字体 （1秒1变色） 12345678910111213&lt;body&gt; &lt;h1 id=&quot;title&quot;&gt;木瓜煲鸡脚&lt;/h1&gt; &lt;script&gt; var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;pink&quot;,&quot;orange&quot;,&quot;black&quot;]; var i = 0; function bian()&#123; document.getElementById(&quot;title&quot;).style.color = colors[i++]; if(i == colors.length)&#123; i = 0; // 颜色重新开始 &#125; &#125; setInterval(bian,100); // 每隔0.1秒，执行一次bian函数 &lt;/script&gt; &lt;/body&gt; 案例：在闪烁字体的基础上扩展，闪烁的电子时钟 1234567891011121314151617181920&lt;body&gt; &lt;h1 id=&quot;title&quot;&gt;&lt;/h1&gt; &lt;script&gt; var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;pink&quot;,&quot;orange&quot;,&quot;black&quot;]; var i = 0; function bian()&#123; document.getElementById(&quot;title&quot;).style.color = colors[i++]; if(i == colors.length)&#123; i = 0; // 颜色重新开始 &#125; &#125; function time()&#123; var d = new Date(); var str = d.getFullYear()+&quot;年&quot;+(d.getMonth()+1)+&quot;月&quot;+d.getDate()+&quot;号&quot;+d.getHours()+&quot;点&quot;+d.getMinutes()+&quot;分&quot;+d.getSeconds()+&quot;秒&quot;; document.getElementById(&quot;title&quot;).innerHTML = str; &#125; setInterval(bian,1000); // 每隔1秒，执行一次变色函数bian setInterval(time,1000); // 每隔1秒，执行一次时间函数time &lt;/script&gt;&lt;/body&gt; 5.2.2 停止定时器clearInterval案列：模拟年会抽奖 12345678910111213141516171819&lt;body&gt; &lt;img id=&quot;tu&quot; src=&quot;./img/1.jpg&quot; width=&quot;50%&quot; /&gt; &lt;br /&gt; &lt;button onclick=&quot;begin()&quot;&gt;开始&lt;/button&gt; &lt;button onclick=&quot;stop()&quot;&gt;停止&lt;/button&gt; &lt;script&gt; var arr = [&quot;1.jpg&quot;, &quot;2.jpg&quot;, &quot;3.jpg&quot;, &quot;4.jpg&quot;, &quot;5.jpg&quot;]; function begin() &#123; timer = setInterval(bian, 100); // 没有使用var，所以timer是全局变量 &#125; function stop() &#123; clearInterval(timer); // 停止定时器 &#125; function bian() &#123; var i = Math.floor(Math.random() * arr.length); // 0-4 document.getElementById(&quot;tu&quot;).src = &quot;../img/&quot; + arr[i]; &#125; &lt;/script&gt; &lt;/body&gt; 5.2.3 一次性定时器setTimeout相当于延迟的效果，只执行一次 1234567&lt;script&gt; function bian()&#123; document.body.style.backgroundColor = &quot;red&quot;; &#125; //3秒之后调用 setTimeout(bian,3000); &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yournotes.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://yournotes.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"CSS详解","slug":"CSS","date":"2020-01-04T06:18:24.000Z","updated":"2025-04-17T08:34:51.957Z","comments":true,"path":"2020/01/04/CSS/","link":"","permalink":"http://yournotes.cn/2020/01/04/CSS/","excerpt":"1. CSS介绍1.1 什么是CSS？","text":"1. CSS介绍1.1 什么是CSS？ CSS是指层叠样式表 cascading style sheets 通过CSS可以让我们定义HTML元素如何显示。 CSS可以让我们原本HTML不能描述的效果，通过CSS描述出来。 通过CSS描述我们的html页面，可以让我们的页面更加漂亮，可以提高工作效率。 2. CSS与HTML结合方式2.1 内联&#x2F;行内 样式就是在我们的HTML标签上通过style属性来引用CSS代码。优点:简单方便 ；缺点:只能对一个标签进行修饰。 2.2 内部样式表我们通过&lt;style&gt;标签来声明我们的CSS. 通常&lt;style&gt;标签我们推荐写在head和body之间，也就是“脖子”的位置 优点:可以通过多个标签进行统一的样式设置缺点: 它只能在本页面上进行修饰语法： 选择器 {属性:值;属性:值} 2.3 外部样式表我们需要单独定义一个CSS文件,注意CSS文件的后缀名就是.css在项目根目录下，创建css目录，在css目录中创建css文件name.css在&lt;head&gt;中使用&lt;link&gt;标签引用外部的css文件 还可以使用另一种引入css文件的方式： 123&lt;style&gt; @import &#x27;css/first.css&#x27; &lt;/style&gt; 关于外部导入css使用&lt;link&gt;与@import的区别? 加载顺序不同 @import方式导入会先加载html，然后才导入css样式，那么如果网络条件不好，就会先看到没有修饰的页面，然后才看到修饰后的页面。 如果使用link方式，它会先加载样式表，也就是说，我们看到的直接就是修饰的页面； @import方式导入css样式，它是不支持javascript的动态修改的。而link支持。 三种样式表的优先级：满足就近原则内联 &gt; 内部 &gt; 外部 3. CSS的使用3.1 css中的选择器3.1.1 元素（标签）选择器它可以对页面上相同的标签进行统一的设置，它描述的就是标签的名称. 3.1.2 类选择器类选择器在使用时使用”.”来描述，它描述的是元素上的class属性值 3.1.3 id选择器它只能选择一个元素，使用 “#” 引入，引用的是元素的id属性值。id选择器值不能重复，比类选择器更具有唯一性 3.1.4 选择器组逗号表示，谁和谁。 例如，我有手机，你有手机，他也有手机，一条一条写太麻烦，就可以合并编写 123我，你，他&#123; 有手机&#125; 3.1.5 派生选择器 子代：父子关系（隔代不管）父 &gt; 子代 后代：父子孙，曾孙，从孙… 父 后代 div&gt;p 只影响div的子标签p 孙标签不影响 div p 后代都影响 3.1.6 CSS伪类 CSS伪类可对css的选择器添加一些特殊效果 伪类属性列表： :active 向被激活的元素添加样式。 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 :link 向未被访问的链接添加样式。 :visited 向已被访问的链接添加样式。 :first-child 向元素的第一个子元素添加样式。 超链接的伪类：要遵守使用顺序，爱恨原则 LoVeHAte：lvha 1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */ a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */ a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */ a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 3.2 CSS基本属性3.2.1文本属性 指定字体：font-family : value; 字体大小：font-size : value; px：像素 em：倍数 字体加粗：font-weight : normal&#x2F;bold; 文本颜色：color : value; 文本排列：text-align : left&#x2F;right&#x2F;center; 文字修饰：text-decoration : none&#x2F;underline; 行高：line-height : value; 首行文本缩进：text-indent : value （2em）; 3.2.2 背景属性CSS 允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 1background-image: url(&#x27;img/1.jpg&#x27;); background-repeat 设置背景图像的墙纸效果，是否及如何重复 repeat：在垂直方向和水平方向重复，为重复值 repeat-x：仅在水平方向重复 repeat-y：仅在垂直方向重复 no-repeat：仅显示一次 background-position 设置背景图像的起始位置 控制水平方向 x轴： 正值，向右移动； 负值，向左移动 控制垂直方向 y轴： 正值，向下移动； 负值，向上移动 12/* 图片向左移动50px，向下移动100px （可以为负值） */ background-position:50px 100px; background-attachment 背景图像是否固定或者随着页面的其余部分滚动 默认值是 scroll：默认情况下，背景会随文档滚动 可取值为 fixed：背景图像固定，并不会随着页面的其余部分滚动，常用于实现称为水印的图像 1background-attachment: fixed; 3.2.3 列表CSS列表属性作用如下： 设置不同的列表项标记为有序列表 设置不同的列表项标记为无序列表 设置列表项标记为图像 有两种类型的列表： 无序列表 - 列表项标记用特殊图形（如小黑点、小方框等） 有序列表 - 列表项的标记有数字或字母 使用CSS，可以列出进一步的样式，并可用图像作列表项标记。 none：无标记。（去除标记） disc：默认。标记是实心圆。 circle：标记是空心圆。 square：标记是实心方块。 decimal：标记是数字。 decimal-leading-zero：0开头的数字标记。(01, 02, 03, 等。) lower-roman：小写罗马数字(i, ii, iii, iv, v, 等。) upper-roman：大写罗马数字(I, II, III, IV, V, 等。) lower-alpha：小写英文字母The marker is lower-alpha (a, b, c, d, e,等。) upper-alpha：大写英文字母The marker is upper-alpha (A, B, C, D, E,等。) 3.2.4 边框属性CSS边框属性允许你指定一个元素边框的样式和颜色。 12345678910&lt;style&gt; div&#123; border-width: 20px; border-color: green; border-style: outset; &#125; &lt;/style&gt;&lt;body&gt; &lt;div&gt;hello&lt;/div&gt; &lt;/body&gt; border-style取值： 3.2.5 轮廓属性轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 轮廓和边框的区别： 边框 (border) 可以是围绕元素内容和内边距的一条或多条线； 轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 CSS outline 属性规定元素轮廓的样式、颜色和宽度。 3.2.6 盒子模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 CSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒子模型允许我们在其它元素和周围元素边框之间的空间放置元素。下面的图片说明了盒子模型(Box Model)： margin(外边距) - 盒子与盒子之间的距离 border(边框) - 盒子的保护壳 padding(内边距&#x2F;填充) - 内填充，盒子边与内容之间的距离 content(内容) - 盒子的内容，显示的文本或图像 3.3 CSS定位3.3.1 默认定位 块级元素：h1~h6，p, div 等，自上而下，垂直排列（自动换行）；可以改变宽高 行内元素：a,b,span,等，从左向右，水平排列（不会换行）；不能改变宽高 行内块元素：input,img等，从左向右，水平排列（自动换行）；可以改变宽高 3.3.2 浮动定位 让元素“飞”起来。不仅可以靠着左边或右边。还可以消除“块级”的霸道特性（独自占一行）。 float取值： none ：不浮动 left：贴着左边 浮动 right：贴着右边 浮动 3.3.3 相对定位和原来的位置进行比较，进行移动定位（偏移） 3.3.4 绝对定位本元素与已定位的祖先元素的距离 如果父级元素定位了，就以父级为参照物； 如果父级没定位，找爷爷级，爷爷定位了，以爷爷为参照物。 如果爷爷没定位，继续向上找，都没定位的话，body是最终选择 1234567&lt;div class=&quot;yeye&quot;&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;a&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 以父节点作为参照物 以爷爷节点作为参照物 3.3.5 固定定位将元素的内容固定在窗口的某个位置，当用户向下滚动页面时元素框并不随着移动 position:fixed 3.3.6 z-index如果有重叠元素，使用z轴属性，定义上下层次。大的在上面 注意： z轴属性，要配合相对或绝对定位来使用。 z值没有额定数值（整型就可以，具体用数字几，悉听尊便） 4. CSS34.1 圆角border-radius：左上 右上 右下 左下; border-radius：四个角; border-radius：50%; 圆形； 4.2 盒子阴影box-shadow：1 2 3 4 5; 1：水平偏移2：垂直偏移3：模糊半径4：扩张半径5：颜色 4.3 渐变4.3.1 线性渐变1background:linear-gradient([方向/角度]，颜色列表)； 123456789101112131415161718&lt;style&gt; div&#123;width: 200px; height: 60px; margin: 10px; &#125; .a1 &#123;background: linear-gradient(red,black); &#125; .a2 &#123;background: linear-gradient(red,black,pink, green); &#125; .a3 &#123;background: linear-gradient(to left,red,black); &#125; .a4 &#123;background: linear-gradient(to top left,red,black); &#125; .a5 &#123;background: linear-gradient(30deg,red,black); &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;a1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;a2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;a3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;a4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;a5&quot;&gt;&lt;/div&gt; &lt;/body&gt; 4.3.2 径向渐变以圆心向外发散 1background: radial-gradient(颜色列表); 1234567891011121314&lt;style&gt; div &#123; width: 200px; height: 200px; margin: 10px; &#125; .a1 &#123; background: radial-gradient(red, black); &#125; .a2 &#123; background: radial-gradient(red, black, pink, green); &#125; .a3 &#123; border-radius: 50%; background: radial-gradient(red, black); &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;a1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;a2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;a3&quot;&gt;&lt;/div&gt;&lt;/body&gt; 4.4 背景background-origin：指定了背景图像的位置区域 border-box : 背景贴边框的边 padding-box : 背景贴内边框的边 content-box : 背景贴内容的边 123456789101112131415161718&lt;style&gt; div &#123; background: url(&quot;img/1.jpg&quot;) no-repeat; width: 200px; height: 80px; margin: 20px; border: 10px dashed black; padding: 20px; &#125; .a &#123;background-origin: border-box; &#125; .b &#123;background-origin: padding-box; &#125; .c &#123;background-origin: content-box; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;a&quot;&gt;&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;/body&gt; 4.4.2 背景剪裁background-clip: border-box 边框开切 padding-box 内边距开切 content-box 内容开切 1234567891011121314151617&lt;style&gt; div &#123; width: 200px; height: 80px; border: 10px dashed red; background-color: darkcyan; margin: 20px; padding: 20px; &#125; .a &#123;background-clip: border-box; &#125; .b &#123;background-clip: padding-box; &#125; .c &#123;background-clip: content-box; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;a&quot;&gt;&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;/body&gt; 4.4.3 背景大小background-size: cover 缩放成完全覆盖背景区域最小大小 contain 缩放成完全适应背景区域最大大小 123456789101112131415&lt;style&gt; div &#123; background: url(&quot;img/1.jpg&quot;) no-repeat; width: 200px; height: 100px; border: 2px solid red; margin: 20px; &#125; .a &#123;background-size: cover; /* 完全覆盖 */ &#125; .b &#123;background-size: contain; /* 完全适应 */ &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;a&quot;&gt;&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;/body&gt; 4.5 过度动画4.5.1 过度从一个状态到另一个状态，中间的“缓慢”过程； 缺点是，控制不了中间某个时间点。 transition｛1 2 3 4｝ 1：过渡或动画模拟的css属性 2：完成过渡所使用的时间（2s内完成） 3：过渡函数… 4：过渡开始出现的延迟时间 1transition: width 2s ease 1s; 目前，css3只开发出部分的过渡属性，下图所示： 12345678910111213141516&lt;style&gt; div&#123; width: 100px; height: 50px; border: 2px solid red; &#125; .a&#123; transition: width 2s linear 1s; /*1秒过后，div在2秒内匀速缓慢的变宽*/ &#125; div:hover&#123; width: 300px; &#125; /*触发div变宽*/ &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;a&quot;&gt;Hello&lt;/div&gt; &lt;/body&gt; 4.5.2 动画从一个状态到另一个状态，过程中每个时间点都可以控制。 关键帧：@keyframes 动画帧 { from{} to{} } 或者{ 0%{} 20%{}… } 动画属性：animation{ 1 , 2 , 3 , 4 , 5 }1：动画帧2：执行时间3：过渡函数4：动画执行的延迟（可省略）5：动画执行的次数 需求1：一个 元素从左向右移动，3秒内执行2次 123456789101112131415161718&lt;style&gt; div&#123; width: 700px; border: 1px solid red; &#125; @keyframes x&#123; from&#123; margin-left: 0px;&#125; to&#123; margin-left: 550px;&#125; &#125; img&#123; animation: x 3s linear 2; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt; &lt;img src=&quot;img/cat.gif&quot;&gt; &lt;/div&gt; &lt;/body&gt; 需求2：一个 元素从左向右移动，3秒内执行完成。无限次交替执行infinite：无限次alternate：来回执行（交替，一去一回） 12345678910111213141516171819202122232425262728&lt;style&gt; .wai&#123; width: 600px; height: 100px; border: 2px solid red; &#125; .nei&#123; width: 40px; height: 80px; margin: 5px; background: red; &#125; .nei&#123; animation: x 3s linear infinite alternate; &#125; @keyframes x&#123; 0%&#123; margin-left: 0px; &#125; 25%&#123; background: yellowgreen; &#125; 50%&#123; background: goldenrod; &#125; 75%&#123; background: palevioletred;&#125; 100%&#123;background: coral; margin-left: 550px; &#125; &#125;&lt;/style&gt; &lt;body&gt; &lt;div class=&quot;wai&quot;&gt; &lt;div class=&quot;nei&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"JDBC综合案例","slug":"JDBC综合案例","date":"2020-01-04T01:51:59.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2020/01/04/JDBC综合案例/","link":"","permalink":"http://yournotes.cn/2020/01/04/JDBC%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","excerpt":"1. 商城案例表设计通过对商城项目的部分表关系进行分析,完成数据库表的设计","text":"1. 商城案例表设计通过对商城项目的部分表关系进行分析,完成数据库表的设计 1.1 表关系分析 1.2 建库,建表 创建名为 store的数据库, 对应商城项目 1create database db6 character set utf8; 创建用户表 12345678CREATE TABLE user ( uid varchar(32) PRIMARY KEY, -- 用户ID username varchar(20) , -- 用户名 password varchar(20) , -- 密码 telephone varchar(20) , -- 电话 birthday date , -- 生日 sex varchar(10) -- 性别); 123456INSERT INTO USER VALUES (&#x27;001&#x27;,&#x27;渣渣辉&#x27;,&#x27;123456&#x27;,&#x27;13511112222&#x27;,&#x27;2015-11-04&#x27;,&#x27;男&#x27;),(&#x27;002&#x27;,&#x27;药水哥&#x27;,&#x27;123456&#x27;,&#x27;13533334444&#x27;,&#x27;1990-02-01&#x27;,&#x27;男&#x27;),(&#x27;003&#x27;,&#x27;大明白&#x27;,&#x27;123456&#x27;,&#x27;13544445555&#x27;,&#x27;2015-11-03&#x27;,&#x27;男&#x27;),(&#x27;004&#x27;,&#x27;长海&#x27;,&#x27;123456&#x27;,&#x27;13566667777&#x27;,&#x27;2000-02-01&#x27;,&#x27;男&#x27;),(&#x27;005&#x27;,&#x27;乔杉&#x27;,&#x27;123456&#x27;,&#x27;13588889999&#x27;,&#x27;2000-02-01&#x27;,&#x27;男&#x27;); 创建订单表 1234567891011CREATE TABLE orders ( oid varchar(32) PRIMARY KEY, -- 订单id ordertime datetime , -- 下单时间 total double , -- 总金额 name varchar(20), -- 收货人姓名 telephone varchar(20) , -- 电话 address varchar(30) , -- 地址 state int(11) , -- 订单状态 uid varchar(32), -- 外键字段 对应用户表id CONSTRAINT ofk_0001 FOREIGN KEY (uid) REFERENCES user (uid)); 123-- 插入一条订单数据INSERT INTO orders VALUES(&#x27;order001&#x27;,&#x27;2019-10-11&#x27;,5500,&#x27;乔杉&#x27;,&#x27;15512342345&#x27;,&#x27;皇家洗浴&#x27;,0,&#x27;001&#x27;); 创建商品分类表 1234CREATE TABLE category ( cid varchar(32) PRIMARY KEY, cname varchar(20)); 1INSERT INTO `category` VALUES (&#x27;1&#x27;,&#x27;手机数码&#x27;),(&#x27;2&#x27;,&#x27;电脑办公&#x27;),(&#x27;3&#x27;,&#x27;运动鞋服&#x27;),(&#x27;4&#x27;,&#x27;图书音像&#x27;); 创建商品表 12345678910CREATE TABLE product ( pid varchar(32) PRIMARY KEY, -- 商品id pname varchar(50) , -- 商品名称 price double, -- 商品价格 pdesc varchar(255), -- 商品描述 pflag int(11) , -- 商品状态 1 上架 ,0 下架 cid varchar(32) , -- 外键对应 分类表id KEY sfk_0001 (cid), CONSTRAINT sfk_0001 FOREIGN KEY (cid) REFERENCES category (cid)); 123456789101112INSERT INTO `product` VALUES (&#x27;1&#x27;,&#x27;小米6&#x27;,2200,&#x27;小米 移动联通电信4G手机 双卡双待&#x27;,0,&#x27;1&#x27;),(&#x27;2&#x27;,&#x27;华为Mate9&#x27;,2599,&#x27;华为 双卡双待 高清大屏&#x27;,0,&#x27;1&#x27;),(&#x27;3&#x27;,&#x27;OPPO11&#x27;,3000,&#x27;移动联通 双4G手机&#x27;,0,&#x27;1&#x27;),(&#x27;4&#x27;,&#x27;华为荣耀&#x27;,1499,&#x27;3GB内存标准版 黑色 移动4G手机&#x27;,0,&#x27;1&#x27;),(&#x27;5&#x27;,&#x27;华硕台式电脑&#x27;,5000,&#x27;爆款直降，满千减百&#x27;,0,&#x27;2&#x27;),(&#x27;6&#x27;,&#x27;MacBook&#x27;,6688,&#x27;128GB 闪存&#x27;,0,&#x27;2&#x27;),(&#x27;7&#x27;,&#x27;ThinkPad&#x27;,4199,&#x27;轻薄系列1)&#x27;,0,&#x27;2&#x27;),(&#x27;8&#x27;,&#x27;联想小新&#x27;,4499,&#x27;14英寸超薄笔记本电脑&#x27;,0,&#x27;2&#x27;),(&#x27;9&#x27;,&#x27;李宁音速6&#x27;,500,&#x27;实战篮球鞋&#x27;,0,&#x27;3&#x27;),(&#x27;10&#x27;,&#x27;AJ11&#x27;,3300,&#x27;乔丹实战系列&#x27;,0,&#x27;3&#x27;),(&#x27;11&#x27;,&#x27;AJ1&#x27;,5800,&#x27;精神小伙系列&#x27;,0,&#x27;3&#x27;); 订单项表 (中间表) 12345678910-- 订单项表CREATE TABLE orderitem ( itemid VARCHAR(32) PRIMARY KEY, -- 订单项ID pid VARCHAR(32), -- 外键 对应商品表 id oid VARCHAR(32), -- 外键 对应订单表 id KEY fk_0001 (pid), KEY fk_0002 (oid), CONSTRAINT fk_0001 FOREIGN KEY (pid) REFERENCES product (pid), CONSTRAINT fk_0002 FOREIGN KEY (oid) REFERENCES orders (oid)); 123-- 向中间表中插入两条数据INSERT INTO orderitem VALUES(&#x27;item001&#x27;,&#x27;1&#x27;,&#x27;order001&#x27;);INSERT INTO orderitem VALUES(&#x27;item002&#x27;,&#x27;11&#x27;,&#x27;order001&#x27;); 2.环境搭建2.1 项目结构1234com.lagou.app 测试包 用于对DAO代码进行测试com.lagou.dao dao包 数据访问层,包含所有对数据库的相关操作的类com.lagou.entity 实体包 保存根据数据库表 对应创建的JavaBean类com.lagou.utils 工具包 2.2 导入所需Jar包1我们只需要导入myjar仓库到项目中就可以了 2.3 导入配置文件及工具类 3. JavaBean类创建3.1 设计用户与订单3.1.1 一对多关系分析 在Java一对多的数据关系中，需要遵循以下设计原则： Java类的名称 &#x3D; 实体表的名称 Java类的属性 &#x3D; 实体表的字段 Java类的一个对象 &#x3D; 表的一行记录 外键关系 &#x3D; 引用配置 一个用户拥有多个订单,所以 用户是一的一方, 订单是多的一方 3.1.2 User类12345678910111213141516171819202122232425/** * 用户表 对应 User类 * `uid` VARCHAR(32) NOT NULL, * `username` VARCHAR(20) DEFAULT NULL, * `password` VARCHAR(20) DEFAULT NULL, * `telephone` VARCHAR(20) DEFAULT NULL, * `birthday` DATE DEFAULT NULL, * `sex` VARCHAR(10) DEFAULT NULL, * */public class User &#123; private String uid; private String username; private String password; private String telephone; private String birthday; private String sex; //提供 get set toString方法&#125; 3.1.3 Orders类1234567891011121314151617181920212223242526/** * 订单表 * `oid` VARCHAR(32) NOT NULL, * `ordertime` DATETIME DEFAULT NULL, * `total` DOUBLE DEFAULT NULL, * `name` VARCHAR(20) DEFAULT NULL, * `telephone` VARCHAR(20) DEFAULT NULL, * `address` VARCHAR(30) DEFAULT NULL, * `state` INT(11) DEFAULT NULL, * `uid` VARCHAR(32) DEFAULT NULL, * * */public class Orders &#123; private String oid; //订单号 private String ordertime; //下单时间 private double total; //订单的总金额 private String name; //收货人姓名 private String telephone; //收货人电话 private String address; //收货人地址 private int state; //订单状态 1 代表已支付 , 0 代表未支付 //订单属于哪个用户呢 ? //提供 get set toString方法&#125; 3.1.4 Orders类设计分析 第一种方式 根据两张表关系的描述 我们可以在 订单类中 添加一个uid 成员变量,表示订单属于哪个用户 1private String uid; 但是这样设计会存在一些问题,比如 我要查询的是订单是属于哪个用户的用户名 ? 但是我们只有一个uid 第二种方式 Java类表示一对多关系,可以在多的一方添加一个成员变量,这个成员变量的类型 就是一的一方的类型. 再在订单表中 添加一个 User对象,User对象中 ,保存该订单关联的用户的所有信息 12private String uid;private User user; 3.1.4 修改Orders类12345678910111213141516public class Orders &#123; private String oid; //订单号 private String ordertime; //下单时间 private double total; //订单的总金额 private String name; //收货人姓名 private String telephone; //收货人电话 private String address; //收货人地址 private int state; //订单状态 1 代表已支付 , 0 代表未支付 //订单属于哪个用户呢 ? private String uid; //表示外键 private User user; //用来保存订单对应的详细的用户信息 //提供 get set toString方法&#125; 3.2 设计商品与分类分类与商品 同样是一对多关系, 我们可以在多的一方进行操作 添加一个成员变量 类型是一的一方的类型 3.2.1 Category类1234567public class Category &#123; private String cid; private String cname; //提供 get set toString方法&#125; 3.2.2 Product类123456789101112131415161718public class Product &#123; private String pid; private String pname; private double price; private String pdesc; private int pflag; //是否上架 1 上架 ,0 下架 private String cid; //外键 对应分类表主键 private Category category; //用于保存Category的详细数据 //提供 get set toString方法&#125; 3.3 设计订单项3.3.1 多对多关系分析商品与订单是多对多关系, 一个订单上可以有多个商品, 一个商品可以出现在多个订单中. 多对多建表原则 需要一张中间表,中间表中至少有两个字段,作为中间表的外键分别指向另外两张表的主键 3.3.2 创建OrderItem123456789101112131415161718192021/** * 订单项表(中间表) * `itemid` VARCHAR(32) NOT NULL, * `pid` VARCHAR(32) DEFAULT NULL, * `oid` VARCHAR(32) DEFAULT NULL, * * */public class OrderItem &#123; //订单项 指的是中间表中的一条数据 private String itemid; //订单项的id private String pid; //外键 指向商品表主键 private String oid; //外键 指向订单表的主键 private Product product;//订单项内部的商品详细信息 private Orders orders;//订单项属于哪个订单 &#125; 4.编写DAO类4.1 UserDao 需求一: 编写一个注册用户的方法,接收的参数是一个User对象 需求二: 编写一个 用户登录的方法,接收的参数是 用户名 和密码, 返回值是User对象 4.1.1 编写UserDao123456789101112131415161718192021222324252627282930313233343536373839public class UserDao &#123; /** * 注册用户 * */ public int register(User user) throws SQLException &#123; //1.获取QueryRunner QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); //2.编写SQL String sql = &quot;insert into user values(?,?,?,?,?,?)&quot;; Object[] param = &#123;user.getUid(), user.getUsername(), user.getPassword(), user.getTelephone(), user.getBirthday(), user.getSex()&#125;; //3.执行插入操作 int update = qr.update(sql,param); //4.返回受影响的行数 return update; &#125; /** * 用户注册 * */ public User login(String username , String password) throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from user where username = ? and password = ?&quot;; //返回的是一个User对象 使用BeanHandler将结果集的第一条和数据封装到一个Javabean中 User user = qr.query(sql, new BeanHandler&lt;User&gt;(User.class), username, password); return user; &#125;&#125; 4.1.2 测试注册与登录功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestUserDao &#123; //创建UserDao UserDao userDao = new UserDao(); //测试注册功能 @Test public void testRegister() throws SQLException &#123; //1. 创建User对象 User user = new User(); //2. 对User对象进行赋值 user.setUid(UUIDUtils.getUUID()); user.setUsername(&quot;大郎&quot;); user.setPassword(&quot;654321&quot;); user.setTelephone(&quot;15052005200&quot;); user.setSex(&quot;男&quot;); user.setBirthday(DateUtils.getDateFormart()); //3.执行注册 int register = userDao.register(user); //4.判断注册是否成功 if(register &gt; 0)&#123; System.out.println(&quot;注册成功,欢迎您: &quot; + user.getUsername()); &#125;else&#123; System.out.println(&quot;注册失败! !&quot;); &#125; &#125; //测试登录功能 @Test public void testLogin() throws SQLException &#123; //调用UserDao的 login方法,传入用户名密码 User user = userDao.login(&quot;大郎&quot;, &quot;654321&quot;); //判断user不为空 登录成功 if(user != null)&#123; System.out.println(user.getUsername() +&quot; 欢迎您!&quot;); &#125;else&#123; System.out.println(&quot;用户名或者密码错误! !&quot;); &#125; &#125;&#125; 4.2 ProductDao 需求1: 根据商品ID 获取商品名称 ,商品价格 以及商品所属分类的名称 参数 pid, 返回值 product对象 需求2: 根据分类ID 获取商品分类信息 参数 cid , 返回值 category对象 需求3: 查询指定分类ID 下的商品个数 参数 cid , 返回值 int类型 商品个数 需求4: 查询指定分类ID 下的所有商品信息 参数分类ID ,返回值 List集合 集合中保存商品对象 4.2.1 编写 ProductDao123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ProductDao &#123; //1.根据商品ID 获取商品名称 ,商品价格 以及商品所属分类的名称 public Product findProductById(String pid) throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from product where pid = ?&quot;; Product product = qr.query(sql, new BeanHandler&lt;Product&gt;(Product.class), pid); //调用 findCategoryById()方法, 传递外键cid 获取商品对应 的分类信息 Category category = findCategoryById(product.getCid()); //将category保存到商品对象中 product.setCategory(category); return product; &#125; //2.根据分类ID 获取商品分类信息 public Category findCategoryById(String cid) throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from category where cid = ?&quot;; Category category = qr.query(sql, new BeanHandler&lt;Category&gt;(Category.class),cid); return category; &#125; //3.查询指定分类ID 下的商品个数 public int getCount(String cid) throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select count(*) from product where cid = ?&quot;; //获取的单列数据 ,使用ScalarHandler 封装 Long count = (Long)qr.query(sql,new ScalarHandler&lt;&gt;(),cid); //将Lang类型转换为 int 类型,并返回 return count.intValue(); &#125; //4.查询指定分类下的所有商品信息 public List&lt;Product&gt; findProductByCid(String cid) throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from product where cid = ?&quot;; //查询结果是一个List集合, 使用BeanListHandler 封装结果集 List&lt;Product&gt; list = qr.query(sql, new BeanListHandler&lt;Product&gt;(Product.class), cid); return list; &#125;&#125; 4.2.2 测试 ProductDao123456789101112131415161718192021222324252627282930313233343536public class TestProductDao &#123; ProductDao productDao = new ProductDao(); //1.测试 根据商品ID 获取商品名称 ,商品价格 以及商品所属分类的名称 @Test public void testFindProductById() throws SQLException &#123; Product product = productDao.findProductById(&quot;1&quot;); System.out.println(&quot;商品名称: &quot;+product.getPname()+ &quot;, 商品价格: &quot; + product.getPrice() + &quot;, 商品所属分类: &quot;+ product.getCategory().getCname()); &#125; //2.测试 查询指定分类ID下的商品数 @Test public void testGetCount() throws SQLException &#123; //查询 cid为3的分类下有多少个商品 int count = productDao.getCount(&quot;3&quot;); System.out.println(&quot;分类ID为3的分类下商品个数: &quot; + count); &#125; //3.测试 查询指定分类下的所有商品信息 @Test public void testFindProductByCid() throws SQLException &#123; //查询cid为 2的分类下 所有的商品信息 List&lt;Product&gt; list = productDao.findProductByCid(&quot;2&quot;); for (Product product : list) &#123; System.out.println(product); &#125; &#125;&#125; 4.3 OrdersDao4.3.1 多对一分析OrderItem表与Orders表的关系是 多对一 之前我们一直是在描述一对多,那么我们再反向描述一下 多对一 方式是在Orders中应该有一个 集合用来保存订单中的订单项信息 在Orders类中添加 订单项的集合 12345678910//该订单中有多少订单项 List&lt;OrderItem&gt; orderItems = new ArrayList&lt;OrderItem&gt;(); public List&lt;OrderItem&gt; getOrderItems() &#123; return orderItems; &#125; public void setOrderItems(List&lt;OrderItem&gt; orderItems) &#123; this.orderItems = orderItems; &#125; 4.3.2 创建OrdersDao 需求1: 获取 uid为 001 的用户的所有订单信息 参数 uid, 返回值 LIst 订单集合 需求2: 获取订单编号为 order001的订单中的所有商品信息 参数 oid, 返回值List 商品集合 123456789101112-- 获取订单编号为: order001的订单中的所有商品信息-- 1.查询订单项表中 oid是order001的 所有商品信息SELECT oi.pidFROM orderitem oi WHERE oid = &#x27;order001&#x27;;-- 2.将上面的查询语句作为in函数的条件, 查询product表SELECT * FROM product WHERE pid IN(SELECT oi.pidFROM orderitem oi WHERE oid = &#x27;order001&#x27;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class OrdersDao &#123; //需求1: 获取 uid为 001 的用户的所有订单信息 public List&lt;Orders&gt; findAllOrders(String uid) throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from orders where uid = ?&quot;; //一个用户所有的订单信息 List&lt;Orders&gt; ordersList = qr.query(sql, new BeanListHandler&lt;Orders&gt;(Orders.class), uid); return ordersList; &#125; //需求2: 获取订单编号为 order001的订单中的所有商品信息 public List&lt;Product&gt; findOrderById(String oid) throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); //1.查询订单项表 获取订单项表中 订单ID为order001的数据 String sql = &quot;SELECT pid FROM orderitem WHERE oid = ? &quot;; //2.查询的结果是 多条订单项数据 List&lt;OrderItem&gt; list = qr.query(sql, new BeanListHandler&lt;OrderItem&gt;(OrderItem.class), oid); //3.创建集合保存商品信息 List&lt;Product&gt; productList = new ArrayList&lt;&gt;(); ProductDao productDao = new ProductDao(); //4.遍历订单项集合 获取Pid for (OrderItem orderItem : list) &#123; //4.1从orderitem中获取 pid String pid = orderItem.getPid(); //4.2 调用productDao Product product = productDao.findProductById(pid); //4.3 保存到集合 productList.add(product); &#125; //返回 订单中对应的商品信息 return productList; &#125;&#125; 4.3.3 测试OrdersDao123456789101112131415161718192021222324252627public class TestOrderDao &#123; OrdersDao ordersDao = new OrdersDao(); //1.获取 uid为 001 的用户的所有订单信息 @Test public void testFindAllOrders() throws SQLException &#123; List&lt;Orders&gt; allOrders = ordersDao.findAllOrders(&quot;001&quot;); //遍历打印订单信息 for (Orders order : allOrders) &#123; System.out.println(order); &#125; &#125; //测试 获取订单编号为: order001的订单中的所有商品信息 @Test public void testFindOrderById() throws SQLException &#123; List&lt;Product&gt; list = ordersDao.findOrderById(&quot;order001&quot;); System.out.println(&quot;订单编号为order001中的商品有: &quot;); for (Product product : list) &#123; System.out.println(product); &#125; &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"数据库连接池&DBUtils","slug":"数据库连接池-DBUtils","date":"2019-12-22T23:31:53.000Z","updated":"2025-04-17T08:34:52.023Z","comments":true,"path":"2019/12/23/数据库连接池-DBUtils/","link":"","permalink":"http://yournotes.cn/2019/12/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-DBUtils/","excerpt":"1. 数据库连接池1.1 连接池介绍 什么是连接池","text":"1. 数据库连接池1.1 连接池介绍 什么是连接池 实际开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程，为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection。这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池. 连接池的好处 用池来管理Connection，这样可以重复使用Connection。 当使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池。 1.2 JDBC方式与连接池方式 普通JDBC方式 连接池方式 1.3 如何使用数据库连接池Java为数据库连接池提供了公共的接口：javax.sql.DataSource，各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池！ 常见的连接池有 DBCP连接池, C3P0连接池, Druid连接池, 接下里我们就详细学习一下 1.4 数据准备12345678910111213141516171819202122232425-- 创建数据库 -- CREATE DATABASE db5 CHARACTER SET utf8;-- 使用数据库 -- USE db5;-- 创建员工表 -- CREATE TABLE employee ( eid INT PRIMARY KEY AUTO_INCREMENT, ename VARCHAR (20), -- 员工姓名 age INT , -- 员工年龄 sex VARCHAR (6), -- 员工性别 salary DOUBLE , -- 薪水 empdate DATE -- 入职日期 );-- 插入数据 --INSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,&#x27;李清 照&#x27;,22,&#x27;女&#x27;,4000,&#x27;2018-11-12&#x27;); INSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,&#x27;林黛玉&#x27;,20,&#x27;女&#x27;,5000,&#x27;2019-03-14&#x27;); INSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,&#x27;杜甫&#x27;,40,&#x27;男&#x27;,6000,&#x27;2020-01-01&#x27;); INSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,&#x27;李白&#x27;,25,&#x27;男&#x27;,3000,&#x27;2017-10-01&#x27;); 1.5 DBCP连接池DBCP也是一个开源的连接池，是Apache成员之一，在企业开发中也比较常见，tomcat内置的连接池。 1.5.1 创建项目 导入jar包1）将这两个 jar包添加到 myJar文件夹中 （jar包在资料里的软件文件夹中） 2） 添加myJar库 到项目的依赖中 1.5.2 编写工具类 连接数据库表的工具类, 采用DBCP连接池的方式来完成 Java中提供了一个连接池的规则接口 ： DataSource , 它是java中提供的连接池 在DBCP包中提供了DataSource接口的实现类，我们要用的具体的连接池BasicDataSource 类 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DBCPUtils&#123; // 1.定义常量 保存数据库连接的相关信息 public static final String DRIVERNAME = &quot;com.mysql.jdbc.Driver&quot;; public static final String URL = &quot;jdbc:mysql://localhost:3306/db5?characterEncoding=UTF-8&quot;; public static final String USERNAME = &quot;root&quot;; public static final String PASSWORD = &quot;123456&quot;; // 2.创建连接池对象（由DBCP提供的实现类） public static BasicDataSource dataSource = new BasicDataSource(); // 3.使用静态代码块配置 static&#123; dataSource.setDriverClassName(DRIVERNAME); dataSource.setUrl(URL); dataSource.setUsername(USERNAME); dataSource.setPassword(PASSWORD); &#125; //4.获取连接的方法 public static Connection getConnection() throws SQLException &#123; //从连接池中获取连接 Connection connection = dataSource.getConnection(); return connection; &#125; //5.释放资源方法 public static void close(Connection con, Statement statement)&#123; if(con != null &amp;&amp; statement != null)&#123; try &#123;statement.close(); //归还连接 con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(Connection con, Statement statement, ResultSet resultSet)&#123; if(con != null &amp;&amp; statement != null &amp;&amp; resultSet != null)&#123; try &#123; resultSet.close(); statement.close(); //归还连接 con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1.5.3 测试工具类需求：查询所有员工的姓名 1234567891011121314151617181920212223242526public class TestDBCP &#123; /* * 测试DBCP连接池 * */ public static void main(String[] args) throws SQLException &#123; //1.从DBCP连接池中拿到连接 Connection con = DBCPUtils.getConnection(); //2.获取Statement对象 Statement statement = con.createStatement(); //3.查询所有员工的姓名 String sql = &quot;select ename from employee&quot;; ResultSet resultSet = statement.executeQuery(sql); //4.处理结果集 while(resultSet.next())&#123; String ename = resultSet.getString(&quot;ename&quot;); System.out.println(&quot;员工姓名: &quot; + ename); &#125; //5.释放资源 DBCPUtils.close(con,statement,resultSet); &#125; &#125; 1.5.4 常见配置项 属性 描述 driverClassName 数据库驱动名称 url 数据库地址 username 用户名 password 密码 maxActive 最大连接数量 maxIdle 最大空闲连接 minIdle 最小空闲连接 initialSize 初始化连接 1.6 C3P0 连接池C3P0是一个开源的JDBC连接池,支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。 1.6.1 导入jar包及配置文件 将jar包 复制到myJar文件夹即可,IDEA会自动导入 导入配置文件 c3p0-confifig.xml c3p0-confifig.xml 文件名不可更改 直接放到src下，也可以放到到资源文件夹中 12345678910111213141516171819202122232425262728&lt;c3p0-config&gt; &lt;!--默认配置--&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/db5?characterEncoding=UTF-8&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;!-- initialPoolSize：初始化时获取三个连接， 取值应在minPoolSize与maxPoolSize之间。 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;3&lt;/property&gt; &lt;!-- maxIdleTime：最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。--&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;60&lt;/property&gt; &lt;!-- maxPoolSize：连接池中保留的最大连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;!-- minPoolSize: 连接池中保留的最小连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;/default-config&gt; &lt;!--配置连接池mysql--&gt; &lt;named-config name=&quot;mysql&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/db5&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;/named-config&gt; &lt;!--配置连接池2,可以配置多个--&gt; &lt;/c3p0-config&gt; 在项目下创建一个resource文件夹(专门存放资源文件) 选择文件夹,右键 将resource文件夹指定为资源文件夹 将文件放在resource目录下即可,创建连接池对象的时候会去加载这个配置文件 1.6.2 编写C3P0工具类 C3P0提供的核心工具类, ComboPooledDataSource , 如果想使用连接池,就必须创建该类的对象 new ComboPooledDataSource(); 使用 默认配置 new ComboPooledDataSource(“mysql”); 使用命名配置 12345678910111213141516171819202122232425262728293031323334353637public class C3P0Utils &#123; //1.创建连接池对象 C3P0对DataSource接口的实现类 //使用的配置是 配置文件中的默认配置 //public static ComboPooledDataSource dataSource = new ComboPooledDataSource(); //使用指定的配置 public static ComboPooledDataSource dataSource = new ComboPooledDataSource(&quot;mysql&quot;); //获取连接的方法 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; //释放资源 public static void close(Connection con, Statement statement)&#123; if(con != null &amp;&amp; statement != null)&#123; try &#123; statement.close(); //归还连接 con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(Connection con, Statement statement, ResultSet resultSet)&#123; if(con != null &amp;&amp; statement != null &amp;&amp; resultSet != null)&#123; try &#123; resultSet.close(); statement.close(); //归还连接 con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1.6.3 测试工具类需求：查询姓名为 李白的员工信息 1234567891011121314151617181920212223242526272829public class TestC3P0 &#123; //需求 查询姓名为李白的 记录 public static void main(String[] args) throws SQLException &#123; //1.获取连接 Connection con = C3P0Utils.getConnection(); //2.获取预处理对象 String sql = &quot;select * from employee where ename = ?&quot;; PreparedStatement ps = con.prepareStatement(sql); //3.设置占位符的值 ps.setString(1,&quot;李白&quot;); ResultSet resultSet = ps.executeQuery(); //4.处理结果集 while(resultSet.next())&#123; int eid = resultSet.getInt(&quot;eid&quot;); String ename = resultSet.getString(&quot;ename&quot;); int age = resultSet.getInt(&quot;age&quot;); String sex = resultSet.getString(&quot;sex&quot;); double salary = resultSet.getDouble(&quot;salary&quot;); Date date = resultSet.getDate(&quot;empdate&quot;); System.out.println(eid +&quot; &quot; + ename + &quot; &quot; + age +&quot; &quot; + sex +&quot; &quot; + salary +&quot; &quot; +date); &#125; //5.释放资源 C3P0Utils.close(con,ps,resultSet); &#125; &#125; 1.6.4 常见配置 1.7 Druid 连接池Druid（德鲁伊）是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况。 1.7.1 导入jar包及配置文件 导入 jar包 导入配置文件 是properties形式的 可以叫任意名称，可以放在任意目录下,我们统一放到 resources资源目录 1234567driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/db5?characterEncoding=UTF-8 username=root password=123456 initialSize=5 maxActive=10 maxWait=3000 1.7.2 编写Druid工具类 获取数据库连接池对象 通过工厂来来获取 DruidDataSourceFactory类的createDataSource方法 createDataSource(Properties p) 方法参数可以是一个属性集对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class DruidUtils &#123; //1.定义成员变量 public static DataSource dataSource; //2.静态代码块 static&#123; try &#123; //3.创建属性集对象 Properties p = new Properties(); //4.加载配置文件 Druid 连接池不能够主动加载配置文件 ,需要指定文件 InputStream inputStream = DruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); //5. 使用Properties对象的 load方法 从字节流中读取配置信息 p.load(inputStream); //6. 通过工厂类获取连接池对象 dataSource = DruidDataSourceFactory.createDataSource(p); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获取连接的方法 public static Connection getConnection()&#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); return null; &#125; &#125; //释放资源 public static void close(Connection con, Statement statement)&#123; if(con != null &amp;&amp; statement != null)&#123; try &#123; statement.close(); //归还连接 con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(Connection con, Statement statement, ResultSet resultSet)&#123; if(con != null &amp;&amp; statement != null &amp;&amp; resultSet != null)&#123; try &#123; resultSet.close(); statement.close(); //归还连接 con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1.7.3 测试工具类需求：查询薪资在3000-5000元之间的员工姓名 12345678910111213141516171819202122public class TestDruid &#123; // 需求 查询 薪资在3000 到 5000之间的员工的姓名 public static void main(String[] args) throws SQLException &#123; //1.获取连接 Connection con = DruidUtils.getConnection(); //2.获取Statement对象 Statement statement = con.createStatement(); //3.执行查询 ResultSet resultSet = statement.executeQuery(&quot;select ename from employee where salary between 3000 and 5000&quot;); //4.处理结果集 while(resultSet.next())&#123; String ename = resultSet.getString(&quot;ename&quot;); System.out.println(ename); &#125; //5.释放资源 DruidUtils.close(con,statement,resultSet); &#125; &#125; 2. DBUtils工具类2.1 DBUtils简介使用JDBC我们发现冗余的代码太多了,为了简化开发 我们选择使用 DbUtils Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。 使用方式: DBUtils就是JDBC的简化开发工具包。需要项目导入commons-dbutils-1.6.jar。 2.1.1 DBUtils核心功能介绍 QueryRunner 中提供对sql语句操作的API. ResultSetHandler接口，用于定义select操作后，怎样封装结果集. DbUtils类,他就是一个工具类,定义了关闭资源与事务处理相关方法 2.2 案列相关知识2.2.1 表和类之间的关系 整个表可以看做是一个类 表中的一行记录,对应一个类的实例(对象) 表中的一列,对应类中的一个成员属性 2.2.2 JavaBean组件 JavaBean 就是一个类, 开发中通常用于封装数据,有一下特点 需要实现 序列化接口, Serializable (暂时可以省略) 提供私有字段: private 类型 变量名; 提供 getter 和 setter 提供 空参构造 创建Employee类和数据库的employee表对应 我们可以创建一个 entity包,专门用来存放 JavaBean类 123456789public class Employee implements Serializable &#123; private int eid; private String ename; private int age; private String sex; private double salary; private Date empdate; //空参 getter setter省略 &#125; 2.3 DBUtils完成 CRUD2.3.1 QueryRunner核心类 构造方法 QueryRunner() QueryRunner(DataSource ds) 提供数据源（连接池），DBUtils底层自动维护连接connection 常用方法 update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作 query(Connection conn, String sql, ResultSetHandler rsh, Object… params)，用来完成表数据的查询操作 2.3.2 QueryRunner的创建 手动模式 12//手动方式 创建QueryRunner对象 QueryRunner qr = new QueryRunner(); 自动模式 12//自动创建 传入数据库连接池对象 QueryRunner qr2 = new QueryRunner(DruidUtils.getDataSource()); 自动模式需要传入连接池对象 1234//获取连接池对象 public static DataSource getDataSource()&#123; return dataSource; &#125; 2.3.3 QueryRunner实现增删改核心方法 update(Connection conn, String sql, Object… params) 参数 说明 Connection conn 数据库连接对象, 自动模式创建QueryRun 可以不传 ,手动模式必须传递 String sql String sql 占位符形式的SQL ,使用 ? 号占位符 Object… param Object类型的 可变参,用来设置占位符上的参数 步骤 创建QueryRunner(手动或自动) 占位符方式 编写SQL 设置占位符参数 执行 2.3.3.1添加1234567891011121314151617@Test public void testInsert() throws SQLException &#123; //1.创建 QueryRunner 手动模式创建 QueryRunner qr = new QueryRunner(); //2.编写 占位符方式 SQL String sql = &quot;insert into employee values(?,?,?,?,?,?)&quot;; //3.设置占位符的参数 Object[] param = &#123;null,&quot;张百万&quot;,20,&quot;女&quot;,10000,&quot;1990-12-26&quot;&#125;; //4.执行 update方法 Connection con = DruidUtils.getConnection(); int i = qr.update(con, sql, param); //5.释放资源 DbUtils.closeQuietly(con); &#125; 2.3.3.2 修改1234567891011121314//修改操作 修改姓名为张百万的员工工资 @Test public void testUpdate() throws SQLException &#123; //1.创建QueryRunner对象 自动模式,传入数据库连接池 QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); //2.编写SQL String sql = &quot;update employee set salary = ? where ename = ?&quot;; //3.设置占位符参数 Object[] param = &#123;0,&quot;张百万&quot;&#125;; //4.执行update, 不需要传入连接对象 qr.update(sql,param); &#125; 2.3.3.3 删除 1234567//删除操作 删除id为1 的数据 @Test public void testDelete() throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;delete from employee where eid = ?&quot;; //只有一个参数,不需要创建数组 qr.update(sql,1); &#125; 2.3.4QueryRunner实现查询操作2.3.4.1 ResultSetHandler接口简介 ResultSetHandler可以对查询出来的ResultSet结果集进行处理，达到一些业务上的需求。 2.3.4.2 ResultSetHandler结果集处理类本例展示的是使用ResultSetHandler接口的几个常见实现类实现数据库的增删改查，可以大大减少代码量，优化、程序。 每一种实现类都代表了对查询结果集的一种处理方式 ResultSetHandler实现类 说明 ArrayHandler 将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值 ArrayListHandler 将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。 BeanHandler 将结果集中第一条记录封装到一个指定的javaBean中. BeanListHandler 将结果集中每一条记录封装到指定的javaBean中，再将这些javaBean在封装到List集合中 ColumnListyHandler 将结果集中指定的列的字段值，封装到一个List集合中 KeyedHandler 将结果集中每一条记录封装到Map&lt;String,Object&gt;,在将这个map集合做为另一个Map的value,另一个Map集合的key是指定的字段的值。 MapHandler 将结果集中第一条记录封装到了Map&lt;String,Object&gt;集合中，key就是字段名称，value就是字段值 MapListHandler 将结果集中每一条记录封装到了Map&lt;String,Object&gt;集合中，key就是字段名称，value就是字段值，在将这些Map封装到List集合中。 ScalarHandler 它是用于封装单个数据。例如 select count(*) from 表操作。 ResultSetHandler 常用实现类测试 QueryRunner的查询方法 query方法的返回值都是泛型,具体的返回值类型,会根据结果集的处理方式,发生变化 方法 说明 query(String sql, handler ,Object[] param) 自动模式创建QueryRunner, 执行查询 query(Connection con,String sql,handler,Object[] param) 手动模式创建QueryRunner, 执行查询 创建一个测试类, 对ResultSetHandler接口的几个常见实现类进行测试 查询id为5的记录,封装到数组中 查询所有数据,封装到List集合中 查询id为5的记录,封装到指定JavaBean中 查询薪资大于 3000 的所员工信息,封装到JavaBean中再封装到List集合中 查询姓名是 张百万的员工信息,将结果封装到Map集合中 查询所有员工的薪资总额 查询id为5的记录,封装到数组中 1234567891011121314151617/* * 查询id为5的记录,封装到数组中 * ArrayHandler 将结果集的第一条数据封装到数组中 * */ @Test public void testFindById() throws SQLException &#123; //1.创建QueryRunner QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); //2.编写SQL String sql = &quot;select * from employee where eid = ?&quot;; //3.执行查询 Object[] query = qr.query(sql, new ArrayHandler(), 5); //4.获取数据 System.out.println(Arrays.toString(query)); &#125; 查询所有数据,封装到List集合中 12345678910111213141516171819/** * 查询所有数据,封装到List集合中 * ArrayListHandler可以将每条数据先封装到数组中, 再将数组封装到集合中 **/ @Test public void testFindAll() throws SQLException &#123; //1.创建QueryRunner QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); //2.编写SQL String sql = &quot;select * from employee&quot;; //3.执行查询 List&lt;Object[]&gt; query = qr.query(sql, new ArrayListHandler()); //4.遍历集合获取数据 for (Object[] objects : query) &#123; System.out.println(Arrays.toString(objects)); &#125; &#125; 根据ID查询,封装到指定JavaBean中 1234567891011/** * 查询id为3的记录,封装到指定JavaBean中 * BeanHandler 将结果集的第一条数据封装到 javaBean中 * **/@Test public void testFindByIdJavaBean() throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from employee where eid = ?&quot;; Employee employee = qr.query(sql, new BeanHandler&lt;Employee&gt;(Employee.class), 3); System.out.println(employee); &#125; 查询薪资大于 3000 的所员工信息,封装到JavaBean中再封装到List集合中 123456789101112/** * 查询薪资大于 3000 的所员工信息,封装到JavaBean中再封装到List集合中 * BeanListHandler 将结果集的每一条和数据封装到 JavaBean中 再将JavaBean 放到list集合中 **/ @Test public void testFindBySalary() throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from employee where salary &gt; ?&quot;; List&lt;Employee&gt; list = qr.query(sql, new BeanListHandler&lt;Employee&gt;(Employee.class), 3000); for (Employee employee : list) &#123; System.out.println(employee); &#125; &#125; 查询姓名是 张百万的员工信息,将结果封装到Map集合中 123456789101112131415/** *查询姓名是 张百万的员工信息,将结果封装到Map集合中 * MapHandler 将结果集的第一条记录封装到 Map&lt;String,Object&gt;中 * key对应的是 列名 value对应的是 列的值 **/ @Test public void testFindByName() throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select * from employee where ename = ?&quot;; Map&lt;String, Object&gt; map = qr.query(sql, new MapHandler(), &quot;张百万&quot;); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;String, Object&gt; entry : entries) &#123; //打印结果 System.out.println(entry.getKey() +&quot; = &quot; +entry.getValue()); &#125; &#125; 查询所有员工的薪资总额 12345678910/** *查询所有员工的薪资总额 * ScalarHandler 用于封装单个的数据 **/ @Test public void testGetSum() throws SQLException &#123; QueryRunner qr = new QueryRunner(DruidUtils.getDataSource()); String sql = &quot;select sum(salary) from employee&quot;; Double sum = (Double)qr.query(sql, new ScalarHandler&lt;&gt;()); System.out.println(&quot;员工薪资总额: &quot; + sum); &#125; 3.数据批处理3.1 什么是批处理 批处理(batch) 操作数据库 批处理指的是一次操作中执行多条SQL语句，批处理相比于一次一次执行效率会提高很多。 当向数据库中添加大量的数据时，需要用到批处理。 举例: 送货员的工作： 未使用批处理的时候，送货员每次只能运送 一件货物给商家； 使用批处理，则是送货员将所有要运送的货物, 都用车带到发放处派给客户。 3.2 实现批处理Statement和PreparedStatement都支持批处理操作，这里我们介绍一下PreparedStatement的批处理方式： 要用到的方法 方法 说明 void addBatch() 将给定的 SQL 命令添加到此 Statement 对象的当前命令列表中。通过调用方法 executeBatch 可以批量执行此列表中的命令。 int[] executeBatch() 每次提交一批命令到数据库中执行，如果所有的命令都成功执行了， mysql 批处理是默认关闭的，所以需要加一个参数才打开mysql 数据库批处理，在url中添加 12rewriteBatchedStatements=true 例如: url=jdbc:mysql://127.0.0.1:3306/db5?characterEncoding=UTF-8&amp;rewriteBatchedStatements=true 创建一张表 1234CREATE TABLE testBatch ( id INT PRIMARY KEY AUTO_INCREMENT, uname VARCHAR(50) ) 测试向表中插入 1万条数据 123456789101112131415161718192021222324252627public class TestBatch &#123; //使用批处理,向表中添加 1万条数据 public static void main(String[] args) &#123; try &#123; //1.获取连接 Connection con = DruidUtils.getConnection(); //2.获取预处理对象 String sql =&quot;insert into testBatch(uname) values(?)&quot;; PreparedStatement ps = con.prepareStatement(sql); //3.创建 for循环 来设置占位符参数 for (int i = 0; i &lt; 10000 ; i++) &#123; ps.setString(1,&quot;小强&quot;+i); //将SQL添加到批处理 列表 ps.addBatch(); &#125; //添加时间戳 测试执行效率 long start = System.currentTimeMillis(); //统一 批量执行 ps.executeBatch(); long end = System.currentTimeMillis(); System.out.println(&quot;插入10000条数据使用: &quot; +(end - start) +&quot; 毫秒!&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4. MySql元数据4.1 什么是元数据 除了表之外的数据都是元数据,可以分为三类 查询结果信息： UPDATE 或 DELETE语句 受影响的记录数。 数据库和数据表的信息： 包含了数据库及数据表的结构信息。 MySQL****服务器信息： 包含了数据库服务器的当前状态，版本号等。 4.2 常用命令123456789-- 元数据相关的命令介绍 -- 1.查看服务器当前状态 -- 2.查看MySQl的版本信息 -- 3.查询表中的详细信息 -- 4.显示数据表的详细索引信息 -- 5.列出所有数据库 -- 6.显示当前数据库的所有表 -- 7.获取当前的数据库名 select version(); 获取mysql服务器的版本信息 show status; 查看服务器的状态信息 show columns from table_name; 显示表的字段信息等，和desc table_name一样 show index from table_name; 显示数据表的详细索引信息，包括PRIMARY KEY（主键） show databases:列出所有数据库 show tables : 显示当前数据库的所有表 select database(): 获取当前的数据库名 4.3 使用JDBC 获取元数据通过JDBC 也可以获取到元数据,比如数据库的相关信息,或者当我们使用程序查询一个不熟悉的表时, 我们可以通过获取元素据信息,了解表中有多少个字段,字段的名称 和 字段的类型 4.3.1 常用类介绍 JDBC中描述元数据的类 元数据类 作用 DatabaseMetaData 描述数据库的元数据对象 ResultSetMetaData 描述结果集的元数据对象 获取元数据对象的方法 : getMetaData () connection 连接对象, 调用 getMetaData () 方法,获取的是DatabaseMetaData 数据库元数据对象 PrepareStatement 预处理对象调用 getMetaData () , 获取的是ResultSetMetaData , 结果集元数据对象 DatabaseMetaData的常用方法 方法 说明 getURL() 获取数据库的URL getUserName() 获取当前数据库的用户名 getDatabaseProductName() 获取数据库的产品名称 getDatabaseProductVersion() 获取数据的版本号 getDriverName() 返回驱动程序的名称 isReadOnly() 判断数据库是否只允许只读 true 代表只读 ResultSetMetaData的常用方法 方法 说明 getColumnCount() 当前结果集共有多少列 getColumnName(int i) 获取指定列号的列名, 参数是整数 从1开始 getColumnTypeName(int i) 获取指定列号列的类型, 参数是整数 从1开始 4.3.2 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TestMetaData &#123; //获取数据库相关的元数据信息 使用DatabaseMetaData @Test public void testDataBaseMetaData() throws SQLException &#123; //1.获取数据库连接对象 connection Connection connection = DruidUtils.getConnection(); //2.获取代表数据库的 元数据对象 DatabaseMetaData DatabaseMetaData metaData = connection.getMetaData(); //3.获取数据库相关的元数据信息 String url = metaData.getURL(); System.out.println(&quot;数据库URL: &quot; + url); String userName = metaData.getUserName(); System.out.println(&quot;当前用户: &quot; + userName ); String productName = metaData.getDatabaseProductName(); System.out.println(&quot;数据库产品名: &quot; + productName); String version = metaData.getDatabaseProductVersion(); System.out.println(&quot;数据库版本: &quot; + version); String driverName = metaData.getDriverName(); System.out.println(&quot;驱动名称: &quot; + driverName); //判断当前数据库是否只允许只读 boolean b = metaData.isReadOnly(); //如果是 true 就表示 只读 if(b)&#123; System.out.println(&quot;当前数据库只允许读操作!&quot;); &#125;else&#123; System.out.println(&quot;不是只读数据库&quot;); &#125; connection.close(); &#125; //获取结果集中的元数据信息 @Test public void testResultSetMetaData() throws SQLException &#123; //1.获取连接 Connection con = DruidUtils.getConnection(); //2.获取预处理对象 PreparedStatement ps = con.prepareStatement(&quot;select * from employee&quot;); ResultSet resultSet = ps.executeQuery(); //3.获取结果集元素据对象 ResultSetMetaData metaData = ps.getMetaData(); //4.获取当前结果集 共有多少列 int count = metaData.getColumnCount(); System.out.println(&quot;当前结果集中共有: &quot; + count + &quot; 列&quot;); //5.结果集中 列的名称 和 类型 for (int i = 1; i &lt;= count; i++) &#123; String columnName = metaData.getColumnName(i); System.out.println(&quot;列名: &quot;+ columnName); String columnTypeName = metaData.getColumnTypeName(i); System.out.println(&quot;类型: &quot; +columnTypeName); &#125; //释放资源 DruidUtils.close(con,ps,resultSet); &#125; &#125;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"JDBC","slug":"JDBC","date":"2019-12-22T04:57:36.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2019/12/22/JDBC/","link":"","permalink":"http://yournotes.cn/2019/12/22/JDBC/","excerpt":"1. JDBC概述1.1 客户端操作数据库的方式 方式1: 使用第三方客户端来访问 MySQL：SQLyog、Navicat等等","text":"1. JDBC概述1.1 客户端操作数据库的方式 方式1: 使用第三方客户端来访问 MySQL：SQLyog、Navicat等等 方式2: 使用命令行 我们今天要学习的是通过 Java程序 来访问 MySQL 数据库 1.2 什么是JDBC JDBC(Java Data Base Connectivity) 是 Java 访问数据库的标准规范.是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范. 1.3 JDBC原理 JDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。 总结： JDBC就是由sun公司定义的一套操作所有关系型数据库的规则(接口)，而数据库厂商需要实现这套接口,提供数据库驱动jar包, 我们可以使用这套接口编程,真正执行的代码是对应驱动包中的实现类。 2. JDBC开发2.1 数据准备12345678910111213141516-- 创建 jdbc_user表 CREATE TABLE jdbc_user ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50), PASSWORD VARCHAR(50), birthday DATE ); -- 添加数据 INSERT INTO jdbc_user (username, PASSWORD,birthday) VALUES(&#x27;admin1&#x27;, &#x27;123&#x27;,&#x27;1991/12/24&#x27;), (&#x27;admin2&#x27;,&#x27;123&#x27;,&#x27;1995/12/24&#x27;), (&#x27;test1&#x27;, &#x27;123&#x27;,&#x27;1998/12/24&#x27;), (&#x27;test2&#x27;, &#x27;123&#x27;,&#x27;2000/12/24&#x27;); 2.2 MySql驱动包 将MySQL驱动包添加到jar包库文件夹中，Myjar文件夹,用于存放当前项目需要的所有jar包 在 idea中 配置jar包库的位置 创建一个新的项目jdbc_task01, 配置jar包库 2.3 API使用：1.注册驱动 JDBC规范定义驱动接口： java.sql.Driver MySql驱动包提供了实现类： com.mysql.jdbc.Driver 加载注册驱动的方式 描述 Class.forName(数据库驱动实现类) 加载和注册数据库驱动,数据库驱动由数据库厂商MySql提供 代码示例 1234567public class JDBCDemo01 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //1.注册驱动 // forName 方法执行将类进行初始化 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; &#125; 为什么这样可以注册驱动? 我们知道 Class类的forName方法 ,可以将一个类初始化, 现在我们一起Driver类的 看一下源码 123456789101112131415161718// Driver类是MySql提供的数据库驱动类, 实现了JDBC的Driver接口 java.sql.Driver public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // 空参构造 public Driver() throws SQLException &#123; &#125; //静态代码块,Class类的 forName()方法将Driver类 加载到内存, static代码块会自动执行 static &#123; try &#123; /* DriverManager 驱动管理类 registerDriver(new Driver) 注册驱动的方法 注册数据库驱动 */ DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; &#125; 注： 从 JDBC3 开始，目前已经普遍使用的版本。可以不用注册驱动而直接使用。 Class.forName 这句话可以省略。 2.4 API使用：2.获得连接 Connection 接口，代表一个连接对象 ,具体的实现类由数据库的厂商实现 使用 DriverManager类的静态方法,getConnection可以获取数据库的连接 获取连接的静态方法 说明 Connection getConnection(String url, String user,String password) 通过连接字符串和用户名,密码来获取数据 getConnection方法 3个 连接参数说明 连接参数 说明 user 登陆用户名 password 登录密码 url 数据库地址，mySql URL的格式jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db4 对URL的详细说明 1jdbc:mysql://localhost:3306/db4?characterEncoding=UTF-8 JDBC规定url的格式由三部分组成，每个部分中间使用冒号分隔。 第一部分是协议 jdbc，这是固定的； 第二部分是子协议，就是数据库名称，连接mysql数据库，第二部分当然是mysql了； 第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，mysql的第三部分分别由数据库服务器的IP地址（localhost）、端口号（3306），以及要使用的 数据库名称 组成。 代码示例 1234567891011public class JDBCDemo02 &#123; public static void main(String[] args) throws Exception &#123; //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获取连接 url,用户名, 密码 String url = &quot;jdbc:mysql://localhost:3306/db4&quot;; Connection con = DriverManager.getConnection(url, &quot;root&quot;, &quot;123456&quot;); //com.mysql.jdbc.JDBC4Connection@2e3fc542 System.out.println(con); &#125; &#125; 2.5 API使用：3.获取语句执行平台 通过Connection 的 createStatement方法 获取sql语句执行对象 Connection接口中的方法 说明 Statement createStatement() 创建 SQL语句执行对象 Statement ： 代表一条语句对象，用于发送 SQL 语句给服务器，用于执行静态 SQL 语句并返回它所生成结果的对象。 Statement类 常用方法 说明 int executeUpdate(String sql) 执行insert update delete语句.返回int类型,代表受影响的行数 ResultSet executeQuery(String 执行select语句, 返回ResultSet结果集对象 代码示例 1234567891011121314151617181920212223242526public class JDBCDemo03 &#123; public static void main(String[] args) throws Exception &#123; //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获取连接 url,用户名, 密码 String url = &quot;jdbc:mysql://localhost:3306/db4&quot;; Connection con = DriverManager.getConnection(url, &quot;root&quot;, &quot;123456&quot;); //3.获取 Statement对象 Statement statement = con.createStatement(); //4.执行创建表操作 String sql = &quot;create table test01(id int, name varchar(20),age int);&quot;; //5.增删改操作 使用executeUpdate,增加一张表 int i = statement.executeUpdate(sql); //6.返回值是受影响的函数 System.out.println(i); //7.关闭流 statement.close(); con.close(); &#125; &#125; 2.6 API使用：4.处理结果集 只有在进行查询操作的时候, 才会处理结果集 代码示例 1234567891011121314151617public class JDBCDemo04 &#123; public static void main(String[] args) throws SQLException &#123; //1.注册驱动 可以省略 //2.获取连接 String url = &quot;jdbc:mysql://localhost:3306/db4&quot;; Connection con = DriverManager.getConnection(url, &quot;root&quot;, &quot;123456&quot;); //3.获取 Statement对象 Statement statement = con.createStatement(); String sql = &quot;select * from jdbc_user&quot;; //执行查询操作,返回的是一个 ResultSet 结果对象 ResultSet resultSet = statement.executeQuery(sql); //4.处理结果集 resultSet &#125; &#125; 2.6.1 ResultSet接口 作用：封装数据库查询的结果集，对结果集进行遍历，取出每一条记录。 ResultSet接口方法 说明 boolean next() 1) 游标向下一行2) 返回 boolean 类型，如果还有下一条记录，返回 true，否则返回 false xxx getXxx( String or int) 1) 通过列名，参数是 String 类型。返回不同的类型2) 通过列号，参数是整数，从 1 开始。返回不同的类型 代码示例 12345678910111213141516171819202122232425262728293031public class JDBCDemo04 &#123; public static void main(String[] args) throws SQLException &#123; //1.注册驱动 可以省略 //2.获取连接 String url = &quot;jdbc:mysql://localhost:3306/db4&quot;; Connection con = DriverManager.getConnection(url, &quot;root&quot;, &quot;123456&quot;); //3.获取 Statement对象 Statement statement = con.createStatement(); String sql = &quot;select * from jdbc_user&quot;; //执行查询操作,返回的是一个 ResultSet 结果对象 ResultSet resultSet = statement.executeQuery(sql); //4.处理结果集 // 使用while循环 while(resultSet.next())&#123; //获取id int id = resultSet.getInt(&quot;id&quot;); //获取姓名 String username = resultSet.getString(&quot;username&quot;); //获取生日 Date birthday = resultSet.getDate(&quot;birthday&quot;); System.out.println(id + &quot; = &quot; +username + &quot; : &quot; + birthday); &#125; //关闭连接 resultSet.close(); statement.close(); con.close(); &#125; &#125; 2.7 API使用：5.释放资源 需要释放的对象：ResultSet 结果集，Statement 语句，Connection 连接 释放原则：先开的后关，后开的先关。ResultSet &#x3D;&#x3D;&gt; Statement &#x3D;&#x3D;&gt; Connection 放在哪个代码块中：fifinally 块 与IO流一样，使用后的东西都需要关闭！关闭的顺序是先开后关, 先得到的后关闭，后得到的先关闭 代码示例 1234567891011121314151617181920212223242526272829303132public class JDBCDemo05 &#123;public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; //1.注册驱动（省略） //2.获取连接 String url = &quot;jdbc:mysql://localhost:3306/db4&quot;; connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;123456&quot;); //3.获取 Statement对象 statement = connection.createStatement(); String sql = &quot;select * from jdbc_user&quot;; resultSet = statement.executeQuery(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; /** * 开启顺序: connection ==&gt; statement =&gt; resultSet * 关闭顺序: resultSet ==&gt; statement ==&gt; connection */ try &#123; resultSet.close(); statement.close(); connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 2.8 步骤总结 获取驱动(可以省略) 获取连接 获取Statement对象 处理结果集(只在查询时处理) 释放资源 3. JDBC实现增删改查3.1 JDBC工具类 什么时候自己创建工具类？ 如果一个功能经常要用到，我们建议把这个功能做成一个工具类，可以在不同的地方重用。 “获得数据库连接”操作，将在以后的增删改查所有功能中都存在，可以封装工具类JDBCUtils。提供获取连接对象的方法，从而达到代码的重复利用。 工具类包含的内容 可以把几个字符串定义成常量：用户名，密码，URL，驱动类 得到数据库的连接：getConnection() 关闭所有打开的资源： 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * JDBC 工具类 */ public class JDBCUtils &#123; //1. 定义字符串常量, 记录获取连接所需要的信息 public static final String DRIVERNAME = &quot;com.mysql.jdbc.Driver&quot;; public static final String URL = &quot;jdbc:mysql://localhost:3306/db4?characterEncoding=UTF-8&quot;; public static final String USER = &quot;root&quot;; public static final String PASSWORD = &quot;123456&quot;; //2. 静态代码块, 随着类的加载而加载 static&#123; try &#123; //注册驱动 Class.forName(DRIVERNAME); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //3.获取连接的静态方法 public static Connection getConnection()&#123; try &#123; //获取连接对象 Connection connection = DriverManager.getConnection(URL, USER, PASSWORD); //返回连接对象 return connection; &#125; catch (SQLException e) &#123; e.printStackTrace(); return null; &#125; &#125; //关闭资源的方法 public static void close(Connection con, Statement st)&#123; if(con != null &amp;&amp; st != null)&#123; try &#123; st.close(); con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(Connection con, Statement st, ResultSet rs)&#123; if(rs != null)&#123; try &#123;rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; close(con,st); &#125; &#125; 3.2 DML操作3.2.1 插入记录解决插入中文乱码问题 12jdbc:mysql://localhost:3306/db4?characterEncoding=UTF-8 characterEncoding=UTF-8 指定字符的编码、解码格式。 代码示例 12345678910111213141516171819202122/** * 插入数据 * @throws SQLException */ @Test public void testInsert() throws SQLException &#123; //1.通过工具类获取连接 Connection connection = JDBCUtils.getConnection(); //2.获取Statement Statement statement = connection.createStatement(); //2.1 编写Sql String sql = &quot;insert into jdbc_user values(null,&#x27;张百万&#x27;,&#x27;123&#x27;,&#x27;2020/1/1&#x27;)&quot;; //2.2 执行Sql int i = statement.executeUpdate(sql); System.out.println(i); //3.关闭流 JDBCUtils.close(connection,statement); &#125; 3.2.2 更新记录 根据ID 需改用户名称 12345678910/** * 修改 id 为1 的用户名为 木瓜煲鸡脚 */ @Test public void testUpdate() throws SQLException &#123; Connection connection = JDBCUtils.getConnection(); Statement statement = connection.createStatement(); String sql = &quot;update jdbc_user set username = &#x27;木瓜煲鸡脚&#x27; where id = 1&quot;; statement.executeUpdate(sql); JDBCUtils.close(connection,statement); &#125; 3.2.3 删除记录 删除id为3和4的记录 1234567891011/** * 删除id 为 3 和 4的记录 * @throws SQLException */ @Test public void testDelete() throws SQLException &#123; Connection connection = JDBCUtils.getConnection(); Statement statement = connection.createStatement(); statement.executeUpdate(&quot;delete from jdbc_user where id in(3,4)&quot;); JDBCUtils.close(connection,statement); &#125; 3.3 DQL操作3.3.1 查询姓名为木瓜煲鸡脚的一条记录12345678910111213141516171819202122public class TestJDBC02 &#123; public static void main(String[] args) throws SQLException &#123; //1.获取连接对象 Connection connection = JDBCUtils.getConnection(); //2.获取Statement对象 Statement statement = connection.createStatement(); String sql = &quot;SELECT * FROM jdbc_user WHERE username = &#x27;木瓜煲鸡脚&#x27;;&quot;; ResultSet resultSet = statement.executeQuery(sql); //3.处理结果集 while(resultSet.next())&#123; //通过列名 获取字段信息 int id = resultSet.getInt(&quot;id&quot;); String username = resultSet.getString(&quot;username&quot;); String password = resultSet.getString(&quot;password&quot;); String birthday = resultSet.getString(&quot;birthday&quot;); System.out.println(id+&quot; &quot;+username+&quot; &quot; + password +&quot; &quot; + birthday); &#125; //4.释放资源 JDBCUtils.close(connection,statement,resultSet); &#125; &#125; 4. SQL注入问题4.1 Sql注入演示 向jdbc_user表中 插入两条数据 123-- 插入2条数据 INSERT INTO jdbc_user VALUES(NULL,&#x27;jack&#x27;,&#x27;123456&#x27;,&#x27;2020/2/24&#x27;); INSERT INTO jdbc_user VALUES(NULL,&#x27;tom&#x27;,&#x27;123456&#x27;,&#x27;2020/2/24&#x27;); SQL注入演示 123-- SQL注入演示 -- 填写一个错误的密码 SELECT * FROM jdbc_user WHERE username = &#x27;tom&#x27; AND PASSWORD = &#x27;123&#x27; OR &#x27;1&#x27; = &#x27;1&#x27;; 如果这是一个登陆操作,那么用户就登陆成功了.显然这不是我们想要看到的结果 4.2 SQL注入案例：用户登陆 需求 用户在控制台上输入用户名和密码, 然后使用 Statement 字符串拼接的方式 实现用户的登录。 步骤 得到用户从控制台上输入的用户名和密码来查询数据库 写一个登录的方法 ​ a) 通过工具类得到连接 ​ b) 创建语句对象，使用拼接字符串的方式生成 SQL 语句 ​ c) 查询数据库，如果有记录则表示登录成功，否则登录失败 ​ d) 释放资源 1Sql注入方式: 123&#x27; or &#x27;1&#x27;=&#x27;1 代码示例 1234567891011121314151617181920212223242526272829303132333435public class TestLogin01 &#123; /** * 用户登录案例 * 使用 Statement字符串拼接的方式完成查询 * @param args */ public static void main(String[] args) throws SQLException &#123; //1.获取连接 Connection connection = JDBCUtils.getConnection(); //2.获取Statement Statement statement = connection.createStatement(); //3.获取用户输入的用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名: &quot;); String name = sc.nextLine(); System.out.println(&quot;请输入密码: &quot;); String pass = sc.nextLine(); System.out.println(pass); //4.拼接Sql,执行查询 String sql = &quot;select * from jdbc_user &quot; + &quot;where username = &quot; + &quot; &#x27;&quot; + name +&quot;&#x27; &quot; +&quot; and password = &quot; +&quot; &#x27;&quot; + pass +&quot;&#x27;&quot;; System.out.println(sql); ResultSet resultSet = statement.executeQuery(sql); //5.处理结果集,判断结果集是否为空 if(resultSet.next())&#123; System.out.println(&quot;登录成功! 欢迎您: &quot; + name); &#125;else &#123; System.out.println(&quot;登录失败!&quot;); &#125; //释放资源 JDBCUtils.close(connection,statement,resultSet); &#125; &#125; 4.3 问题分析 什么是SQL注入? 我们让用户输入的密码和 SQL 语句进行字符串拼接。用户输入的内容作为了 SQL 语句语法的一部分，改变了 原有SQL 真正的意义，以上问题称为 SQL 注入 . 如何实现的注入 根据用户输入的数据,拼接处的字符串 12345select * from jdbc_user where username = &#x27;abc&#x27; and password = &#x27;abc&#x27; or &#x27;1&#x27;=&#x27;1&#x27; name=&#x27;abc&#x27; and password=&#x27;abc&#x27; 为假 &#x27;1&#x27;=&#x27;1&#x27; 真 相当于 select * from user where true=true; 查询了所有记录 如何解决 要解决 SQL 注入就不能让用户输入的密码和我们的 SQL 语句进 行简单的字符串拼接。 5. 预处理对象5.1 PreparedStatement接口介绍 PreparedStatement 是 Statement 接口的子接口，继承于父接口中所有的方法。它是一个预编译的 SQL 语句对象. 预编译: 是指SQL 语句被预编译,并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行该语句。 5.2 PreparedStatement 特点 因为有预先编译的功能，提高 SQL 的执行效率。 可以有效的防止 SQL 注入的问题，安全性更高 5.3 获取PreparedStatement 对象 通过Connection创建PreparedStatement对象 Connection 接口中的方法 说明 PreparedStatement prepareStatement(String sql) 指定预编译的 SQL 语句 5.4 PreparedStatement 接口常用方法 常用方法 说明 int executeUpdate() 执行insert update delete语句. ResultSet executeQuery() 执行select语句. 返回结果集对象 Resulet 5.5 使用PreparedStatement的步骤 编写 SQL 语句，未知内容使用?占位： 1SELECT * FROM jdbc_user WHERE username=? AND password=? 获得 PreparedStatement 对象 设置实际参数：setXxx( 占位符的位置, 真实的值) 执行参数化 SQL 语句 5)关闭资源 setXxx重载方法 说明 void setDouble(int parameterIndex, double x) 将指定参数设置为给定 Java double 值。 void setInt(int parameterIndex, int x) 将指定参数设置为给定 Java int 值。 void setString(int parameterIndex, String x) 将指定参数设置为给定 Java String 值。 void setObject(int parameterIndex, Object x) 使用给定对象设置指定参数的值。 5.6 使用PreparedStatement完成登陆案例 使用 PreparedStatement 预处理对象,可以有效的避免SQL注入 步骤： 1.获取数据库连接对象 2.编写SQL 使用? 占位符方式 3.获取预处理对象 (预编译对象会将Sql发送给数据库 进行预编译) 4.提示用户输入用户名 &amp; 密码 5.设置实际参数：setXxx(占位符的位置, 真实的值) 6.执行查询获取结果集 7.判断是否查询到数据 8.关闭资源 12345678910111213141516171819202122232425262728293031323334353637383940public class TestLogin02 &#123; /** * 使用预编译对象 PrepareStatement 完成登录案例 * @param args * @throws SQLException */ public static void main(String[] args) throws SQLException &#123; //1.获取连接 Connection connection = JDBCUtils.getConnection(); //2.获取Statement Statement statement = connection.createStatement(); //3.获取用户输入的用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名: &quot;); String name = sc.nextLine(); System.out.println(&quot;请输入密码: &quot;); String pass = sc.nextLine(); System.out.println(pass); //4.获取 PrepareStatement 预编译对象 //4.1 编写SQL 使用 ? 占位符方式 String sql = &quot;select * from jdbc_user where username = ? and password = ?&quot;; PreparedStatement ps = connection.prepareStatement(sql); //4.2 设置占位符参数 ps.setString(1,name); ps.setString(2,pass); //5. 执行查询 处理结果集 ResultSet resultSet = ps.executeQuery(); if(resultSet.next())&#123; System.out.println(&quot;登录成功! 欢迎您: &quot; + name); &#125;else&#123; System.out.println(&quot;登录失败!&quot;); &#125; //6.释放资源 JDBCUtils.close(connection,statement,resultSet); &#125; &#125; 5.7 PreparedStatement的执行原理 分别使用 Statement对象 和 PreparedStatement对象进行插入操作 代码示例 1234567891011121314151617181920212223242526272829303132public class TestPS &#123; public static void main(String[] args) throws SQLException &#123; Connection con = JDBCUtils.getConnection(); //获取 Sql语句执行对象 Statement st = con.createStatement(); //插入两条数据 st.executeUpdate(&quot;insert into jdbc_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,&#x27;1992/12/26&#x27;)&quot;); st.executeUpdate(&quot;insert into jdbc_user values(null,&#x27;李四&#x27;,&#x27;123&#x27;,&#x27;1992/12/26&#x27;)&quot;); //获取预处理对象 PreparedStatement ps = con.prepareStatement(&quot;insert into jdbc_user values(?,?,?,?)&quot;); //第一条数 设置占位符对应的参数 ps.setString(1,null); ps.setString(2,&quot;长海&quot;); ps.setString(3,&quot;qwer&quot;); ps.setString(4,&quot;1990/1/10&quot;); //执行插入 ps.executeUpdate(); //第二条数据 ps.setString(1,null); ps.setString(2,&quot;小斌&quot;); ps.setString(3,&quot;1122&quot;); ps.setString(4,&quot;1990/1/10&quot;); //执行插入 ps.executeUpdate(); //释放资源 st.close(); ps.close(); con.close(); &#125; &#125; 5.8 Statement 与 PreparedStatement的区别 Statement用于执行静态SQL语句，在执行时，必须指定一个事先准备好的SQL语句。 PrepareStatement是预编译的SQL语句对象，语句中可以包含动态参数“?”，在执行时可以为“?”动态设置参数值。 PrepareStatement可以减少编译次数提高数据库性能。 6 JDBC 控制事务 之前我们是使用 MySQL 的命令来操作事务。接下来我们使用 JDBC 来操作银行转账的事务。 6.1 数据准备123456789101112-- 创建账户表 CREATE TABLE account( -- 主键 id INT PRIMARY KEY AUTO_INCREMENT, -- 姓名 NAME VARCHAR(10), -- 转账金额 money DOUBLE ); -- 添加两个用户 INSERT INTO account (NAME, money) VALUES (&#x27;tom&#x27;, 1000), (&#x27;jack&#x27;, 1000); 6.2 事务相关API我们使用Connection中的方法实现事务管理 方法 说明 void setAutoCommit(boolean autoCommit) 参数是 true 或 false 如果设置为 false，表示关闭自动提交，相当于开启事务 void commit() 提交事务 void rollback() 回滚事务 6.3 开发步骤 获取连接 开启事务 获取到 PreparedStatement , 执行两次更新操作 正常情况下提交事务 出现异常回滚事务 最后关闭资源 6.4 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243public class JDBCTransaction &#123; //JDBC 操作事务 public static void main(String[] args) &#123; Connection con = null; PreparedStatement ps = null; try &#123; //1. 获取连接 con = JDBCUtils.getConnection(); //2. 开启事务 con.setAutoCommit(false); //3. 获取到 PreparedStatement 执行两次更新操作 //3.1 tom 账户 -500 ps = con.prepareStatement(&quot;update account set money = money - ? where name = ? &quot;); ps.setDouble(1,500.0); ps.setString(2,&quot;tom&quot;); ps.executeUpdate(); //模拟tom转账后 出现异常 System.out.println(1 / 0); //3.2 jack 账户 +500 ps = con.prepareStatement(&quot;update account set money = money + ? where name = ? &quot;); ps.setDouble(1,500.0); ps.setString(2,&quot;jack&quot;); ps.executeUpdate(); //4. 正常情况下提交事务 con.commit(); System.out.println(&quot;转账成功!&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; //5. 出现异常回滚事务 con.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; finally &#123; //6. 最后关闭资源 JDBCUtils.close(con,ps); &#125; &#125; &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"Java新特性","slug":"Java新特性","date":"2019-08-24T13:06:29.000Z","updated":"2025-04-17T08:34:51.979Z","comments":true,"path":"2019/08/24/Java新特性/","link":"","permalink":"http://yournotes.cn/2019/08/24/Java%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"1 Java8的新特性1.1 Java8的概述 Java8是 Java 语言的一个重要版本，该版本于2014年3月发布，是自Java5以来最具革命性的版 本，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。","text":"1 Java8的新特性1.1 Java8的概述 Java8是 Java 语言的一个重要版本，该版本于2014年3月发布，是自Java5以来最具革命性的版 本，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。 1.2 函数式接口 函数式接口主要指只包含一个抽象方法的接口，如：java.lang.Runnable、java.util.Comparator 接口等。 Java8提供@FunctionalInterface注解来定义函数式接口，若定义的接口不符合函数式的规范便会 报错。 Java8中增加了java.util.function包，该包包含了常用的函数式接口，具体如下： 接口名称 方法声明 功能介绍 Consumer void accept(T t) 根据指定的参数执行操作 Supplier T get() 得到一个返回值 Function R apply(T t) 根据指定的参数执行操作并返回 Predicate boolean test(T t) 判断指定的参数是否满足条件 1.3 Lambda表达式 Lambda 表达式是实例化函数式接口的重要方式，使用 Lambda 表达式可以使代码变的更加简洁 紧凑。 lambda表达式：参数列表、箭头符号-&gt;和方法体组成，而方法体中可以是表达式，也可以是语句 块。 语法格式：(参数列表) -&gt; &#123; 方法体; &#125; 其中()、参数类型、{} 以及return关键字 可以省略。 1.4 方法引用 方法引用主要指通过方法的名字来指向一个方法而不需要为方法引用提供方法体，该方法的调用交 给函数式接口执行。 方法引用使用一对冒号 :: 将类或对象与方法名进行连接，通常使用方式如下： 对象的非静态方法引用 ObjectName :: MethodName 类的静态方法引用 ClassName :: StaticMethodName 类的非静态方法引用 ClassName :: MethodName 构造器的引用 ClassName :: new 数组的引用 TypeName[] :: new 方法引用是在特定场景下lambda表达式的一种简化表示，可以进一步简化代码的编写使代码更加 紧凑简洁，从而减少冗余代码。 1.5 Stream接口（1）基本概念 java.util.stream.Stream接口是对集合功能的增强，可以对集合元素进行复杂的查找、过滤、筛选 等操作。 Stream接口借助于Lambda 表达式极大的提高编程效率和程序可读性，同时它提供串行和并行两 种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。 （2）使用步骤 创建Stream，通过一个数据源来获取一个流。 转换Stream，每次转换返回一个新的Stream对象。 对Stream进行聚合操作并产生结果。 （3）创建方式 方式一：通过调用集合的默认方法来获取流，如：default Stream stream() 方式二：通过数组工具类中的静态方法来获取流，如：static IntStream stream(int[] array) 方式三：通过Stream接口的静态方法来获取流，如：static Stream of(T… values) 方式四：通过Stream接口的静态方法来获取流，static Stream generate(Supplier s) （4）中间操作 筛选与切片的常用方法如下： 方法声明 功能介绍 Stream filter(Predicate predicate) 返回一个包含匹配元素的流 Stream distinct() 返回不包含重复元素的流 Stream limit(long maxSize) 返回不超过给定元素数量的流 Stream skip(long n) 返回丢弃前n个元素后的流 映射的常用方法如下： 方法声明 功能介绍 Stream sorted() 返回经过自然排序后元素组成的流 Stream sorted(Comparator comparator) 返回经过比较器排序后元素组成的流 （5）终止操作 匹配与查找的常用方法如下： 方法声明 功能介绍 Optional findFirst() 返回该流的第一个元素 boolean allMatch(Predicate predicate) 返回所有元素是否匹配 boolean noneMatch(Predicate predicate) 返回没有元素是否匹配 Optional max(Comparator comparator) 根据比较器返回最大元素 Optional min(Comparator comparator) 根据比较器返回最小元素 long count() 返回元素的个数 void forEach(Consumer action) 对流中每个元素执行操作 规约的常用方法如下： 方法声明 功能介绍 Optional reduce(BinaryOperator accumulator) 返回结合后的元素值 收集的常用方法如下： 方法声明 功能介绍 R collect(Collector collector) 使用收集器对元素进行处理 （6）案例题目： 准备一个List集合并放入Person类型的对象，将集合中所有成年人过滤出来放到另外一个集合并打 印出来。 1.6 Optional类（1）基本概念 java.util.Optional类可以理解为一个简单的容器，其值可能是null或者不是null，代表一个值存在 或不存在。 该类的引入很好的解决空指针异常，不用显式进行空值检测。 （2）常用的方法 方法声明 功能介绍 static Optional ofNullable(T value) 根据参数指定数值来得到Optional类型的对象 Optional map(Function mapper) 根据参数指定规则的结果来得到Optional类型的对象 T orElse(T other) 若该值存在就返回，否则返回other的数值。 2 Java9的新特性2.1 Java9的概述 Java9发布于2017年9月发布，带来了很多新特性，其中最主要的变化是模块化系统。 模块就是代码和数据的封装体，模块的代码被组织成多个包，每个包中包含Java类和接口，模块的 数据则包括资源文件和其他静态信息。 2.2 模块化的使用（1）语法格式 在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块，具体如下： 123module 模块名称 &#123; //Content&#125; （2）模块化的优势 减少内存的开销。 可简化各种类库和大型应用的 开发和维护。 安全性，可维护性，提高性能。 2.3 钻石操作符的使用升级 在Java9中允许在匿名内部类的使用中使用钻石操作符。 2.4 集合工厂方法（1）基本概念 Java9的List、Set和Map集合中增加了静态工厂方法of实现不可变实例的创建。 不可变体现在无法添加、修改和删除它们的元素。 不允许添加null元素对象。 （2）实际意义 保证线程安全：在并发程序中既保证线程安全性，也大大增强了并发时的效率。 被不可信的类库使用时会很安全。 如果一个对象不需要支持修改操作，将会节省空间和时间的开销。 可以当作一个常量来对待，并且这个对象在以后也不会被改变。 2.5 InputStream的增强 InputStream类中提供了transferTo方法实现将数据直接传输到OutputStream中。 3 Java10的新特性3.1 Java10的概述 Java10于2018年3月发布，改进的关键点包括一个本地类型推断、一个垃圾回收的增强。 方法声明 功能介绍 boolean isBlank() 判断字符串是否为空或只包含空白代码点 Optional map(Function mapper) 根据参数指定规则的结果来得到Optional类 型的对象 T orElse(T other) 若该值存在就返回，否则返回other的数 值。 Java10计划只是一个短期版本，因此公开更新将在六个月内结束，9月份发布的Java11将是Java的 长期支持（LTS）版本，LTS版本的发布每三年发布一次。 3.2 局部变量类型推断（1）基本概念 Java10可以使用var作为局部变量类型推断标识符，此符号仅适用于局部变量，增强for循环的索 引，以及传统for循环的本地变量。 它不能使用于方法形式参数，构造函数形式参数，方法返回类型，字段，catch形式参数或任何其 他类型的变量声明。 （2）实际意义 标识符var不是关键字，只是一个保留的类型名称。这意味着var用作变量，方法名或包名的代码不 会受到影响，但var不能作为类或则接口的名字。 避免了信息冗余。 对齐了变量名。 更容易阅读。 4 Java11的新特性4.1 Java11的概述 Java11于2018年9月正式发布，这是 Java 大版本周期变化 后的第一个长期支持版本，非常值得关 注。 4.2 简化的编译运行操作 在Java11中可以使用java命令一次性进行编译和运行操作。 执行源文件中的第一个类必须包含主方法。 不可以使用其它源文件中自定义的类。 4.3 String类新增方法 方法声明 功能介绍 boolean isBlank() 判断字符串是否为空或只包含空白代码点 Optional map(Function&lt;? super T,? extends U&gt; mapper) 根据参数指定规则的结果来得到Optional类 型的对象 T orElse(T other) 若该值存在就返回，否则返回other的数 值。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"IO流","slug":"IO流","date":"2019-08-18T10:49:13.000Z","updated":"2025-04-17T08:34:51.978Z","comments":true,"path":"2019/08/18/IO流/","link":"","permalink":"http://yournotes.cn/2019/08/18/IO%E6%B5%81/","excerpt":"1. IO流概述1.1 IO流的概念 IO就是Input和Output的简写，也就是输入和输出的含义。","text":"1. IO流概述1.1 IO流的概念 IO就是Input和Output的简写，也就是输入和输出的含义。 IO流就是指读写数据时像流水一样从一端流到另外一端，因此得名为“流”。 1.2 基本分类 按照读写数据的基本单位不同，分为 字节流 和 字符流。 其中字节流主要指以字节为单位进行数据读写的流，可以读写任意类型的文件。 其中字符流主要指以字符(2个字节)为单位进行数据读写的流，只能读写文本文件。 按照读写数据的方向不同，分为 输入流 和 输出流（站在程序的角度）。 其中输入流主要指从文件中读取数据内容输入到程序中，也就是读文件。 其中输出流主要指将程序中的数据内容输出到文件中，也就是写文件。 按照流的角色不同分为节点流和处理流。 其中节点流主要指直接和输入输出源对接的流。 其中处理流主要指需要建立在节点流的基础之上的流 1.3 体系结构 2. 相关流的详解2.1 FileWriter类（重点）（1）基本概念 java.io.FileWriter类主要用于将文本内容写入到文本文件。 （2）常用的方法 方法声明 功能介绍 FileWriter(String fileName) 根据参数指定的文件名构造对象 FileWriter(String fileName, boolean append) 以追加的方式根据参数指定的文件名来构造对象 void write(int c) 写入单个字符 void write(char[] cbuf, int off, int len) 将指定字符数组中从偏移量off开始的len个字符写入此 文件输出流 void write(char[] cbuf) 将cbuf.length个字符从指定字符数组写入此文件输出 流中 void flush() 刷新流 void close() 关闭流对象并释放有关的资源 2.1 FileReader类（重点）（1）基本概念 java.io.FileReader类主要用于从文本文件读取文本数据内容。 （2）常用的方法 方法声明 功能介绍 FileReader(String fileName) 根据参数指定的文件名构造对象 int read() 读取单个字符的数据并返回，返回-1表示读取到末尾 int read(char[] cbuf, int offset, int length) 从输入流中将最多len个字符的数据读入一个字符数组中，返回读取 到的字符个数，返回-1表示读取到末尾 int read(char[] cbuf) 从此输入流中将最多 cbuf.length 个字符的数据读入字符数组中，返 回读取到的字符个数，返回-1表示读取到末尾 void close() 关闭流对象并释放有关的资源 2.3 FileOutputStream类（重点）（1）基本概念 java.io.FileOutputStream类主要用于将图像数据之类的原始字节流写入到输出流中。 （2）常用的方法 方法声明 功能介绍 FileOutputStream(String name) 根据参数指定的文件名来构造对象 FileOutputStream(String name, boolean append) 以追加的方式根据参数指定的文件名来构造对象 void write(int b) 将指定字节写入此文件输出流 void write(byte[] b, int off, int len) 将指定字节数组中从偏移量off开始的len个字节写入 此文件输出流 void write(byte[] b) 将 b.length 个字节从指定字节数组写入此文件输出 流中 void flush() 刷新此输出流并强制写出任何缓冲的输出字节 void close() 关闭流对象并释放有关的资源 2.4 FileInputStream类（重点）（1）基本概念 java.io.FileInputStream类主要用于从输入流中以字节流的方式读取图像数据等。 （2）常用的方法 方法声明 功能介绍 FileInputStream(String name) 根据参数指定的文件路径名来构造对象 int read() 从输入流中读取单个字节的数据并返回，返回-1表示读取到末尾 int read(byte[] b, int off, int len) 从此输入流中将最多len个字节的数据读入字节数组中，返回读取到的 字节个数，返回-1表示读取到末尾 int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入字节数组中，返回读 取到的字节个数，返回-1表示读取到末尾 void close() 关闭流对象并释放有关的资源 int available() 获取输入流所关联文件的大小 案例题目 编程实现两个文件之间的拷贝功能。 2.5 BufferedOutputStream类（重点）（1）基本概念 java.io.BufferedOutputStream类主要用于描述缓冲输出流，此时不用为写入的每个字节调用底层 系统。 （2）常用的方法 方法声明 功能介绍 BufferedOutputStream(OutputStream out) 根据参数指定的引用来构造对象 BufferedOutputStream(OutputStream out, int size) 根据参数指定的引用和缓冲区大小来构造 对象 void write(int b) 写入单个字节 void write(byte[] b, int off, int len) 写入字节数组中的一部分数据 void write(byte[] b) 写入参数指定的整个字节数组 void flush() 刷新流 void close() 关闭流对象并释放有关的资源 2.6 BufferedInputStream类（重点）（1）基本概念 java.io.BufferedInputStream类主要用于描述缓冲输入流。 （2）常用的方法 方法声明 功能介绍 BufferedInputStream(InputStream in) 根据参数指定的引用构造对象 BufferedInputStream(InputStream in, int size) 根据参数指定的引用和缓冲区大小构造对象 int read() 读取单个字节 int read(byte[] b, int off, int len) 读取len个字节 int read(byte[] b) 读取b.length个字节 void close() 关闭流对象并释放有关的资源 2.7 BufferedWriter类（重点）（1）基本概念 java.io.BufferedWriter类主要用于写入单个字符、字符数组以及字符串到输出流中。 （2）常用的方法 方法声明 功能介绍 BufferedWriter(Writer out) 根据参数指定的引用来构造对象 BufferedWriter(Writer out, int sz) 根据参数指定的引用和缓冲区大小来构造对象 void write(int c) 写入单个字符到输出流中 void write(char[] cbuf, int off, int len) 将字符数组cbuf中从下标off开始的len个字符写入输出流 中 void write(char[] cbuf) 将字符串数组cbuf中所有内容写入输出流中 void write(String s, int off, int len) 将参数s中下标从off开始的len个字符写入输出流中 void write(String str) 将参数指定的字符串内容写入输出流中 void newLine() 用于写入行分隔符到输出流中 void flush() 刷新流 void close() 关闭流对象并释放有关的资源 2.8 BufferedReader类（重点）（1）基本概念 java.io.BufferedReader类用于从输入流中读取单个字符、字符数组以及字符串。 （2）常用的方法 方法声明 功能介绍 BufferedReader(Reader in) 根据参数指定的引用来构造对象 BufferedReader(Reader in, int sz) 根据参数指定的引用和缓冲区大小来构造对象 int read() 从输入流读取单个字符，读取到末尾则返回-1，否则返回实际读取到 的字符内容 int read(char[] cbuf, int off, int len) 从输入流中读取len个字符放入数组cbuf中下标从off开始的位置上， 若读取到末尾则返回-1，否则返回实际读取到的字符个数 int read(char[] cbuf) 从输入流中读满整个数组cbuf String readLine() 读取一行字符串并返回，返回null表示读取到末尾 void close() 关闭流对象并释放有关的资源 2.9 PrintStream类（1）基本概念 java.io.PrintStream类主要用于更加方便地打印各种数据内容。 （2）常用的方法 方法声明 功能介绍 PrintStream(OutputStream out) 根据参数指定的引用来构造对象 void print(String s) 用于将参数指定的字符串内容打印出来 void println(String x) 用于打印字符串后并终止该行 void flush() 刷新流 void close() 用于关闭输出流并释放有关的资源 2.10 PrintWriter类（1）基本概念 java.io.PrintWriter类主要用于将对象的格式化形式打印到文本输出流。 （2）常用的方法 方法声明 功能介绍 PrintWriter(Writer out) 根据参数指定的引用来构造对象 void print(String s) 将参数指定的字符串内容打印出来 void println(String x) 打印字符串后并终止该行 void flush() 刷新流 void close() 关闭流对象并释放有关的资源 案例题目 不断地提示用户输入要发送的内容，若发送的内容是”bye”则聊天结束，否则将用户输入的内容写 入到文件d:&#x2F;a.txt中。 要求使用BufferedReader类来读取键盘的输入 System.in代表键盘输入 要求 使用PrintStream类负责将数据写入文件 2.11 OutputStreamWriter类（1）基本概念 java.io.OutputStreamWriter类主要用于实现从字符流到字节流的转换。 （2）常用的方法 方法声明 功能介绍 OutputStreamWriter(OutputStream out) 根据参数指定的引用来构造对象 OutputStreamWriter(OutputStream out, String charsetName) 根据参数指定的引用和编码构造 对象 void write(String str) 将参数指定的字符串写入 void flush() 刷新流 void close() 用于关闭输出流并释放有关的资 源 2.12 InputStreamReader类（1）基本概念 java.io.InputStreamReader类主要用于实现从字节流到字符流的转换。 （2）常用的方法 方法声明 功能介绍 InputStreamReader(InputStream in) 根据参数指定的引用来构造对象 InputStreamReader(InputStream in, String charsetName) 根据参数指定的引用和编码来构造对 象 int read(char[] cbuf) 读取字符数据到参数指定的数组 void close() 用于关闭输出流并释放有关的资源 2.13 DataOutputStream类（了解）（1）基本概念 java.io.DataOutputStream类主要用于以适当的方式将基本数据类型写入输出流中。 （2）常用的方法 方法声明 功能介绍 DataOutputStream(OutputStream out) 根据参数指定的引用构造对象 OutputStream类是个抽象 类，实参需要传递子类对象 void writeInt(int v) 用于将参数指定的整数一次性写入输出流，优先写入高字 节 void close() 用于关闭文件输出流并释放有关的资源 2.14 DataInputStream类（了解）（1）基本概念 java.io.DataInputStream类主要用于从输入流中读取基本数据类型的数据。 （2）常用的方法 方法声明 功能介绍 DataInputStream(InputStream in) 根据参数指定的引用来构造对象 InputStream类是抽象类， 实参需要传递子类对象 int readInt() 用于从输入流中一次性读取一个整数数据并返回 void close() 用于关闭文件输出流并释放有关的资源 2.15 ObjectOutputStream类（重点）（1）基本概念 java.io.ObjectOutputStream类主要用于将一个对象的所有内容整体写入到输出流中。 只能将支持 java.io.Serializable 接口的对象写入流中。 类通过实现 java.io.Serializable 接口以启用其序列化功能。 所谓序列化主要指将一个对象需要存储的相关信息有效组织成字节序列的转化过程。 （2）常用的方法 方法声明 功能介绍 ObjectOutputStream(OutputStream out) 根据参数指定的引用来构造对象 void writeObject(Object obj) 用于将参数指定的对象整体写入到输出流中 void close() 用于关闭输出流并释放有关的资源 2.16 ObjectInputStream类（重点）（1）基本概念 java.io.ObjectInputStream类主要用于从输入流中一次性将对象整体读取出来。 所谓反序列化主要指将有效组织的字节序列恢复为一个对象及相关信息的转化过程。 （2）常用的方法 方法声明 功能介绍 ObjectInputStream(InputStream in) 根据参数指定的引用来构造对象 Object readObject() 主要用于从输入流中读取一个对象并返回 无法通过返回值 来判断是否读取到文件的末尾 void close() 用于关闭输入流并释放有关的资源 （3）序列化版本号 序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时， JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如 果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常 (InvalidCastException)。 （4）transient关键字 transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行 化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 （5）经验的分享 当希望将多个对象写入文件时，通常建议将多个对象放入一个集合中，然后将集合这个整体看做一 个对象写入输出流中，此时只需要调用一次readObject方法就可以将整个集合的数据读取出来， 从而避免了通过返回值进行是否达到文件末尾的判断。 2.17 RandomAccessFile类（1）基本概念 java.io.RandomAccessFile类主要支持对随机访问文件的读写操作。 （2）常用的方法 方法声明 功能介绍 RandomAccessFile(String name, String mode) 根据参数指定的名称和模式构造对象 r: 以只读方式打开 rw：打开以便读取和写入 rwd:打开以便读取和写入，同步文件内容的更新 rws:打开以便读取和写入，同步文件内容和元数据 的更新 int read() 读取单个字节的数据 void seek(long pos) 用于设置从此文件的开头开始测量的文件指针偏移 量 void write(int b) 将参数指定的单个字节写入 void close() 用于关闭流并释放有关的资源 3. 字符编码（1）编码表的由来 计算机只能识别二进制数据，早期就是电信号。为了方便计算机可以识别各个国家的文字，就需要 将各个国家的文字采用数字编号的方式进行描述并建立对应的关系表，该表就叫做编码表。 （2）常见的编码表 ASCII：美国标准信息交换码， 使用一个字节的低7位二位进制进行表示。 ISO8859-1：拉丁码表，欧洲码表，使用一个字节的8位二进制进行表示。 GB2312：中国的中文编码表，最多使用两个字节16位二进制为进行表示。 GBK：中国的中文编码表升级，融合了更多的中文文字符号，最多使用两个字节16位二进制位表 示。 Unicode：国际标准码，融合了目前人类使用的所有字符，为每个字符分配唯一的字符码。所有的 文字都用两个字节16位二进制位来表示。 （3）编码的发展 面向传输的众多 UTF（UCS Transfer Format）标准出现了，UTF-8就是每次8个位传输数据，而 UTF-16就是每次16个位。这是为传输而设计的编码并使编码无国界，这样就可以显示全世界上所 有文化的字符了。 Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体 存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"XML","slug":"XML","date":"2019-03-03T03:57:54.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2019/03/03/XML/","link":"","permalink":"http://yournotes.cn/2019/03/03/XML/","excerpt":"1. XML基本介绍1.1 概述XML即可扩展标记语言（Extensible Markup Language）","text":"1. XML基本介绍1.1 概述XML即可扩展标记语言（Extensible Markup Language） W3C在1998年2月发布1.0版本，2004年2月又发布1.1版本，但因为1.1版本不能向下兼容1.0版 本，所以1.1没有人用。同时，在2004年2月W3C又发布了1.0版本的第三版。我们要学习的还是 1.0版本 ! 特点 可扩展的, 标签都是自定义的 语法十分严格 1.2 XML的作用XML能做什么？ 功能 说明 存储数据&emsp;&emsp;&emsp;&emsp; 通常，我们在数据库中存储数据。不过，如果希望数据的可移植性更强，我们可以把数据存储 XML 文件中 配置文件&emsp;&emsp;&emsp;&emsp; 作为各种技术框架的配置文件使用 (最多) 在网络中&emsp;&emsp;&emsp;&emsp; 客户端可以使用XML格式向服务器端发送数据,服务器接收到xml格式数据,进行解析 2. XML语法2.1 XML文档声明格式 文档声明必须为结束 文档声明必须写在第一行 1）语法格式 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 2）属性说明 versioin：指定XML文档版本。必须属性，因为我们不会选择1.1，只会选择1.0 encoding：指定当前文档的编码。可选属性，默认值是utf-8； 2.2 元素Element 元素: 是XML文档中最重要的组成部分 元素的命名规则： 不能使用空格，不能使用冒号 xml 标签名称区分大小写 XML 必须有且只有一个根元素 语法格式： 1&lt;users&gt;&lt;/users&gt; 1）XML 必须有且只有一个根元素，它是所有其他元素的父元素，比如以下实例中 users 就是根元素： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;users&gt;&lt;/users&gt; 2）普通元素的结构开始标签、元素体、结束标签组成。 1&lt;hello&gt; 大家好 &lt;/hello&gt; 3）元素体：元素体可以是元素，也可以是文本 123&lt;hello&gt; &lt;a&gt;你好&lt;/a&gt; &lt;/hello&gt; 4）空元素：空元素只有开始标签，而没有结束标签，但元素必须自己闭合 1&lt;close/&gt; 2.3 属性1&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; &lt;/bean&gt; 2.4 注释 XML的注释，以“ ”结束。注释内容会被XML解析器忽略！ 2.5 使用XML描述数据表中的数据 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;employees&gt; &lt;employee eid=&quot;2&quot;&gt; &lt;ename&gt;林黛玉&lt;/ename&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;女&lt;/sex&gt; &lt;salary&gt;5000&lt;/salary&gt; &lt;empdate&gt;2019-03-14&lt;/empdate&gt; &lt;/employee&gt; &lt;employee eid=&quot;3&quot;&gt; &lt;ename&gt;杜甫&lt;/ename&gt; &lt;age&gt;40&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;salary&gt;15000&lt;/salary&gt; &lt;empdate&gt;2010-01-01&lt;/empdate&gt; &lt;/employee&gt; &lt;/employees&gt; 3. XML约束 在XML技术里，可以编写一个文档来约束一个XML文档的书写规范，这称之为XML约束。 常见的xml约束： DTD Schema 作为程序员只要掌握两点 会阅读 会引入 不用自己编写 3.1 DTD约束DTD（Document Type Defifinition），文档类型定义，用来约束XML文档。规定XML文档中元素的名称，子元素的名称及顺序，元素的属性等。 3.1.1 编写DTD 开发中，我们不会自己编写DTD约束文档 常情况我们都是通过框架提供的DTD约束文档，编写对应的XML文档。常见框架使用DTD约束有：Struts2、hibernate等。 创建约束文件 student.dtd 1234567891011121314151617181920212223&lt;!ELEMENT students (student+) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; &lt;!-- ELEMENT: 用来定义元素 students (student+) : 代表根元素 必须是 &lt;students&gt; student+ : 根标签中至少有一个 student子元素, + 代表至少一个 student (name,age,sex): student 标签中包含的子元素,按顺序出现 #PCDATA: 是普通文本内容 ATTLIST: 用来定义属性 student number ID #REQUIRED student子元素中 有一个ID属性叫做 number,是必须填写的 ID: 唯一 值只能是字母或者下划线开头 --&gt; 3.2 Schema约束3.2.1 什么是Schema约束 Schema是新的XML文档约束, 比DTD强大很多，是DTD 替代者； Schema本身也是XML文档，但Schema文档的扩展名为xsd，而不是xml。 Schema 功能更强大，内置多种简单和复杂的数据类型 Schema 支持命名空间 (一个XML中可以引入多个约束文档) 3.2.2 Schema约束示例student.xsd 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot;?&gt; &lt;xsd:schema xmlns=&quot;http://www.jasper.com/xml&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.jasper.com/xml&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;xsd:element name=&quot;students&quot; type=&quot;studentsType&quot;/&gt; &lt;xsd:complexType name=&quot;studentsType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;student&quot; type=&quot;studentType&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;xsd:complexType name=&quot;studentType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;age&quot; type=&quot;ageType&quot; /&gt; &lt;xsd:element name=&quot;sex&quot; type=&quot;sexType&quot; /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;number&quot; type=&quot;numberType&quot; use=&quot;required&quot;/&gt; &lt;/xsd:complexType&gt; &lt;xsd:simpleType name=&quot;sexType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;male&quot;/&gt; &lt;xsd:enumeration value=&quot;female&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;ageType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:integer&quot;&gt; &lt;xsd:minInclusive value=&quot;0&quot;/&gt; &lt;xsd:maxInclusive value=&quot;200&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;numberType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:pattern value=&quot;hehe_\\d&#123;4&#125;&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;/xsd:schema&gt; Xml Schema元素 3.2.3 XML引入Schema约束xml中引入schema文档约束的步骤 查看schema文档，找到根元素，在xml中写出来 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;students&gt; &lt;/students&gt; 根元素来自哪个命名空间。使用xmlns指令来声明 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;students xmlns=&quot;http://www.jasper.com/xml&quot;&gt; &lt;/students&gt; 引入 w3c的标准命名空间, 复制即可 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;students xmlns=&quot;http://www.lagou.com/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;/students&gt; 引入的命名空间跟哪个xsd文件对应？ 使用schemaLocation来指定：两个取值：第一个为命名空间 第二个为xsd文件的路径 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;students xmlns=&quot;http://www.lagou.com/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.jasper.com/xml student.xsd&quot;&gt; &lt;/students&gt; 命名空间 1指的是一个环境,所用的标签来自于哪个环境定义的。 student.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;students xmlns=&quot;http://www.lagou.com/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.lagou.com/xml student.xsd&quot; &gt; &lt;student number=&quot;hehe_1234&quot;&gt; &lt;name&gt;张百万&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;hehe_0000&quot;&gt; &lt;name&gt;小斌&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 4. XML解析4.1 解析概述​ 当将数据存储在XML后，我们就希望通过程序获得XML的内容。如果我们使用Java基础所学习的IO知识是可以完成的，不过你需要非常繁琐的操作才可以完成，且开发中会遇到不同问题（只读、读写）。人们为不同问题提供不同的解析方式，并提交对应的解析器，方便开发人员操作XML。 4.2 XML解析方式开发中比较常见的解析方式有两种，如下： DOM：要求解析器把整个XML文档装载到内存，并解析成一个Document对象。 优点：元素与元素之间保留结构关系，故可以进行增删改查操作。 缺点：XML文档过大，可能出现内存溢出显现。 SAX：是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。并以事件驱动的方式进行具体解析，每执行一行，都将触发对应的事件。（了解） 优点：占用内存少 处理速度快，可以处理大文件 缺点：只能读，逐行后将释放资源。 4.3 XML常见的解析器解析器：就是根据不同的解析方式提供的具体实现。有的解析器操作过于繁琐，为了方便开发人员，有提供易于操作的解析开发包 JAXP：sun公司提供的解析器，支持DOM和SAX两种思想 DOM4J：一款非常优秀的解析器 , Dom4j是一个易用的、开源的库，用于XML，XPath和XSLT。它应用于Java平台，采用了Java集合框架并完全支持DOM，SAX和JAXP。 Jsoup：jsoup 是一款Java 的HTML解析器 ,也可以解析XML PULL：Android内置的XML解析方式，类似SAX。 4.4 dom4j的使用4.4.1 导入JAR包 4.4.2 API介绍使用核心类SaxReader加载xml文档获得Document，通过Document 对象获得文档的根元素，然后就可以操作了 常用API如下： SaxReader对象 read(…) 加载执行xml文档 Document对象 getRootElement() 获得根元素 Element对象 elements(…) 获得指定名称的所有子元素。可以不指定名称 element(…) 获得指定名称的第一个子元素。可以不指定名称 getName() 获得当前元素的元素名 attributeValue(…) 获得指定属性名的属性值 elementText(…) 获得指定名称子元素的文本值 getText() 获得当前元素的文本内容 4.4.3 准备xml文件编写user.xsd schema约束 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;xsd:schema xmlns=&quot;http://www.lagou.com/xml&quot; xmlns: xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.lagou.com/xml&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;xsd:element name=&quot;users&quot; type=&quot;usersType&quot;/&gt; &lt;xsd:complexType name=&quot;usersType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;user&quot; type=&quot;userType&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;xsd:complexType name=&quot;userType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;age&quot; type=&quot;ageType&quot; /&gt; &lt;xsd:element name=&quot;hobby&quot; type=&quot;hobbyType&quot; /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;id&quot; type=&quot;numberType&quot; use=&quot;required&quot;/&gt; &lt;/xsd:complexType&gt; &lt;xsd:simpleType name=&quot;ageType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:integer&quot;&gt; &lt;xsd:minInclusive value=&quot;0&quot;/&gt; &lt;xsd:maxInclusive value=&quot;100&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;hobbyType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;抽烟&quot;/&gt; &lt;xsd:enumeration value=&quot;喝酒&quot;/&gt; &lt;xsd:enumeration value=&quot;烫头&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;numberType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:pattern value=&quot;\\d&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;/xsd:schema&gt; 编写user.xml 引入约束 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;users xmlns=&quot;http://www.lagou.com/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.lagou.com/xml user.xsd&quot; &gt; &lt;user id=&quot;1&quot;&gt; &lt;name&gt;张百万&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;hobby&gt;抽烟&lt;/hobby&gt; &lt;/user&gt; &lt;user id=&quot;2&quot;&gt; &lt;name&gt;于谦&lt;/name&gt; &lt;age&gt;50&lt;/age&gt; &lt;hobby&gt;喝酒&lt;/hobby&gt; &lt;/user&gt; &lt;user id=&quot;3&quot;&gt; &lt;name&gt;刘能&lt;/name&gt; &lt;age&gt;40&lt;/age&gt; &lt;hobby&gt;烫头&lt;/hobby&gt; &lt;/user&gt; &lt;/users&gt; 4.4.4 读取XML12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestDOM4j &#123; //获取XML文件中的 所有的元素名称(标签) @Test public void test1() throws DocumentException &#123; //1.获取XML解析对象 SAXReader reader = new SAXReader(); //2.解析XML 获取 文档对象 document Document document = reader.read(&quot;H:\\\\jdbc_work\\\\xml_task03\\\\src\\\\com\\\\lagou\\\\xml03\\\\user.xml&quot;); //3.获取根元素 Element rootElement = document.getRootElement(); //获取根元素名称 System.out.println(rootElement.getName()); //获取 根元素下的标签 List&lt;Element&gt; elements = rootElement.elements(); for (Element element : elements) &#123; System.out.println(&quot;根标签下的子节点: &quot; + element.getName()); List&lt;Element&gt; eList = element.elements(); for (Element e : eList) &#123; System.out.println(&quot;user标签下的子节点&quot; + e.getName()); &#125; break; &#125; &#125; /** * 获取具体的节点内容 获取张百万的所有信息 */ @Test public void test2() throws DocumentException &#123; //1.创建XML文档解析对象 SAXReader sr = new SAXReader(); //2.读取XML获取到document对象 Document document = sr.read(&quot;src\\\\com\\\\lagou\\\\xml02\\\\user.xml&quot;); //3.获取根节点 Element rootElement = document.getRootElement(); //4.得到当前节点的 所有子节点 List&lt;Element&gt; elements = rootElement.elements(); //5.获取第一个子节点 Element user = elements.get(0); //6.获取所有信息 String id = user.attributeValue(&quot;id&quot;); String name = user.elementText(&quot;name&quot;); String age = user.elementText(&quot;age&quot;); //使用getText获取当前元素的文本内容 String hobby = user.element(&quot;hobby&quot;).getText(); //打印 System.out.println(id+&quot; &quot; + name +&quot; &quot; + age +&quot; &quot; + hobby); &#125; &#125; 4.5 xpath方式读取xml4.5.1 xpath介绍XPath 是一门在 XML 文档中查找信息的语言。 可以是使用xpath查找xml中的内容。 XPath 的好处 由于DOM4J在解析XML时只能一层一层解析，所以当XML文件层数过多时使用会很不方便，结合XPATH就可以直接获取到某个元素 1）需要再导入 jaxen-1.1-beta-6.jar 4.5.2 XPath基本语法介绍2）使用dom4j支持xpath的操作的几种主要形式 语法 说明 &#x2F;AAA&#x2F;DDD&#x2F;BBB 表示一层一层的，AAA下面 DDD下面的BBB &#x2F;&#x2F;BBB 表示和这个名称相同，表示只要名称是BBB，都得到 &#x2F;&#x2F;* 所有元素 BBB[1] , BBB[last()] 第一种表示第一个BBB元素, 第二种表示最后一个BBB元素 &#x2F;&#x2F;BBB[@id] 表示只要BBB元素上面有id属性，都得到 &#x2F;&#x2F;BBB[@id&#x3D;’b1’] 表示元素名称是BBB,在BBB上面有id属性，并且id的属性值是b1 4.5.3 API介绍 常用方法 描述 selectSingleNode(query) 查找和 XPath 查询匹配的一个节点。参数是Xpath 查询串。 selectNodes(query) 得到的是xml根节点下的所有满足 xpath 的节点 4.5.4 Xpath读取XML3）数据准备book.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;bookstore&gt; &lt;book id=&quot;book1&quot;&gt; &lt;name&gt;金瓶梅&lt;/name&gt; &lt;author&gt;金圣叹&lt;/author&gt; &lt;price&gt;99&lt;/price&gt; &lt;/book&gt; &lt;book id=&quot;book2&quot;&gt; &lt;name&gt;红楼梦&lt;/name&gt; &lt;author&gt;曹雪芹&lt;/author&gt; &lt;price&gt;69&lt;/price&gt; &lt;/book&gt; &lt;book id=&quot;book3&quot;&gt; &lt;name&gt;Java编程思想&lt;/name&gt; &lt;author&gt;埃克尔&lt;/author&gt; &lt;price&gt;59&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt; 4）代码示例 使用selectSingleNode方法 查询指定节点中的内容 12345678910111213141516171819/* * 1. 使用selectSingleNode方法 查询指定节点中的内容 * */ @Test public void test1() throws DocumentException &#123; //1.创建解析器对象 SAXReader sr = new SAXReader(); //2.获取文档对象 Document document = sr.read(&quot;H:\\\\jdbc_work\\\\xml_task03\\\\src\\\\com\\\\lagou\\\\xml03\\\\book.xml&quot;); //3.调用 selectSingleNode() 方法,获取name节点对象 Node node1 = document.selectSingleNode(&quot;/bookstore/book/name&quot;); System.out.println(&quot;节点: &quot; + node1.getName()); System.out.println(&quot;书名: &quot; + node1.getText()); //4.获取第二本书的名称 Node node2 = document.selectSingleNode(&quot;/bookstore/book[2]/name&quot;); System.out.println(&quot;第二本书的书名为: &quot; + node2.getText()); &#125; 使用selectSingleNode方法 获取属性值,或者属性值对应的节点 1234567891011121314151617181920212223/* * 2.使用selectSingleNode方法 获取属性值,或者属性值对应的节点 * */ @Test public void test2() throws DocumentException &#123; //1.创建解析器对象 SAXReader sr = new SAXReader(); //2.获取文档对象 Document document = sr.read(&quot;H:\\\\jdbc_work\\\\xml_task03\\\\src\\\\com\\\\lagou\\\\xml03\\\\book.xml&quot;); //3.获取第一个book节点的 id属性的值 Node node1 = document.selectSingleNode(&quot;/bookstore/book/attribute::id&quot;); System.out.println(&quot;第一个book的id值为: &quot; + node1.getText()); //4.获取最后一个book节点的 id属性的值 Node node2 = document.selectSingleNode(&quot;/bookstore/book[last()]/attribute::id&quot;); System.out.println(&quot;最后一个book节点的id值为: &quot; + node2.getText()); //5.获取id属性值为 book2的 书名 Node node3 = document.selectSingleNode(&quot;/bookstore/book[@id=&#x27;book2&#x27;]&quot;); String name = node3.selectSingleNode(&quot;name&quot;).getText(); System.out.println(&quot;id为book2的书名是: &quot; + name); &#125; 使用 selectNodes()方法 获取对应名称的所有节点 123456789101112131415161718192021222324252627282930/* * 3.使用 selectNodes()方法 获取对应名称的所有节点 * * */ @Test public void test3() throws DocumentException &#123; //1.创建解析器对象 SAXReader sr = new SAXReader(); //2.获取文档对象 Document document = sr.read(&quot;H:\\\\jdbc_work\\\\xml_task03\\\\src\\\\com\\\\lagou\\\\xml03\\\\book.xml&quot;); //3.获取所有节点,打印节点名 List&lt;Node&gt; list = document.selectNodes(&quot;//*&quot;); for (Node node : list) &#123; System.out.println(&quot;节点名: &quot; + node.getName()); &#125; //4.获取所有的书名 List&lt;Node&gt; names = document.selectNodes(&quot;//name&quot;); for (Node name : names) &#123; System.out.println(name.getText()); &#125; //5.获取指定 id值为book1的节点的所有 内容 List&lt;Node&gt; book1 = document.selectNodes(&quot;/bookstore/book[@id=&#x27;book1&#x27;]//*&quot;); for (Node node : book1) &#123; System.out.println(node.getName()+&quot; = &quot; + node.getText()); &#125; &#125; 5. JDBC自定义XML5.1 定义配置文件1）创建自定义xml文件，保存数据库连接信息 jdbc-config.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;jdbc&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/db5? characterEncoding=UTF-8&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;/jdbc&gt; 5.2 编写工具类（配置式）2）编写工具类 ,使用xpath 读取数据库信息 12345678910111213141516171819202122232425262728293031323334353637public class JDBCUtils &#123; //1. 定义字符串变量, 记录获取连接所需要的信息 public static String DRIVERNAME; public static String URL; public static String USER; public static String PASSWORD; //2.静态代码块 static &#123; try &#123; //使用 xpath读取 xml中的配置信息 SAXReader sr = new SAXReader(); Document document = sr.read(&quot;H:\\\\workspace01\\\\JDBC_day02\\\\src\\\\com\\\\lagou\\\\xml03\\\\jdbc-config.xml&quot;); Node node = document.selectSingleNode(&quot;/jdbc/property[@name=&#x27;driverClass&#x27;]&quot;); //System.out.println(node.getText()); DRIVERNAME = node.getText(); URL = document.selectSingleNode(&quot;/jdbc/property[@name=&#x27;jdbcUrl&#x27;]&quot;).getText(); USER = document.selectSingleNode(&quot;/jdbc/property[@name=&#x27;user&#x27;]&quot;).getText(); PASSWORD = document.selectSingleNode(&quot;/jdbc/property[@name=&#x27;password&#x27;]&quot;).getText(); //注册驱动 Class.forName(DRIVERNAME); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //3.获取连接的静态方法 public static Connection getConnection()&#123; try &#123; //获取连接对象 Connection connection = DriverManager.getConnection(URL, USER, PASSWORD); //返回连接对象 return connection; &#125; catch (SQLException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#125; 5.3 测试工具类3）测试：获取所有员工的姓名 1234567891011121314151617181920//获取所有员工的姓名 public static void main(String[] args) &#123; try &#123; //1.获取连接 Connection connection = JDBCUtils.getConnection(); //2.获取 statement ,执行SQL Statement statement = connection.createStatement(); String sql = &quot;select * from employee&quot;; //3.处理结果集 ResultSet resultSet = statement.executeQuery(sql); while(resultSet.next())&#123; String ename = resultSet.getString(&quot;ename&quot;); System.out.println(ename); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"反射机制","slug":"反射机制","date":"2019-01-24T12:16:22.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2019/01/24/反射机制/","link":"","permalink":"http://yournotes.cn/2019/01/24/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"1 基本概念 通常情况下编写代码都是固定的，无论运行多少次执行的结果也是固定的，在某些特殊场合中编写 代码时不确定要创建什么类型的对象，也不确定要调用什么样的方法，","text":"1 基本概念 通常情况下编写代码都是固定的，无论运行多少次执行的结果也是固定的，在某些特殊场合中编写 代码时不确定要创建什么类型的对象，也不确定要调用什么样的方法，这些都希望通过运行时传递 的参数来决定，该机制叫做动态编程技术，也就是反射机制。 通俗来说，反射机制就是用于动态创建对象并且动态调用方法的机制。 目前主流的框架底层都是采用反射机制实现的。 如： 1234//表示声明Person类型的引用指向Person类型的对象Person p = new Person();//表示调用Person类中的成员方法showp.show(); 2 Class类2.1 基本概念 java.lang.Class类的实例可以用于描述Java应用程序中的类和接口，也就是一种数据类型。 该类没有公共构造方法，该类的实例由Java虚拟机和类加载器自动构造完成，本质上就是加载到内 存中的运行时类。 2.2 获取Class对象的方式 使用数据类型.class的方式可以获取对应类型的Class对象（掌握）。 使用引用&#x2F;对象.getClass()的方式可以获取对应类型的Class对象。 使用包装类.TYPE的方式可以获取对应基本数据类型的Class对象。 使用Class.forName()的方式来获取参数指定类型的Class对象（掌握）。 使用类加载器ClassLoader的方式获取指定类型的Class对象。 2.3 常用的方法（掌握） 方法声明 功能介绍 static Class forName(String className) 用于获取参数指定类型对应的Class对象并返回 T newInstance() 用于创建该Class对象所表示类的新实例 3 Constructor类3.1 基本概念 java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息 3.2 Class类的常用方法 方法声明 功能介绍 Constructor getConstructor(Class… parameterTypes) 用于获取此Class对象所表示类型中参数指定的 公共构造方法 Constructor[] getConstructors() 用于获取此Class对象所表示类型中所有的公共 构造方法 3.3 Constructor类的常用方法 方法声明 功能介绍 T newInstance(Object… initargs) 使用此Constructor对象描述的构造方法来构造Class对象代表类 型的新实例 int getModifiers() 获取方法的访问修饰符 String getName() 获取方法的名称 Class[] getParameterTypes() 获取方法所有参数的类型 4 Field类4.1 基本概念 java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。 4.2 Class类的常用方法 方法声明 功能介绍 Field getDeclaredField(String name) 用于获取此Class对象所表示类中参数指定的单个成员变量 信息 Field[] getDeclaredFields() 用于获取此Class对象所表示类中所有成员变量信息 4.3 Field类的常用方法 方法声明 功能介绍 Object get(Object obj) 获取参数对象obj中此Field对象所表示成员变量的数值 void set(Object obj, Object value) 将参数对象obj中此Field对象表示成员变量的数值修改为参数 value的数值 void setAccessible(boolean flag) 当实参传递true时，则反射对象在使用时应该取消 Java 语言访 问检查 int getModifiers() 获取成员变量的访问修饰符 Class getType() 获取成员变量的数据类型 String getName() 获取成员变量的名称 5 Method类5.1 基本概念 java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息 5.2 Class类的常用方法 方法声明 功能介绍 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 用于获取该Class对象表示类中名字为name参数为 parameterTypes的指定公共成员方法 Method[] getMethods() 用于获取该Class对象表示类中所有公共成员方法 5.3 Method类的常用方法 方法声明 功能介绍 Object invoke(Object obj, Object… args) 使用对象obj来调用此Method对象所表示的成员方法，实 参传递args int getModifiers() 获取方法的访问修饰符 Class getReturnType() 获取方法的返回值类型 String getName() 获取方法的名称 Class[] getParameterTypes() 获 获取方法所有参数的类型 Class[] getExceptionTypes() 获取方法的异常信息 6 获取其它结构信息 方法声明 功能介绍 Package getPackage() 获取所在的包信息 Class getSuperclass() 获取继承的父类信息 Class[] getInterfaces( 获取实现的所有接口 Annotation[] getAnnotations() 获取注解信息 Type[] getGenericInterfaces() 获取泛型信息","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"网络编程","slug":"网络编程","date":"2019-01-23T14:49:34.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2019/01/23/网络编程/","link":"","permalink":"http://yournotes.cn/2019/01/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"1 网络编程的常识 目前主流的网络通讯软件有：微信、QQ、飞信、阿里旺旺、陌陌、探探、…","text":"1 网络编程的常识 目前主流的网络通讯软件有：微信、QQ、飞信、阿里旺旺、陌陌、探探、… 1.1 七层网络模型 OSI（Open System Interconnect），即开放式系统互联，是ISO（国际标准化组织）组织在1985 年研究的网络互连模型。 OSI七层模型和TCP&#x2F;IP五层模型的划分如下： 当发送数据时，需要对发送的内容按照上述七层模型进行层层加包后发送出去。 当接收数据时，需要对接收的内容按照上述七层模型相反的次序层层拆包并显示出来。 1.2 相关的协议（笔试题）（1）协议的概念 计算机在网络中实现通信就必须有一些约定或者规则，这种约定和规则就叫做通信协议，通信协议 可以对速率、传输代码、代码结构、传输控制步骤、出错控制等制定统一的标准。 （2）TCP协议 传输控制协议(Transmission Control Protocol)，是一种面向连接的协议，类似于打电话。 建立连接 &#x3D;&gt; 进行通信 &#x3D;&gt; 断开连接 在传输前采用”三次握手”方式。 在通信的整个过程中全程保持连接，形成数据传输通道。 保证了数据传输的可靠性和有序性。 是一种全双工的字节流通信方式，可以进行大数据量的传输。 传输完毕后需要释放已建立的连接，发送数据的效率比较低。 （3）UDP协议 用户数据报协议(User Datagram Protocol)，是一种非面向连接的协议，类似于写信。 在通信的整个过程中不需要保持连接，其实是不需要建立连接。 不保证数据传输的可靠性和有序性。 是一种全双工的数据报通信方式，每个数据报的大小限制在64K内。 发送数据完毕后无需释放资源，开销小，发送数据的效率比较高，速度快。 1.3 IP地址（重点） 192.168.1.1 - 是绝大多数路由器的登录地址，主要配置用户名和密码以及Mac过滤。 IP地址是互联网中的唯一地址标识，本质上是由32位二进制组成的整数，叫做IPv4，当然也有128 位二进制组成的整数，叫做IPv6，目前主流的还是IPv4。 日常生活中采用点分十进制表示法来进行IP地址的描述，将每个字节的二进制转化为一个十进制整 数，不同的整数之间采用小数点隔开。 如： 0x01020304 &#x3D;&gt; 1.2.3.4 查看IP地址的方式： Windows系统：在dos窗口中使用ipconfig或ipconfig&#x2F;all命令即可 Unix&#x2F;linux系统：在终端窗口中使用ifconfig或&#x2F;sbin&#x2F;ifconfig命令即可 特殊的地址 本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost 1.4 端口号（重点） IP地址 - 可以定位到具体某一台设备。 端口号 - 可以定位到该设备中具体某一个进程。 端口号本质上是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间的端口号通 常被系统占用，建议编程从1025开始使用。 特殊的端口： HTTP:80 FTP:21 Oracle:1521 MySQL:3306 Tomcat:8080 网络编程需要提供：IP地址 + 端口号，组合在一起叫做网络套接字：Socket。 2 基于tcp协议的编程模型（重点）2.1 C&#x2F;S架构的简介 在C&#x2F;S模式下客户向服务器发出服务请求，服务器接收请求后提供服务。 例如：在一个酒店中，顾客找服务员点菜,服务员把点菜单通知厨师，厨师按点菜单做好菜后让服 务员端给客户，这就是一种C&#x2F;S工作方式。如果把酒店看作一个系统，服务员就是客户端，厨师就 是服务器。这种系统分工和协同工作的方式就是C&#x2F;S的工作方式。 客户端部分：为每个用户所专有的，负责执行前台功能。 服务器部分：由多个用户共享的信息与功能，招待后台服务。 2.2 编程模型 服务器： （1）创建ServerSocket类型的对象并提供端口号； （2）等待客户端的连接请求，调用accept()方法； （3）使用输入输出流进行通信； （4）关闭Socket； 客户端： （1）创建Socket类型的对象并提供服务器的IP地址和端口号； （2）使用输入输出流进行通信； （3）关闭Socket； 2.3 相关类和方法的解析（1）ServerSocket类 java.net.ServerSocket类主要用于描述服务器套接字信息（大插排）。 常用的方法如下： 方法声明 功能介绍 ServerSocket(int port) 根据参数指定的端口号来构造对象 Socket accept() 侦听并接收到此套接字的连接请求 void close() 用于关闭套接字 （2）Socket类 java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点（小插排）。 常用的方法如下： 方法声明 功能介绍 Socket(String host, int port) 根据指定主机名和端口来构造对象 InputStream getInputStream() 用于获取当前套接字的输入流 OutputStream getOutputStream() 用于获取当前套接字的输出流 void close() 用于关闭套接字 （3）注意事项 客户端 Socket 与服务器端 Socket 对应, 都包含输入和输出流。 客户端的socket.getInputStream() 连接于服务器socket.getOutputStream()。 客户端的socket.getOutputStream()连接于服务器socket.getInputStream() 3 基于udp协议的编程模型（熟悉）3.1 编程模型 接收方： （1）创建DatagramSocket类型的对象并提供端口号； （2）创建DatagramPacket类型的对象并提供缓冲区； （3）通过Socket接收数据内容存放到Packet中，调用receive方法； （4）关闭Socket； 发送方： （1）创建DatagramSocket类型的对象； （2）创建DatagramPacket类型的对象并提供接收方的通信地址； （3）通过Socket将Packet中的数据内容发送出去，调用send方法； （4）关闭Socket； 3.2 相关类和方法的解析（1）DatagramSocket类 java.net.DatagramSocket类主要用于描述发送和接收数据报的套接字(邮局)。 换句话说，该类就是包裹投递服务的发送或接收点。 常用的方法如下： 方法声明 功能介绍 DatagramSocket() 使用无参的方式构造对象 DatagramSocket(int port) 根据参数指定的端口号来构造对象 void receive(DatagramPacket p) 用于接收数据报存放到参数指定的位置 void send(DatagramPacket p) 用于将参数指定的数据报发送出去 void close() 关闭Socket并释放相关资源 （2）DatagramPacket类 java.net.DatagramPacket类主要用于描述数据报，数据报用来实现无连接包裹投递服务。 常用方法如下： 方法声明 功能介绍 DatagramPacket(byte[] buf, int length) 根据参数指定的数组来构造对象，用于接 收长度为length的数据报 DatagramPacket(byte[] buf, int length, InetAddress address, int port) 根据参数指定数组来构造对象，将数据报 发送到指定地址和端口 InetAddress getAddress() 用于获取发送方或接收方的通信地址 int getPort() 用于获取发送方或接收方的端口号 int getLength() 用于获取发送数据或接收数据的长度 （3）InetAddress类 java.net.InetAddress类主要用于描述互联网通信地址信息。 常用的方法如下： 方法声明 功能介绍 static InetAddress getLocalHost() 用于获取当前主机的通信地址 static InetAddress getByName(String host) 根据参数指定的主机名获取通信地址 4 URL类（熟悉）4.1 基本概念 java.net.URL（Uniform Resource Identifier）类主要用于表示统一的资源定位器，也就是指向万 维网上“资源”的指针。这个资源可以是简单的文件或目录，也可以是对复杂对象的引用，例如对数 据库或搜索引擎的查询等。 通过URL可以访问万维网上的网络资源，最常见的就是www和ftp站点，浏览器通过解析给定的 URL可以在网络上查找相应的资源。 URL的基本结构如下： &lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;资源地址&gt; 4.2 常用的方法 方法声明 功能介绍 URL(String spec) 根据参数指定的字符串信息构造对象 String getProtocol() 获取协议名称 String getHost() 获取主机名称 int getPort() 获取端口号 String getPath() 获取路径信息 String getFile() 获取文件名 URLConnection openConnection() 获取URLConnection类的实例 4.3 URLConnection类（1）基本概念 java.net.URLConnection类是个抽象类，该类表示应用程序和URL之间的通信链接的所有类的超 类，主要实现类有支持HTTP特有功能的HttpURLConnection类。 （2）HttpURLConnection类的常用方法 方法声明 功能介绍 InputStream getInputStream() 获取输入流 void disconnect() 断开连接","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"多线程","slug":"多线程","date":"2019-01-20T11:28:43.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2019/01/20/多线程/","link":"","permalink":"http://yournotes.cn/2019/01/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"1 基本概念1.1 程序和进程的概念 程序 - 数据结构 + 算法，主要指存放在硬盘上的可执行文件。","text":"1 基本概念1.1 程序和进程的概念 程序 - 数据结构 + 算法，主要指存放在硬盘上的可执行文件。 进程 - 主要指运行在内存中的可执行文件。 目前主流的操作系统都支持多进程，为了让操作系统同时可以执行多个任务，但进程是重量级的， 也就是新建一个进程会消耗CPU和内存空间等系统资源，因此进程的数量比较局限。 1.2 线程的概念 为了解决上述问题就提出线程的概念，线程就是进程内部的程序流，也就是说操作系统内部支持多 进程的，而每个进程的内部又是支持多线程的，线程是轻量的，新建线程会共享所在进程的系统资 源，因此目前主流的开发都是采用多线程。 多线程是采用时间片轮转法来保证多个线程的并发执行，所谓并发就是指宏观并行微观串行的机 制。 2 线程的创建（重中之重）2.1 Thread类的概念 java.lang.Thread类代表线程，任何线程对象都是Thread类（子类）的实例。 Thread类是线程的模板，封装了复杂的线程开启等操作，封装了操作系统的差异性。 2.2 创建方式 自定义类继承Thread类并重写run方法，然后创建该类的对象调用start方法。 自定义类实现Runnable接口并重写run方法，创建该类的对象作为实参来构造Thread类型的对 象，然后使用Thread类型的对象调用start方法。 2.3 相关的方法 方法声明 功能介绍 Thread() 使用无参的方式构造对象 Thread(String name) 根据参数指定的名称来构造对象 Thread(Runnable target) 根据参数指定的引用来构造对象，其中Runnable是个接口类 型 Thread(Runnable target, String name) 根据参数指定引用和名称来构造对象 void run() 若使用Runnable引用构造了线程对象，调用该方法时最终调 用接口中的版本 若没有使用Runnable引用构造线程对象，调用该方法时则啥 也不做 void start() 用于启动线程，Java虚拟机会自动调用该线程的run方法 2.4 执行流程 执行main方法的线程叫做主线程，执行run方法的线程叫做新线程&#x2F;子线程。 main方法是程序的入口，对于start方法之前的代码来说，由主线程执行一次，当start方法调用成 功后线程的个数由1个变成了2个，新启动的线程去执行run方法的代码，主线程继续向下执行，两 个线程各自独立运行互不影响。 当run方法执行完毕后子线程结束，当main方法执行完毕后主线程结束。 两个线程执行没有明确的先后执行次序，由操作系统调度算法来决定。 2.5 方式的比较 继承Thread类的方式代码简单，但是若该类继承Thread类后则无法继承其它类，而实现 Runnable接口的方式代码复杂，但不影响该类继承其它类以及实现其它接口，因此以后的开发中 推荐使用第二种方式。 2.6 匿名内部类的方式 使用匿名内部类的方式来创建和启动线程。 3 线程的生命周期（熟悉） 新建状态 - 使用new关键字创建之后进入的状态，此时线程并没有开始执行。 就绪状态 - 调用start方法后进入的状态，此时线程还是没有开始执行。 运行状态 - 使用线程调度器调用该线程后进入的状态，此时线程开始执行，当线程的时间片执行完 毕后任务没有完成时回到就绪状态。 消亡状态 - 当线程的任务执行完成后进入的状态，此时线程已经终止。 阻塞状态 - 当线程执行的过程中发生了阻塞事件进入的状态，如：sleep方法。 阻塞状态解除后进入就绪状态。 4 线程的编号和名称（熟悉） 方法声明 功能介绍 long getId() 获取调用对象所表示线程的编号 String getName() 获取调用对象所表示线程的名称 void setName(String name) 设置&#x2F;修改线程的名称为参数指定的数值 static Thread currentThread() 获取当前正在执行线程的引用 案例题目 自定义类继承Thread类并重写run方法，在run方法中先打印当前线程的编号和名称，然后将线程 的名称修改为”zhangfei”后再次打印编号和名称。 要求在main方法中也要打印主线程的编号和名称。 5 常用的方法（重点） 方法声明 功能介绍 static void yield() 当前线程让出处理器（离开Running状态），使当前线程进入Runnable 状态等待 static void sleep(times) 使当前线程从 Running 放弃处理器进入Block状态, 休眠times毫秒, 再返 回到Runnable如果其他线程打断当前线程的Block(sleep), 就会发生 InterruptedException。 int getPriority() 获取线程的优先级 void setPriority(int newPriority) 修改线程的优先级。 优先级越高的线程不一定先执行，但该线程获取到时间片的机会会更多 一些 void join() 等待该线程终止 void join(long millis) 等待参数指定的毫秒数 boolean isDaemon() 用于判断是否为守护线程 void setDaemon(boolean on) 用于设置线程为守护线程 案例题目 编程创建两个线程，线程一负责打印1 ~ 100之间的所有奇数，其中线程二负责打印1 ~ 100之间的 所有偶数。 在main方法启动上述两个线程同时执行,主线程等待两个线程终止。 6 线程同步机制（重点）6.1 基本概念 当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对线 程之间进行通信和协调，该机制就叫做线程的同步机制。 多个线程并发读写同一个临界资源时会发生线程并发安全问题。 异步操作:多线程并发的操作，各自独立运行。 同步操作:多线程串行的操作，先后执行的顺序。 6.2 解决方案 由程序结果可知：当两个线程同时对同一个账户进行取款时，导致最终的账户余额不合理。 引发原因：线程一执行取款时还没来得及将取款后的余额写入后台，线程二就已经开始取款。 解决方案：让线程一执行完毕取款操作后，再让线程二执行即可，将线程的并发操作改为串行操 作。 经验分享：在以后的开发尽量减少串行操作的范围，从而提高效率。 6.3 实现方式 在Java语言中使用synchronized关键字来实现同步&#x2F;对象锁机制从而保证线程执行的原子性，具体 方式如下： 12345678//使用同步代码块的方式实现部分代码的锁定，格式如下： synchronized(类类型的引用) &#123; 编写所有需要锁定的代码； &#125; //使用同步方法的方式实现所有代码的锁定。 直接使用synchronized关键字来修饰整个方法即可 该方式等价于:synchronized(this) &#123; 整个方法体的代码 &#125; 6.4 静态方法的锁定 当我们对一个静态方法加锁，如: public synchronized static void xxx()&#123;….&#125; 那么该方法锁的对象是类对象。每个类都有唯一的一个类对象。获取类对象的方式:类名.class。 静态方法与非静态方法同时使用了synchronized后它们之间是非互斥关系的。 原因在于：静态方法锁的是类对象而非静态方法锁的是当前方法所属对象。 6.5 注意事项 使用synchronized保证线程同步应当注意: 多个需要同步的线程在访问同步块时，看到的应该是同一个锁对象引用。 在使用同步块时应当尽量减少同步范围以提高并发的执行效率。 6.6 线程安全类和不安全类 StringBuffer类是线程安全的类，但StringBuilder类不是线程安全的类。 Vector类和 Hashtable类是线程安全的类，但ArrayList类和HashMap类不是线程安全的类。 Collections.synchronizedList() 和 Collections.synchronizedMap()等方法实现安全。 6.7 死锁的概念 线程一执行的代码： 1234567public void run()&#123; synchronized(a)&#123; //持有对象锁a，等待对象锁b synchronized(b)&#123; 编写锁定的代码; &#125; &#125;&#125; 线程二执行的代码： 1234567public void run()&#123; synchronized(b)&#123; //持有对象锁b，等待对象锁a synchronized(a)&#123; 编写锁定的代码; &#125; &#125;&#125; 注意： 在以后的开发中尽量减少同步的资源，减少同步代码块的嵌套结构的使用！ 6.8 使用Lock（锁）实现线程同步（1）基本概念 从Java5开始提供了更强大的线程同步机制—使用显式定义的同步锁对象来实现。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。 该接口的主要实现类是ReentrantLock类，该类拥有与synchronized相同的并发性，在以后的线程 安全控制中，经常使用ReentrantLock类显式加锁和释放锁。 （2）常用的方法 方法声明 功能介绍 ReentrantLock() 使用无参方式构造对象 void lock() 获取锁 void unlock() 释放锁 （3）与synchronized方式的比较 Lock是显式锁，需要手动实现开启和关闭操作，而synchronized是隐式锁，执行锁定代码后自动 释放。 Lock只有同步代码块方式的锁，而synchronized有同步代码块方式和同步方法两种锁。 使用Lock锁方式时，Java虚拟机将花费较少的时间来调度线程，因此性能更好。 6.9 Object类常用的方法 方法声明 功能介绍 void wait() 用于使得线程进入等待状态，直到其它线程调用notify()或notifyAll()方 法 void wait(long timeout) 用于进入等待状态，直到其它线程调用方法或参数指定的毫秒数已经过 去为止 void notify() 用于唤醒等待的单个线程 void notifyAll() 用于唤醒等待的所有线程 6.10 线程池（熟悉）（1）实现Callable接口 从Java5开始新增加创建线程的第三种方式为实现java.util.concurrent.Callable接口。 常用方法如下： 方法声明 功能介绍 V call() 计算结果并返回 （2）FutureTask类 java.util.concurrent.FutureTask类用于描述可取消的异步计算，该类提供了Future接口的基本实 现，包括启动和取消计算、查询计算是否完成以及检索计算结果的方法，也可以用于获取方法调用 后的返回结果。 常用的方法如下： 方法声明 功能介绍 FutureTask(Callable callable) 根据参数指定的引用来创建一个未来任务 V get() 获取call方法计算的结果 （3）线程池的由来 在服务器编程模型的原理，每一个客户端连接用一个单独的线程为之服务，当与客户端的会话结束 时，线程也就结束了，即每来一个客户端连接，服务器端就要创建一个新线程。 如果访问服务器的客户端很多，那么服务器要不断地创建和销毁线程，这将严重影响服务器的性 能 （4）概念和原理 线程池的概念：首先创建一些线程，它们的集合称为线程池，当服务器接受到一个客户请求后，就 从线程池中取出一个空闲的线程为之服务，服务完后不关闭该线程，而是将该线程还回到线程池 中。 在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务 后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，任务是提交给整个线程 池，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。 （5）相关类和方法 从Java5开始提供了线程池的相关类和接口：java.util.concurrent.Executors类和 java.util.concurrent.ExecutorService接口。 其中Executors是个工具类和线程池的工厂类，可以创建并返回不同类型的线程池，常用方法如 下： 方法声明 功能介绍 static ExecutorService newCachedThreadPool() 创建一个可根据需要创建新线程的线程池 static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池 static ExecutorService newSingleThreadExecutor() 创建一个只有一个线程的线程池 其中ExecutorService接口是真正的线程池接口，主要实现类是ThreadPoolExecutor，常用方法 如下： 方法声明 功能介绍 void execute(Runnable command) 执行任务和命令，通常用于执行Runnable Future submit(Callable task) 执行任务和命令，通常用于执行Callable void shutdown() 启动有序关闭","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"异常机制和File类","slug":"异常机制和File类","date":"2019-01-17T11:39:42.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2019/01/17/异常机制和File类/","link":"","permalink":"http://yournotes.cn/2019/01/17/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E5%92%8CFile%E7%B1%BB/","excerpt":"1. 异常机制（重点）1.1 基本概念 异常就是”不正常”的含义，在Java语言中主要指程序执行中发生的不正常情况。","text":"1. 异常机制（重点）1.1 基本概念 异常就是”不正常”的含义，在Java语言中主要指程序执行中发生的不正常情况。 java.lang.Throwable类是Java语言中错误(Error)和异常(Exception)的超类。 其中Error类主要用于描述Java虚拟机无法解决的严重错误，通常无法编码解决，如：JVM挂掉了 等。 其中Exception类主要用于描述因编程错误或偶然外在因素导致的轻微错误，通常可以编码解决， 如：0作为除数等。 1.2 异常的分类 java.lang.Exception类是所有异常的超类，主要分为以下两种： RuntimeException - 运行时异常，也叫作非检测性异常 IOException和其它异常 - 其它异常，也叫作检测性异常，所谓检测性异常就是指在编译阶段都能 被编译器检测出来的异常。 其中RuntimeException类的主要子类： ArithmeticException类 - 算术异常 ArrayIndexOutOfBoundsException类 - 数组下标越界异常 NullPointerException - 空指针异常 ClassCastException - 类型转换异常 NumberFormatException - 数字格式异常 注意： 当程序执行过程中发生异常但又没有手动处理时，则由Java虚拟机采用默认方式处理异常，而默认 处理方式就是：打印异常的名称、异常发生的原因、异常发生的位置以及终止程序。 1.3 异常的避免 在以后的开发中尽量使用if条件判断来避免异常的发生。 但是过多的if条件判断会导致程序的代码加长、臃肿，可读性差。 1.4 异常的捕获 语法格式 12345678910try &#123; 编写可能发生异常的代码;&#125;catch(异常类型 引用变量名) &#123; 编写针对该类异常的处理代码；&#125;...finally &#123; 编写无论是否发生异常都要执行的代码；&#125; 注意事项 当需要编写多个catch分支时，切记小类型应该放在大类型的前面 懒人的写法： catch(Exception e) {} finally通常用于进行善后处理，如：关闭已经打开的文件等。 执行流程 123456789try &#123; a; b; //可能发生异常的语句 c;&#125;catch(Exception ex) &#123; d;&#125;finally &#123; e;&#125; 当没有发生异常时的执行流程：a b c e 当发生异常时的执行流程：a b d e 1.5 异常的抛出 基本概念 在某些特殊情况下有些异常不能处理或者不便于处理时，就可以将该异常转移给该方法的调用者， 这种方法就叫异常的抛出。当方法执行时出现异常，则底层生成一个异常类对象抛出，此时异常代 码后续的代码就不再执行。 语法格式 访问权限 返回值类型 方法名称(形参列表) throws 异常类型1,异常类型2,…{ 方法体; } 如： public void show() throws IOException&#123;&#125; 方法重写的原则 要求方法名相同、参数列表相同以及返回值类型相同，从jdk1.5开始支持返回子类类型 要求方法的访问权限不能变小，可以相同或者变大 要求方法不能抛出更大的异常； 注意： 子类重写的方法不能抛出更大的异常、不能抛出平级不一样的异常，但可以抛出一样的异常、更小 的异常以及不抛出异常。 经验分享 若父类中被重写的方法没有抛出异常时，则子类中重写的方法只能进行异常的捕获处理。 若一个方法内部又以递进方式分别调用了好几个其它方法，则建议这些方法内可以使用抛出 的方法处理到最后一层进行捕获方式处理。 1.6 自定义异常 基本概念 当需要在程序中表达年龄不合理的情况时，而Java官方又没有提供这种针对性的异常，此时就需要 程序员自定义异常加以描述。 实现流程 自定义xxxException异常类继承Exception类或者其子类。 提供两个版本的构造方法，一个是无参构造方法，另外一个是字符串作为参数的构造方法。 异常的产生 throw new 异常类型(实参); 如： throw new AgeException(&quot;年龄不合理！！！&quot;); Java采用的异常处理机制是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序 简洁、优雅，并易于维护。 2 File类（重点）2.1 基本概念 java.io.File类主要用于描述文件或目录路径的抽象表示信息，可以获取文件或目录的特征信息， 如：大小等。 方法声明 功能概述 File(String pathname) 根据参数指定的路径名来构造对象 File(String parent, String child) 根据参数指定的父路径和子路径信息构造对象 File(File parent, String child) 根据参数指定的父抽象路径和子路径信息构造对象 boolean exists() 测试此抽象路径名表示的文件或目录是否存在 String getName() 用于获取文件的名称 long length() 返回由此抽象路径名表示的文件的长度 long lastModified() 用于获取文件的最后一次修改时间 String getAbsolutePath() 用于获取绝对路径信息 boolean delete() 用于删除文件，当删除目录时要求是空目录 boolean createNewFile() 用于创建新的空文件 boolean mkdir() 用于创建目录 boolean mkdirs() 用于创建多级目录 File[] listFiles() 获取该目录下的所有内容 boolean isFile() 判断是否为文件 boolean isDirectory() 判断是否为目录 File[] listFiles(FileFilter filter) 获取目录下满足筛选器的所有内容 案例题目 : 遍历指定目录以及子目录中的所有内容并打印出来。","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"常用设计原则和设计模式","slug":"常用设计原则和设计模式","date":"2019-01-17T11:02:50.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2019/01/17/常用设计原则和设计模式/","link":"","permalink":"http://yournotes.cn/2019/01/17/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"1. 常用的设计原则（记住）1.1 软件开发的流程 需求分析文档、概要设计文档、详细设计文档、编码和测试、安装和调试、维护和升级","text":"1. 常用的设计原则（记住）1.1 软件开发的流程 需求分析文档、概要设计文档、详细设计文档、编码和测试、安装和调试、维护和升级 1.2 常用的设计原则 开闭原则（Open Close Principle） 对扩展开放对修改关闭，为了使程序的扩展性好，易于维护和升级。 里氏代换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现，多使用多态的方式。 依赖倒转原则（Dependence Inversion Principle） 尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性 接口隔离原则（Interface Segregation Principle） 尽量多使用小接口而不是大接口，避免接口的污染，降低类之间耦合度。 迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少与其他实体之间发生相互作用，使系统功能模块相对独立。 高内聚，低耦合。 合成复用原则（Composite Reuse Principle） 尽量多使用合成&#x2F;聚合的方式，而不是继承的方式。 2. 常用的设计模式2.1 基本概念 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验 的总结。 设计模式就是一种用于固定场合的固定套路。 2.2 基本分类 创建型模式 - 单例设计模式、工厂方法模式、抽象工厂模式、… 结构型模式 - 装饰器模式、代理模式、… 行为型模式 - 模板设计模式、… 3 设计模式详解（重点）3.1 单例设计模式 单例设计模式主要分为：饿汉式 和 懒汉式，懒汉式需要对多线程进行同步处理。 3.2 普通工厂模式（1）基本概念 普通工厂方法模式就是建立一个工厂类，对实现了同一接口的不同实现类进行实例的创建。 （2）类图结构 （3）主要缺点 在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，并且可能出现空指针异 常。 3.3 多个工厂方法模式（1）类图结构 （2）主要缺点 在多个工厂方法模式中，为了能够正确创建对象，先需要创建工厂类的对象才能调用工厂类中的生 产方法。 3.4 静态工厂方法模式（1）类图结构 （2）实际意义 工厂方法模式适合：凡是出现了大量的产品需要创建且具有共同的接口时，可以通过工厂方法模式 进行创建。 （3）主要缺点 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序生产新的产 品，就必须对工厂类的代码进行修改，这就违背了开闭原则。 3.5 抽象工厂模式（1）类图结构 3.6 装饰器模式（1）基本概念 装饰器模式就是给一个对象动态的增加一些新功能，要求装饰对象和被装饰对象实现同一个接口， 装饰对象持有被装饰对象的实例。 （2）类图结构 （3）实际意义 可以实现一个类功能的扩展。 可以动态的增加功能，而且还能动态撤销（继承不行）。 缺点：产生过多相似的对象，不易排错。 3.7 代理模式（1）基本概念 代理模式就是找一个代理类替原对象进行一些操作。 比如我们在租房子的时候找中介，再如我们打官司需要请律师，中介和律师在这里就是我们的代 理。 （2）类图结构 （3）实际意义 如果在使用的时候需要对原有的方法进行改进，可以采用一个代理类调用原有方法，并且对产生的 结果进行控制，这种方式就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护 （4）代理模式和装饰器模式的比较 装饰器模式通常的做法是将原始对象作为一个参数传给装饰者的构造器，而代理模式通常在一个代 理类中创建一个被代理类的对象。 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。 3.8 模板方法模式（1）基本概念 模板方法模式主要指一个抽象类中封装了一个固定流程，流程中的具体步骤可以由不同子类进行不 同的实现，通过抽象类让固定的流程产生不同的结果。 （2）类图结构 （3）实际意义 将多个子类共有且逻辑基本相同的内容提取出来实现代码复用。 不同的子类实现不同的效果形成多态，有助于后期维护。","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"集合类库（下）","slug":"集合类库（下）","date":"2019-01-16T11:36:20.000Z","updated":"2025-04-17T08:34:52.025Z","comments":true,"path":"2019/01/16/集合类库（下）/","link":"","permalink":"http://yournotes.cn/2019/01/16/%E9%9B%86%E5%90%88%E7%B1%BB%E5%BA%93%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"1. 泛型机制（熟悉）1.1 基本概念 通常情况下集合中可以存放不同类型的对象，是因为将所有对象都看做Object类型放入的","text":"1. 泛型机制（熟悉）1.1 基本概念 通常情况下集合中可以存放不同类型的对象，是因为将所有对象都看做Object类型放入的，因此 从集合中取出元素时也是Object类型，为了表达该元素真实的数据类型，则需要强制类型转换， 而强制类型转换可能会引发类型转换异常。 为了避免上述错误的发生，从Java5开始增加泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt; 的方式来明确要求该集合中可以存放的元素类型，若放入其它类型的元素则编译报错。 泛型只在编译时期有效，在运行时期不区分是什么类型。 1.2 底层原理 泛型的本质就是参数化类型，也就是让数据类型作为参数传递，其中E相当于形式参数负责占位， 而使用集合时&lt;&gt;中的数据类型相当于实际参数，用于给形式参数E进行初始化，从而使得集合中所 有的E被实际参数替换，由于实际参数可以传递各种各样广泛的数据类型，因此得名为泛型。 如： 12345678910111213141516171819//其中i叫做形式参数，负责占位//int i = 10;//int i = 20;public static void show(int i) &#123; ... &#125;//其中10或20叫做实际参数，负责给形式参数初始化show(10);show(20);//其中E叫做形式参数，负责占位//E = String; //E = Integer; public interface List &#123; ... &#125; //其中String或者Integer叫做实际参数List lt1 = ...; List lt2 = ...; 1.3 自定义泛型接口 泛型接口和普通接口的区别就是后面添加了类型参数列表，可以有多个类型参数，如： 等。 1.4 自定义泛型类 泛型类和普通类的区别就是类名后面添加了类型参数列表，可以有多个类型参数，如： 等。 实例化泛型类时应该指定具体的数据类型，并且是引用数据类型而不是基本数据类型。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型。 子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。 1.5 自定义泛型方法 泛型方法就是我们输入参数的时候，输入的是泛型参数，而不是具体的参数。我们在调用这个泛型 方法的时需要对泛型参数进行实例化。 泛型方法的格式： [访问权限] &lt;泛型&gt; 返回值类型 方法名([泛型标识 参数名称]) { 方法体; } 在静态方法中使用泛型参数的时候，需要我们把静态方法定义为泛型方法。 1.6 泛型在继承上的体现 如果B是A的一个子类或子接口，而G是具有泛型声明的类或接口，则G并不是G的子类型！ 比如：String是Object的子类，但是List并不是List的子类。 1.7 通配符的使用 有时候我们希望传入的类型在一个指定的范围内，此时就可以使用泛型通配符了。 如：之前传入的类型要求为Integer类型，但是后来业务需要Integer的父类Number类也可以传 入。 泛型中有三种通配符形式： 无限制通配符：表示我们可以传入任意类型的参数。 表示类型的上界是E，只能是E或者是E的子类。 表示类型的下界是E，只能是E或者是E的父类。 2. Set集合（熟悉）2.1 基本概念 java.util.Set集合是Collection集合的子集合，与List集合平级。 该集合中元素没有先后放入次序，且不允许重复。 该集合的主要实现类是：HashSet类 和 TreeSet类以及LinkedHashSet类。 其中HashSet类的底层是采用哈希表进行数据管理的。 其中TreeSet类的底层是采用红黑树进行数据管理的。 其中LinkedHashSet类与HashSet类的不同之处在于内部维护了一个双向链表，链表中记录了元 素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。 2.2 常用的方法 参考Collection集合中的方法即可！ 案例题目 准备一个Set集合指向HashSet对象，向该集合中添加元素”two”并打印，再向集合中添加元 素”one”并打印，再向集合中添加元素”three”并打印，再向集合中添加”one”并打印。 2.3 元素放入HashSet集合的原理 使用元素调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算出该元素在数组中的索 引位置。 若该位置没有元素，则将该元素直接放入即可。 若该位置有元素，则使用新元素与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放 入。 若新元素与已有元素的哈希值相同，则使用新元素调用equals方法与已有元素依次比较。 若相等则添加元素失败，否则将元素直接放入即可。 思考：为什么要求重写equals方法后要重写hashCode方法呢？ 解析： 当两个元素调用equals方法相等时证明这两个元素相同，重写hashCode方法后保证这两个元 素得到的哈希码值相同，由同一个哈希算法生成的索引位置相同，此时只需要与该索引位置已有元 素比较即可，从而提高效率并避免重复元素的出现。 2.4 TreeSet集合的概念 二叉树主要指每个节点最多只有两个子节点的树形结构。 满足以下3个特征的二叉树叫做有序二叉树。 左子树中的任意节点元素都小于根节点元素值 右子树中的任意节点元素都大于根节点元素值 左子树和右子树的内部也遵守上述规则 由于TreeSet集合的底层采用红黑树进行数据的管理，当有新元素插入到TreeSet集合时，需要使 用新元素与集合中已有的元素依次比较来确定新元素的合理位置。 比较元素大小的规则有两种方式： 使用元素的自然排序规则进行比较并排序，让元素类型实现java.lang.Comparable接口 使用比较器规则进行比较并排序，构造TreeSet集合时传入java.util.Comparator接口 自然排序的规则比较单一，而比较器的规则比较多元化，而且比较器优先于自然排序； 3. Map集合（重点）3.1 基本概念 java.util.Map集合中存取元素的基本单位是：单对元素，其中类型参数如下： K - 此映射所维护的键(Key)的类型，相当于目录。 V - 映射值(Value)的类型，相当于内容。 该集合中key是不允许重复的，而且一个key只能对应一个value。 该集合的主要实现类有：HashMap类、TreeMap类、LinkedHashMap类、Hashtable类、 Properties类。 其中HashMap类的底层是采用哈希表进行数据管理的。 其中TreeMap类的底层是采用红黑树进行数据管理的。 其中LinkedHashMap类与HashMap类的不同之处在于内部维护了一个双向链表，链表中记录了 元素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。 其中Hashtable类是古老的Map实现类，与HashMap类相比属于线程安全的类，且不允许null作 为key或者value的数值。 其中Properties类是Hashtable类的子类，该对象用于处理属性文件，key和value都是String类 型的。 Map集合是面向查询优化的数据结构, 在大数据量情况下有着优良的查询性能。 经常用于根据key检索value的业务场景。 3.2 常用的方法 方法声明 功能介绍 V put(K key, V value) 将Key-Value对存入Map，若集合中已经包含该Key，则替换该Key所对 应的Value，返回值为该Key原来所对应的Value，若没有则返回null V get(Object key) 返回与参数Key所对应的Value对象，如果不存在则返回null boolean containsKey(Object key) 判断集合中是否包含指定的Key boolean containsValue (Object value) 判断集合中是否包含指定的Value V remove(Object key) 根据参数指定的key进行删除 Set keySet() 返回此映射中包含的键的Set视图 Collection values() 返回此映射中包含的值的Set视图 Set&gt; entrySet() 返回此映射中包含的映射的Set视图 3.3 元素放入HashMap集合的原理 使用元素的key调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算在数组中的索引 位置。 若该位置没有元素，则将该键值对直接放入即可。 若该位置有元素，则使用key与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放 入。 若key与已有元素的哈希值相同，则使用key调用equals方法与已有元素依次比较。 若相等则将对应的value修改，否则将键值对直接放入即可。 3.4 相关的常量 属性 属性介绍 DEFAULT_INITIAL_CAPACITY HashMap的默认容量是16 DEFAULT_LOAD_FACTOR HashMap的默认加载因子是0.75 threshold 扩容的临界值，该数值为：容量*填充因子，也就是12 TREEIFY_THRESHOLD 若Bucket中链表长度大于该默认值则转化为红黑树存储，该数值是8 MIN_TREEIFY_CAPACITY 桶中的Node被树化时最小的hash表容量，该数值是64 4. Collections类4.1 基本概念 java.util.Collections类主要提供了对集合操作或者返回集合的静态方法。 4.2 常用的方法 方法声明 功能介绍 static &gt; T max(Collection coll) 根据元素的自然顺序返回给定集 合的最大元素 static T max(Collection coll, Comparator comp) 根据指定比较器引发的顺序返回 给定集合的最大元素 static &gt; T min(Collection coll) 根据元素的自然顺序返回给定集 合的最小元素 static T min(Collection coll, Comparator comp) 根据指定比较器引发的顺序返回 给定集合的最小元素 static void copy(List dest, List src) 将一个列表中的所有元素复制到 另一个列表中 方法声明 功能介绍 static void reverse(List list) 反转指定列表中元素的顺序 static void shuffle(List list) 使用默认的随机源随机置换指定的列表 static &gt; void sort(List list) 根据其元素的自然顺序将指定列表按升 序排序 static void sort(List list, Comparator c) 根据指定比较器指定的顺序对指定列表 进行排序 static void swap(List list, int i, int j) 交换指定列表中指定位置的元素","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"集合类库（上）","slug":"集合类库（上）","date":"2019-01-16T11:04:40.000Z","updated":"2025-04-17T08:34:52.024Z","comments":true,"path":"2019/01/16/集合类库（上）/","link":"","permalink":"http://yournotes.cn/2019/01/16/%E9%9B%86%E5%90%88%E7%B1%BB%E5%BA%93%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"1. 集合的概述（重点）1.1 集合的由来 当需要在Java程序中记录单个数据内容时，则声明一个变量。","text":"1. 集合的概述（重点）1.1 集合的由来 当需要在Java程序中记录单个数据内容时，则声明一个变量。 当需要在Java程序中记录多个类型相同的数据内容时，声明一个一维数组。 当需要在Java程序中记录多个类型不同的数据内容时，则创建一个对象。 当需要在Java程序中记录多个类型相同的对象数据时，创建一个对象数组。 当需要在Java程序中记录多个类型不同的对象数据时，则准备一个集合。 1.2 集合的框架结构 Java中集合框架顶层框架是：java.util.Collection集合 和 java.util.Map集合。 其中Collection集合中存取元素的基本单位是：单个元素。 其中Map集合中存取元素的基本单位是：单对元素。 2. Collection集合（重点）2.1 基本概念 java.util.Collection接口是List接口、Queue 接口以及Set接口的父接口，因此该接口里定义的方法 既可用于操作List集合，也可用于操作Queue集合和Set集合。 2.2 常用的方法（练熟、记住） 方法声明 功能介绍 boolean add(E e) 向集合中添加对象 boolean addAll(Collection c) 用于将参数指定集合c中的所有元素添加到当前集合中 boolean contains(Object o) 判断是否包含指定对象 boolean containsAll(Collection c) 判断是否包含参数指定的所有对象 boolean retainAll(Collection c) 保留当前集合中存在且参数集合中存在的所有对象 boolean remove(Object o); 从集合中删除对象 boolean removeAll(Collection c) 从集合中删除参数指定的所有对象 void clear() 清空集合 int size() 返回包含对象的个数 boolean isEmpty() 判断是否为空 boolean equals(Object o) 判断是否相等 int hashCode() 获取当前集合的哈希码值 Object[] toArray() 将集合转换为数组 Iterator iterator() 获取当前集合的迭代器 3. Iterator接口（重点）3.1 基本概念 java.util.Iterator接口主要用于描述迭代器对象，可以遍历Collection集合中的所有元素。 java.util.Collection接口继承Iterator接口，因此所有实现Collection接口的实现类都可以使用该迭 代器对象。 3.2 常用的方法 方法声明 功能介绍 boolean hasNext() 判断集合中是否有可以迭代&#x2F;访问的元素 E next() 用于取出一个元素并指向下一个元素 void remove() 用于删除访问到的最后一个元素 案例题目： 如何使用迭代器实现toString方法的打印效果？ 4. for each循环（重点）4.1 基本概念 Java5推出了增强型for循环语句，可以应用数组和集合的遍历。 是经典迭代的“简化版”。 4.2 语法格式 123for(元素类型 变量名 : 数组/集合名称) &#123; 循环体;&#125; 4.3 执行流程 不断地从数组&#x2F;集合中取出一个元素赋值给变量名并执行循环体，直到取完所有元素为止。 5. List集合（重中之重）5.1 基本概念 java.util.List集合是Collection集合的子集合，该集合中允许有重复的元素并且有先后放入次序。 该集合的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类。 其中ArrayList类的底层是采用动态数组进行数据管理的，支持下标访问，增删元素不方便。 其中LinkedList类的底层是采用双向链表进行数据管理的，访问不方便，增删元素方便。 可以认为ArrayList和LinkedList的方法在逻辑上完全一样，只是在性能上有一定的差别，ArrayList 更适合于访问而LinkedList更适合于插入和删除在性能要求不是特别苛刻的情形下可以忽略这个差别。 其中Stack类的底层是采用动态数组进行数据管理的，该类主要用于描述一种具有后进先出特征的 数据结构，叫做栈(last in first out LIFO)。 其中Vector类的底层是采用动态数组进行数据管理的，该类与ArrayList类相比属于线程安全的 类，效率比较低，以后开发中基本不用。 5.2 常用的方法 方法声明 功能介绍 void add(int index, E element) 向集合中指定位置添加元素 boolean addAll(int index, Collection c) 向集合中添加所有元素 E get(int index) 从集合中获取指定位置元素 int indexOf(Object o) 查找参数指定的对象 int lastIndexOf(Object o) 反向查找参数指定的对象 E set(int index, E element) 修改指定位置的元素 E remove(int index) 删除指定位置的元素 List subList(int fromIndex, int toIndex) 用于获取子List 案例题目 准备一个Stack集合，将数据11、22、33、44、55依次入栈并打印，然后查看栈顶元素并打印， 然后将栈中所有数据依次出栈并打印。 再准备一个Stack对象，将数据从第一个栈中取出来放入第二个栈中，然后再从第二个栈中取出并 打印。 6. Queue集合（重点）6.1 基本概念 java.util.Queue集合是Collection集合的子集合，与List集合属于平级关系。 该集合的主要用于描述具有先进先出特征的数据结构，叫做队列(first in first out FIFO)。 该集合的主要实现类是LinkedList类，因为该类在增删方面比较有优势。 6.2 常用的方法 方法声明 功能介绍 boolean offer(E e) 将一个对象添加至队尾，若添加成功则返回true E poll() 从队首删除并返回一个元素 E peek() 返回队首的元素（但并不删除） 案例题目 准备一个Queue集合，将数据11、22、33、44、55依次入队并打印，然后查看队首元素并打印， 然后将队列中所有数据依次出队并打印。","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"常用类的概述和使用","slug":"常用类的概述和使用","date":"2019-01-11T16:00:00.000Z","updated":"2025-04-17T08:34:52.022Z","comments":true,"path":"2019/01/12/常用类的概述和使用/","link":"","permalink":"http://yournotes.cn/2019/01/12/%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"1. 常用的包（熟悉）1.1 包的名称和功能 java.lang包 ： 该包是Java语言的核心包，并且该包中的所有内容由Java虚拟机自动导入。","text":"1. 常用的包（熟悉）1.1 包的名称和功能 java.lang包 ： 该包是Java语言的核心包，并且该包中的所有内容由Java虚拟机自动导入。如：System类、String类、… java.util包 - 该包是Java语言的工具包，里面提供了大量工具类以及集合类等。 如：Scanner类、Random类、List集合、… java.io包 - 该包是Java语言中的输入输出包，里面提供了大量读写文件相关的类等。 如：FileInputStream类、FileOutputStream类、… java.net包 - 该包是Java语言中的网络包，里面提供了大量网络编程相关的类等。 如：ServerSocket类、Socket类、… java.sql 包 - 该包是Java语言中的数据包，里面提供了大量操作数据库的类和接口等。 如：DriverManager类、Connection接口、… … … Java程序员在编程时可以使用大量类库，因此Java编程时需要记的很多，对编程能力本身要求不是 特别的高。 2. Object类的概述（重点）2.1 基本概念 java.lang.Object类是Java语言中类层次结构的根类，也就是说任何一个类都是该类的直接或者间 接子类。 如果定义一个Java类时没有使用extends关键字声明其父类，则其父类为 java.lang.Object 类。 Object类定义了“对象”的基本行为, 被子类默认继承。 2.2 常用方法 方法声明 功能介绍 Object() 使用无参方式构造对象 boolean equals(Object obj) 用于判断调用对象是否与参数对象相等。 该方法默认比较两个对象的地址是否相等，与 &#x3D;&#x3D; 运算符的结果一致若希望比较两个对象的内容则需要重写该方法。若该方法被重写后，则应该重写hashCode方法来保证结果的一致性。 int hashCode() 用于获取调用对象的哈希码值(内存地址的编号)。 若两个对象调用equals方法相等，则各自调用该方法的结果必须相 同 若两个调用对象equals方法不相等，则各自调用该方法的结果应该 不相同。 为了使得该方法与equals方法保持一致，需要重写该方法。 String toString() 用于获取调用对象的字符串形式 该方法默认返回的字符串为：包名.类名@哈希码值的十六进制 为了返回更有意义的数据，需要重写该方法 使用print或println打印引用或字符串拼接引用都会自动调用该方法 Class getClass() 用于返回调用对象执行时的Class实例，反射机制使用 案例题目： ​ 编程实现Student类的封装，特征：学号(id)和姓名，要求提供打印所有特征的方法。 ​ 编程实现StudentTest类，在main方法中使用有参方式构造两个Student类型的对象并打印特征。 题目扩展: ​ 如何实现以姓名作为基准判断两个对象是否相等？以及以学号和姓名同时作为基准判断两个对象是 否相等？ 3. 包装类（熟悉）3.1 包装类的概念​ 通常情况下基本数据类型的变量不是对象，为了满足万物皆对象的理念就需要对基本数据类型的变 量进行打包封装处理变成对象，而负责将这些变量声明为成员变量进行对象化处理的相关类，叫做包装 类。 如： 12Person p = new Person(); int num = 10; 3.2 包装类的分类 包装类 对应的基本类型 java.lang.Byte byte java.lang.Short short java.lang.Integer int java.lang.Long long java.lang.Float float java.lang.Double double java.lang.Boolean boolean java.lang.Character char 3.3 Integer类的概述（1）基本概念 java.lang.Integer类内部包装了一个int类型的变量作为成员变量，主要用于实现对int类型的包装并 提供int类型到String类之间的转换等方法。 （2）常用的常量 常量类型和名称 功能介绍 public static final int MAX_VALUE 表示int类型可以描述的最大值，即2^31-1 public static final int MIN_VALUE 表示int类型可以描述的最小值，即-2^31 public static final int SIZE 表示int类型采用二进制补码形式的位数 public static final int BYTES 表示int类型所占的字节个数 public static final Class TYPE 表示int类型的Class实例 （3）常用的方法 方法声明 功能介绍 Integer(int value) 根据参数指定的整数来构造对象（已过时） Integer(String s) 根据参数指定的字符串来构造对象 （已过时） int intValue() 获取调用对象中的整数值并返回 static Integer valueOf(int i) 根据参数指定整数值得到Integer类型对象 boolean equals(Object obj) 比较调用对象与参数指定的对象是否相等 String toString() 返回描述调用对象数值的字符串形式 static int parseInt(String s) 将字符串类型转换为int类型并返回 static String toString(int i) 获取参数指定整数的十进制字符串形式 static String toBinaryString(int i) 获取参数指定整数的二进制字符串形式 static String toHexString(int i) 获取参数指定整数的十六进制字符串形式 static String toOctalString(int i) 获取参数指定整数的八进制字符串形式 （4）常用的方法 ​ 在Java5发布之前使用包装类对象进行运算时，需要较为繁琐的“拆箱”和“装箱”操作；即运算前先将 包装类对象拆分为基本类型数据，运算后再将结果封装成包装类对象。 从Java5开始增加了自动拆箱和自动装箱的功能。 （5）常用的方法 ​ 在Integer类的内部提供了自动装箱池技术，将-128到127之间的整数已经装箱完毕，当程序中使用 该范围之间的整数时，无需装箱直接取用自动装箱池中的对象即可，从而提高效率。 3.4 Double类概述（1）基本概念 ​ java.lang.Double类型内部包装了一个double类型的变量作为成员变量，主要用于实现对double 类型的包装并提供double类型到String类之间的转换等方法。 （2）常用的常量 常量类型和名称 功能介绍 public static final int SIZE 表示double类型的二进制位数 public static final int BYTES 表示double类型的字节个数 public static final Class TYPE 表示double类型的Class实例 （3）常用的方法 方法声明 功能介绍 Double(double value) 根据参数指定的浮点数据来构造对象（已过时） Double(String s) 根据参数指定的字符串来构造对象 （已过时） double doubleValue() 获取调用对象中的浮点数据并返回 static Double valueOf(double d) 根据参数指定浮点数据得到Double类型对象 boolean equals(Object obj) 比较调用对象与参数指定的对象是否相等 String toString() 返回描述调用对象数值的字符串形式 static double parseDouble(String s) 将字符串类型转换为double类型并返回 boolean isNaN() 判断调用对象的数值是否为非数字 扩展： ​ java.lang.Number类是个抽象类，是上述类的父类来描述所有类共有的成员。 3.5 Boolean类的概述（1）基本概念 ​ java.lang.Boolean类型内部包装了一个boolean类型的变量作为成员变量，主要用于实现对 boolean类型的包装并提供boolean类型到String类之间的转换等方法。 （2）常用的常量 常量类型和名称 功能介绍 public static final Boolean FALSE 对应基值为false的对象 public static final Boolean TRUE 对应基值为true的对象 public static final Class TYPE 表示boolean类型的Class实例 （3）常用的方法 方法声明 功能介绍 Boolean(boolean value) 根据参数指定的布尔数值来构造对象（已过时） Boolean(String s) 根据参数指定的字符串来构造对象 （已过时） boolean booleanValue() 获取调用对象中的布尔数值并返回 static Boolean valueOf(boolean b) ) 根据参数指定布尔数值得到Boolean类型对象 boolean equals(Object obj) 比较调用对象与参数指定的对象是否相等 String toString() 返回描述调用对象数值的字符串形式 static boolean parseBoolean(String s) 将字符串类型转换为boolean类型并返回 3.6 Character类的概述（1）基本概念 ​ java.lang.Character类型内部包装了一个char类型的变量作为成员变量，主要用于实现对char类型 的包装并提供字符类别的判断和转换等方法。 （2）常用的常量 常量类型和名称 功能介绍 public static final int SIZE 表示char类型的二进制位数 public static final int BYTES 表示char类型的字节个数 public static final Class TYPE 表示char类型的Class实例 （3）常用的方法 方法声明 功能介绍 Character(char value) 根据参数指定的字符数据来构造对象（已过时） char charValue() 获取调用对象中的字符数据并返回 static Character valueOf(char c) 根据参数指定字符数据得到Character类型对象 boolean equals(Object obj) 比较调用对象与参数指定的对象是否相等 String toString() 返回描述调用对象数值的字符串形式 static boolean isUpperCase(char ch) 判断参数指定字符是否为大写字符 static boolean isLowerCase(char ch) 判断参数指定字符是否为小写字符 static boolean isDigit(char ch) 判断参数指定字符是否为数字字符 static char toUpperCase(char ch) 将参数指定的字符转换为大写字符 static char toLowerCase(char ch) 将参数指定的字符转换为小写字符 3.7 包装类（Wrapper）的使用总结 基本数据类型转换为对应包装类的方式 ：调用包装类的构造方法或静态方法即可 获取包装类对象中基本数据类型变量数值的方式：调用包装类中的xxxValue方法即可 字符串转换为基本数据类型的方式：调用包装类中的parseXxx方法即可 4. 数学处理类（熟悉）4.1 Math类的概述（1）基本概念 ​ java.lang.Math类主要用于提供执行数学运算的方法，如：对数，平方根。 （2）常用的方法 方法声明 功能介绍 static int max(int a, int b) 返回两个参数中的最大值 static int min(int a, int b) 返回两个参数中的最小值 static double pow(double a, double b) 返回第一个参数的幂 static int abs(int a) 返回参数指定数值的绝对值 static long round(double a) 返回参数四舍五入的结果 static double sqrt(double a) 返回参数的平方根 static double random() 返回0.0到1.0的随机数 4.2 BigDecimal类的概述（1）基本概念 ​ 由于float类型和double类型在运算时可能会有误差，若希望实现精确运算则借助 java.math.BigDecimal类型加以描述。 （2）常用的方法 方法声明 功能介绍 BigDecimal(String val) 根据参数指定的字符串来构造对象 BigDecimal add(BigDecimal augend) 用于实现加法运算 BigDecimal subtract(BigDecimal subtrahend) 用于实现减法运算 BigDecimal multiply(BigDecimal multiplicand) 用于实现乘法运算 BigDecimal divide(BigDecimal divisor) 用于实现除法运算 4.3 BigInteger类的概念（1）基本概念 ​ 若希望表示比long类型范围还大的整数数据，则需要借助java.math.BigInteger类型描述。 （2）常用的方法 方法声明 功能介绍 BigInteger(String val) 根据参数指定的字符串来构造对象 BigInteger add(BigInteger val) 用于实现加法运算 BigInteger subtract(BigInteger val) 用于实现减法运算 BigInteger multiply(BigInteger val) 用于实现乘法运算 BigInteger divide(BigInteger val) 用于实现除法运算 BigInteger remainder(BigInteger val) 用于实现取余运算 BigInteger[] divideAndRemainder(BigInteger val) 用于实现取商和余数的运算","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"String类的概述和使用","slug":"String类的概述和使用","date":"2019-01-11T09:23:14.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2019/01/11/String类的概述和使用/","link":"","permalink":"http://yournotes.cn/2019/01/11/String%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"1 String类的概念（重点） java.lang.String类用于描述字符串，Java程序中所有的字符串字面值都可以使用该类的对象加以描 述，如：”abc”。 该类由final关键字修饰，表示该类不能被继承。 从jdk1.9开始该类的底层不使用char[]来存储","text":"1 String类的概念（重点） java.lang.String类用于描述字符串，Java程序中所有的字符串字面值都可以使用该类的对象加以描 述，如：”abc”。 该类由final关键字修饰，表示该类不能被继承。 从jdk1.9开始该类的底层不使用char[]来存储数据，而是改成 byte[]加上编码标记，从而节约了一 些空间。 该类描述的字符串内容是个常量不可更改，因此可以被共享使用。 如： ​ String str1 &#x3D; “abc”; - 其中”abc”这个字符串是个常量不可改变 ​ str1 &#x3D; “123”; - 将“123”字符串的地址赋值给变量str1。 ​ 改变str1的指向并没有改变指向的内容 2 常量池的概念（原理）​ 由于String类型描述的字符串内容是常量不可改变，因此Java虚拟机将首次出现的字符串放入常量 池中，若后续代码中出现了相同字符串内容则直接使用池中已有的字符串对象而无需申请内存及创建对 象，从而提高了性能。 3 常用的构造方法（练熟、记住） 方法声明 功能介绍 String() 使用无参方式构造对象得到空字符序列 String(byte[] bytes, int offset, int length) 使用bytes数组中下标从offset位置开始的length个字节来 构造对象 String(byte[] bytes) 使用bytes数组中的所有内容构造对象 String(char[] value, int offset, int count) 使用value数组中下标从offset位置开始的count个字符来构 造对象 String(char[] value) 使用value数组中的所有内容构造对象 String(String original) 根据参数指定的字符串内容来构造对象，新创建对象为参 数对象的副本 4 常用的成员方法（练熟、记住） 方法声明 功能介绍 String toString() 返回字符串本身 byte[] getBytes() 将当前字符串内容转换为byte数组并返回 char[] toCharArray() 用于将当前字符串内容转换为char数组并返回 方法声明 功能介绍 char charAt(int index) 方法charAt用于返回字符串指定位置的字符。 int length() 返回字符串字符序列的长度 boolean isEmpty() 判断字符串是否为空 案例题目 判断字符串“上海自来水来自海上”是否为回文并打印，所谓回文是指一个字符序列无论从左向右读 还是从右向左读都是相同的句子。 方法声明 功能介绍 int compareTo(String anotherString) 用于比较调用对象和参数对象的大小关系 int compareToIgnoreCase(String str) 不考虑大小写，也就是’a’和’A’是相等的关系 案例题目 编程实现字符串之间大小的比较并打印 方法声明 功能介绍 String concat(String str) 用于实现字符串的拼接 boolean contains(CharSequence s) 用于判断当前字符串是否包含参数指定的内容 String toLowerCase() 返回字符串的小写形式 String toUpperCase() 返回字符串的大写形式 String trim() 返回去掉前导和后继空白的字符串 boolean startsWith(String prefix) 判断字符串是否以参数字符串开头 boolean startsWith(String prefix, int toffset) 从指定位置开始是否以参数字符串开头 boolean endsWith(String suffix) 判断字符串是否以参数字符串结尾 案例题目 编程实现上述方法的使用。 方法声明 功能介绍 boolean equals(Object anObject) 用于比较字符串内容是否相等并返回 int hashCode() 获取调用对象的哈希码值 boolean equalsIgnoreCase(String anotherString) 用于比较字符串内容是否相等并返回，不考虑大小写， 如：’A’和’a’是相等 案例题目 提示用户从键盘输入用户名和密码信息，若输入”admin”和”123456”则提示“登录成功，欢迎使 用”，否则提示“用户名或密码错误，您还有n次机会”，若用户输入三次后依然错误则提示“账户已 冻结，请联系客服人员！” 方法声明 功能介绍 int indexOf(int ch) 用于返回当前字符串中参数ch指定的字符第一次出现的 下标 int indexOf(int ch, int fromIndex) 用于从fromIndex位置开始查找ch指定的字符 int indexOf(String str) 在字符串中检索str返回其第一次出现的位置，若找不到 返回-1 int indexOf(String str, int fromIndex) 表示从字符串的fromIndex位置开始检索str第一次出现 的位置 int lastIndexOf(int ch) 用于返回参数ch指定的字符最后一次出现的下标 int lastIndexOf(int ch, int fromIndex) 用于从fromIndex位置开始查找ch指定字符出现的下标 int lastIndexOf(String str) 返回str指定字符串最后一次出现的下标 int lastIndexOf(String str, int fromIndex) 用于从fromIndex位置开始反向搜索的第一次出现的下标。 案例题目 编写通用的代码可以查询字符串”Good Good Study, Day Day Up!”中所有”Day”出现的索引位置并 打印出来。 方法声明 功能介绍 String substring(int beginIndex, int endIndex) 返回字符串中从下标beginIndex（包括）开始到 endIndex（不包括）结束的子字符串 String substring(int beginIndex) 返回字符串中从下标beginIndex（包括）开始到字符串结尾 的子字符串 案例题目 提示用户从键盘输入一个字符串和一个字符，输出该字符(不含)后面的所有子字符串。 5 正则表达式的概念（了解）​ 正则表达式本质就是一个“规则字符串”，可以用于对字符串数据的格式进行验证，以及匹配、查 找、替换等操作。该字符串通常使用^运算符作为开头标志，使用$运算符作为结尾标志，当然也可以省 略。 6 正则表达式的规则（了解） 正则表达式 说明 [abc] 可以出现a、b、c中任意一个字符 [^abc] 可以出现任何字符，除了a、b、c的任意字符 [a-z] 可以出现a、b、c、……、z中的任意一个字符 [a-zA-Z0-9] 可以出现az、AZ、0~9中任意一个字符 正则表达式 说明 . 任意一个字符（通常不包含换行符） \\d 任意一个数字字符，相当于[0-9] \\D 任意一个非数字字符 \\s 空白字符，相当于[\\t\\n\\x0B\\f\\r] \\S 非空白字符 \\w 任意一个单词字符，相当于[a-zA-Z_0-9] \\W 任意一个非单词字符 正则表达式 说明 X? 表示X可以出现一次或一次也没有，也就是0 ~ 1次 X* 表示X可以出现零次或多次，也就是0 ~ n次 X+ 表示X可以出现一次或多次，也就是1 ~ n次 X{n} 表示X可以出现恰好 n 次 X{n，} 表示X可以出现至少 n 次，也就是&gt;&#x3D;n次 X{n，m} 表示X可以出现至少 n 次，但是不超过 m 次，也就是&gt;&#x3D;n并且&lt;&#x3D;m次 7 正则表达式相关的方法（熟悉） 方法名称 方法说明 boolean matches(String regex) 判断当前正在调用的字符串是否匹配参数指定的正则表达式规 则 案例题目 使用正则表达式描述一下银行卡密码的规则：要求是由6位数字组成。 使用正则表达式描述一下QQ号码的规则：要求是由非0开头的5~15位数组成。 使用正则表达式描述一下手机号码的规则：要求是由1开头，第二位数是3、4、5、7、8中的一 位，总共11位 描述身份证号码的规则：总共18位，6位数字代表地区，4位数字代表年，2位数字代表月，2位数 字代表日期，3位数字代表个人，最后一位可能数字也可能是X。 方法名称 方法说明 String[] split(String regex) 参数regex为正则表达式，以regex所表示的字符串为分隔 符，将字符串拆分成字符串数组 String replace(char oldChar, char newChar) 使用参数newChar替换此字符串中出现的所有参数 oldChar String replaceFirst(String regex, String replacement) 替换此字符串匹配给定的正则表达式的第一个子字符串 String replaceAll(String regex, String replacement) 将字符串中匹配正则表达式regex的字符串替换成 replacement","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"可变字符串类和日期相关类","slug":"可变字符串类和日期相关类","date":"2018-01-13T12:10:57.000Z","updated":"2025-04-17T08:34:52.021Z","comments":true,"path":"2018/01/13/可变字符串类和日期相关类/","link":"","permalink":"http://yournotes.cn/2018/01/13/%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%B1%BB/","excerpt":"1. 可变字符串类（重点）1.1 基本概念 由于String类描述的字符串内容是个常量不可改变，当需要在Java代码中描述大量类似的字符串时，只能单独申请和存储，此时会造成内存空间的浪费。","text":"1. 可变字符串类（重点）1.1 基本概念 由于String类描述的字符串内容是个常量不可改变，当需要在Java代码中描述大量类似的字符串时，只能单独申请和存储，此时会造成内存空间的浪费。 为了解决上述问题，可以使用java.lang.StringBuilder类和java.lang.StringBuffer类来描述字符序列可以改变的字符串，如：”ab”。 StringBuffer类是从jdk1.0开始存在，属于线程安全的类，因此效率比较低。 StringBuilder类是从jdk1.5开始存在，属于非线程安全的类，效率比较高。 1.2 StringBuilder类常用的构造方法 方法声明 功能介绍 StringBuilder() 使用无参方式构造对象，容量为16 StringBuilder(int capacity) 根据参数指定的容量来构造对象，容量为参数指定大小 StringBuilder(String str) 根据参数指定的字符串来构造对象，容量为：16+字符串长度 1.3 StringBuilder类常用的成员方法 方法声明 功能介绍 int capacity() 用于返回调用对象的容量 int length() 用于返回字符串的长度，也就是字符的个数 StringBuilder insert(int offset, String str) 插入字符串并返回调用对象的引用，就是自 己。 StringBuilder append(String str) 追加字符串 StringBuilder deleteCharAt(int index) 将当前字符串中下标为index位置的单个字符 删除 StringBuilder delete(int start，int end) 删除字符串 StringBuilder replace(int start，int end， String str) 替换字符串 StringBuilder reverse() 字符串反转 注意 作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。 返回值的设计 StringBuilder的很多方法的返回值均为StringBuilder类型。这些方法的返回语句均为：return this。 由此可见，这些方法在对StringBuilder所封装的字符序列进行改变后又返回了该对象的引用。基 于这样设计的目的在于可以连续调用。 2. Java8之前的日期相关类（熟悉）2.1 System类的概述（1）基本概念 Java.lang.System类中提供了一些有用的类字段和方法。 （2）常用的方法 方法声明 功能介绍 Date() 使用无参的方式构造对象，也就是当前系统时间 Date(long date) 根据参数指定毫秒数构造对象， 参数为距离1970年1月1日0时0分0秒 的毫秒数 long getTime() 获取调用对象距离1970年1月1日0时0分0秒的毫秒数 void setTime(long time) 设置调用对象为距离基准时间time毫秒的时间点 2.2 SimpleDateFormat类的概述（1）基本概念 java.text.SimpleDateFormat类主要用于实现日期和文本之间的转换。 （2）常用的方法 方法声明 功能介绍 SimpleDateFormat() 使用无参方式构造对象 SimpleDateFormat(String pattern) 根据参数指定的模式来构造对象，模式主要有: y-年 M-月 d-日 H-时 m-分 s-秒 final String format(Date date) 用于将日期类型转换为文本类型 Date parse(String source) 用于将文本类型转换为日期类型 2.3 Calendar类的概述（1）基本概念 java.util.Calender类主要用于描述特定的瞬间，取代Date类中的过时方法实现全球化。 该类是个抽象类，因此不能实例化对象，其具体子类针对不同国家的日历系统，其中应用最广泛的 是GregorianCalendar（格里高利历），对应世界上绝大多数国家&#x2F;地区使用的标准日历系统。 （2）常用的方法 方法声明 功能介绍 static Calendar getInstance() 用于获取Calendar类型的引 用 void set(int year, int month, int date, int hourOfDay, int minute, int second) 用于设置年月日时分秒信息 Date getTime() 用于将Calendar类型转换为 Date类型 void set(int field, int value) 设置指定字段的数值 void add(int field, int amount) 向指定字段增加数值 （2）多态的使用场合 通过方法的参数传递形成多态 1234public static void draw(Shape s)&#123; s.show(); &#125; draw(new Rect(1, 2, 3, 4)); 在方法体中直接使用多态的语法格式 1Account acc = new FixedAccount(); 通过方法的返回值类型形成多态 123Calender getInstance()&#123; return new GregorianCalendar(zone, aLocale); &#125; 3. Java8中的日期相关类（熟悉）3.1 Java8日期类的由来 ​ JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被 弃用 了。而Calendar并不比Date好多少。它们面临的问题是： Date类中的年份是从1900开始的，而月份都从0开始。 格式化只对Date类有用，对Calendar类则不能使用。 非线程安全等。 3.2 Java8日期类的概述 Java 8通过发布新的Date-Time API来进一步加强对 日期与时间的处理。 java.time包：该包日期&#x2F;时间API的基础包。 java.time.chrono包：该包提供对不同日历系统的访问。 java.time.format包：该包能够格式化和解析日期时间对象。 java.time.temporal包：该包包含底层框架和扩展特性。 java.time.zone包：该包支持不同时区以及相关规则的类。 3.3 LocalDate类的概述（1）基本概念 java.time.LocalDate类主要用于描述年-月-日格式的日期信息，该类不表示时间和时区信息。 （2）常用的方法 方法声明 功能介绍 static LocalDate now() 在默认时区中从系统时钟获取当前日期 3.4 LocalTime类的概述（1）基本概念 java.time.LocalTime 类主要用于描述时间信息，可以描述时分秒以及纳秒。 （2）常用的方法 方法声明 功能介绍 static LocalTime now() 从默认时区的系统时间中获取当前时间 static LocalTime now(ZoneId zone) 获取指定时区的当前时间 3.5 LocalDateTime类的概述（1）基本概念 java.time.LocalDateTime类主要用于描述ISO-8601日历系统中没有时区的日期时间，如2007-12- 03T10:15:30。 （2）常用的方法 方法声明 功能介绍 static LocalDateTime now() 从默认时区的系统时间中获取当前时间 static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) 根据参数指定的年月日时分秒 信息来设置日期时间 int getYear() 获取年份字段的数值 int getMonthValue() 获取1到12之间的月份字段 int getDayOfMonth() 获取日期字段 int getHour() 获取小时数 int getMinute() 获取分钟数 int getSecond() 获取秒数 LocalDateTime withYear(int year) 设置为参数指定的年 LocalDateTime withMonth(int month) 设置为参数指定的月 LocalDateTime withDayOfMonth(int dayOfMonth) 设置为参数指定的日 LocalDateTime withHour(int hour) 设置为参数指定的时 LocalDateTime withMinute(int minute) 设置为参数指定的分 LocalDateTime withSecond(int second) 设置为参数指定的秒 LocalDateTime plusYears(long years) 加上参数指定的年 LocalDateTime plusMonths(long months) 加上参数指定的月 LocalDateTime plusDays(long days) 加上参数指定的日 LocalDateTime plusHours(long hours) 加上参数指定的时 LocalDateTime plusMinutes(long minutes) 加上参数指定的分 LocalDateTime plusSeconds(long seconds) 加上参数指定的秒 LocalDateTime minusYears(long years) 减去参数指定的年 LocalDateTime minusMonths(long months) 减去参数指定的月 LocalDateTime minusDays(long days) 减去参数指定的日 LocalDateTime minusHours(long hours) 减去参数指定的时 LocalDateTime minusMinutes(long minutes) 减去参数指定的分 LocalDateTime minusSeconds(long seconds) 减去参数指定的秒 3.6 Instant类的概述（1）基本概念 java.time.Instant类主要用于描述瞬间的时间点信息。 （2）常用的方法 方法声明 功能介绍 static Instant now() 从系统时钟上获取当前时间 OffsetDateTime atOffset(ZoneOffset offset) 将此瞬间与偏移量组合以创建偏移日期时间 static Instant ofEpochMilli(long epochMilli) 根据参数指定的毫秒数来构造对象，参数为距离1970年1月1 日0时0分0秒的毫秒数 long toEpochMilli() 获取距离1970年1月1日0时0分0秒的毫秒数 3.7 DateTimeFormatter类的概述（1）基本概念 java.time.format.DateTimeFormatter类主要用于格式化和解析日期。 （2）常用的方法 方法声明 功能介绍 static DateTimeFormatter ofPattern(String pattern) 根据参数指定的模式来获取对象 String format(TemporalAccessor temporal) 将参数指定日期时间转换为字符串 TemporalAccessor parse(CharSequence text) 将参数指定字符串转换为日期时间","categories":[{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]},{"title":"HTML详解","slug":"html","date":"2017-01-04T01:51:59.000Z","updated":"2025-04-17T08:34:52.019Z","comments":true,"path":"2017/01/04/html/","link":"","permalink":"http://yournotes.cn/2017/01/04/html/","excerpt":"1. HTML介绍&amp;规范1.1 介绍HTML 指的是超文本标记&#x2F;标签语言 (Hyper Text Markup Language)专门制作网页的计算机语言","text":"1. HTML介绍&amp;规范1.1 介绍HTML 指的是超文本标记&#x2F;标签语言 (Hyper Text Markup Language)专门制作网页的计算机语言 普通的文本就是英文单词，英文字母一样的存在。超文本的意思是有一些单词或字母，在网页浏览器的世界中被赋予了特殊的权利。 比如：我们都是普通人，但是有些人经过国家的选拔，穿上警服之后，他就被赋予了执法的特殊权利，普通人是没有执法权的。字母img只是普通的字母，没什么特殊的含义。而被加上尖括号后，在网页的世界中，就具备了显示图片的作用。 1.2 使用记事本开发第一个网页在计算机任意的位置，创建一个空白的记事本 重点：文件的后缀名必须是 “htm” 或 “html” 鼠标右键文件，选择打开方式为”记事本”，输入下面代码 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;Jasper&lt;/title&gt; &lt;/head&gt; &lt;body&gt;木瓜煲鸡脚&lt;/body&gt; &lt;/html&gt; 保存文件，双击文件会以计算机默认的浏览器运行，你的第一个网页就制作完成了！ 注意： &lt;html&gt;标签它代表当前页面是一个HTML &lt;head&gt;标签中可以声明HTML页面的相关信息 &lt;body&gt;标签要有开始，有介绍，成双成对 开始标签与结束标签中的内容是标签的内容，如果没有标签内容，可以让标签自关闭&lt;br/&gt; 大多数标签它具有属性,属性值要使用引号引起来。 HTML它本身是不区分大小写的。 1.3 下载安装VSCode记事本编写网页不方便，所以推荐一款编写网页的神器！ 1.3.1 下载地址https://code.visualstudio.com/ 1.3.2 初始中文设置安装vscode之后，在界面的左侧，选择安装中文插件。 点击安装后，右下角会弹出重启的窗口 重启就可以了 1.3.3 创建项目vscode本身没有新建项目的选项，所以要先创建一个空的文件夹，如: vscode目录 然后打开vscode软件，在vscode软件中选择 File -&gt; Open Folder 打开刚才创建的文件夹 右键目录，创建子目录my-html，在my-html目录下创建文件，输入Test1.html 在代码编辑区，最上面输入！回车，就是见证奇迹的时刻 1.3.4 运行页面需要安装插件 “open in browser ” 安装完插件，右键想要运行的页面文件，或者 使用快捷键 alt+b 这里推荐使用chrome谷歌浏览器，精简，速度快。 先安装好chrome浏览器 修改默认的浏览器：首页的设置 添加代码 1&quot;open-in-browser.default&quot;:&quot;chrome&quot; 2. HTML的使用2.1 文件标签&lt;html&gt; 标签： 代表当前书写的是一个HTML文档 &lt;head&gt; 标签：存储的本页面的一些重要的信息，它不会显示 &lt;head&gt; 标签：有一个子标签&lt;title&gt;它是用于定义页面的标题的 &lt;body&gt; 标签：书写的内容会显示出来 &lt;body&gt;标签的属性： text 用于设置文字颜色 bgcolor 用于设置页面的背景色 background 用于设置页面的背景图片 2.2 排版标签2.2.1 HTML注释 2.2.2换行标签&lt;br/&gt; 标签就是一个换行（回车）功能标签，标签中的 &#x2F; 可有可无的。 有&#x2F;是html语言的标准化，但是html语言是一门不那么严谨的语言 2.2.3 段落标签在&lt;p&gt;标签中的内容,会在开始与结束之间产生一个空白行，并且它会自动换行. 常用属性 align 它的作用是设置段落中的内容对齐方式 可取值有 left right center 2.2.4 水平线标签&lt;hr&gt;标签会在页面上产生一个水平线 对于hr标签它有常用属性: align：可取值有left right center 代表水平线位置 size：代表水平线厚度（粗细） width：代表水平线宽度 color：水平线的颜色 单位：size&#x3D;”5”，5是默认的单位，为”像素”&#x2F;“像素点”，像素就是构成计算机图片的最小单位！也可以使用百分比，size&#x3D;”50%” 2.2.5 分区标签div是一个块标签，用来进行布局的 普通的div并没有什么效果，肉眼也看不见，但div与CSS结合，就会更好对页面进行排版 div与span都是“容器”的作用，具体区别: div会自动换行，我们也叫这样的标签为块级元素 span标签它不会自动换行，我们也叫它为行内元素 div：整体划分区块 span：局部划分 两个div的区别是显而易见的，后面我们再具体学习css语法 2.3 字体标签2.3.1 字体标签&lt;font&gt;标签可以设置字体，字的大小及颜色，常用属性： face:用于设置字体，例如 宋体 隶书 楷体 size:用于设置字的大小（大小默认设置1-7，7最大，想更大，往后学css即可） color:用于设置字的颜色 注： 我们所看到的屏幕上所有的颜色都是由红、绿、蓝这三种基色调混合而成的。 每一种颜色的饱和度和透明度都是可以变化的，用0～255的数值来表示。如纯红色表示为（255，0， 0），十六进制表示为#FF0000。 按这种表达方式，理论上我们可以得到256 * 256 * 256 &#x3D; 16777216种颜色。 使用十六进制方式，取值范围 #000000 ~ #FFFFFF （黑色到白色）。当颜色值为#cc3300 时，可简化成 #c30 这种方式 1&lt;body bgcolor=&quot;#666&quot;&gt; RGB颜色表示法：RGB（x,y,z）。x、y、z是0 ～ 255之间的整数。rgb字母大小写无所谓 1&lt;body bgcolor=&quot;rgb(11,11,11)&quot;&gt; （在线颜色选择器： http://www.86y.org/code/colorpicker/color.html ） 查看电脑已有的字体才能显示，这里使用仿宋 也可下载别的，百度搜索：字魂网，下载一个免费的字体，并安装到计算机中。在我们的网页中显示出来！ 2.3.2 标题标记给一段文字起一个标题 &lt;h1&gt; ----- &lt;h6&gt; h1最大 h6最小，它们代表的是标题（和word文档是一样的） 自动换行，字体加粗，标题与标题之间产生一定的距离 注意:在HTML中允许标签进行嵌套的，但是一般都包裹嵌套，而不可以进行交叉嵌套 2.3.3 格式化标签 &lt;br&gt;：字体加粗 &lt;i&gt;：字体倾斜 &lt;del&gt;：删除线 &lt;u&gt;：下划线 2.4 列表标记 ol：有序列表 type&#x3D;’A’：字母排序 type&#x3D;’I’：罗马排序 start&#x3D;“3” 序列从几开始 ul：无序列表 type&#x3D;”disc”：默认，实心圆 type&#x3D;”square”：方块 type&#x3D;”circle”：空心圆 li：列表项 2.5 图像标签&lt;img&gt;它可以让我们在网页引入一张图片，常用属性： src 代表的图片的路径 width 图片的宽度 height 图片的高度 border 用于设置图片的边框 alt 如果图片不可以显示时，默认显示的文本信息 title鼠标悬停图片上，默认显示的文本信息 align 图片附件文字的对齐方式，可取值有 left：把图像对齐到左边 right：把图像对齐到右边 middle：把图像与中央对齐 top：把图像与顶部对齐 bottom：把图像与底部对齐（默认） 2.6 超链接标签&lt;a&gt;标签,可以实现跳转到其它页面操作. 超链接内容不仅可以是文本，也可以是图片等信息 常用属性: href 代表的我们要跳转的路径 target 这个属性规定在何处打开这个链接文档，可取值： _blank在新窗口中打开页面 _self 默认。在本窗口打开页面 功能性连接： 1.发邮件 1&lt;a href=&quot;mailto:1839646816@qq.com&quot;&gt;联系站长&lt;/a&gt; 2.QQ聊天窗口 123&lt;a href=&quot;tencent://message/?uin=1839646816&amp;Menu=yes&quot;&gt; &lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=1:615050000:7&quot;/&gt; &lt;/a&gt; 2.7 表格&lt;table&gt;：定义一个表格 border：边框，取值是像素为单位 width 代表的表格的宽度 align 代表表格的对齐方式；取值 left 左对齐表格 right 右对齐表格 center 居中对齐表格 cellspacing：单元格间距（通常设置0表示单线表格） &lt;tr&gt;：表格中的行 （Table Row） align 代表表格的对齐方式；取值 &lt;td&gt;：表格中的数据单元格 （Table DataCell） colspan 指示列的合并 rowspan 指示行的合并 计划统计表 收入金额 5 6 8 9 11 12 123456789101112131415161718192021&lt;table border=&quot;1&quot; width=&quot;400px&quot; align=&quot;center&quot; cellspacing=&quot;0&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td colspan=&quot;3&quot;&gt;计划统计表&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;3&quot;&gt;收入金额&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 2.8 表单标签表单可以让我们将录入信息携带到服务器端。 简单说，通过表单可以将要提交的数据提交到指定的位置。 但一个一个的提交，不方便。表单正好解决了这个问题，将所有的数据形成一个整体，一起提交给服务器。 常见的 登录页面、注册页面 都离不开表单的应用 2.8.1 form属性action：整个表单提交的目的地 method：表单提交的方式 get：提交时，传输数据量少（传递普通文字信息，传递照片会失败），明文提交（在浏览器的url后面会显示提交的数据，不适合用于登录） post：提交时，传输数据量大（传递文字和图片都行），密文提交（浏览器的url后面看不到提交的数据） 2.8.2 表单中的元素（空间）&lt;input&gt;元素的type属性 text：默认值，普通的文本输入框 placeholder属性：提示文本 maxlength属性：最多能输入字符数量 password：密码输入框 checkbox：多选框&#x2F;复选框 checked：被选中 radio：单选按钮 file：上传文件 reset：重置按钮 submit：提交按钮 button：普通按钮 &lt;select&gt;：下拉列表&#x2F;下拉框 &lt;option&gt;：列表中的项 selected：被选中 &lt;textarea&gt;：文本域（多行文本框） 可以通过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的height和 width 属性。 &lt;button&gt;：按钮 在form表单中，作用和submit一样 不在form表单中，就是普通按钮（配合后期的javascript，可扩展性更高） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;form action=&quot;baidu&quot; method=&quot;GET&quot;&gt; &lt;p&gt;帐号：&lt;input name=&quot;a&quot; type=&quot;text&quot; placeholder=&quot;请输入帐号...&quot; maxlength=&quot;5&quot; &gt;&lt;/p&gt; &lt;p&gt; 密码： &lt;input name=&quot;b&quot; type=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; 爱好： &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot;&gt; 抽烟 &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt; 喝酒 &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot;&gt; 烫头 &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot;&gt; 泡澡 &lt;/p&gt; &lt;p&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;&gt; 女 &lt;/p&gt; &lt;p&gt; 身份： &lt;input type=&quot;radio&quot; name=&quot;role&quot;&gt; ceo &lt;input type=&quot;radio&quot; name=&quot;role&quot;&gt; cto &lt;input type=&quot;radio&quot; name=&quot;role&quot;&gt; coo &lt;input type=&quot;radio&quot; name=&quot;role&quot; checked=&quot;checked&quot;&gt; ufo &lt;/p&gt; &lt;p&gt; 头像： &lt;input type=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; 血型： &lt;select&gt; &lt;option&gt;A型&lt;/option&gt; &lt;option&gt;B型&lt;/option&gt; &lt;option&gt;C型&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;O型&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; 个人简介： &lt;textarea cols=&quot;10&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;reset&quot; value=&quot;清空&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;取消&quot;&gt; &lt;button&gt;保存&lt;/button&gt; &lt;/p&gt; &lt;/form&gt; &lt;button&gt;测试&lt;/button&gt; 注意事项： 所有表单中的元素都要具有名称（否则提交到服务器之后，服务器无法区识别多个元素之间的不同） 单选框要想可以一次只选择一个，要具有相同的name值 所有的复选框以组为单位，组内的每个复选框都应该具有相同的name值 2.9 框架标签通过&lt;frameset&gt;和&lt;frame&gt;框架标签可以定制HTML页面布局。可以理解为：用多个页面拼装成一个页面。 注意：框架标签和body标签不共存。“有你没我，有我没你” 12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;frameset rows=&quot;10%,*,13%&quot;&gt; &lt;frame src=&quot;top.html&quot;&gt;&lt;/frame&gt; &lt;frameset cols=&quot;15%,*&quot;&gt; &lt;frame src=&quot;left.html&quot;&gt;&lt;/frame&gt; &lt;frame src=&quot;right.html&quot;&gt;&lt;/frime&gt; &lt;/frameset&gt; &lt;frame src=&quot;foot.html&quot;&gt;&lt;/frame&gt; &lt;/frameset&gt;&lt;/html&gt; top.html、left.html、right.html、foot.html 四个页面内容一样，稍微改下文字而已，以top.html为例 123456789101112&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;顶部导航区域&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2.10 其他标签与特殊字符2.10.1 &lt;meta&gt;标签&lt;meta&gt;标签必须写在&lt;head&gt;标签之间. 123&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; 当前页面的字符编码 gbk：中文简体 这里 的 名字 是 viewport （显示窗口）数据 是 文本 内容 content&#x3D;”width&#x3D;device-width, initial-scale&#x3D;1.0”也就是 显示窗口 宽度 是 客户端的 屏幕 宽度 （就是 满屏 ！），显示的文字和图形的初始比例 是1.0 每个电脑内置的IE版本是不一样的，为了兼容所有的版本以最高级模式渲染文档，也就是任何IE版本都以当前版本所支持的最高级标准模式渲染 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url=http://yournotes.cn&quot;&gt; 注意：在html中如果跳转的互联网上的网站资源，那么我们在书写路径时，一定要带协议的路径。 2.10.2 &lt;link&gt;标签后面我们会使用link标签来导入css 注意:link标签也必须写在&lt;head&gt;标签中。 2.10.3 特殊字符 3. HTML5 新特性3.1 HTML5与HTML4的区别H5包含H4 1.大小写不敏感 标签 属性 属性的值 1&lt;inPUT tYPe=&quot;pasSWord&quot;/&gt; 2.引号可以省略 12&lt;input type=&quot;password&quot;&gt; &lt;input type=password&gt; 3.结尾标签也可省略 12&lt;p&gt;哈哈哈哈哈哈哈 &lt;p&gt;哈哈哈哈哈哈哈 3.2 新增语义化标签新增许多语义化标签，让div“见名知意” section标签：表示页面中的内容区域，部分，页面的主体部分 article标签：文章 aside标签：文章内容之外的，标题 header标签：头部，页眉，页面的顶部 hgroup标签：内容与标题的组合 nav标签：导航 figure标签：图文并茂 foot：页脚，页面的底部 3.3 媒体标签想在网页上播放视频，就要使用&lt;video&gt;，属性有： src：媒体资源文件的位置 controls：控制面板 autoplay：自动播放（谷歌失效，360浏览器可以） loop：循环播放 1&lt;video src=&quot;img/html-css-js之间的关系.mp4&quot; controls loop autoplay&gt;&lt;/video&gt; 3.4 新增表单空间表单的控件更加丰富了 &lt;input&gt; 增加了type属性： color：调色板 date：日历 month：月历 week：周历 number：数值域 min：最小值（默认值是1） max：最大值（默认值无上限） step：递增量 range：滑块 search：搜索框（带×号，可一键删除框中内容） 进度条&lt;progress/&gt; 高亮&lt;mark&gt; 联想输入框&lt;datalist&gt; （模糊查询） 选项&lt;option&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yournotes.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://yournotes.cn/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"}]}],"categories":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/categories/LLM/"},{"name":"记录文档","slug":"记录文档","permalink":"http://yournotes.cn/categories/%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/"},{"name":"算法","slug":"算法","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"乐谱","slug":"乐谱","permalink":"http://yournotes.cn/categories/%E4%B9%90%E8%B0%B1/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"日常","slug":"日常","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"问题","slug":"日常/问题","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E9%97%AE%E9%A2%98/"},{"name":"折腾","slug":"日常/折腾","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E6%8A%98%E8%85%BE/"},{"name":"博客系统","slug":"博客系统","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"name":"Hexo","slug":"博客系统/Hexo","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/Hexo/"},{"name":"hexo","slug":"博客系统/hexo","permalink":"http://yournotes.cn/categories/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/hexo/"},{"name":"记录","slug":"日常/记录","permalink":"http://yournotes.cn/categories/%E6%97%A5%E5%B8%B8/%E8%AE%B0%E5%BD%95/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yournotes.cn/categories/JAVA/"},{"name":"Spring","slug":"JAVA/Spring","permalink":"http://yournotes.cn/categories/JAVA/Spring/"},{"name":"乐谱","slug":"算法/乐谱","permalink":"http://yournotes.cn/categories/%E7%AE%97%E6%B3%95/%E4%B9%90%E8%B0%B1/"},{"name":"前端","slug":"前端","permalink":"http://yournotes.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://yournotes.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://yournotes.cn/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"http://yournotes.cn/tags/LLM/"},{"name":"日常问题","slug":"日常问题","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"总结文档","slug":"总结文档","permalink":"http://yournotes.cn/tags/%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"},{"name":"LeetCode日常","slug":"LeetCode日常","permalink":"http://yournotes.cn/tags/LeetCode%E6%97%A5%E5%B8%B8/"},{"name":"吉他谱","slug":"吉他谱","permalink":"http://yournotes.cn/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yournotes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"随笔","slug":"随笔","permalink":"http://yournotes.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"日常折腾","slug":"日常折腾","permalink":"http://yournotes.cn/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yournotes.cn/tags/Hexo/"},{"name":"面试","slug":"面试","permalink":"http://yournotes.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"java框架","slug":"java框架","permalink":"http://yournotes.cn/tags/java%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yournotes.cn/tags/Java/"}]}