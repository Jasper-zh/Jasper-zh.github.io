---
title: LeetCode初级算法之动态规划：198.打家劫舍
date: 2021-02-23 01:40:17
tags: LeetCode日常
categories: 
- 算法
- LeetCode
---
### 题目信息
>题目地址：https://leetcode-cn.com/problems/house-robber/

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```java
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
**示例 2：**
```java
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```
<br>

**提示：**

0 <= nums.length <= 100<br>
0 <= nums[i] <= 400

### 解法一：动态规划
由题知道我们的这个小偷他偷一家必须得至少隔一家再偷不能连着偷，那我们可以从最简单的来推导看看：
```java
一条街
一开始只有一家：2块
后来搬来了一家有钱人：7块
后来陆陆续续来了几家：3块、4块、5块
```
那只有一家的时候只能偷2块<br>
`f(1) = 2`<br>
有两家了进行一次选择挑个富的<br>
`f(2) = max(第一家，第二家)` = 7<br>
有三家的时候也要进行一次选择<br>
`f(3) = max(f(1)+第三家，f(2))` = 7<br>
到这个地方其实就出来了表达式<br>
`dp[i] = max(dp[i - 2] + nums[i] , dp[i - 1])`<br>
存储之前的结果推导下一个结果，也就是动态规划过滤掉一半的组合。比如（2，7，3，4）对于（2，7，3）我们已经得到最大方案是7并记录了，那么与第四家4块结合的必不是（2、3）里的。4家虽然有三种组合但（2+4）这种组合就不会出现在计算中
![](https://gitee-blogimage.oss-cn-beijing.aliyuncs.com/blogImage/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/1.png)

动态规划每次记录之前的偷的最多与前前偷的最多的值，进行取舍，要么是前前的累计最大金额算上当前房子大要么就还是之前的最大，避免树形展开
![](https://gitee-blogimage.oss-cn-beijing.aliyuncs.com/blogImage/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/2.gif)

所以我们要准备存两个量一个是最新的最大金额也就是结果，要动态的选择结果还要一个前几个房子的最大金额，来决定下次偷还是不偷

代码如下：
```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        // 两个量：到目前累计最大与之前房屋累计最大
        int[] dp = [nums[0],Math.max(nums[0],nums[1])];
        for (int i = 2; i < length; i++) {
            // 扫描到下一个了，两个量按次序变换
            int temp = dp[1];
            second = Math.max(dp[0] + nums[i], dp[1]);
            dp[0] = temp;
        }
        return result;
    }
}
```
![](https://gitee-blogimage.oss-cn-beijing.aliyuncs.com/blogImage/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/3.png)
### 总结
其实这题和之前写的爬楼梯比较像，可以对照着总结。总体来说第一就是dp表也就是备忘录解决子问题重叠，第二就是空间的压缩我们需要明白是否必要存每个子问题的结果。





